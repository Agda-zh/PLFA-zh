<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: 列表与高阶函数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-112" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-119" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-136" class="Keyword">where</a>
</pre><p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-497" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-542" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-545" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-548" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-556" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-566" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a><a id="plfa_plfa-part1-Lists-584" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-586" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Lists-590" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-592" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-597" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-612" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-617" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-624" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-634" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-641" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-645" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-651" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-653" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-658" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-660" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Lists-661" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-663" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-666" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-668" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-671" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-673" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Lists-676" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-678" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-683" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-690" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-699" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-707" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-713" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-718" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-720" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-723" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-728" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-730" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-733" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-735" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-738" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-740" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-743" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-745" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-748" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-750" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-755" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-762" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-782" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-791" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-798" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-800" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-811" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-813" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-824" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-826" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-833" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-835" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-846" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-848" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-859" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-861" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20560" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-873" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-875" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-880" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-887" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-904" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-910" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-911" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-913" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-915" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-918" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-920" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-923" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-925" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-927" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-929" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-934" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-941" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-954" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-960" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-961" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-964" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-966" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1369" class="Function">∃</a><a id="plfa_plfa-part1-Lists-967" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-969" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1806" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-977" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-979" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-988" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-989" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-993" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-1001" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1003" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1008" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1015" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-1024" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1030" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1031" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-1034" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1036" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1041" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1048" href="https://agda.github.io/agda-stdlib/v1.7.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-1054" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1060" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1061" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#591" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-1066" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1068" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1073" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1080" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-1103" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1109" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1110" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-1113" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-1115" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-1118" class="Symbol">)</a>
</pre><h2 id="列表">列表</h2>Agda 中的列表如下定义：<pre class="Agda"><a id="plfa_plfa-part1-Lists-1223" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1228" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1233" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1234" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1236" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1238" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1241" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1243" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1245" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1249" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1257" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1261" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1263" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1268" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1272" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1276" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1278" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1280" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1282" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1287" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1289" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1291" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1296" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1299" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1306" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1308" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a>
</pre><p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-1977" href="../Lists/#plfa_plfa-part1-Lists-1977" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1979" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1981" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1986" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1988" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1990" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1992" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1994" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1996" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1998" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2000" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2002" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2004" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p><p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-2751" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2756" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2762" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2764" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2768" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2770" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2774" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2782" href="../Lists/#plfa_plfa-part1-Lists-2782" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2787" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2789" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2791" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2792" href="../Lists/#plfa_plfa-part1-Lists-2792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2794" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2796" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2799" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2801" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2803" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2809" href="../Lists/#plfa_plfa-part1-Lists-2792" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2813" href="../Lists/#plfa_plfa-part1-Lists-2813" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2818" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2820" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2822" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2823" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2825" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2827" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2830" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2832" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2834" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2836" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2838" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2844" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2846" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2848" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2854" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a>
</pre><p>每个构造子将参数作为隐式参数。因此我们列表的例子也可以写作：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3019" href="../Lists/#plfa_plfa-part1-Lists-3019" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3021" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3023" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3028" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-3030" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-3032" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3034" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3038" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3039" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3040" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3042" class="Number">0</a> <a id="plfa_plfa-part1-Lists-3044" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3045" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3049" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3050" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3051" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3053" class="Number">1</a> <a id="plfa_plfa-part1-Lists-3055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3056" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3060" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3061" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3062" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3064" class="Number">2</a> <a id="plfa_plfa-part1-Lists-3066" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3067" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-3070" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3071" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3072" class="Symbol">})))</a>
</pre><p>此处我们将隐式参数显式地声明。</p><p>包含下面的编译器指令</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p><h2 id="列表语法">列表语法</h2><p>我们可以用下面的定义，更简便地表示列表：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3696" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3704" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3708" href="../Lists/#plfa_plfa-part1-Lists-3712" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3710" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3712" href="../Lists/#plfa_plfa-part1-Lists-3712" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3714" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3716" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3719" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3727" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3733" href="../Lists/#plfa_plfa-part1-Lists-3739" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3735" href="../Lists/#plfa_plfa-part1-Lists-3743" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3737" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3739" href="../Lists/#plfa_plfa-part1-Lists-3739" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3741" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3743" href="../Lists/#plfa_plfa-part1-Lists-3743" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3745" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3747" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3750" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3758" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3766" href="../Lists/#plfa_plfa-part1-Lists-3774" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3768" href="../Lists/#plfa_plfa-part1-Lists-3778" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3770" href="../Lists/#plfa_plfa-part1-Lists-3782" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3772" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3774" href="../Lists/#plfa_plfa-part1-Lists-3774" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3776" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3778" href="../Lists/#plfa_plfa-part1-Lists-3778" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3780" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3782" href="../Lists/#plfa_plfa-part1-Lists-3782" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3784" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3786" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3789" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3797" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3807" href="../Lists/#plfa_plfa-part1-Lists-3817" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3809" href="../Lists/#plfa_plfa-part1-Lists-3821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3811" href="../Lists/#plfa_plfa-part1-Lists-3825" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3813" href="../Lists/#plfa_plfa-part1-Lists-3829" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3815" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3817" href="../Lists/#plfa_plfa-part1-Lists-3817" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3819" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3821" href="../Lists/#plfa_plfa-part1-Lists-3821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3823" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3825" href="../Lists/#plfa_plfa-part1-Lists-3825" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3827" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3829" href="../Lists/#plfa_plfa-part1-Lists-3829" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3831" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3833" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3836" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3844" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3856" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3858" href="../Lists/#plfa_plfa-part1-Lists-3872" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3860" href="../Lists/#plfa_plfa-part1-Lists-3876" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3862" href="../Lists/#plfa_plfa-part1-Lists-3880" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3864" href="../Lists/#plfa_plfa-part1-Lists-3884" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3866" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3868" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3870" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3872" href="../Lists/#plfa_plfa-part1-Lists-3872" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3874" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3876" href="../Lists/#plfa_plfa-part1-Lists-3876" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3878" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3880" href="../Lists/#plfa_plfa-part1-Lists-3880" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3882" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3884" href="../Lists/#plfa_plfa-part1-Lists-3884" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3886" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3888" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3891" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3899" href="../Lists/#plfa_plfa-part1-Lists-3899" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3913" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3915" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3917" href="../Lists/#plfa_plfa-part1-Lists-3935" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3919" href="../Lists/#plfa_plfa-part1-Lists-3939" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3921" href="../Lists/#plfa_plfa-part1-Lists-3943" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3923" href="../Lists/#plfa_plfa-part1-Lists-3947" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3925" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3927" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3929" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3931" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3933" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3935" href="../Lists/#plfa_plfa-part1-Lists-3935" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3937" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3939" href="../Lists/#plfa_plfa-part1-Lists-3939" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3941" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3943" href="../Lists/#plfa_plfa-part1-Lists-3943" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3945" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3947" href="../Lists/#plfa_plfa-part1-Lists-3947" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3949" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3951" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p><h2 id="附加">附加</h2><p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-4504" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-4511" class="Number">5</a> <a id="plfa_plfa-part1-Lists-4513" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-4519" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-4524" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4526" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4528" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4529" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4531" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4533" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4536" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4538" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4540" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4545" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4547" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4549" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4554" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4556" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4558" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4563" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-4565" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-4574" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4577" href="../Lists/#plfa_plfa-part1-Lists-4577" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4581" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4584" href="../Lists/#plfa_plfa-part1-Lists-4577" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-4587" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4588" href="../Lists/#plfa_plfa-part1-Lists-4588" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4590" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4592" href="../Lists/#plfa_plfa-part1-Lists-4592" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4594" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4596" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4599" href="../Lists/#plfa_plfa-part1-Lists-4599" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4603" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4606" href="../Lists/#plfa_plfa-part1-Lists-4588" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4608" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4610" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4611" href="../Lists/#plfa_plfa-part1-Lists-4592" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4614" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4617" href="../Lists/#plfa_plfa-part1-Lists-4599" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4619" class="Symbol">)</a>
</pre><p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p><p>我们举个例子，来展示将两个列表附加的计算过程：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-5246" href="../Lists/#plfa_plfa-part1-Lists-5246" class="Function">_</a> <a id="plfa_plfa-part1-Lists-5248" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5250" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5252" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5254" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5256" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5258" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5260" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5262" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5264" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5267" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5269" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5271" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5273" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5275" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5277" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5279" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5281" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5283" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5285" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5287" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5289" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5291" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5293" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5295" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5297" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5299" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-5301" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-5303" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5307" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5317" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5319" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5321" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5323" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5325" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5327" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5329" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5332" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5335" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5337" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5339" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5341" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5343" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5348" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5356" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5358" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5360" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5361" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5363" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5365" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5367" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5369" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5372" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5375" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5377" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5379" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5381" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5383" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5385" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5389" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5397" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5399" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5401" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5403" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5405" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5406" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5408" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5410" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5413" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5416" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5418" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5420" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5422" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5424" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5426" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5438" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5440" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5442" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5444" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5446" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5448" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5450" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5451" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5454" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5457" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5459" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5461" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5463" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5465" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5467" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5471" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5479" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5481" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5483" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5485" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5487" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5489" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5491" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5493" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5495" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5497" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5499" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>附加两个列表需要对于第一个列表元素个数线性的时间。</p><h2 id="论证附加">论证附加</h2>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-5859" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5868" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5870" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5872" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5873" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5875" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5880" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5882" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5883" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5886" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5889" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5892" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5894" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5899" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5900" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5904" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5906" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5907" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5910" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5913" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5915" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5917" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5920" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5923" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5925" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5928" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5931" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5932" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5935" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5938" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5940" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-5942" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5951" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5954" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5957" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5960" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5964" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5974" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5975" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5978" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5981" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5983" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5985" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5988" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5993" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6001" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6004" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6007" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6012" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6020" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6023" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6026" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6027" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6030" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6033" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6035" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6039" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6041" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6050" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6051" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6053" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6055" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6057" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6059" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6062" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6065" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6069" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6079" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6080" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6082" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6084" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6087" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6090" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6092" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6094" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6097" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6102" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6110" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6112" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6114" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6115" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6118" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6121" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6123" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6125" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6128" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6133" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6141" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6143" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6145" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-6147" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6150" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6153" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6155" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6157" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6160" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6162" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6166" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6169" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6174" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6175" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6177" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6179" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6181" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6182" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6191" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6194" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6197" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6199" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6201" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6207" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6209" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6211" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6212" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6215" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6218" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6219" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6222" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6225" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6227" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6232" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6240" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6242" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6244" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6247" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6251" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6254" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6257" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6259" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6263" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p><p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>提升至等式：</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>即证明中所需。</p><p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-7363" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7376" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7378" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7380" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7381" href="../Lists/#plfa_plfa-part1-Lists-7381" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7383" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7385" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7388" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7390" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7391" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7394" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7396" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7401" href="../Lists/#plfa_plfa-part1-Lists-7381" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7402" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7404" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7406" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7409" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7412" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7415" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7417" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7420" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7433" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7436" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7440" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7450" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7453" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7456" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7461" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7469" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7474" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>右幺元的证明可由简单的归纳得到：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-7573" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7586" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7588" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7590" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7591" href="../Lists/#plfa_plfa-part1-Lists-7591" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7593" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7598" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7601" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7604" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7606" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7611" href="../Lists/#plfa_plfa-part1-Lists-7591" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7612" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7614" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7616" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7619" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7622" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7627" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7630" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7643" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7646" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7650" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7660" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7663" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7666" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7671" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7679" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7684" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7686" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7699" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7700" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7702" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7704" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7706" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7708" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7712" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7722" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7723" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7725" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7727" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7729" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7731" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7734" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7739" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7747" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7749" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7751" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7752" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7755" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7758" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7760" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7764" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7767" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7772" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7773" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7775" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-7777" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7779" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7780" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7793" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7795" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7797" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7803" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7805" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7807" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7812" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p><h2 id="长度">长度</h2><p>在下一个函数里，我们来寻找列表的长度：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-8104" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8111" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8113" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8115" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8116" href="../Lists/#plfa_plfa-part1-Lists-8116" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8118" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8120" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8123" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8125" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8127" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8132" href="../Lists/#plfa_plfa-part1-Lists-8116" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8134" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8136" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-8138" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8145" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8155" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8158" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-8163" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8171" href="../Lists/#plfa_plfa-part1-Lists-8171" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8173" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8175" href="../Lists/#plfa_plfa-part1-Lists-8175" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8177" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8180" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8187" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8188" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8195" href="../Lists/#plfa_plfa-part1-Lists-8175" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8197" class="Symbol">)</a>
</pre><p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>我们用下面的例子来展示如何计算列表的长度：<pre class="Agda"><a id="plfa_plfa-part1-Lists-8531" href="../Lists/#plfa_plfa-part1-Lists-8531" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8533" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8535" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8542" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8544" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8546" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8548" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8550" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8552" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8554" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8558" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-8560" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8562" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8566" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8576" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8583" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8584" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8586" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8588" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8590" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8592" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8594" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8596" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8598" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8602" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8614" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8615" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8622" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8623" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8625" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8627" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8629" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8631" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8633" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8638" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8646" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8650" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8655" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8656" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8663" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8664" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8666" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8668" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8670" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8676" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8689" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8693" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8698" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8699" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8706" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8707" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-8708" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8710" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8712" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8718" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8730" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8735" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8736" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-8744" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8749" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>计算列表的长度需要关于列表元素个数线性的时间。</p><p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p><h2 id="论证长度">论证长度</h2><p>两个附加在一起的列表的长度是两列表长度之和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-9348" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9358" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9360" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-9362" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9363" href="../Lists/#plfa_plfa-part1-Lists-9363" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-9365" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9367" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-9370" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9372" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9373" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9376" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9379" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9381" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-9386" href="../Lists/#plfa_plfa-part1-Lists-9363" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9387" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9391" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-9393" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9400" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9401" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9404" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9407" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9409" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9411" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-9413" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9420" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9423" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9425" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9432" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-9435" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9445" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9446" href="../Lists/#plfa_plfa-part1-Lists-9446" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9447" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9449" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9452" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9455" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9459" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9469" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9476" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9477" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9480" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9483" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9485" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9489" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9497" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9504" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9509" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9517" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9524" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9525" href="../Lists/#plfa_plfa-part1-Lists-9446" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9526" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9528" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9531" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9533" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9540" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9545" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-9547" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9557" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9558" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9560" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9562" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9564" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9566" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9569" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9573" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9583" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9590" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9592" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9594" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9596" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9598" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9600" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9603" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9605" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9609" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9617" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9621" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9622" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9630" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9633" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9636" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9638" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9643" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-9646" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-9651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9655" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9656" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9666" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9669" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9671" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9673" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-9679" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9683" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9684" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9691" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9696" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9703" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9705" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9709" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9717" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9725" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9727" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9729" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9731" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9733" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9735" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9742" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p><h2 id="反转">反转</h2>我们可以使用附加，来简单地构造一个函数来反转一个列表：<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-10630" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10638" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10640" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10642" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10643" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10645" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10650" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10652" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10654" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10659" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10661" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10663" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10668" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10670" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10678" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-10688" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10691" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-10694" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10702" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10703" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10705" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10707" href="../Lists/#plfa_plfa-part1-Lists-10707" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10709" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-10712" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10715" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10723" href="../Lists/#plfa_plfa-part1-Lists-10707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10726" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10729" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10731" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10733" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
</pre><p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>下面的例子展示了如何反转一个列表。<pre class="Agda"><a id="plfa_plfa-part1-Lists-11037" href="../Lists/#plfa_plfa-part1-Lists-11037" class="Function">_</a> <a id="plfa_plfa-part1-Lists-11039" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11041" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11049" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11051" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11053" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11055" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11057" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11059" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11061" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11063" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-11065" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11067" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11069" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11071" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11073" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11075" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11077" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-11079" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-11081" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11085" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11095" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11103" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11104" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11106" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11108" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11110" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11112" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11114" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11116" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11118" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11122" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11130" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11138" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11139" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11141" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11143" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11145" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11147" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11149" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11151" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11154" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11156" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11158" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11162" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11171" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11179" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11180" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11182" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11184" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11186" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11188" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11191" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11193" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11195" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11196" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11198" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11201" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11203" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11205" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11209" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11217" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11219" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11227" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11230" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11233" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11235" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11237" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11238" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11240" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11243" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11245" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11247" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11248" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11250" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11253" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11255" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11257" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11261" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11269" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11271" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11274" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11277" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11279" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11281" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11282" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11284" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11287" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11289" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11291" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11292" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11294" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11297" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11299" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11301" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11305" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11313" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11315" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11318" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11321" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11323" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11325" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11327" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11329" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11332" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11334" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11336" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11338" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11340" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11343" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11345" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11347" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11352" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11360" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11361" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11363" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11365" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11368" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11371" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11373" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11375" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11377" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11379" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11382" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11384" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11386" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11391" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11399" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11401" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11403" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11404" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11407" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11410" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11412" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11414" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11416" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11418" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11421" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11423" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11425" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11438" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11439" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11441" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11443" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11445" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11447" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11449" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11451" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11454" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11456" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11458" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11463" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11471" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11473" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11475" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11476" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11478" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11480" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11483" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11486" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11488" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11490" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11492" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11496" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11504" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11506" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11508" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11510" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11512" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11513" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11516" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11519" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11521" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11523" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11525" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11529" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11537" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11539" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11541" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11543" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11545" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11547" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11549" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11554" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11562" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11564" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11566" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11568" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11570" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11572" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11574" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11578" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p><h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4><p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-12483" class="Comment">-- Your code goes here</a>
</pre><h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4><p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-12838" class="Comment">-- Your code goes here</a>
</pre><h2 id="更快地反转">更快地反转</h2><p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-13215" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13221" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13223" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13225" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13226" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13228" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13230" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13233" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13235" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13237" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13242" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13244" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13246" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13251" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13253" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13255" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13260" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-13262" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13268" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-13277" href="../Lists/#plfa_plfa-part1-Lists-13277" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13281" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13284" href="../Lists/#plfa_plfa-part1-Lists-13277" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13287" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13293" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13294" href="../Lists/#plfa_plfa-part1-Lists-13294" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13296" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13298" href="../Lists/#plfa_plfa-part1-Lists-13298" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13300" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13302" href="../Lists/#plfa_plfa-part1-Lists-13302" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13306" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13309" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13315" href="../Lists/#plfa_plfa-part1-Lists-13298" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13319" href="../Lists/#plfa_plfa-part1-Lists-13294" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13321" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13323" href="../Lists/#plfa_plfa-part1-Lists-13302" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13325" class="Symbol">)</a>
</pre><p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>转移（Shunt）与反转的关系如下：<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-13660" href="../Lists/#plfa_plfa-part1-Lists-13660" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13674" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13676" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13678" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13679" href="../Lists/#plfa_plfa-part1-Lists-13679" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13681" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13683" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13686" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13689" href="../Lists/#plfa_plfa-part1-Lists-13689" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13692" href="../Lists/#plfa_plfa-part1-Lists-13692" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13695" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13697" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13702" href="../Lists/#plfa_plfa-part1-Lists-13679" class="Bound">A</a><a id="plfa_plfa-part1-Lists-13703" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13707" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13709" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13715" href="../Lists/#plfa_plfa-part1-Lists-13689" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13718" href="../Lists/#plfa_plfa-part1-Lists-13692" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13721" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13723" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13731" href="../Lists/#plfa_plfa-part1-Lists-13689" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13734" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13737" href="../Lists/#plfa_plfa-part1-Lists-13692" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13740" href="../Lists/#plfa_plfa-part1-Lists-13660" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13754" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13757" href="../Lists/#plfa_plfa-part1-Lists-13757" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13760" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13764" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13774" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13780" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13783" href="../Lists/#plfa_plfa-part1-Lists-13757" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13788" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13796" href="../Lists/#plfa_plfa-part1-Lists-13757" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13801" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13809" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13817" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13820" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13823" href="../Lists/#plfa_plfa-part1-Lists-13757" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13828" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-13830" href="../Lists/#plfa_plfa-part1-Lists-13660" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13844" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13845" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13847" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13849" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13851" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13853" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13856" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13860" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13870" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13876" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13877" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13879" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13881" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13883" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13885" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13890" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13898" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13904" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13907" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13908" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13910" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13912" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13914" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13918" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13921" href="../Lists/#plfa_plfa-part1-Lists-13660" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13935" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13938" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13939" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13941" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13943" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13945" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13947" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13953" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13961" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13964" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13967" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13968" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13970" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13972" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13974" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13978" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13986" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13994" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13997" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14000" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14001" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14003" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14005" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14007" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14010" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14012" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-14016" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-14019" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-14023" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14024" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-14033" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14034" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14042" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14044" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14046" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14048" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14050" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14052" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14054" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14056" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-14062" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14063" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14071" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14074" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14077" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14079" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14081" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-14082" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14084" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14087" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14092" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14100" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14108" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14109" href="../Lists/#plfa_plfa-part1-Lists-13845" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14111" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14113" href="../Lists/#plfa_plfa-part1-Lists-13849" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14115" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14117" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14120" href="../Lists/#plfa_plfa-part1-Lists-13853" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14125" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p><p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p><p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-15146" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15155" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15157" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15159" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15160" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15162" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15167" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15169" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15171" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15176" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15178" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15180" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15185" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-15187" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15196" href="../Lists/#plfa_plfa-part1-Lists-15196" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15199" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-15201" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15207" href="../Lists/#plfa_plfa-part1-Lists-15196" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15210" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-15356" href="../Lists/#plfa_plfa-part1-Lists-15356" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15365" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15367" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15369" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15370" href="../Lists/#plfa_plfa-part1-Lists-15370" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15372" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15377" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15379" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15380" href="../Lists/#plfa_plfa-part1-Lists-15380" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15383" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15385" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15390" href="../Lists/#plfa_plfa-part1-Lists-15370" class="Bound">A</a><a id="plfa_plfa-part1-Lists-15391" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15395" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15397" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15406" href="../Lists/#plfa_plfa-part1-Lists-15380" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15409" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15411" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15419" href="../Lists/#plfa_plfa-part1-Lists-15380" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-15422" href="../Lists/#plfa_plfa-part1-Lists-15356" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15431" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15434" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15438" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15448" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15457" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15462" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15470" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15476" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15479" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15484" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15487" href="../Lists/#plfa_plfa-part1-Lists-13660" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-15501" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15504" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15507" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15513" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15521" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15524" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-15527" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15532" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15535" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-15548" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15549" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15557" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15559" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15561" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15567" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15575" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15580" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-15709" href="../Lists/#plfa_plfa-part1-Lists-15709" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15711" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15713" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15722" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15724" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15726" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15728" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15730" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15732" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15734" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15736" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15738" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15740" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15742" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15744" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15746" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15748" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15750" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-15752" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15754" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15758" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15768" href="../Lists/#plfa_plfa-part1-Lists-15146" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15777" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15778" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15780" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15782" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15784" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15786" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15788" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15790" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15792" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15796" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15804" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15810" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15811" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15813" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15815" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15817" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15819" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15821" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15823" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15825" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15827" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15832" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15840" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15846" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15847" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15849" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15851" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15853" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15855" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15857" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15859" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15860" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15862" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15864" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15866" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15870" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15878" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15884" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15885" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15887" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15889" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15891" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15893" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15894" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15896" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15898" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15900" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15902" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15904" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15908" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15916" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15922" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15925" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15926" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15928" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15930" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15932" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15934" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15936" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15938" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15940" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15944" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15952" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15954" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15956" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15958" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15960" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15962" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15964" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15969" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>现在反转一个列表需要的时间与列表的长度线性相关。</p><h2 id="Map">映射</h2><p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-16439" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16443" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16445" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-16447" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-16448" href="../Lists/#plfa_plfa-part1-Lists-16448" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16450" href="../Lists/#plfa_plfa-part1-Lists-16450" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-16452" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16454" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-16457" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-16459" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16461" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16462" href="../Lists/#plfa_plfa-part1-Lists-16448" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16464" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16466" href="../Lists/#plfa_plfa-part1-Lists-16450" class="Bound">B</a><a id="plfa_plfa-part1-Lists-16467" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16469" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16471" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16476" href="../Lists/#plfa_plfa-part1-Lists-16448" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16478" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16480" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16485" href="../Lists/#plfa_plfa-part1-Lists-16450" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-16487" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16491" href="../Lists/#plfa_plfa-part1-Lists-16491" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16493" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-16503" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16506" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-16509" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16513" href="../Lists/#plfa_plfa-part1-Lists-16513" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16515" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16516" href="../Lists/#plfa_plfa-part1-Lists-16516" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16518" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16520" href="../Lists/#plfa_plfa-part1-Lists-16520" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-16522" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-16525" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16528" href="../Lists/#plfa_plfa-part1-Lists-16513" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16530" href="../Lists/#plfa_plfa-part1-Lists-16516" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16532" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16534" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16538" href="../Lists/#plfa_plfa-part1-Lists-16513" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16540" href="../Lists/#plfa_plfa-part1-Lists-16520" class="Bound">xs</a>
</pre><p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p><p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-16989" href="../Lists/#plfa_plfa-part1-Lists-16989" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16991" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16993" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16997" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17001" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17003" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17005" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17007" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17009" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17011" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17013" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17015" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17017" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17019" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17021" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17023" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17025" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17027" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17029" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17031" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17033" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17037" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17047" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17051" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17056" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17058" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17060" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17062" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17064" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17066" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17068" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17070" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17074" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17082" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17086" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17088" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17090" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17094" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17099" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17101" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17103" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17105" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17107" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17109" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17113" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17121" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17125" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17127" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17129" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17133" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17135" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17137" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17141" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17145" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17146" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17148" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17150" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17152" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17156" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17168" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17170" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17172" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17176" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17178" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17180" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17184" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17186" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17188" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17192" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17196" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17201" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17209" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17213" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17215" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17221" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17223" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17225" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17229" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17231" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17233" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17238" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17246" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17248" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17250" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17252" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17254" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17256" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17258" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17263" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>映射需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-17569" href="../Lists/#plfa_plfa-part1-Lists-17569" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17574" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17576" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17581" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-17583" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17585" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-17592" href="../Lists/#plfa_plfa-part1-Lists-17569" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17597" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-17599" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17603" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-17608" href="../Lists/#plfa_plfa-part1-Lists-17608" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17610" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17612" href="../Lists/#plfa_plfa-part1-Lists-17569" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17617" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17619" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17621" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17623" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17625" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17627" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17629" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17633" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17635" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17637" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17639" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17641" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17643" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17645" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17647" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17649" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17653" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17663" href="../Lists/#plfa_plfa-part1-Lists-17569" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17668" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17670" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17672" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17674" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17676" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17678" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17680" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17684" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17692" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17696" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17700" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17702" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17704" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17706" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17708" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17710" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17712" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17716" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17724" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17726" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17728" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17730" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17732" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17734" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17736" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17740" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p><h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4><p>证明函数组合的映射是两个映射的组合：</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>证明的最后一步需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18543" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4><p>证明下列关于映射与附加的关系：</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18786" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4><p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-19007" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-19012" href="../Lists/#plfa_plfa-part1-Lists-19012" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19017" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19018" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19020" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19022" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19024" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19027" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19029" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19031" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19035" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-19043" href="../Lists/#plfa_plfa-part1-Lists-19043" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-19048" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19050" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19052" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19054" href="../Lists/#plfa_plfa-part1-Lists-19012" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19059" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19061" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-19065" href="../Lists/#plfa_plfa-part1-Lists-19065" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-19070" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19072" href="../Lists/#plfa_plfa-part1-Lists-19012" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19077" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19079" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19081" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19083" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19085" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19087" href="../Lists/#plfa_plfa-part1-Lists-19012" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19092" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19094" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19096" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19098" href="../Lists/#plfa_plfa-part1-Lists-19012" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19103" href="../Lists/#plfa_plfa-part1-Lists-19018" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19105" href="../Lists/#plfa_plfa-part1-Lists-19020" class="Bound">B</a>
</pre><p>定义一个对于树的映射运算符：</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19265" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="Fold">折叠</h2><p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-19556" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19562" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19564" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19566" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19567" href="../Lists/#plfa_plfa-part1-Lists-19567" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19569" href="../Lists/#plfa_plfa-part1-Lists-19569" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19571" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19573" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19576" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19578" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19580" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19581" href="../Lists/#plfa_plfa-part1-Lists-19567" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19583" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19585" href="../Lists/#plfa_plfa-part1-Lists-19569" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19587" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19589" href="../Lists/#plfa_plfa-part1-Lists-19569" class="Bound">B</a><a id="plfa_plfa-part1-Lists-19590" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19592" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19594" href="../Lists/#plfa_plfa-part1-Lists-19569" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19596" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19598" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19603" href="../Lists/#plfa_plfa-part1-Lists-19567" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19605" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19607" href="../Lists/#plfa_plfa-part1-Lists-19569" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-19609" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19615" href="../Lists/#plfa_plfa-part1-Lists-19615" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19619" href="../Lists/#plfa_plfa-part1-Lists-19619" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19621" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-19631" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19634" href="../Lists/#plfa_plfa-part1-Lists-19619" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-19636" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19642" href="../Lists/#plfa_plfa-part1-Lists-19642" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19646" href="../Lists/#plfa_plfa-part1-Lists-19646" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19648" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19649" href="../Lists/#plfa_plfa-part1-Lists-19649" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19651" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19653" href="../Lists/#plfa_plfa-part1-Lists-19653" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19655" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-19658" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19661" href="../Lists/#plfa_plfa-part1-Lists-19649" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19663" href="../Lists/#plfa_plfa-part1-Lists-19642" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19665" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19671" href="../Lists/#plfa_plfa-part1-Lists-19642" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19675" href="../Lists/#plfa_plfa-part1-Lists-19646" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19677" href="../Lists/#plfa_plfa-part1-Lists-19653" class="Bound">xs</a>
</pre><p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p><p>下面的例子展示了如何使用折叠来对一个列表求和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-20011" href="../Lists/#plfa_plfa-part1-Lists-20011" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20013" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20015" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20021" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20025" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20027" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20029" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20031" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20033" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20035" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20037" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20039" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20041" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20043" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20045" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20047" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20050" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20052" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20056" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20066" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20072" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20076" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20078" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20079" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20081" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20083" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20085" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20087" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20089" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20091" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20093" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20095" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20097" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20101" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20109" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20111" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20113" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20123" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20125" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20126" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20128" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20130" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20132" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20134" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20136" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20138" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20140" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20144" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20152" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20154" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20156" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20157" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20159" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20161" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20167" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20171" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20173" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20174" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20176" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20178" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20180" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20182" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20184" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-20189" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20197" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20199" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20201" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20202" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20204" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20206" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20207" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20209" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20211" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20221" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20223" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20224" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20226" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20228" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20230" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20236" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20244" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20246" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20248" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20249" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20251" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20253" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20254" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20256" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20258" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20259" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20261" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20263" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20269" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20273" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20275" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20277" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20283" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20291" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20293" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20295" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20296" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20298" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20300" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20301" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20303" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20305" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20306" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20308" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20310" class="Number">0</a><a id="plfa_plfa-part1-Lists-20311" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20317" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>折叠需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-20712" href="../Lists/#plfa_plfa-part1-Lists-20712" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20716" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20718" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20723" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-20725" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20727" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-20729" href="../Lists/#plfa_plfa-part1-Lists-20712" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20733" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-20735" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20741" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20745" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-20748" href="../Lists/#plfa_plfa-part1-Lists-20748" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20750" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20752" href="../Lists/#plfa_plfa-part1-Lists-20712" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20756" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20758" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20760" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20762" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20764" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20766" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20768" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20770" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20772" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20774" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20776" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20779" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20781" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20785" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20795" href="../Lists/#plfa_plfa-part1-Lists-20712" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20799" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20801" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20803" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20805" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20807" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20809" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20811" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20813" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20815" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20819" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20827" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20833" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20837" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20839" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20841" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20843" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20845" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20847" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20849" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20851" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20853" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20855" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20859" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20867" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-20872" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p><p>举另外一个例子，观察</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>二者相等的证明留作练习。</p><h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4><p>使用折叠来定义一个计算列表数字之积的函数。例如：</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21912" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4><p>证明折叠和附加有如下的关系：</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22148" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4><p>证明映射可以用折叠定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22450" class="Comment">-- 请将代码写在此处。</a>
</pre><p>此证明需要外延性。</p><h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4><p>请证明 map 可使用 fold 来定义：</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>此证明需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22777" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4><p>请为预先给定的三个类型定义一个合适的折叠函数：</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23058" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4><p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23282" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4><p>定义一个向下数数的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-23457" href="../Lists/#plfa_plfa-part1-Lists-23457" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23466" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23468" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-23470" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23472" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-23479" href="../Lists/#plfa_plfa-part1-Lists-23457" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23488" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-23497" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23500" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-23503" href="../Lists/#plfa_plfa-part1-Lists-23457" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23512" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23513" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-23517" href="../Lists/#plfa_plfa-part1-Lists-23517" class="Bound">n</a><a id="plfa_plfa-part1-Lists-23518" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-23521" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23524" href="../Lists/#plfa_plfa-part1-Lists-23517" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-23526" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23528" href="../Lists/#plfa_plfa-part1-Lists-23457" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23537" href="../Lists/#plfa_plfa-part1-Lists-23517" class="Bound">n</a>
</pre><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23580" href="../Lists/#plfa_plfa-part1-Lists-23580" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23582" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23584" href="../Lists/#plfa_plfa-part1-Lists-23457" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23593" class="Number">3</a> <a id="plfa_plfa-part1-Lists-23595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-23597" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23599" class="Number">2</a> <a id="plfa_plfa-part1-Lists-23601" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23603" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23605" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23607" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23609" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-23611" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-23613" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23615" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23814" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="幺半群">幺半群</h2><p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p><p>我们可以用一个合适的记录类型来定义幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24206" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-24213" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24222" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24223" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24225" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24227" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24230" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24232" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24233" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-24237" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24239" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24241" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24243" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24245" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24247" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24248" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24251" href="../Lists/#plfa_plfa-part1-Lists-24251" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24253" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24255" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24256" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24258" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24260" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-24264" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-24272" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-24282" href="../Lists/#plfa_plfa-part1-Lists-24282" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24288" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24290" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24292" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24293" href="../Lists/#plfa_plfa-part1-Lists-24293" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24295" href="../Lists/#plfa_plfa-part1-Lists-24295" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24297" href="../Lists/#plfa_plfa-part1-Lists-24297" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24299" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24301" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24302" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24304" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24306" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24307" href="../Lists/#plfa_plfa-part1-Lists-24293" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24309" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24311" href="../Lists/#plfa_plfa-part1-Lists-24295" class="Bound">y</a><a id="plfa_plfa-part1-Lists-24312" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24314" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24316" href="../Lists/#plfa_plfa-part1-Lists-24297" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24318" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24320" href="../Lists/#plfa_plfa-part1-Lists-24293" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24322" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24324" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24325" href="../Lists/#plfa_plfa-part1-Lists-24295" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24327" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24329" href="../Lists/#plfa_plfa-part1-Lists-24297" class="Bound">z</a><a id="plfa_plfa-part1-Lists-24330" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-24336" href="../Lists/#plfa_plfa-part1-Lists-24336" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24346" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24348" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24350" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24351" href="../Lists/#plfa_plfa-part1-Lists-24351" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24353" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24355" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24356" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24358" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24360" href="../Lists/#plfa_plfa-part1-Lists-24251" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24362" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24364" href="../Lists/#plfa_plfa-part1-Lists-24351" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24366" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24368" href="../Lists/#plfa_plfa-part1-Lists-24351" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-24374" href="../Lists/#plfa_plfa-part1-Lists-24374" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24384" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24386" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24388" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24389" href="../Lists/#plfa_plfa-part1-Lists-24389" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24391" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24393" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24394" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24396" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24398" href="../Lists/#plfa_plfa-part1-Lists-24389" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24400" href="../Lists/#plfa_plfa-part1-Lists-24233" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24402" href="../Lists/#plfa_plfa-part1-Lists-24251" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24404" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24406" href="../Lists/#plfa_plfa-part1-Lists-24389" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-24409" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-24414" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Module">IsMonoid</a>
</pre><p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-24587" href="../Lists/#plfa_plfa-part1-Lists-24587" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24596" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24598" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24607" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-24611" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-24613" href="../Lists/#plfa_plfa-part1-Lists-24587" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24622" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24626" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24637" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24639" href="../Lists/#plfa_plfa-part1-Lists-24282" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24645" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24647" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-24659" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24661" href="../Lists/#plfa_plfa-part1-Lists-24336" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24671" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24673" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24689" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24691" href="../Lists/#plfa_plfa-part1-Lists-24374" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24701" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24703" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24719" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-24722" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24731" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24733" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24742" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-24746" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-24748" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24757" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24761" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24772" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24774" href="../Lists/#plfa_plfa-part1-Lists-24282" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24780" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24782" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-24794" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24796" href="../Lists/#plfa_plfa-part1-Lists-24336" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24806" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24808" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24824" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24826" href="../Lists/#plfa_plfa-part1-Lists-24374" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24836" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24838" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24854" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-24857" href="../Lists/#plfa_plfa-part1-Lists-24857" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24867" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24869" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24871" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24872" href="../Lists/#plfa_plfa-part1-Lists-24872" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24874" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24876" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24879" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24881" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24883" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24892" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24893" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24898" href="../Lists/#plfa_plfa-part1-Lists-24872" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24899" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24901" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-24906" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-24909" href="../Lists/#plfa_plfa-part1-Lists-24857" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24919" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24923" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24934" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24936" href="../Lists/#plfa_plfa-part1-Lists-24282" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24942" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24944" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-24957" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24959" href="../Lists/#plfa_plfa-part1-Lists-24336" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24969" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24971" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24988" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24990" href="../Lists/#plfa_plfa-part1-Lists-24374" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-25000" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25002" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-25019" class="Symbol">}</a>
</pre><p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-25200" href="../Lists/#plfa_plfa-part1-Lists-25200" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25213" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25215" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25217" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25218" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25220" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25222" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25225" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25227" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25228" href="../Lists/#plfa_plfa-part1-Lists-25228" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25232" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25234" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25236" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25238" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25240" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25242" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25243" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25245" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25246" href="../Lists/#plfa_plfa-part1-Lists-25246" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25248" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25250" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25251" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25253" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25255" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25264" href="../Lists/#plfa_plfa-part1-Lists-25228" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25268" href="../Lists/#plfa_plfa-part1-Lists-25246" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25270" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25274" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25276" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25277" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25280" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25282" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25287" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25288" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25290" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25291" href="../Lists/#plfa_plfa-part1-Lists-25291" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25293" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25295" href="../Lists/#plfa_plfa-part1-Lists-25218" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25296" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25298" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25300" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25306" href="../Lists/#plfa_plfa-part1-Lists-25228" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25310" href="../Lists/#plfa_plfa-part1-Lists-25291" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25312" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25315" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25317" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25323" href="../Lists/#plfa_plfa-part1-Lists-25228" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25327" href="../Lists/#plfa_plfa-part1-Lists-25246" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25329" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25332" href="../Lists/#plfa_plfa-part1-Lists-25228" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25334" href="../Lists/#plfa_plfa-part1-Lists-25291" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-25336" href="../Lists/#plfa_plfa-part1-Lists-25200" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25349" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25353" href="../Lists/#plfa_plfa-part1-Lists-25353" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25355" href="../Lists/#plfa_plfa-part1-Lists-25355" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25364" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25367" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25369" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25373" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25383" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25389" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25393" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25395" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-25400" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25408" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25412" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25415" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25419" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25420" href="../Lists/#plfa_plfa-part1-Lists-24336" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25430" href="../Lists/#plfa_plfa-part1-Lists-25355" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25439" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25440" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25442" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25448" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25449" href="../Lists/#plfa_plfa-part1-Lists-25353" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25451" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25453" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25454" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25458" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25466" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25472" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25476" href="../Lists/#plfa_plfa-part1-Lists-25353" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25478" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25481" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25483" href="../Lists/#plfa_plfa-part1-Lists-25367" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25487" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-25489" href="../Lists/#plfa_plfa-part1-Lists-25200" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25502" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25506" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25508" href="../Lists/#plfa_plfa-part1-Lists-25508" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25517" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25518" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25520" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25522" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25524" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25526" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25528" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25532" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25542" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25548" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25552" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25554" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25555" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25557" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25559" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25561" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25565" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25573" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25575" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25577" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25578" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25584" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25588" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25590" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25592" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25596" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25599" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-25604" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25605" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25607" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-25609" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25611" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25612" href="../Lists/#plfa_plfa-part1-Lists-25200" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25625" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25629" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25631" href="../Lists/#plfa_plfa-part1-Lists-25508" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25640" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25643" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25644" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25646" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25652" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25654" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25656" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25657" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25663" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25667" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25669" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25672" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25674" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25675" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25679" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25682" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25686" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25687" href="../Lists/#plfa_plfa-part1-Lists-24282" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25693" href="../Lists/#plfa_plfa-part1-Lists-25508" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25702" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25704" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25705" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25711" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25715" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25717" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25719" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25721" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25722" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25724" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25730" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25731" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25733" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25735" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25741" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25745" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25747" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25749" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25751" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25753" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25757" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25765" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25771" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25775" href="../Lists/#plfa_plfa-part1-Lists-25506" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25777" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25778" href="../Lists/#plfa_plfa-part1-Lists-25518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25780" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25782" href="../Lists/#plfa_plfa-part1-Lists-25522" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25784" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25786" href="../Lists/#plfa_plfa-part1-Lists-25502" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25788" href="../Lists/#plfa_plfa-part1-Lists-25526" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25792" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在之前的练习中，我们证明了以下定理：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25885" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-25897" href="../Lists/#plfa_plfa-part1-Lists-25897" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-25906" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25908" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25910" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25911" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25913" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25915" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25918" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25920" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25921" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25925" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25927" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25929" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25931" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25933" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25935" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25936" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25938" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25939" href="../Lists/#plfa_plfa-part1-Lists-25939" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25941" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25943" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25944" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25947" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25950" href="../Lists/#plfa_plfa-part1-Lists-25950" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25953" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25955" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25960" href="../Lists/#plfa_plfa-part1-Lists-25911" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25961" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25963" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25969" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25975" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25979" href="../Lists/#plfa_plfa-part1-Lists-25939" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25981" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25982" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25985" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25988" href="../Lists/#plfa_plfa-part1-Lists-25950" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25990" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25992" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25994" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26000" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26004" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26005" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26011" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26015" href="../Lists/#plfa_plfa-part1-Lists-25939" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26017" href="../Lists/#plfa_plfa-part1-Lists-25950" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26019" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26021" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">xs</a>
</pre><p>由此，我们可以将幺半群中附加的折叠如下分解成两个折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-26166" href="../Lists/#plfa_plfa-part1-Lists-26166" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26182" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26184" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26186" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26187" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26189" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26191" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26194" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26196" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26197" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26201" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26203" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26205" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26207" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26209" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26211" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26212" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26214" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26215" href="../Lists/#plfa_plfa-part1-Lists-26215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26217" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26219" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26220" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26222" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26224" href="../Lists/#plfa_plfa-part1-Lists-24213" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-26233" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26237" href="../Lists/#plfa_plfa-part1-Lists-26215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26239" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-26243" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26245" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26246" href="../Lists/#plfa_plfa-part1-Lists-26246" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26249" href="../Lists/#plfa_plfa-part1-Lists-26249" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26252" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26254" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26259" href="../Lists/#plfa_plfa-part1-Lists-26187" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26260" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26262" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26264" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26270" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26274" href="../Lists/#plfa_plfa-part1-Lists-26215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26276" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26277" href="../Lists/#plfa_plfa-part1-Lists-26246" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26280" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26283" href="../Lists/#plfa_plfa-part1-Lists-26249" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26285" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26287" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-26289" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26295" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26299" href="../Lists/#plfa_plfa-part1-Lists-26215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26301" href="../Lists/#plfa_plfa-part1-Lists-26246" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26304" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26306" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26312" href="../Lists/#plfa_plfa-part1-Lists-26197" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26316" href="../Lists/#plfa_plfa-part1-Lists-26215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26318" href="../Lists/#plfa_plfa-part1-Lists-26249" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-26321" href="../Lists/#plfa_plfa-part1-Lists-26166" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26337" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26341" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26343" href="../Lists/#plfa_plfa-part1-Lists-26343" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26352" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26355" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26358" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-26362" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-26372" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26378" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26382" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26384" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26385" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26388" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26391" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26393" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26397" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26400" href="../Lists/#plfa_plfa-part1-Lists-25897" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-26409" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26413" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26415" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26418" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26421" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26427" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26433" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26437" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26438" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26444" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26448" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26450" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26452" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26454" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-26459" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26462" href="../Lists/#plfa_plfa-part1-Lists-25200" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26475" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26479" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26481" href="../Lists/#plfa_plfa-part1-Lists-26343" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26490" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26493" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26494" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26500" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26504" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26506" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26508" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26510" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26516" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26522" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26526" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26528" href="../Lists/#plfa_plfa-part1-Lists-26352" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26531" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26533" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26539" href="../Lists/#plfa_plfa-part1-Lists-26337" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26543" href="../Lists/#plfa_plfa-part1-Lists-26341" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26545" href="../Lists/#plfa_plfa-part1-Lists-26355" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-26550" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4><p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-26932" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4><p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27230" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="All">所有</h2><p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p><p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27560" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-27565" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27569" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27570" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27572" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27574" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27577" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27579" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27580" href="../Lists/#plfa_plfa-part1-Lists-27580" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27582" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27584" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27586" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27588" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27591" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27593" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27595" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27600" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27602" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27604" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-27608" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-27616" href="../Lists/#plfa_plfa-part1-Lists-27616" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-27620" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27622" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27626" href="../Lists/#plfa_plfa-part1-Lists-27580" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27628" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-27633" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-27637" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27639" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27641" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27642" href="../Lists/#plfa_plfa-part1-Lists-27642" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27644" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27646" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27647" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27649" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27650" href="../Lists/#plfa_plfa-part1-Lists-27650" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27653" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27655" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27660" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27661" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27663" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27665" href="../Lists/#plfa_plfa-part1-Lists-27580" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27667" href="../Lists/#plfa_plfa-part1-Lists-27642" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27669" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27671" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27675" href="../Lists/#plfa_plfa-part1-Lists-27580" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27677" href="../Lists/#plfa_plfa-part1-Lists-27650" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27680" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27682" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27686" href="../Lists/#plfa_plfa-part1-Lists-27580" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27689" href="../Lists/#plfa_plfa-part1-Lists-27642" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27691" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27693" href="../Lists/#plfa_plfa-part1-Lists-27650" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27695" class="Symbol">)</a>
</pre><p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p><p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28676" href="../Lists/#plfa_plfa-part1-Lists-28676" class="Function">_</a> <a id="plfa_plfa-part1-Lists-28678" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28680" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28684" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28685" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-28688" class="Number">2</a><a id="plfa_plfa-part1-Lists-28689" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28691" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-28693" class="Number">0</a> <a id="plfa_plfa-part1-Lists-28695" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28697" class="Number">1</a> <a id="plfa_plfa-part1-Lists-28699" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28701" class="Number">2</a> <a id="plfa_plfa-part1-Lists-28703" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-28705" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-28707" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-28709" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28713" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28715" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28719" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28723" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28725" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28729" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28730" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28734" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-28737" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28739" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28741" href="../Lists/#plfa_plfa-part1-Lists-27616" class="InductiveConstructor">[]</a>
</pre><p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p><p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p><h2 id="任意">任意</h2><p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-29666" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-29671" href="../Lists/#plfa_plfa-part1-Lists-29671" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29675" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29676" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29678" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29683" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29685" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29686" href="../Lists/#plfa_plfa-part1-Lists-29686" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29688" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29690" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29692" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29697" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29699" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29701" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29706" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29708" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29714" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-29722" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-29728" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29730" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29732" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29733" href="../Lists/#plfa_plfa-part1-Lists-29733" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29735" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29737" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29738" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29740" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29741" href="../Lists/#plfa_plfa-part1-Lists-29741" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29744" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29746" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29751" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29752" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29754" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29756" href="../Lists/#plfa_plfa-part1-Lists-29686" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29758" href="../Lists/#plfa_plfa-part1-Lists-29733" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29760" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29762" href="../Lists/#plfa_plfa-part1-Lists-29671" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29766" href="../Lists/#plfa_plfa-part1-Lists-29686" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29768" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29769" href="../Lists/#plfa_plfa-part1-Lists-29733" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29771" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29773" href="../Lists/#plfa_plfa-part1-Lists-29741" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29775" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-29779" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-29785" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29787" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29789" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29790" href="../Lists/#plfa_plfa-part1-Lists-29790" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29792" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29794" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29795" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29797" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29798" href="../Lists/#plfa_plfa-part1-Lists-29798" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29801" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29803" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29808" href="../Lists/#plfa_plfa-part1-Lists-29676" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29809" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29811" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29813" href="../Lists/#plfa_plfa-part1-Lists-29671" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29817" href="../Lists/#plfa_plfa-part1-Lists-29686" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29819" href="../Lists/#plfa_plfa-part1-Lists-29798" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29822" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29824" href="../Lists/#plfa_plfa-part1-Lists-29671" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29828" href="../Lists/#plfa_plfa-part1-Lists-29686" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29830" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29831" href="../Lists/#plfa_plfa-part1-Lists-29790" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29833" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29835" href="../Lists/#plfa_plfa-part1-Lists-29798" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29837" class="Symbol">)</a>
</pre><p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30165" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-30171" class="Number">4</a> <a id="plfa_plfa-part1-Lists-30173" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30177" href="../Lists/#plfa_plfa-part1-Lists-30252" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-30182" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30186" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30188" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30190" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30191" href="../Lists/#plfa_plfa-part1-Lists-30191" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30193" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30195" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30198" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30200" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30201" href="../Lists/#plfa_plfa-part1-Lists-30201" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30203" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30205" href="../Lists/#plfa_plfa-part1-Lists-30191" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30206" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30208" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30209" href="../Lists/#plfa_plfa-part1-Lists-30209" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30212" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30214" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30219" href="../Lists/#plfa_plfa-part1-Lists-30191" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30220" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30222" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30224" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30228" href="../Lists/#plfa_plfa-part1-Lists-30228" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30230" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30232" href="../Lists/#plfa_plfa-part1-Lists-30232" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30235" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30237" href="../Lists/#plfa_plfa-part1-Lists-29671" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30241" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30242" href="../Lists/#plfa_plfa-part1-Lists-30228" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30244" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-30246" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30248" href="../Lists/#plfa_plfa-part1-Lists-30232" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-30252" href="../Lists/#plfa_plfa-part1-Lists-30252" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-30256" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30258" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30260" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30261" href="../Lists/#plfa_plfa-part1-Lists-30261" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30263" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30265" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30268" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30270" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30271" href="../Lists/#plfa_plfa-part1-Lists-30271" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30275" href="../Lists/#plfa_plfa-part1-Lists-30261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30276" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30279" href="../Lists/#plfa_plfa-part1-Lists-30279" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30282" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30284" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30289" href="../Lists/#plfa_plfa-part1-Lists-30261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30290" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30292" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30294" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30298" href="../Lists/#plfa_plfa-part1-Lists-30298" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30300" href="../Lists/#plfa_plfa-part1-Lists-30252" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30302" href="../Lists/#plfa_plfa-part1-Lists-30302" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30305" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30307" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-30309" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30310" href="../Lists/#plfa_plfa-part1-Lists-30298" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30312" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30314" href="../Lists/#plfa_plfa-part1-Lists-30302" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30316" class="Symbol">)</a>
</pre><p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30663" href="../Lists/#plfa_plfa-part1-Lists-30663" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30665" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30667" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30669" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30671" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30673" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30675" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30677" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30679" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30681" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30683" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30685" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30687" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30689" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30691" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30693" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30698" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-30704" href="../Lists/#plfa_plfa-part1-Lists-30704" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30706" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30708" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30710" href="../Lists/#plfa_plfa-part1-Lists-30182" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30712" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30714" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30716" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30718" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30720" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30722" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30724" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30726" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30728" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30730" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30732" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30734" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30740" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30741" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30747" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30748" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30753" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-30757" class="Symbol">))</a>
</pre><p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-30956" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30963" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30965" class="Number">3</a> <a id="plfa_plfa-part1-Lists-30967" href="../Lists/#plfa_plfa-part1-Lists-30252" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30969" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30971" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30973" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30975" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30977" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30979" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30981" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30983" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30985" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30987" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30994" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30995" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31000" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-31004" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31011" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31012" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31018" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31019" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31024" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-31029" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31037" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31043" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31044" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31050" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31051" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31056" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-31062" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31069" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31070" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31076" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31077" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31083" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31084" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31090" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31091" href="../Lists/#plfa_plfa-part1-Lists-29722" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31096" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-31103" href="../Lists/#plfa_plfa-part1-Lists-30956" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31110" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31111" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31117" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31118" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31124" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31125" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31131" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31132" href="../Lists/#plfa_plfa-part1-Lists-29779" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31138" class="Symbol">()))))</a>
</pre><p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p><h2 id="所有和附加">所有和附加</h2><p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-31610" href="../Lists/#plfa_plfa-part1-Lists-31610" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31619" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31621" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31623" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31624" href="../Lists/#plfa_plfa-part1-Lists-31624" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31626" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31628" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31631" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31633" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31634" href="../Lists/#plfa_plfa-part1-Lists-31634" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31636" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31638" href="../Lists/#plfa_plfa-part1-Lists-31624" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31640" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31642" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31645" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31647" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31648" href="../Lists/#plfa_plfa-part1-Lists-31648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31651" href="../Lists/#plfa_plfa-part1-Lists-31651" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31654" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31656" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31661" href="../Lists/#plfa_plfa-part1-Lists-31624" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31662" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31664" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-31668" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31672" href="../Lists/#plfa_plfa-part1-Lists-31634" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31674" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31675" href="../Lists/#plfa_plfa-part1-Lists-31648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31678" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31681" href="../Lists/#plfa_plfa-part1-Lists-31651" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31683" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31685" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-31687" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31688" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31692" href="../Lists/#plfa_plfa-part1-Lists-31634" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31694" href="../Lists/#plfa_plfa-part1-Lists-31648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31697" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31699" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31703" href="../Lists/#plfa_plfa-part1-Lists-31634" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31705" href="../Lists/#plfa_plfa-part1-Lists-31651" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31707" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-31709" href="../Lists/#plfa_plfa-part1-Lists-31610" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31718" href="../Lists/#plfa_plfa-part1-Lists-31718" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31721" href="../Lists/#plfa_plfa-part1-Lists-31721" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31724" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-31728" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-31739" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31741" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15016" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-31750" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31753" href="../Lists/#plfa_plfa-part1-Lists-31808" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31756" href="../Lists/#plfa_plfa-part1-Lists-31718" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31759" href="../Lists/#plfa_plfa-part1-Lists-31721" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31766" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-31768" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15033" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-31777" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31780" href="../Lists/#plfa_plfa-part1-Lists-32033" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31785" href="../Lists/#plfa_plfa-part1-Lists-31718" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31788" href="../Lists/#plfa_plfa-part1-Lists-31721" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31795" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-31799" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-31808" href="../Lists/#plfa_plfa-part1-Lists-31808" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31811" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31813" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31815" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31816" href="../Lists/#plfa_plfa-part1-Lists-31816" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31818" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31820" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31823" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31825" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31826" href="../Lists/#plfa_plfa-part1-Lists-31826" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31828" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31830" href="../Lists/#plfa_plfa-part1-Lists-31816" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31832" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31834" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31837" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31839" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31840" href="../Lists/#plfa_plfa-part1-Lists-31840" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31843" href="../Lists/#plfa_plfa-part1-Lists-31843" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31846" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31848" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31853" href="../Lists/#plfa_plfa-part1-Lists-31816" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31854" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31856" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-31862" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31866" href="../Lists/#plfa_plfa-part1-Lists-31826" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31868" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31869" href="../Lists/#plfa_plfa-part1-Lists-31840" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31872" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31875" href="../Lists/#plfa_plfa-part1-Lists-31843" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31877" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31879" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31881" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31882" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31886" href="../Lists/#plfa_plfa-part1-Lists-31826" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31888" href="../Lists/#plfa_plfa-part1-Lists-31840" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31891" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31893" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31897" href="../Lists/#plfa_plfa-part1-Lists-31826" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31899" href="../Lists/#plfa_plfa-part1-Lists-31843" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31901" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-31905" href="../Lists/#plfa_plfa-part1-Lists-31808" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31908" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31911" href="../Lists/#plfa_plfa-part1-Lists-31911" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31914" href="../Lists/#plfa_plfa-part1-Lists-31914" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31918" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31920" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31922" href="../Lists/#plfa_plfa-part1-Lists-27616" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31925" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31927" href="../Lists/#plfa_plfa-part1-Lists-31914" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31931" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-31935" href="../Lists/#plfa_plfa-part1-Lists-31808" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31938" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31939" href="../Lists/#plfa_plfa-part1-Lists-31939" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-31941" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31943" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-31945" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31947" href="../Lists/#plfa_plfa-part1-Lists-31947" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31950" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31951" href="../Lists/#plfa_plfa-part1-Lists-31951" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31954" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31956" href="../Lists/#plfa_plfa-part1-Lists-31956" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-31963" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31965" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-31970" href="../Lists/#plfa_plfa-part1-Lists-31808" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31973" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31976" href="../Lists/#plfa_plfa-part1-Lists-31947" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31979" href="../Lists/#plfa_plfa-part1-Lists-31956" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-31989" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-31993" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-31995" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31997" href="../Lists/#plfa_plfa-part1-Lists-31997" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32001" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32003" href="../Lists/#plfa_plfa-part1-Lists-32003" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32007" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32009" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32011" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32013" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32016" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32018" href="../Lists/#plfa_plfa-part1-Lists-31997" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32022" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32024" href="../Lists/#plfa_plfa-part1-Lists-32003" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32028" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-32033" href="../Lists/#plfa_plfa-part1-Lists-32033" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32038" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32040" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-32042" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-32044" href="../Lists/#plfa_plfa-part1-Lists-32044" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32048" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32051" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32053" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-32054" href="../Lists/#plfa_plfa-part1-Lists-32054" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32056" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32058" href="../Lists/#plfa_plfa-part1-Lists-32044" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32060" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32062" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32065" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32067" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32068" href="../Lists/#plfa_plfa-part1-Lists-32068" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32071" href="../Lists/#plfa_plfa-part1-Lists-32071" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32074" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32076" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32081" href="../Lists/#plfa_plfa-part1-Lists-32044" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32082" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32084" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-32090" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32094" href="../Lists/#plfa_plfa-part1-Lists-32054" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32096" href="../Lists/#plfa_plfa-part1-Lists-32068" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32099" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32101" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32105" href="../Lists/#plfa_plfa-part1-Lists-32054" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32107" href="../Lists/#plfa_plfa-part1-Lists-32071" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32110" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32112" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32116" href="../Lists/#plfa_plfa-part1-Lists-32054" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32118" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32119" href="../Lists/#plfa_plfa-part1-Lists-32068" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32122" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32125" href="../Lists/#plfa_plfa-part1-Lists-32071" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32127" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32131" href="../Lists/#plfa_plfa-part1-Lists-32033" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32136" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32139" href="../Lists/#plfa_plfa-part1-Lists-32139" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32142" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32144" href="../Lists/#plfa_plfa-part1-Lists-27616" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32147" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32149" href="../Lists/#plfa_plfa-part1-Lists-32149" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32153" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32155" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32157" href="../Lists/#plfa_plfa-part1-Lists-32149" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-32163" href="../Lists/#plfa_plfa-part1-Lists-32033" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32168" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32169" href="../Lists/#plfa_plfa-part1-Lists-32169" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32171" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32173" href="../Lists/#plfa_plfa-part1-Lists-32173" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32175" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32177" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32180" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32182" href="../Lists/#plfa_plfa-part1-Lists-32182" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32185" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32187" href="../Lists/#plfa_plfa-part1-Lists-32187" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32191" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32193" href="../Lists/#plfa_plfa-part1-Lists-32193" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32197" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32199" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32202" href="../Lists/#plfa_plfa-part1-Lists-32182" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32205" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32207" href="../Lists/#plfa_plfa-part1-Lists-32033" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32212" href="../Lists/#plfa_plfa-part1-Lists-32173" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32215" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32218" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32220" href="../Lists/#plfa_plfa-part1-Lists-32187" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32224" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32226" href="../Lists/#plfa_plfa-part1-Lists-32193" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32230" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4><p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32607" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4><p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32821" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4><p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p><p>以下定律是否也成立？</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>若成立，请证明；否则请解释原因。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33463" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4><p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33724" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4><p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33926" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4><p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34135" class="Comment">-- 请将代码写在此处</a>
</pre><p>如果成立，请证明；如果不成立，请解释原因。</p><h2 id="所有的可判定性">所有的可判定性</h2><p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-34546" href="../Lists/#plfa_plfa-part1-Lists-34546" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34550" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34552" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-34554" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-34555" href="../Lists/#plfa_plfa-part1-Lists-34555" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34557" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-34562" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-34564" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34566" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-34567" href="../Lists/#plfa_plfa-part1-Lists-34555" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34569" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34571" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-34575" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-34577" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34579" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-34584" href="../Lists/#plfa_plfa-part1-Lists-34555" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34586" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34588" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-34593" href="../Lists/#plfa_plfa-part1-Lists-34546" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34597" href="../Lists/#plfa_plfa-part1-Lists-34597" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-34600" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-34603" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-34609" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-34613" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-34618" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-34620" href="../Lists/#plfa_plfa-part1-Lists-16439" class="Function">map</a> <a id="plfa_plfa-part1-Lists-34624" href="../Lists/#plfa_plfa-part1-Lists-34597" class="Bound">p</a>
</pre><p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p><p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-35350" href="../Lists/#plfa_plfa-part1-Lists-35350" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35360" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35362" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35364" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35365" href="../Lists/#plfa_plfa-part1-Lists-35365" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35367" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35369" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35372" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35374" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35376" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35377" href="../Lists/#plfa_plfa-part1-Lists-35365" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35379" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35381" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35384" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35386" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35388" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-35392" href="../Lists/#plfa_plfa-part1-Lists-35350" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35402" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35403" href="../Lists/#plfa_plfa-part1-Lists-35403" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35404" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35406" href="../Lists/#plfa_plfa-part1-Lists-35406" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-35409" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35412" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35414" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35415" href="../Lists/#plfa_plfa-part1-Lists-35415" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35417" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35419" href="../Lists/#plfa_plfa-part1-Lists-35403" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35420" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35422" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35424" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-35428" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35429" href="../Lists/#plfa_plfa-part1-Lists-35406" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35431" href="../Lists/#plfa_plfa-part1-Lists-35415" class="Bound">x</a><a id="plfa_plfa-part1-Lists-35432" class="Symbol">)</a>
</pre>那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-35611" href="../Lists/#plfa_plfa-part1-Lists-35611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35616" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35618" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35620" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35621" href="../Lists/#plfa_plfa-part1-Lists-35621" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35623" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35628" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35630" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35631" href="../Lists/#plfa_plfa-part1-Lists-35631" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35633" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35635" href="../Lists/#plfa_plfa-part1-Lists-35621" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35637" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35642" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35644" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35646" href="../Lists/#plfa_plfa-part1-Lists-35350" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35656" href="../Lists/#plfa_plfa-part1-Lists-35631" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35658" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35660" href="../Lists/#plfa_plfa-part1-Lists-35350" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35670" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35671" href="../Lists/#plfa_plfa-part1-Lists-27565" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-35675" href="../Lists/#plfa_plfa-part1-Lists-35631" class="Bound">P</a><a id="plfa_plfa-part1-Lists-35676" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35678" href="../Lists/#plfa_plfa-part1-Lists-35611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35683" href="../Lists/#plfa_plfa-part1-Lists-35683" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35686" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-35721" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35724" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35728" href="../Lists/#plfa_plfa-part1-Lists-27616" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-35731" href="../Lists/#plfa_plfa-part1-Lists-35611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35736" href="../Lists/#plfa_plfa-part1-Lists-35736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35739" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35740" href="../Lists/#plfa_plfa-part1-Lists-35740" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35742" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35744" href="../Lists/#plfa_plfa-part1-Lists-35744" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-35746" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35748" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-35753" href="../Lists/#plfa_plfa-part1-Lists-35736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35756" href="../Lists/#plfa_plfa-part1-Lists-35740" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-35760" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35762" href="../Lists/#plfa_plfa-part1-Lists-35611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35767" href="../Lists/#plfa_plfa-part1-Lists-35736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35770" href="../Lists/#plfa_plfa-part1-Lists-35744" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-35773" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35793" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35795" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35799" href="../Lists/#plfa_plfa-part1-Lists-35799" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35802" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35804" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35808" href="../Lists/#plfa_plfa-part1-Lists-35808" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-35816" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35819" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35823" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35824" href="../Lists/#plfa_plfa-part1-Lists-35799" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35827" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35829" href="../Lists/#plfa_plfa-part1-Lists-35808" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35832" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35834" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35854" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35856" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35859" href="../Lists/#plfa_plfa-part1-Lists-35859" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35863" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35865" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-35877" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35880" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35883" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35886" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35887" href="../Lists/#plfa_plfa-part1-Lists-35887" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35890" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35892" href="../Lists/#plfa_plfa-part1-Lists-35892" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35895" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35897" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35899" href="../Lists/#plfa_plfa-part1-Lists-35859" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35903" href="../Lists/#plfa_plfa-part1-Lists-35887" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-35908" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-35910" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-35913" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-35930" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35931" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35932" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-35933" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-35939" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35940" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35941" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-35943" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35944" href="../Lists/#plfa_plfa-part1-Lists-35944" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-35953" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35956" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35959" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35962" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35963" href="../Lists/#plfa_plfa-part1-Lists-35963" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35966" href="../Lists/#plfa_plfa-part1-Lists-27633" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35968" href="../Lists/#plfa_plfa-part1-Lists-35968" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35971" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35973" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35975" href="../Lists/#plfa_plfa-part1-Lists-35944" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-35980" href="../Lists/#plfa_plfa-part1-Lists-35968" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-35984" class="Symbol">}</a>
</pre><p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p><h4 id="练习-any延伸">练习 <code>Any?</code>（延伸）</h4><p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36859" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-split延伸">练习 <code>split</code>（延伸）</h4><p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37064" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-37069" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37075" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37076" href="../Lists/#plfa_plfa-part1-Lists-37076" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-37078" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37080" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-37083" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-37085" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37087" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37088" href="../Lists/#plfa_plfa-part1-Lists-37088" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37091" href="../Lists/#plfa_plfa-part1-Lists-37091" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37094" href="../Lists/#plfa_plfa-part1-Lists-37094" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-37097" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37099" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-37104" href="../Lists/#plfa_plfa-part1-Lists-37076" class="Bound">A</a><a id="plfa_plfa-part1-Lists-37105" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37107" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37109" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-37113" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-37122" href="../Lists/#plfa_plfa-part1-Lists-37122" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37125" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-37133" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-37154" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37160" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37163" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37166" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-37172" href="../Lists/#plfa_plfa-part1-Lists-37172" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37179" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37181" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37183" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37184" href="../Lists/#plfa_plfa-part1-Lists-37184" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37186" href="../Lists/#plfa_plfa-part1-Lists-37186" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37189" href="../Lists/#plfa_plfa-part1-Lists-37189" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37192" href="../Lists/#plfa_plfa-part1-Lists-37192" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37194" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37200" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37202" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37208" href="../Lists/#plfa_plfa-part1-Lists-37186" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37211" href="../Lists/#plfa_plfa-part1-Lists-37189" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37214" href="../Lists/#plfa_plfa-part1-Lists-37192" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37223" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37254" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37256" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37262" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37263" href="../Lists/#plfa_plfa-part1-Lists-37184" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37265" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37267" href="../Lists/#plfa_plfa-part1-Lists-37186" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-37269" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37271" href="../Lists/#plfa_plfa-part1-Lists-37189" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37274" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37275" href="../Lists/#plfa_plfa-part1-Lists-37184" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37277" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37279" href="../Lists/#plfa_plfa-part1-Lists-37192" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37281" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-37286" href="../Lists/#plfa_plfa-part1-Lists-37286" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37294" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37296" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37298" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37299" href="../Lists/#plfa_plfa-part1-Lists-37299" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37301" href="../Lists/#plfa_plfa-part1-Lists-37301" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37304" href="../Lists/#plfa_plfa-part1-Lists-37304" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37307" href="../Lists/#plfa_plfa-part1-Lists-37307" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37309" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37315" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37317" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37323" href="../Lists/#plfa_plfa-part1-Lists-37301" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37326" href="../Lists/#plfa_plfa-part1-Lists-37304" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37329" href="../Lists/#plfa_plfa-part1-Lists-37307" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37338" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37369" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37371" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37377" href="../Lists/#plfa_plfa-part1-Lists-37301" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37380" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37381" href="../Lists/#plfa_plfa-part1-Lists-37299" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37383" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37385" href="../Lists/#plfa_plfa-part1-Lists-37304" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-37387" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37389" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37390" href="../Lists/#plfa_plfa-part1-Lists-37299" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37392" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37394" href="../Lists/#plfa_plfa-part1-Lists-37307" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37396" class="Symbol">)</a>
</pre><p>例如</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37438" href="../Lists/#plfa_plfa-part1-Lists-37438" class="Function">_</a> <a id="plfa_plfa-part1-Lists-37440" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37442" href="../Lists/#plfa_plfa-part1-Lists-37069" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37448" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37450" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37452" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37454" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37456" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37458" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37460" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37462" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37464" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37466" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37468" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37470" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37472" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37474" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37476" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37478" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37480" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37482" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37484" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-37486" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-37488" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-37490" href="../Lists/#plfa_plfa-part1-Lists-37172" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37497" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37498" href="../Lists/#plfa_plfa-part1-Lists-37286" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37506" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37507" href="../Lists/#plfa_plfa-part1-Lists-37286" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37515" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37516" href="../Lists/#plfa_plfa-part1-Lists-37172" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37523" href="../Lists/#plfa_plfa-part1-Lists-37122" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-37525" class="Symbol">)))</a>
</pre><p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p><p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-38359" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-38537" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38544" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-38554" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38560" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38561" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#130" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-38565" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38567" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-38571" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38573" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4864" class="Function">length</a><a id="plfa_plfa-part1-Lists-38579" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38581" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#9817" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-38588" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38590" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1544" class="Function">map</a><a id="plfa_plfa-part1-Lists-38593" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38595" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4192" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-38600" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38602" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#6273" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-38610" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38612" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38619" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-38648" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38654" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38655" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-38658" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38660" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-38662" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38664" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-38667" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38669" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38676" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-38705" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38711" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38712" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-38715" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38717" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-38721" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38723" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-38728" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38730" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38737" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-38772" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38778" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38779" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-38782" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38784" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38791" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-38814" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38820" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38821" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#34556" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-38839" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38841" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3768" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-38852" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38854" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3085" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-38868" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38870" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#16280" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-38878" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-38882" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-38891" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38892" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#40456" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-38902" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-38905" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-38917" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38919" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38926" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-38945" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38951" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38952" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html#2801" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-38960" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38962" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38969" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-38984" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38990" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38991" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html#3536" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-39000" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39002" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39009" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-39025" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39031" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39032" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-39041" class="Symbol">)</a>
</pre><p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p><p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p><h2 id="unicode">Unicode</h2><p>本章使用了下列 Unicode：</p><pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>