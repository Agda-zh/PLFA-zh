<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: 列表与高阶函数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-96" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-103" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-120" class="Keyword">where</a>
</pre><p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-481" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-488" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-526" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-529" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-532" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-537" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-540" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-546" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-547" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-550" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-552" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-556" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-558" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="plfa_plfa-part1-Lists-561" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1938" class="Function">trans</a><a id="plfa_plfa-part1-Lists-568" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-570" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="plfa_plfa-part1-Lists-574" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-576" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-581" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-596" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-601" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-608" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Lists-623" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-630" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-634" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-636" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-640" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-642" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-647" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-649" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#1348" class="Function">T</a><a id="plfa_plfa-part1-Lists-650" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-652" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#995" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-657" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-660" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-662" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#941" class="Function">not</a><a id="plfa_plfa-part1-Lists-665" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-667" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-672" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-679" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Lists-693" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-699" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-700" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-701" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-703" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-707" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-709" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-712" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-714" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-717" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-719" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-722" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-724" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#4462" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-727" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-729" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1697" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-732" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-734" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1762" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-737" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-739" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1720" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-742" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-744" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-749" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-756" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-776" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-784" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-785" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15309" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-792" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-794" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15410" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-805" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-807" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15465" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-818" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-820" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#22870" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-827" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-829" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#21770" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-840" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-842" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#21834" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-853" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-855" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#22384" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-867" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-869" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-874" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-881" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-898" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-904" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-905" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-907" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-909" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-912" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-914" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-917" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-919" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-921" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-923" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-928" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-935" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="plfa_plfa-part1-Lists-953" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-959" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-960" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-963" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-965" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#852" class="Function">∃</a><a id="plfa_plfa-part1-Lists-966" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-968" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1371" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-976" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-978" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-987" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-988" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-992" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-1000" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1002" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1007" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1014" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html" class="Module">Function.Base</a> <a id="plfa_plfa-part1-Lists-1028" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1034" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1035" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-1038" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1040" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1045" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1052" href="https://agda.github.io/agda-stdlib/v2.2-dev/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-1058" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1064" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1065" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#742" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-1070" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1072" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1077" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1084" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-1107" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1113" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1114" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-1117" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-1119" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14965" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-1122" class="Symbol">)</a>
</pre><h2 id="列表">列表</h2>Agda 中的列表如下定义：<pre class="Agda"><a id="plfa_plfa-part1-Lists-1227" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1232" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1237" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1238" href="../Lists/#plfa_plfa-part1-Lists-1238" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1240" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1242" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1245" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1247" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1249" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1253" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1261" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1265" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1267" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1272" href="../Lists/#plfa_plfa-part1-Lists-1238" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1276" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1280" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1282" href="../Lists/#plfa_plfa-part1-Lists-1238" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1284" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1286" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1291" href="../Lists/#plfa_plfa-part1-Lists-1238" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1293" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1295" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1300" href="../Lists/#plfa_plfa-part1-Lists-1238" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1303" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1310" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1312" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">_∷_</a>
</pre><p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-1981" href="../Lists/#plfa_plfa-part1-Lists-1981" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1983" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1985" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1990" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1992" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1994" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1996" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1998" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2000" class="Number">1</a> <a id="plfa_plfa-part1-Lists-2002" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2004" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2006" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2008" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
</pre><p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p><p>正如我们所见，有些参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-2759" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2764" href="../Lists/#plfa_plfa-part1-Lists-2764" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2770" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2772" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2776" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2778" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="plfa_plfa-part1-Lists-2783" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2791" href="../Lists/#plfa_plfa-part1-Lists-2791" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2796" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2798" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2800" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2801" href="../Lists/#plfa_plfa-part1-Lists-2801" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2803" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2805" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2808" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2810" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2812" href="../Lists/#plfa_plfa-part1-Lists-2764" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2818" href="../Lists/#plfa_plfa-part1-Lists-2801" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2822" href="../Lists/#plfa_plfa-part1-Lists-2822" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2827" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2829" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2831" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2832" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2834" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2836" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2839" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2841" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2843" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2845" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2847" href="../Lists/#plfa_plfa-part1-Lists-2764" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2853" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2855" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2857" href="../Lists/#plfa_plfa-part1-Lists-2764" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2863" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">A</a>
</pre><p>二者几乎是等价的，只不过参数化类型的结果可以是 <code>Set</code>， 而由于技术原因，索引类型要求结果为 <code>Set₁</code>。</p><p>每个 <code>List</code> 的构造子都将参数作为隐式参数。因此我们列表的例子也可以写作：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3282" href="../Lists/#plfa_plfa-part1-Lists-3282" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3284" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3286" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3291" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-3293" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-3295" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3297" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3301" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3302" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3303" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3305" class="Number">0</a> <a id="plfa_plfa-part1-Lists-3307" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3308" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3312" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3313" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3314" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3316" class="Number">1</a> <a id="plfa_plfa-part1-Lists-3318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3319" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3323" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3324" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3325" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3327" class="Number">2</a> <a id="plfa_plfa-part1-Lists-3329" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3330" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-3333" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3334" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3335" class="Symbol">})))</a>
</pre><p>此处我们将隐式参数显式地声明。</p><p>包含下面的编译器指令</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p><h2 id="列表语法">列表语法</h2><p>我们可以用下面的定义，更简便地表示列表：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3959" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3967" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3971" href="../Lists/#plfa_plfa-part1-Lists-3975" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3973" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3975" href="../Lists/#plfa_plfa-part1-Lists-3975" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3977" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3979" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3982" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3990" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3996" href="../Lists/#plfa_plfa-part1-Lists-4002" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3998" href="../Lists/#plfa_plfa-part1-Lists-4006" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4000" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-4002" href="../Lists/#plfa_plfa-part1-Lists-4002" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4004" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4006" href="../Lists/#plfa_plfa-part1-Lists-4006" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4008" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4010" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-4013" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-4021" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-4029" href="../Lists/#plfa_plfa-part1-Lists-4037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4031" href="../Lists/#plfa_plfa-part1-Lists-4041" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4033" href="../Lists/#plfa_plfa-part1-Lists-4045" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4035" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-4037" href="../Lists/#plfa_plfa-part1-Lists-4037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4039" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4041" href="../Lists/#plfa_plfa-part1-Lists-4041" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4043" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4045" href="../Lists/#plfa_plfa-part1-Lists-4045" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4047" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4049" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-4052" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-4060" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-4070" href="../Lists/#plfa_plfa-part1-Lists-4080" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4072" href="../Lists/#plfa_plfa-part1-Lists-4084" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4074" href="../Lists/#plfa_plfa-part1-Lists-4088" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4076" href="../Lists/#plfa_plfa-part1-Lists-4092" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4078" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-4080" href="../Lists/#plfa_plfa-part1-Lists-4080" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4082" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4084" href="../Lists/#plfa_plfa-part1-Lists-4084" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4086" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4088" href="../Lists/#plfa_plfa-part1-Lists-4088" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4090" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4092" href="../Lists/#plfa_plfa-part1-Lists-4092" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4094" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4096" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-4099" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-4107" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-4119" href="../Lists/#plfa_plfa-part1-Lists-4131" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-4121" href="../Lists/#plfa_plfa-part1-Lists-4135" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4123" href="../Lists/#plfa_plfa-part1-Lists-4139" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4125" href="../Lists/#plfa_plfa-part1-Lists-4143" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4127" href="../Lists/#plfa_plfa-part1-Lists-4147" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4129" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-4131" href="../Lists/#plfa_plfa-part1-Lists-4131" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-4133" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4135" href="../Lists/#plfa_plfa-part1-Lists-4135" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4137" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4139" href="../Lists/#plfa_plfa-part1-Lists-4139" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4141" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4143" href="../Lists/#plfa_plfa-part1-Lists-4143" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4145" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4147" href="../Lists/#plfa_plfa-part1-Lists-4147" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4149" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4151" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-4154" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-4162" href="../Lists/#plfa_plfa-part1-Lists-4162" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-4176" href="../Lists/#plfa_plfa-part1-Lists-4190" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-4178" href="../Lists/#plfa_plfa-part1-Lists-4194" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-4180" href="../Lists/#plfa_plfa-part1-Lists-4198" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4182" href="../Lists/#plfa_plfa-part1-Lists-4202" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4184" href="../Lists/#plfa_plfa-part1-Lists-4206" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4186" href="../Lists/#plfa_plfa-part1-Lists-4210" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4188" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-4190" href="../Lists/#plfa_plfa-part1-Lists-4190" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-4192" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4194" href="../Lists/#plfa_plfa-part1-Lists-4194" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-4196" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4198" href="../Lists/#plfa_plfa-part1-Lists-4198" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-4200" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4202" href="../Lists/#plfa_plfa-part1-Lists-4202" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4204" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4206" href="../Lists/#plfa_plfa-part1-Lists-4206" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-4208" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4210" href="../Lists/#plfa_plfa-part1-Lists-4210" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-4212" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4214" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
</pre><p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p><h2 id="附加">附加</h2><p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-4767" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-4774" class="Number">5</a> <a id="plfa_plfa-part1-Lists-4776" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-4782" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-4787" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4789" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4791" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4792" href="../Lists/#plfa_plfa-part1-Lists-4792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4794" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4796" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4799" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4801" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4803" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4808" href="../Lists/#plfa_plfa-part1-Lists-4792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4810" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4812" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4817" href="../Lists/#plfa_plfa-part1-Lists-4792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4819" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4821" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4826" href="../Lists/#plfa_plfa-part1-Lists-4792" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-4828" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-4837" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4840" href="../Lists/#plfa_plfa-part1-Lists-4840" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4844" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4847" href="../Lists/#plfa_plfa-part1-Lists-4840" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-4850" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4851" href="../Lists/#plfa_plfa-part1-Lists-4851" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4853" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4855" href="../Lists/#plfa_plfa-part1-Lists-4855" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4857" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4859" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4862" href="../Lists/#plfa_plfa-part1-Lists-4862" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4866" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4869" href="../Lists/#plfa_plfa-part1-Lists-4851" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4871" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4873" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4874" href="../Lists/#plfa_plfa-part1-Lists-4855" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4877" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4880" href="../Lists/#plfa_plfa-part1-Lists-4862" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4882" class="Symbol">)</a>
</pre><p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p><p>我们举个例子，来展示将两个列表附加的计算过程：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-5509" href="../Lists/#plfa_plfa-part1-Lists-5509" class="Function">_</a> <a id="plfa_plfa-part1-Lists-5511" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5513" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5515" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5517" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5519" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5521" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5523" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5525" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5527" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5530" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5532" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5534" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5536" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5538" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5540" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5542" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5544" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5546" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5548" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5550" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5552" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5554" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5556" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5558" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5560" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5562" href="../Lists/#plfa_plfa-part1-Lists-4107" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-5564" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-5566" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5570" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5580" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5582" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5584" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5586" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5588" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5590" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5592" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5595" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5598" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5600" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5602" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5604" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5606" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5611" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5619" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5621" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5623" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5624" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5626" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5628" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5630" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5632" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5635" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5638" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5640" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5642" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5644" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5646" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5648" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5652" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5660" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5662" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5664" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5666" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5668" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5669" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5671" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5673" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5676" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5679" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5681" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5683" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5685" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5687" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5689" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5693" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5701" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5703" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5705" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5707" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5709" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5711" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5713" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5714" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5717" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5720" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5722" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5724" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5726" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5728" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5730" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5734" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5742" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5744" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5746" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5748" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5750" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5752" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5754" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5756" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5758" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5760" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5762" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5767" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>附加两个列表需要对于第一个列表元素个数线性的时间。</p><h2 id="论证附加">论证附加</h2>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-6122" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6131" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6133" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6135" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6136" href="../Lists/#plfa_plfa-part1-Lists-6136" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6138" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6140" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6143" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6145" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6146" href="../Lists/#plfa_plfa-part1-Lists-6146" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6149" href="../Lists/#plfa_plfa-part1-Lists-6149" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6152" href="../Lists/#plfa_plfa-part1-Lists-6152" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6155" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6157" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6162" href="../Lists/#plfa_plfa-part1-Lists-6136" class="Bound">A</a><a id="plfa_plfa-part1-Lists-6163" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6167" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6169" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6170" href="../Lists/#plfa_plfa-part1-Lists-6146" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6173" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6176" href="../Lists/#plfa_plfa-part1-Lists-6149" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6178" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6180" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6183" href="../Lists/#plfa_plfa-part1-Lists-6152" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6186" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6188" href="../Lists/#plfa_plfa-part1-Lists-6146" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6191" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6194" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6195" href="../Lists/#plfa_plfa-part1-Lists-6149" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6198" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6201" href="../Lists/#plfa_plfa-part1-Lists-6152" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6203" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-6205" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6214" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6217" href="../Lists/#plfa_plfa-part1-Lists-6217" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6220" href="../Lists/#plfa_plfa-part1-Lists-6220" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6223" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6227" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6237" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6238" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6241" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6244" href="../Lists/#plfa_plfa-part1-Lists-6217" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6246" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6248" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6251" href="../Lists/#plfa_plfa-part1-Lists-6220" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6256" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6264" href="../Lists/#plfa_plfa-part1-Lists-6217" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6267" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6270" href="../Lists/#plfa_plfa-part1-Lists-6220" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6275" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6283" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6286" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6289" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6290" href="../Lists/#plfa_plfa-part1-Lists-6217" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6293" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6296" href="../Lists/#plfa_plfa-part1-Lists-6220" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6298" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6302" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6304" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6313" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6314" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6316" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6318" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6320" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6322" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6325" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6328" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6332" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6342" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6343" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6345" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6347" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6350" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6353" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6355" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6357" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6360" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6365" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6373" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6375" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6377" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6378" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6381" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6384" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6386" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6388" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6391" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6396" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6404" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6406" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6408" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-6410" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6413" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6416" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6418" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6420" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6423" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6425" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6429" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6432" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6437" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6438" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6440" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6442" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6444" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6445" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6454" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6457" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6460" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6462" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6464" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6470" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6472" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6474" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6475" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6478" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6481" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6482" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6485" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6488" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6490" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6495" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6503" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6505" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6507" href="../Lists/#plfa_plfa-part1-Lists-6318" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6510" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6513" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6514" href="../Lists/#plfa_plfa-part1-Lists-6322" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6517" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6520" href="../Lists/#plfa_plfa-part1-Lists-6325" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6522" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6526" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p><p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>提升至等式：</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>即证明中所需。</p><p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-7626" href="../Lists/#plfa_plfa-part1-Lists-7626" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7639" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7641" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7643" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7644" href="../Lists/#plfa_plfa-part1-Lists-7644" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7646" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7648" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7651" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7653" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7654" href="../Lists/#plfa_plfa-part1-Lists-7654" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7657" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7659" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7664" href="../Lists/#plfa_plfa-part1-Lists-7644" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7665" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7667" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7669" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7672" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7675" href="../Lists/#plfa_plfa-part1-Lists-7654" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7678" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7680" href="../Lists/#plfa_plfa-part1-Lists-7654" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7683" href="../Lists/#plfa_plfa-part1-Lists-7626" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7696" href="../Lists/#plfa_plfa-part1-Lists-7696" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7699" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7703" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7713" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7716" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7719" href="../Lists/#plfa_plfa-part1-Lists-7696" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7724" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7732" href="../Lists/#plfa_plfa-part1-Lists-7696" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7737" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre>右幺元的证明可由简单的归纳得到：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-7836" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7849" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7851" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7853" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7854" href="../Lists/#plfa_plfa-part1-Lists-7854" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7856" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7858" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7861" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7863" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7864" href="../Lists/#plfa_plfa-part1-Lists-7864" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7867" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7869" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7874" href="../Lists/#plfa_plfa-part1-Lists-7854" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7875" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7877" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7879" href="../Lists/#plfa_plfa-part1-Lists-7864" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7882" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7885" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7888" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7890" href="../Lists/#plfa_plfa-part1-Lists-7864" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7893" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7906" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7909" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7913" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7923" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7926" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7929" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7934" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7942" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7947" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7949" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7962" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7963" href="../Lists/#plfa_plfa-part1-Lists-7963" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7965" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7967" href="../Lists/#plfa_plfa-part1-Lists-7967" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7969" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7971" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7975" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7985" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7986" href="../Lists/#plfa_plfa-part1-Lists-7963" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7988" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7990" href="../Lists/#plfa_plfa-part1-Lists-7967" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7992" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7994" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7997" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-8002" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8010" href="../Lists/#plfa_plfa-part1-Lists-7963" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8012" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8014" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8015" href="../Lists/#plfa_plfa-part1-Lists-7967" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-8018" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8021" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8023" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8027" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-8030" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-8035" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8036" href="../Lists/#plfa_plfa-part1-Lists-7963" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8038" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-8040" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8042" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8043" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-8056" href="../Lists/#plfa_plfa-part1-Lists-7967" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8058" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8060" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-8066" href="../Lists/#plfa_plfa-part1-Lists-7963" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8068" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8070" href="../Lists/#plfa_plfa-part1-Lists-7967" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-8075" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p><h2 id="长度">长度</h2><p>在下一个函数里，我们来寻找列表的长度：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-8367" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8374" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8376" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8378" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8379" href="../Lists/#plfa_plfa-part1-Lists-8379" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8381" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8383" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8386" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8388" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8390" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8395" href="../Lists/#plfa_plfa-part1-Lists-8379" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8397" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8399" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-8401" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8408" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8418" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8421" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-8426" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8433" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8434" href="../Lists/#plfa_plfa-part1-Lists-8434" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8436" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8438" href="../Lists/#plfa_plfa-part1-Lists-8438" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8440" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8443" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8446" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8450" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8451" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8458" href="../Lists/#plfa_plfa-part1-Lists-8438" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8460" class="Symbol">)</a>
</pre><p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>我们用下面的例子来展示如何计算列表的长度：<pre class="Agda"><a id="plfa_plfa-part1-Lists-8794" href="../Lists/#plfa_plfa-part1-Lists-8794" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8796" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8798" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8805" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8807" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8809" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8811" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8813" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8815" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8817" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8819" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8821" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-8823" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8825" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8829" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8839" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8846" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8847" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8849" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8851" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8853" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8855" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8857" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8859" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8861" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8865" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8873" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8877" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8878" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8885" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8886" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8888" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8890" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8892" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8894" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8896" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8901" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8909" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8913" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8914" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8918" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8919" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8926" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8927" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8929" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8931" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8933" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8939" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8947" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8951" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8952" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8956" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8957" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8961" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8962" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8969" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8970" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-8971" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8973" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8975" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8981" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8989" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8993" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8994" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8998" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8999" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9003" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-9007" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9012" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>计算列表的长度需要关于列表元素个数线性的时间。</p><p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p><h2 id="论证长度">论证长度</h2><p>两个附加在一起的列表的长度是两列表长度之和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-9611" href="../Lists/#plfa_plfa-part1-Lists-9611" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9621" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9623" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-9625" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9626" href="../Lists/#plfa_plfa-part1-Lists-9626" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-9628" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9630" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-9633" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9635" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9636" href="../Lists/#plfa_plfa-part1-Lists-9636" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9639" href="../Lists/#plfa_plfa-part1-Lists-9639" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9642" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9644" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-9649" href="../Lists/#plfa_plfa-part1-Lists-9626" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9650" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9654" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-9656" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9663" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9664" href="../Lists/#plfa_plfa-part1-Lists-9636" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9667" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9670" href="../Lists/#plfa_plfa-part1-Lists-9639" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9672" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9674" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-9676" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9683" href="../Lists/#plfa_plfa-part1-Lists-9636" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9686" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9688" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9695" href="../Lists/#plfa_plfa-part1-Lists-9639" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-9698" href="../Lists/#plfa_plfa-part1-Lists-9611" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9708" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9709" href="../Lists/#plfa_plfa-part1-Lists-9709" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9710" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9712" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9715" href="../Lists/#plfa_plfa-part1-Lists-9715" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9718" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9722" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9732" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9739" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9740" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9743" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9746" href="../Lists/#plfa_plfa-part1-Lists-9715" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9748" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9752" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9760" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9767" href="../Lists/#plfa_plfa-part1-Lists-9715" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9772" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9780" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9787" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9788" href="../Lists/#plfa_plfa-part1-Lists-9709" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9789" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9791" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9794" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9796" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9803" href="../Lists/#plfa_plfa-part1-Lists-9715" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9808" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-9810" href="../Lists/#plfa_plfa-part1-Lists-9611" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9820" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9821" href="../Lists/#plfa_plfa-part1-Lists-9821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9823" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9825" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9827" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9829" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9832" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9836" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9846" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9853" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9855" href="../Lists/#plfa_plfa-part1-Lists-9821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9857" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9859" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9861" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9863" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9866" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9868" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9872" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9880" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9884" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9885" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9892" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9893" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9896" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9899" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9901" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9906" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-9909" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-9914" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9918" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9919" href="../Lists/#plfa_plfa-part1-Lists-9611" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9929" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9932" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9934" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9936" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-9942" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9947" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9954" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9957" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9959" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9966" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9968" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9972" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9980" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9987" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9988" href="../Lists/#plfa_plfa-part1-Lists-9821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9990" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9992" href="../Lists/#plfa_plfa-part1-Lists-9825" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9994" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9996" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9998" href="../Lists/#plfa_plfa-part1-Lists-8367" class="Function">length</a> <a id="plfa_plfa-part1-Lists-10005" href="../Lists/#plfa_plfa-part1-Lists-9829" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10010" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p><h2 id="反转">反转</h2>我们可以使用附加，来简单地构造一个函数来反转一个列表：<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-10893" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10901" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10903" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10905" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10906" href="../Lists/#plfa_plfa-part1-Lists-10906" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10908" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10910" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10913" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10915" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10917" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10922" href="../Lists/#plfa_plfa-part1-Lists-10906" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10924" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10926" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10931" href="../Lists/#plfa_plfa-part1-Lists-10906" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10933" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10941" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-10951" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10954" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-10957" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10965" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10966" href="../Lists/#plfa_plfa-part1-Lists-10966" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10968" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10970" href="../Lists/#plfa_plfa-part1-Lists-10970" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10972" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-10975" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10978" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10986" href="../Lists/#plfa_plfa-part1-Lists-10970" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10989" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10992" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10994" href="../Lists/#plfa_plfa-part1-Lists-10966" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10996" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a>
</pre><p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>下面的例子展示了如何反转一个列表。<pre class="Agda"><a id="plfa_plfa-part1-Lists-11300" href="../Lists/#plfa_plfa-part1-Lists-11300" class="Function">_</a> <a id="plfa_plfa-part1-Lists-11302" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11304" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11312" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11314" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11316" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11318" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11320" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11322" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11324" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11326" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-11328" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11330" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11332" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11334" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11336" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11338" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11340" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-11342" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-11344" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11348" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11358" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11366" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11367" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11369" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11371" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11373" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11375" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11377" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11379" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11381" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11385" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11393" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11401" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11402" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11404" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11406" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11408" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11410" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11412" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11414" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11417" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11419" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11421" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11425" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11433" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11434" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11442" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11443" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11445" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11447" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11449" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11451" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11454" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11456" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11458" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11459" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11461" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11464" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11466" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11468" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11472" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11480" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11482" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11490" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11493" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11496" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11498" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11500" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11501" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11503" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11506" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11508" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11510" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11511" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11513" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11516" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11518" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11520" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11524" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11532" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11534" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11537" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11540" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11542" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11544" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11545" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11547" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11550" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11552" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11554" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11555" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11557" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11560" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11562" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11564" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11568" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11576" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11578" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11581" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11584" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11586" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11588" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11590" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11592" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11595" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11597" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11599" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11601" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11603" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11606" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11608" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11610" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11615" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11623" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11624" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11626" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11628" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11631" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11634" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11636" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11638" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11640" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11642" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11645" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11647" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11649" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11654" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11662" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11664" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11666" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11667" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11670" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11673" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11675" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11677" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11679" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11681" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11684" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11686" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11688" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11693" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11701" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11702" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11704" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11706" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11708" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11710" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11712" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11714" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11717" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11719" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11721" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11726" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11734" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11736" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11738" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11739" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11741" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11743" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11746" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11749" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11751" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11753" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11755" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11759" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11767" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11769" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11771" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11773" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11775" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11776" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11779" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11782" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11784" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11786" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11788" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11792" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11800" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11802" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11804" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11806" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11808" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11810" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11812" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11817" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11825" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11827" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11829" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11831" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11833" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11835" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11837" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11841" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p><h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4><p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-12746" class="Comment">-- Your code goes here</a>
</pre><h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4><p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-13101" class="Comment">-- Your code goes here</a>
</pre><h2 id="更快地反转">更快地反转</h2><p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-13478" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13484" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13486" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13488" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13489" href="../Lists/#plfa_plfa-part1-Lists-13489" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13491" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13493" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13496" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13498" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13500" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13505" href="../Lists/#plfa_plfa-part1-Lists-13489" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13507" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13509" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13514" href="../Lists/#plfa_plfa-part1-Lists-13489" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13516" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13518" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13523" href="../Lists/#plfa_plfa-part1-Lists-13489" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-13525" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13531" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-13540" href="../Lists/#plfa_plfa-part1-Lists-13540" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13544" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13547" href="../Lists/#plfa_plfa-part1-Lists-13540" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13550" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13556" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13557" href="../Lists/#plfa_plfa-part1-Lists-13557" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13559" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13561" href="../Lists/#plfa_plfa-part1-Lists-13561" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13563" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13565" href="../Lists/#plfa_plfa-part1-Lists-13565" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13569" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13572" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13578" href="../Lists/#plfa_plfa-part1-Lists-13561" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13581" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13582" href="../Lists/#plfa_plfa-part1-Lists-13557" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13584" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13586" href="../Lists/#plfa_plfa-part1-Lists-13565" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13588" class="Symbol">)</a>
</pre><p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>转移（Shunt）与反转的关系如下：<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-13923" href="../Lists/#plfa_plfa-part1-Lists-13923" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13937" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13939" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13941" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13942" href="../Lists/#plfa_plfa-part1-Lists-13942" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13944" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13946" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13949" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13951" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13952" href="../Lists/#plfa_plfa-part1-Lists-13952" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13955" href="../Lists/#plfa_plfa-part1-Lists-13955" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13958" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13960" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13965" href="../Lists/#plfa_plfa-part1-Lists-13942" class="Bound">A</a><a id="plfa_plfa-part1-Lists-13966" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13970" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13972" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13978" href="../Lists/#plfa_plfa-part1-Lists-13952" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13981" href="../Lists/#plfa_plfa-part1-Lists-13955" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13984" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13986" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13994" href="../Lists/#plfa_plfa-part1-Lists-13952" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13997" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14000" href="../Lists/#plfa_plfa-part1-Lists-13955" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-14003" href="../Lists/#plfa_plfa-part1-Lists-13923" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-14017" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-14020" href="../Lists/#plfa_plfa-part1-Lists-14020" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-14023" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-14027" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-14037" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-14043" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-14046" href="../Lists/#plfa_plfa-part1-Lists-14020" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14051" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14059" href="../Lists/#plfa_plfa-part1-Lists-14020" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14064" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14072" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14080" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-14083" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14086" href="../Lists/#plfa_plfa-part1-Lists-14020" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14091" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-14093" href="../Lists/#plfa_plfa-part1-Lists-13923" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-14107" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14108" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14110" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14112" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14114" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14116" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-14119" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-14123" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-14133" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-14139" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14140" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14142" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14144" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14146" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14148" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14153" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14161" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-14167" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14171" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14173" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14175" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14177" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-14181" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-14184" href="../Lists/#plfa_plfa-part1-Lists-13923" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-14198" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14201" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14202" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14204" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14206" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14208" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14210" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-14216" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14224" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14227" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14230" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14231" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14233" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14235" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14237" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-14241" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14249" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14257" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14260" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14263" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14264" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14266" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14268" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14270" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14273" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14275" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-14279" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-14282" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-14286" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14287" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-14296" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14297" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14305" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14307" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14309" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14311" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14313" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14315" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14317" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14319" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-14325" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14326" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14334" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14337" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14340" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14342" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14344" href="../Lists/#plfa_plfa-part1-Lists-3967" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-14345" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14347" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14350" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14355" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14363" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14371" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14372" href="../Lists/#plfa_plfa-part1-Lists-14108" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14374" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14376" href="../Lists/#plfa_plfa-part1-Lists-14112" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14378" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14380" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14383" href="../Lists/#plfa_plfa-part1-Lists-14116" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14388" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p><p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p><p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-15409" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15418" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15420" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15422" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15423" href="../Lists/#plfa_plfa-part1-Lists-15423" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15425" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15427" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15430" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15432" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15434" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15439" href="../Lists/#plfa_plfa-part1-Lists-15423" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15441" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15443" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15448" href="../Lists/#plfa_plfa-part1-Lists-15423" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-15450" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15459" href="../Lists/#plfa_plfa-part1-Lists-15459" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15462" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-15464" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15470" href="../Lists/#plfa_plfa-part1-Lists-15459" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15473" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
</pre><p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-15619" href="../Lists/#plfa_plfa-part1-Lists-15619" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15628" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15630" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15632" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15633" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15635" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15637" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15640" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15642" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15643" href="../Lists/#plfa_plfa-part1-Lists-15643" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15646" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15648" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15653" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">A</a><a id="plfa_plfa-part1-Lists-15654" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15658" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15660" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15669" href="../Lists/#plfa_plfa-part1-Lists-15643" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15672" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15674" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15682" href="../Lists/#plfa_plfa-part1-Lists-15643" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-15685" href="../Lists/#plfa_plfa-part1-Lists-15619" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15694" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15697" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15701" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15711" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15720" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15725" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15733" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15739" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15742" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15747" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15750" href="../Lists/#plfa_plfa-part1-Lists-13923" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-15764" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15767" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15770" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15776" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15784" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15787" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-15790" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15795" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15798" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-15811" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15812" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15820" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15822" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15824" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15830" href="../Lists/#plfa_plfa-part1-Lists-10893" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15838" href="../Lists/#plfa_plfa-part1-Lists-15694" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15843" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-15972" href="../Lists/#plfa_plfa-part1-Lists-15972" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15974" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15976" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15985" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15987" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15989" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15991" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15993" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15995" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15997" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15999" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16001" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16003" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16005" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16007" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16009" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16011" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16013" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-16015" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16017" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16021" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16031" href="../Lists/#plfa_plfa-part1-Lists-15409" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-16040" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16041" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16043" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16045" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16047" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16049" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16051" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16053" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16055" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16059" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16067" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-16073" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16074" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16076" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16078" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16080" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16082" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16084" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16086" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16088" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16090" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-16095" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16103" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-16109" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16110" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16112" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16114" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16116" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16118" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16120" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16122" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16123" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16125" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16127" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16129" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16133" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16141" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-16147" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16148" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16150" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16152" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16154" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16156" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16157" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16159" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16161" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16163" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16165" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16167" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16171" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16179" href="../Lists/#plfa_plfa-part1-Lists-13478" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-16185" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-16188" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16189" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16191" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16193" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16195" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16197" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16199" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16201" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16203" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16207" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16215" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16217" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16219" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16221" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16223" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16225" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16227" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-16232" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>现在反转一个列表需要的时间与列表的长度线性相关。</p><h2 id="Map">映射</h2><p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-16702" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16706" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16708" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-16710" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-16711" href="../Lists/#plfa_plfa-part1-Lists-16711" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16713" href="../Lists/#plfa_plfa-part1-Lists-16713" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-16715" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16717" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-16720" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-16722" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16725" href="../Lists/#plfa_plfa-part1-Lists-16711" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16727" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16729" href="../Lists/#plfa_plfa-part1-Lists-16713" class="Bound">B</a><a id="plfa_plfa-part1-Lists-16730" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16732" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16734" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16739" href="../Lists/#plfa_plfa-part1-Lists-16711" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16741" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16743" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16748" href="../Lists/#plfa_plfa-part1-Lists-16713" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-16750" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16754" href="../Lists/#plfa_plfa-part1-Lists-16754" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16756" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-16766" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16769" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-16772" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16776" href="../Lists/#plfa_plfa-part1-Lists-16776" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16778" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16779" href="../Lists/#plfa_plfa-part1-Lists-16779" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16781" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16783" href="../Lists/#plfa_plfa-part1-Lists-16783" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-16785" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-16788" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16791" href="../Lists/#plfa_plfa-part1-Lists-16776" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16793" href="../Lists/#plfa_plfa-part1-Lists-16779" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16795" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16797" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16801" href="../Lists/#plfa_plfa-part1-Lists-16776" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16803" href="../Lists/#plfa_plfa-part1-Lists-16783" class="Bound">xs</a>
</pre><p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p><p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-17252" href="../Lists/#plfa_plfa-part1-Lists-17252" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17254" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17256" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17260" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17264" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17266" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17268" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17270" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17272" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17274" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17276" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17278" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17280" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17282" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17284" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17286" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17288" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17290" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17292" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17294" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17296" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17300" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17310" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17314" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17319" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17321" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17323" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17325" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17327" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17329" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17331" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17333" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17337" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17345" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17349" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17351" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17353" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17357" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17361" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17362" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17364" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17366" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17368" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17370" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17372" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17376" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17384" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17388" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17390" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17392" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17396" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17398" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17400" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17404" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17408" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17409" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17411" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17413" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17415" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17419" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17427" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17431" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17433" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17435" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17439" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17441" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17443" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17447" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17449" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17451" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17455" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17459" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17464" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17472" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17476" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17478" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17480" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17484" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17486" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17488" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17492" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17494" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17496" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17501" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17509" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17511" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17513" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17515" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17517" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17519" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17521" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17526" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>映射需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-17832" href="../Lists/#plfa_plfa-part1-Lists-17832" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17837" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17839" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17844" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-17846" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17848" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17853" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-17855" href="../Lists/#plfa_plfa-part1-Lists-17832" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17860" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-17862" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17866" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-17871" href="../Lists/#plfa_plfa-part1-Lists-17871" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17873" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17875" href="../Lists/#plfa_plfa-part1-Lists-17832" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17880" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17882" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17884" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17886" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17888" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17890" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17892" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17894" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17896" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17898" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17900" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17902" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17904" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17906" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17908" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17910" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17912" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17916" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17926" href="../Lists/#plfa_plfa-part1-Lists-17832" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17931" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17933" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17935" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17937" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17939" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17941" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17943" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17947" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17955" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17959" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17963" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17965" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17967" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17969" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17971" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17973" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17975" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17979" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17987" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17989" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17991" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17993" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17995" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17997" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17999" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-18003" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p><h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4><p>证明函数组合的映射是两个映射的组合：</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>证明的最后一步需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18806" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4><p>证明下列关于映射与附加的关系：</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19048" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4><p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-19268" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-19273" href="../Lists/#plfa_plfa-part1-Lists-19273" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19279" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19281" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19283" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19285" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19288" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19290" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19292" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19296" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-19304" href="../Lists/#plfa_plfa-part1-Lists-19304" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-19309" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19311" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19313" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19315" href="../Lists/#plfa_plfa-part1-Lists-19273" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19320" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19322" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-19326" href="../Lists/#plfa_plfa-part1-Lists-19326" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-19331" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19333" href="../Lists/#plfa_plfa-part1-Lists-19273" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19338" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19340" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19342" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19344" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19346" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19348" href="../Lists/#plfa_plfa-part1-Lists-19273" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19353" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19355" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19357" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19359" href="../Lists/#plfa_plfa-part1-Lists-19273" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19364" href="../Lists/#plfa_plfa-part1-Lists-19279" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19366" href="../Lists/#plfa_plfa-part1-Lists-19281" class="Bound">B</a>
</pre><p>定义一个对于树的映射运算符：</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19526" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="Fold">折叠</h2><p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-19816" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19822" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19824" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19826" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19827" href="../Lists/#plfa_plfa-part1-Lists-19827" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19829" href="../Lists/#plfa_plfa-part1-Lists-19829" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19831" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19833" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19836" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19838" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19840" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19841" href="../Lists/#plfa_plfa-part1-Lists-19827" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19843" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19845" href="../Lists/#plfa_plfa-part1-Lists-19829" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19847" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19849" href="../Lists/#plfa_plfa-part1-Lists-19829" class="Bound">B</a><a id="plfa_plfa-part1-Lists-19850" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19852" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19854" href="../Lists/#plfa_plfa-part1-Lists-19829" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19856" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19858" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19863" href="../Lists/#plfa_plfa-part1-Lists-19827" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19865" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19867" href="../Lists/#plfa_plfa-part1-Lists-19829" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-19869" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19875" href="../Lists/#plfa_plfa-part1-Lists-19875" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19879" href="../Lists/#plfa_plfa-part1-Lists-19879" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19881" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-19891" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19894" href="../Lists/#plfa_plfa-part1-Lists-19879" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-19896" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19902" href="../Lists/#plfa_plfa-part1-Lists-19902" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19906" href="../Lists/#plfa_plfa-part1-Lists-19906" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19908" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19909" href="../Lists/#plfa_plfa-part1-Lists-19909" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19911" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19913" href="../Lists/#plfa_plfa-part1-Lists-19913" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19915" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-19918" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19921" href="../Lists/#plfa_plfa-part1-Lists-19909" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19923" href="../Lists/#plfa_plfa-part1-Lists-19902" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19925" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19931" href="../Lists/#plfa_plfa-part1-Lists-19902" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19935" href="../Lists/#plfa_plfa-part1-Lists-19906" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19937" href="../Lists/#plfa_plfa-part1-Lists-19913" class="Bound">xs</a>
</pre><p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p><p>下面的例子展示了如何使用折叠来对一个列表求和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-20271" href="../Lists/#plfa_plfa-part1-Lists-20271" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20275" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20281" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20285" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20287" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20289" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20291" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20293" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20295" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20297" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20299" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20301" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20303" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20305" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20307" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20310" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20312" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20316" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20326" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20332" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20336" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20338" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20339" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20341" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20343" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20345" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20347" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20349" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20351" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20353" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20355" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20357" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20361" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20369" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20371" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20373" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20379" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20383" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20385" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20386" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20388" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20390" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20392" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20394" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20396" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20398" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20400" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20404" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20412" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20414" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20416" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20417" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20419" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20421" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20427" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20431" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20433" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20434" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20436" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20438" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20440" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20442" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20444" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-20449" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20457" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20459" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20461" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20462" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20464" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20466" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20467" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20469" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20471" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20477" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20481" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20483" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20484" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20486" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20488" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20490" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20496" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20504" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20506" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20508" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20509" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20511" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20513" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20514" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20516" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20518" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20519" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20521" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20523" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20529" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20533" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20535" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20537" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20543" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20551" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20553" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20555" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20556" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20558" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20560" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20561" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20563" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20565" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20566" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20568" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20570" class="Number">0</a><a id="plfa_plfa-part1-Lists-20571" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20577" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>折叠需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-20972" href="../Lists/#plfa_plfa-part1-Lists-20972" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20976" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20978" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20983" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-20985" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20987" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-20989" href="../Lists/#plfa_plfa-part1-Lists-20972" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20993" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-20995" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21001" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-21005" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-21008" href="../Lists/#plfa_plfa-part1-Lists-21008" class="Function">_</a> <a id="plfa_plfa-part1-Lists-21010" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21012" href="../Lists/#plfa_plfa-part1-Lists-20972" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-21016" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-21018" class="Number">1</a> <a id="plfa_plfa-part1-Lists-21020" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21022" class="Number">2</a> <a id="plfa_plfa-part1-Lists-21024" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21026" class="Number">3</a> <a id="plfa_plfa-part1-Lists-21028" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21030" class="Number">4</a> <a id="plfa_plfa-part1-Lists-21032" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-21034" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-21036" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-21039" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-21041" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-21045" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-21055" href="../Lists/#plfa_plfa-part1-Lists-20972" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-21059" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-21061" class="Number">1</a> <a id="plfa_plfa-part1-Lists-21063" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21065" class="Number">2</a> <a id="plfa_plfa-part1-Lists-21067" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21069" class="Number">3</a> <a id="plfa_plfa-part1-Lists-21071" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21073" class="Number">4</a> <a id="plfa_plfa-part1-Lists-21075" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-21079" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-21087" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21093" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-21097" class="Number">0</a> <a id="plfa_plfa-part1-Lists-21099" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-21101" class="Number">1</a> <a id="plfa_plfa-part1-Lists-21103" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21105" class="Number">2</a> <a id="plfa_plfa-part1-Lists-21107" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21109" class="Number">3</a> <a id="plfa_plfa-part1-Lists-21111" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-21113" class="Number">4</a> <a id="plfa_plfa-part1-Lists-21115" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-21119" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-21127" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-21132" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p><p>举另外一个例子，观察</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>二者相等的证明留作练习。</p><h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4><p>使用折叠来定义一个计算列表数字之积的函数。例如：</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22172" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4><p>证明折叠和附加有如下的关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22347" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-22359" href="../Lists/#plfa_plfa-part1-Lists-22359" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-22368" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22370" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-22372" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22373" href="../Lists/#plfa_plfa-part1-Lists-22373" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22375" href="../Lists/#plfa_plfa-part1-Lists-22375" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-22377" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22379" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-22382" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22384" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22385" href="../Lists/#plfa_plfa-part1-Lists-22385" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-22389" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22391" href="../Lists/#plfa_plfa-part1-Lists-22373" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22393" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22395" href="../Lists/#plfa_plfa-part1-Lists-22375" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-22397" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22399" href="../Lists/#plfa_plfa-part1-Lists-22375" class="Bound">B</a><a id="plfa_plfa-part1-Lists-22400" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22402" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22403" href="../Lists/#plfa_plfa-part1-Lists-22403" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-22405" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22407" href="../Lists/#plfa_plfa-part1-Lists-22375" class="Bound">B</a><a id="plfa_plfa-part1-Lists-22408" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22410" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22411" href="../Lists/#plfa_plfa-part1-Lists-22411" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22414" href="../Lists/#plfa_plfa-part1-Lists-22414" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-22417" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22419" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-22424" href="../Lists/#plfa_plfa-part1-Lists-22373" class="Bound">A</a><a id="plfa_plfa-part1-Lists-22425" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22427" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-22433" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-22439" href="../Lists/#plfa_plfa-part1-Lists-22385" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-22443" href="../Lists/#plfa_plfa-part1-Lists-22403" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-22445" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22446" href="../Lists/#plfa_plfa-part1-Lists-22411" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22449" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-22452" href="../Lists/#plfa_plfa-part1-Lists-22414" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-22454" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22456" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-22458" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-22464" href="../Lists/#plfa_plfa-part1-Lists-22385" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-22468" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22469" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-22475" href="../Lists/#plfa_plfa-part1-Lists-22385" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-22479" href="../Lists/#plfa_plfa-part1-Lists-22403" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-22481" href="../Lists/#plfa_plfa-part1-Lists-22414" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-22483" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22485" href="../Lists/#plfa_plfa-part1-Lists-22411" class="Bound">xs</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22501" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-foldr--实践">练习 <code>foldr-∷</code> （实践）</h4><p>证明</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>证明它为前面的 <code>foldr-++</code> 的推论，使得</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4><p>证明映射可以用折叠定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22884" class="Comment">-- 请将代码写在此处</a>
</pre><p>此证明需要外延性。</p><h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4><p>请证明 map 可使用 fold 来定义：</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>此证明需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23210" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4><p>请为预先给定的三个类型定义一个合适的折叠函数：</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23490" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4><p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23713" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4><p>定义一个向下数数的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-23887" href="../Lists/#plfa_plfa-part1-Lists-23887" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23896" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23898" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-23900" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23902" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23907" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-23909" href="../Lists/#plfa_plfa-part1-Lists-23887" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23918" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-23927" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23930" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-23933" href="../Lists/#plfa_plfa-part1-Lists-23887" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23942" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23943" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-23947" href="../Lists/#plfa_plfa-part1-Lists-23947" class="Bound">n</a><a id="plfa_plfa-part1-Lists-23948" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-23951" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23954" href="../Lists/#plfa_plfa-part1-Lists-23947" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-23956" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23958" href="../Lists/#plfa_plfa-part1-Lists-23887" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23967" href="../Lists/#plfa_plfa-part1-Lists-23947" class="Bound">n</a>
</pre><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24010" href="../Lists/#plfa_plfa-part1-Lists-24010" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24012" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24014" href="../Lists/#plfa_plfa-part1-Lists-23887" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-24023" class="Number">3</a> <a id="plfa_plfa-part1-Lists-24025" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24027" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24029" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24031" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24033" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24035" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24037" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24039" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24041" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24043" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24045" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-24244" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="幺半群">幺半群</h2><p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p><p>我们可以用一个合适的记录类型来定义幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24635" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-24642" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24651" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24652" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24654" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24656" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24659" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24661" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24662" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-24666" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24668" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24670" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24672" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24674" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24676" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24677" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24679" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24680" href="../Lists/#plfa_plfa-part1-Lists-24680" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24682" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24684" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24685" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24687" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24689" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-24693" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-24701" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-24711" href="../Lists/#plfa_plfa-part1-Lists-24711" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24717" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24719" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24721" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24722" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24724" href="../Lists/#plfa_plfa-part1-Lists-24724" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24726" href="../Lists/#plfa_plfa-part1-Lists-24726" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24728" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24730" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24731" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24733" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24735" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24736" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24738" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24740" href="../Lists/#plfa_plfa-part1-Lists-24724" class="Bound">y</a><a id="plfa_plfa-part1-Lists-24741" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24743" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24745" href="../Lists/#plfa_plfa-part1-Lists-24726" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24747" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24749" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24751" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24753" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24754" href="../Lists/#plfa_plfa-part1-Lists-24724" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24756" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24758" href="../Lists/#plfa_plfa-part1-Lists-24726" class="Bound">z</a><a id="plfa_plfa-part1-Lists-24759" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-24765" href="../Lists/#plfa_plfa-part1-Lists-24765" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24775" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24777" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24779" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24780" href="../Lists/#plfa_plfa-part1-Lists-24780" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24782" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24784" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24785" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24787" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24789" href="../Lists/#plfa_plfa-part1-Lists-24680" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24791" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24793" href="../Lists/#plfa_plfa-part1-Lists-24780" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24795" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24797" href="../Lists/#plfa_plfa-part1-Lists-24780" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-24803" href="../Lists/#plfa_plfa-part1-Lists-24803" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24813" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24815" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24817" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24818" href="../Lists/#plfa_plfa-part1-Lists-24818" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24820" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24822" href="../Lists/#plfa_plfa-part1-Lists-24652" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24823" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24825" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24827" href="../Lists/#plfa_plfa-part1-Lists-24818" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24829" href="../Lists/#plfa_plfa-part1-Lists-24662" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24831" href="../Lists/#plfa_plfa-part1-Lists-24680" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24833" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24835" href="../Lists/#plfa_plfa-part1-Lists-24818" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-24838" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-24843" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Module">IsMonoid</a>
</pre><p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-25016" href="../Lists/#plfa_plfa-part1-Lists-25016" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-25025" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25027" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25036" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-25040" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-25042" href="../Lists/#plfa_plfa-part1-Lists-25016" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-25051" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25055" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-25066" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25068" href="../Lists/#plfa_plfa-part1-Lists-24711" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25074" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25076" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15309" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-25088" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25090" href="../Lists/#plfa_plfa-part1-Lists-24765" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25100" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25102" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15410" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-25118" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25120" href="../Lists/#plfa_plfa-part1-Lists-24803" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-25130" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25132" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15465" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-25148" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-25151" href="../Lists/#plfa_plfa-part1-Lists-25151" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-25160" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25162" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25171" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-25175" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-25177" href="../Lists/#plfa_plfa-part1-Lists-25151" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-25186" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25190" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-25201" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25203" href="../Lists/#plfa_plfa-part1-Lists-24711" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25209" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25211" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#22870" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-25223" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25225" href="../Lists/#plfa_plfa-part1-Lists-24765" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25235" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25237" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#21770" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-25253" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25255" href="../Lists/#plfa_plfa-part1-Lists-24803" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-25265" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25267" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#21834" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-25283" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-25286" href="../Lists/#plfa_plfa-part1-Lists-25286" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-25296" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25298" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25300" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25301" href="../Lists/#plfa_plfa-part1-Lists-25301" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25303" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25305" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25308" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25310" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25312" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25321" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25322" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25327" href="../Lists/#plfa_plfa-part1-Lists-25301" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25328" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25330" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-25335" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-25338" href="../Lists/#plfa_plfa-part1-Lists-25286" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-25348" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25352" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-25363" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25365" href="../Lists/#plfa_plfa-part1-Lists-24711" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25371" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25373" href="../Lists/#plfa_plfa-part1-Lists-6122" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-25386" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25388" href="../Lists/#plfa_plfa-part1-Lists-24765" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25398" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25400" href="../Lists/#plfa_plfa-part1-Lists-7626" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-25417" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25419" href="../Lists/#plfa_plfa-part1-Lists-24803" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-25429" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25431" href="../Lists/#plfa_plfa-part1-Lists-7836" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-25448" class="Symbol">}</a>
</pre><p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-25629" href="../Lists/#plfa_plfa-part1-Lists-25629" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25642" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25644" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25646" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25647" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25649" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25651" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25654" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25656" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25657" href="../Lists/#plfa_plfa-part1-Lists-25657" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25661" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25663" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25665" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25667" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25669" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25671" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25672" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25674" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25675" href="../Lists/#plfa_plfa-part1-Lists-25675" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25677" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25679" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25680" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25682" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25684" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25693" href="../Lists/#plfa_plfa-part1-Lists-25657" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25697" href="../Lists/#plfa_plfa-part1-Lists-25675" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25699" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25703" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25706" href="../Lists/#plfa_plfa-part1-Lists-25706" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25709" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25711" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25716" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25717" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25719" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25720" href="../Lists/#plfa_plfa-part1-Lists-25720" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25722" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25724" href="../Lists/#plfa_plfa-part1-Lists-25647" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25725" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25727" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25729" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25735" href="../Lists/#plfa_plfa-part1-Lists-25657" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25739" href="../Lists/#plfa_plfa-part1-Lists-25720" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25741" href="../Lists/#plfa_plfa-part1-Lists-25706" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25744" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25746" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25752" href="../Lists/#plfa_plfa-part1-Lists-25657" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25756" href="../Lists/#plfa_plfa-part1-Lists-25675" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25758" href="../Lists/#plfa_plfa-part1-Lists-25706" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25761" href="../Lists/#plfa_plfa-part1-Lists-25657" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25763" href="../Lists/#plfa_plfa-part1-Lists-25720" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-25765" href="../Lists/#plfa_plfa-part1-Lists-25629" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25778" href="../Lists/#plfa_plfa-part1-Lists-25778" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25782" href="../Lists/#plfa_plfa-part1-Lists-25782" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25784" href="../Lists/#plfa_plfa-part1-Lists-25784" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25793" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25796" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25798" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25802" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25812" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25818" href="../Lists/#plfa_plfa-part1-Lists-25778" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25822" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25824" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-25829" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25837" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25841" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25844" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25848" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25849" href="../Lists/#plfa_plfa-part1-Lists-24765" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25859" href="../Lists/#plfa_plfa-part1-Lists-25784" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25868" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25869" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25871" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25877" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25878" href="../Lists/#plfa_plfa-part1-Lists-25782" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25880" href="../Lists/#plfa_plfa-part1-Lists-25778" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25882" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25883" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25887" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25895" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25901" href="../Lists/#plfa_plfa-part1-Lists-25778" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25905" href="../Lists/#plfa_plfa-part1-Lists-25782" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25907" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25910" href="../Lists/#plfa_plfa-part1-Lists-25778" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25912" href="../Lists/#plfa_plfa-part1-Lists-25796" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25916" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-25918" href="../Lists/#plfa_plfa-part1-Lists-25629" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25931" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25935" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25937" href="../Lists/#plfa_plfa-part1-Lists-25937" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25947" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25949" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25951" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25953" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25955" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25957" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25961" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25971" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25977" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25981" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25983" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25984" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25986" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25988" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25990" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25994" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-26002" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26004" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26006" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26007" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26013" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26017" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-26019" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-26021" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26025" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26028" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-26033" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26034" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26036" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-26038" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26040" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26041" href="../Lists/#plfa_plfa-part1-Lists-25629" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26054" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26058" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26060" href="../Lists/#plfa_plfa-part1-Lists-25937" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-26069" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26072" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a><a id="plfa_plfa-part1-Lists-26073" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26075" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26081" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26083" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26085" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26086" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26092" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26096" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26098" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26101" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26103" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a><a id="plfa_plfa-part1-Lists-26104" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26108" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26111" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-26115" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26116" href="../Lists/#plfa_plfa-part1-Lists-24711" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-26122" href="../Lists/#plfa_plfa-part1-Lists-25937" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-26131" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26133" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26134" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26140" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26144" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26146" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-26148" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26150" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a><a id="plfa_plfa-part1-Lists-26151" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26153" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26159" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26160" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26162" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26164" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26170" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26174" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26176" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-26178" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26180" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26182" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-26186" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-26194" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26200" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26204" href="../Lists/#plfa_plfa-part1-Lists-25935" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26206" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26207" href="../Lists/#plfa_plfa-part1-Lists-25947" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-26209" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-26211" href="../Lists/#plfa_plfa-part1-Lists-25951" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-26213" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26215" href="../Lists/#plfa_plfa-part1-Lists-25931" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26217" href="../Lists/#plfa_plfa-part1-Lists-25955" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-26221" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>在之前 <code>foldr-++</code> 的练习中，我们证明了以下定理：</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><p>由此，我们可以将幺半群中附加的折叠如下分解成两个折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-26521" href="../Lists/#plfa_plfa-part1-Lists-26521" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26537" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26539" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26541" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26542" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26544" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26546" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26549" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26552" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26556" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26558" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26560" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26562" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26564" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26566" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26567" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26569" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26570" href="../Lists/#plfa_plfa-part1-Lists-26570" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26572" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26574" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26575" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26577" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26579" href="../Lists/#plfa_plfa-part1-Lists-24642" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-26588" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26592" href="../Lists/#plfa_plfa-part1-Lists-26570" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26594" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-26598" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26601" href="../Lists/#plfa_plfa-part1-Lists-26601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26604" href="../Lists/#plfa_plfa-part1-Lists-26604" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26607" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26609" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26614" href="../Lists/#plfa_plfa-part1-Lists-26542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26615" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26617" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26619" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26625" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26629" href="../Lists/#plfa_plfa-part1-Lists-26570" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26631" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26632" href="../Lists/#plfa_plfa-part1-Lists-26601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26635" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26638" href="../Lists/#plfa_plfa-part1-Lists-26604" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26640" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26642" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-26644" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26650" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26654" href="../Lists/#plfa_plfa-part1-Lists-26570" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26656" href="../Lists/#plfa_plfa-part1-Lists-26601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26659" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26661" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26667" href="../Lists/#plfa_plfa-part1-Lists-26552" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26671" href="../Lists/#plfa_plfa-part1-Lists-26570" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26673" href="../Lists/#plfa_plfa-part1-Lists-26604" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-26676" href="../Lists/#plfa_plfa-part1-Lists-26521" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26692" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26696" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26698" href="../Lists/#plfa_plfa-part1-Lists-26698" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26707" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26710" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26713" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-26717" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-26727" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26733" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26737" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26739" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26740" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26743" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26746" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26748" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26752" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26755" href="../Lists/#plfa_plfa-part1-Lists-22359" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-26764" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26768" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26770" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26773" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26776" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26782" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26788" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26792" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26793" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26799" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26803" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26805" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26807" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26809" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-26814" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26817" href="../Lists/#plfa_plfa-part1-Lists-25629" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26830" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26834" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26836" href="../Lists/#plfa_plfa-part1-Lists-26698" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26845" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26848" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26849" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26855" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26859" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26861" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26863" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26865" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26871" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26877" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26881" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26883" href="../Lists/#plfa_plfa-part1-Lists-26707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26886" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26888" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26894" href="../Lists/#plfa_plfa-part1-Lists-26692" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26898" href="../Lists/#plfa_plfa-part1-Lists-26696" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26900" href="../Lists/#plfa_plfa-part1-Lists-26710" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-26905" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4><p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-27285" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4><p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27582" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="All">所有</h2><p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p><p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27911" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-27916" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27920" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27921" href="../Lists/#plfa_plfa-part1-Lists-27921" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27923" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27925" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27928" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27930" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27931" href="../Lists/#plfa_plfa-part1-Lists-27931" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27933" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27935" href="../Lists/#plfa_plfa-part1-Lists-27921" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27937" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27939" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27942" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27944" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27946" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27951" href="../Lists/#plfa_plfa-part1-Lists-27921" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27953" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27955" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-27959" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-27967" href="../Lists/#plfa_plfa-part1-Lists-27967" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-27971" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27973" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27977" href="../Lists/#plfa_plfa-part1-Lists-27931" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27979" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-27984" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-27988" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27990" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27992" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27993" href="../Lists/#plfa_plfa-part1-Lists-27993" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27995" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27997" href="../Lists/#plfa_plfa-part1-Lists-27921" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27998" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-28000" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28001" href="../Lists/#plfa_plfa-part1-Lists-28001" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28004" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28006" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-28011" href="../Lists/#plfa_plfa-part1-Lists-27921" class="Bound">A</a><a id="plfa_plfa-part1-Lists-28012" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-28014" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28016" href="../Lists/#plfa_plfa-part1-Lists-27931" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-28018" href="../Lists/#plfa_plfa-part1-Lists-27993" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28020" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28022" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28026" href="../Lists/#plfa_plfa-part1-Lists-27931" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-28028" href="../Lists/#plfa_plfa-part1-Lists-28001" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28031" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28033" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28037" href="../Lists/#plfa_plfa-part1-Lists-27931" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-28039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28040" href="../Lists/#plfa_plfa-part1-Lists-27993" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28042" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28044" href="../Lists/#plfa_plfa-part1-Lists-28001" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-28046" class="Symbol">)</a>
</pre><p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p><p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-29027" href="../Lists/#plfa_plfa-part1-Lists-29027" class="Function">_</a> <a id="plfa_plfa-part1-Lists-29029" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29031" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-29035" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29036" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1697" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-29039" class="Number">2</a><a id="plfa_plfa-part1-Lists-29040" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29042" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29044" class="Number">0</a> <a id="plfa_plfa-part1-Lists-29046" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29048" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29050" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29052" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29054" href="../Lists/#plfa_plfa-part1-Lists-4021" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-29056" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-29058" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-29060" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1720" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-29064" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29066" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1762" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-29070" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1720" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-29074" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29076" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1762" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-29080" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29081" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1762" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-29085" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#1720" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-29088" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29090" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29092" href="../Lists/#plfa_plfa-part1-Lists-27967" class="InductiveConstructor">[]</a>
</pre><p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p><p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p><h2 id="任意">任意</h2><p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30017" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-30022" href="../Lists/#plfa_plfa-part1-Lists-30022" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30026" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30027" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30029" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30031" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30034" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30037" href="../Lists/#plfa_plfa-part1-Lists-30037" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-30039" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30041" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30043" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30045" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30048" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30050" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30052" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30057" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30059" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30061" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-30065" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-30073" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-30079" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30081" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30083" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30084" href="../Lists/#plfa_plfa-part1-Lists-30084" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30086" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30088" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30089" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30091" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30092" href="../Lists/#plfa_plfa-part1-Lists-30092" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30095" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30097" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30102" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30103" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30105" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30107" href="../Lists/#plfa_plfa-part1-Lists-30037" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-30109" href="../Lists/#plfa_plfa-part1-Lists-30084" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30111" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30113" href="../Lists/#plfa_plfa-part1-Lists-30022" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30117" href="../Lists/#plfa_plfa-part1-Lists-30037" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-30119" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30120" href="../Lists/#plfa_plfa-part1-Lists-30084" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30122" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-30124" href="../Lists/#plfa_plfa-part1-Lists-30092" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30126" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-30130" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30136" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30138" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30140" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30141" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30143" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30145" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30146" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30148" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30149" href="../Lists/#plfa_plfa-part1-Lists-30149" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30152" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30154" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30159" href="../Lists/#plfa_plfa-part1-Lists-30027" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30160" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30162" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30164" href="../Lists/#plfa_plfa-part1-Lists-30022" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30168" href="../Lists/#plfa_plfa-part1-Lists-30037" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-30170" href="../Lists/#plfa_plfa-part1-Lists-30149" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30173" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30175" href="../Lists/#plfa_plfa-part1-Lists-30022" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30179" href="../Lists/#plfa_plfa-part1-Lists-30037" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-30181" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30182" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30184" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-30186" href="../Lists/#plfa_plfa-part1-Lists-30149" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30188" class="Symbol">)</a>
</pre><p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30516" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-30522" class="Number">4</a> <a id="plfa_plfa-part1-Lists-30524" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30528" href="../Lists/#plfa_plfa-part1-Lists-30603" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-30533" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30537" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30539" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30541" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30542" href="../Lists/#plfa_plfa-part1-Lists-30542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30544" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30546" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30549" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30552" href="../Lists/#plfa_plfa-part1-Lists-30552" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30554" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30556" href="../Lists/#plfa_plfa-part1-Lists-30542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30557" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30559" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30560" href="../Lists/#plfa_plfa-part1-Lists-30560" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30563" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30565" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30570" href="../Lists/#plfa_plfa-part1-Lists-30542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30571" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30573" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30575" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30579" href="../Lists/#plfa_plfa-part1-Lists-30579" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30581" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30583" href="../Lists/#plfa_plfa-part1-Lists-30583" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30586" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30588" href="../Lists/#plfa_plfa-part1-Lists-30022" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30592" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30593" href="../Lists/#plfa_plfa-part1-Lists-30579" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30595" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-30597" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30599" href="../Lists/#plfa_plfa-part1-Lists-30583" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-30603" href="../Lists/#plfa_plfa-part1-Lists-30603" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-30607" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30609" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30611" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30612" href="../Lists/#plfa_plfa-part1-Lists-30612" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30614" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30616" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30619" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30621" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30622" href="../Lists/#plfa_plfa-part1-Lists-30622" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30624" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30626" href="../Lists/#plfa_plfa-part1-Lists-30612" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30627" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30630" href="../Lists/#plfa_plfa-part1-Lists-30630" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30633" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30635" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30640" href="../Lists/#plfa_plfa-part1-Lists-30612" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30641" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30643" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30645" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30649" href="../Lists/#plfa_plfa-part1-Lists-30649" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30651" href="../Lists/#plfa_plfa-part1-Lists-30603" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30653" href="../Lists/#plfa_plfa-part1-Lists-30653" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30656" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30658" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-30660" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30661" href="../Lists/#plfa_plfa-part1-Lists-30649" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30663" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30665" href="../Lists/#plfa_plfa-part1-Lists-30653" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30667" class="Symbol">)</a>
</pre><p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-31014" href="../Lists/#plfa_plfa-part1-Lists-31014" class="Function">_</a> <a id="plfa_plfa-part1-Lists-31016" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31018" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31020" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-31022" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-31024" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31026" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31028" class="Number">1</a> <a id="plfa_plfa-part1-Lists-31030" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31032" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31034" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31036" class="Number">2</a> <a id="plfa_plfa-part1-Lists-31038" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-31040" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-31042" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31044" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31049" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-31055" href="../Lists/#plfa_plfa-part1-Lists-31055" class="Function">_</a> <a id="plfa_plfa-part1-Lists-31057" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31059" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31061" href="../Lists/#plfa_plfa-part1-Lists-30533" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-31063" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-31065" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31067" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31069" class="Number">1</a> <a id="plfa_plfa-part1-Lists-31071" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31073" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31075" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31077" class="Number">2</a> <a id="plfa_plfa-part1-Lists-31079" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-31081" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-31083" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31085" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31091" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31092" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31099" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31104" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-31108" class="Symbol">))</a>
</pre><p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-31307" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31314" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31316" class="Number">3</a> <a id="plfa_plfa-part1-Lists-31318" href="../Lists/#plfa_plfa-part1-Lists-30603" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-31320" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-31322" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31324" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31326" class="Number">1</a> <a id="plfa_plfa-part1-Lists-31328" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31330" class="Number">0</a> <a id="plfa_plfa-part1-Lists-31332" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31334" class="Number">2</a> <a id="plfa_plfa-part1-Lists-31336" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-31338" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31345" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31346" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31351" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-31355" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31362" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31363" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31369" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31370" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31375" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-31380" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31387" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31388" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31394" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31395" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31401" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31402" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31407" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-31413" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31420" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31421" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31427" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31428" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31434" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31435" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31441" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31442" href="../Lists/#plfa_plfa-part1-Lists-30073" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31447" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-31454" href="../Lists/#plfa_plfa-part1-Lists-31307" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31461" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31462" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31468" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31469" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31475" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31476" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31482" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31483" href="../Lists/#plfa_plfa-part1-Lists-30130" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31489" class="Symbol">()))))</a>
</pre><p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p><h2 id="所有和附加">所有和附加</h2><p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-31961" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31970" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31972" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31974" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31975" href="../Lists/#plfa_plfa-part1-Lists-31975" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31977" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31979" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31982" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31984" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31985" href="../Lists/#plfa_plfa-part1-Lists-31985" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31987" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31989" href="../Lists/#plfa_plfa-part1-Lists-31975" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31991" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31993" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31996" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31998" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31999" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32002" href="../Lists/#plfa_plfa-part1-Lists-32002" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32005" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32007" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32012" href="../Lists/#plfa_plfa-part1-Lists-31975" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32013" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32015" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-32019" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32023" href="../Lists/#plfa_plfa-part1-Lists-31985" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32025" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32026" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32029" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32032" href="../Lists/#plfa_plfa-part1-Lists-32002" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32034" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32036" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14965" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-32038" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32039" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32043" href="../Lists/#plfa_plfa-part1-Lists-31985" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32045" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32048" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32050" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32054" href="../Lists/#plfa_plfa-part1-Lists-31985" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32056" href="../Lists/#plfa_plfa-part1-Lists-32002" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32058" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-32060" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-32069" href="../Lists/#plfa_plfa-part1-Lists-32069" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32072" href="../Lists/#plfa_plfa-part1-Lists-32072" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32075" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-32079" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-32090" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-32092" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15005" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-32101" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32104" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Function">to</a> <a id="plfa_plfa-part1-Lists-32107" href="../Lists/#plfa_plfa-part1-Lists-32069" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32110" href="../Lists/#plfa_plfa-part1-Lists-32072" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-32117" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-32119" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15022" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-32128" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32131" href="../Lists/#plfa_plfa-part1-Lists-32384" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32136" href="../Lists/#plfa_plfa-part1-Lists-32069" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32139" href="../Lists/#plfa_plfa-part1-Lists-32072" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-32146" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-32150" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-32159" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Function">to</a> <a id="plfa_plfa-part1-Lists-32162" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32164" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-32166" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-32167" href="../Lists/#plfa_plfa-part1-Lists-32167" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32169" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32171" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32174" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32176" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-32177" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32179" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32181" href="../Lists/#plfa_plfa-part1-Lists-32167" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32183" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32185" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32188" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32190" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32191" href="../Lists/#plfa_plfa-part1-Lists-32191" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32194" href="../Lists/#plfa_plfa-part1-Lists-32194" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32197" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32199" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32204" href="../Lists/#plfa_plfa-part1-Lists-32167" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32205" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32207" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-32213" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32217" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32220" href="../Lists/#plfa_plfa-part1-Lists-32191" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32223" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32226" href="../Lists/#plfa_plfa-part1-Lists-32194" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32228" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32230" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32232" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32233" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32237" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32239" href="../Lists/#plfa_plfa-part1-Lists-32191" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32242" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32244" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32248" href="../Lists/#plfa_plfa-part1-Lists-32177" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32250" href="../Lists/#plfa_plfa-part1-Lists-32194" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32252" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32256" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Function">to</a> <a id="plfa_plfa-part1-Lists-32259" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32262" href="../Lists/#plfa_plfa-part1-Lists-32262" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32265" href="../Lists/#plfa_plfa-part1-Lists-32265" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32269" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32271" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32273" href="../Lists/#plfa_plfa-part1-Lists-27967" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32276" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32278" href="../Lists/#plfa_plfa-part1-Lists-32265" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32282" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-32286" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Function">to</a> <a id="plfa_plfa-part1-Lists-32289" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32290" href="../Lists/#plfa_plfa-part1-Lists-32290" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32292" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32294" href="../Lists/#plfa_plfa-part1-Lists-32294" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32296" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32298" href="../Lists/#plfa_plfa-part1-Lists-32298" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32301" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32302" href="../Lists/#plfa_plfa-part1-Lists-32302" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32305" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32307" href="../Lists/#plfa_plfa-part1-Lists-32307" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-32314" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32316" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-32321" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Function">to</a> <a id="plfa_plfa-part1-Lists-32324" href="../Lists/#plfa_plfa-part1-Lists-32294" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32327" href="../Lists/#plfa_plfa-part1-Lists-32298" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32330" href="../Lists/#plfa_plfa-part1-Lists-32307" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-32340" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-32344" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-32346" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32348" href="../Lists/#plfa_plfa-part1-Lists-32348" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32352" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32354" href="../Lists/#plfa_plfa-part1-Lists-32354" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32358" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32360" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32362" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32364" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32367" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32369" href="../Lists/#plfa_plfa-part1-Lists-32348" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32373" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32375" href="../Lists/#plfa_plfa-part1-Lists-32354" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32379" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-32384" href="../Lists/#plfa_plfa-part1-Lists-32384" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32389" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32391" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-32393" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-32395" href="../Lists/#plfa_plfa-part1-Lists-32395" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32397" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32399" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32402" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32404" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-32405" href="../Lists/#plfa_plfa-part1-Lists-32405" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32407" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32409" href="../Lists/#plfa_plfa-part1-Lists-32395" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32411" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32413" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32416" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32418" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32419" href="../Lists/#plfa_plfa-part1-Lists-32419" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32422" href="../Lists/#plfa_plfa-part1-Lists-32422" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32425" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32427" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32432" href="../Lists/#plfa_plfa-part1-Lists-32395" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32433" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32435" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-32441" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32445" href="../Lists/#plfa_plfa-part1-Lists-32405" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32447" href="../Lists/#plfa_plfa-part1-Lists-32419" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32450" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32452" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32456" href="../Lists/#plfa_plfa-part1-Lists-32405" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32458" href="../Lists/#plfa_plfa-part1-Lists-32422" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32461" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32463" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32467" href="../Lists/#plfa_plfa-part1-Lists-32405" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32469" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32470" href="../Lists/#plfa_plfa-part1-Lists-32419" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32473" href="../Lists/#plfa_plfa-part1-Lists-4782" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32476" href="../Lists/#plfa_plfa-part1-Lists-32422" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32478" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32482" href="../Lists/#plfa_plfa-part1-Lists-32384" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32487" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32490" href="../Lists/#plfa_plfa-part1-Lists-32490" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32493" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32495" href="../Lists/#plfa_plfa-part1-Lists-27967" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32498" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32500" href="../Lists/#plfa_plfa-part1-Lists-32500" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32504" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32506" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32508" href="../Lists/#plfa_plfa-part1-Lists-32500" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-32514" href="../Lists/#plfa_plfa-part1-Lists-32384" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32519" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32520" href="../Lists/#plfa_plfa-part1-Lists-32520" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32522" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32524" href="../Lists/#plfa_plfa-part1-Lists-32524" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32526" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32528" href="../Lists/#plfa_plfa-part1-Lists-32528" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32531" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32533" href="../Lists/#plfa_plfa-part1-Lists-32533" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32536" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32538" href="../Lists/#plfa_plfa-part1-Lists-32538" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32542" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32544" href="../Lists/#plfa_plfa-part1-Lists-32544" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32548" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32550" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32553" href="../Lists/#plfa_plfa-part1-Lists-32533" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32556" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32558" href="../Lists/#plfa_plfa-part1-Lists-32384" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32563" href="../Lists/#plfa_plfa-part1-Lists-32524" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32566" href="../Lists/#plfa_plfa-part1-Lists-32528" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32569" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32571" href="../Lists/#plfa_plfa-part1-Lists-32538" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32575" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32577" href="../Lists/#plfa_plfa-part1-Lists-32544" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32581" href="../Lists/#plfa_plfa-part1-Lists-995" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4><p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32958" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4><p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33171" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4><p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p><p>以下定律是否也成立？</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>若成立，请证明；否则请解释原因。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33812" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4><p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34072" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4><p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34274" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4><p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34483" class="Comment">-- 请将代码写在此处</a>
</pre><p>如果成立，请证明；如果不成立，请解释原因。</p><h2 id="所有的可判定性">所有的可判定性</h2><p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-34894" href="../Lists/#plfa_plfa-part1-Lists-34894" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34898" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34900" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-34902" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-34903" href="../Lists/#plfa_plfa-part1-Lists-34903" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34905" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34907" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-34910" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-34912" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34914" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-34915" href="../Lists/#plfa_plfa-part1-Lists-34903" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34917" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34919" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-34923" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-34925" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34927" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-34932" href="../Lists/#plfa_plfa-part1-Lists-34903" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34934" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34936" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-34941" href="../Lists/#plfa_plfa-part1-Lists-34894" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34945" href="../Lists/#plfa_plfa-part1-Lists-34945" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-34948" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-34951" href="../Lists/#plfa_plfa-part1-Lists-19816" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-34957" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#995" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-34961" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-34966" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-34968" href="../Lists/#plfa_plfa-part1-Lists-16702" class="Function">map</a> <a id="plfa_plfa-part1-Lists-34972" href="../Lists/#plfa_plfa-part1-Lists-34945" class="Bound">p</a>
</pre><p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p><p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-35698" href="../Lists/#plfa_plfa-part1-Lists-35698" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35708" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35710" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35712" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35713" href="../Lists/#plfa_plfa-part1-Lists-35713" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35715" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35717" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35720" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35722" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35725" href="../Lists/#plfa_plfa-part1-Lists-35713" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35727" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35729" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35732" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35734" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35736" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-35740" href="../Lists/#plfa_plfa-part1-Lists-35698" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35750" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35751" href="../Lists/#plfa_plfa-part1-Lists-35751" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35752" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35754" href="../Lists/#plfa_plfa-part1-Lists-35754" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-35757" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35760" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35762" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35763" href="../Lists/#plfa_plfa-part1-Lists-35763" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35765" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35767" href="../Lists/#plfa_plfa-part1-Lists-35751" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35768" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35770" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35772" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-35776" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35777" href="../Lists/#plfa_plfa-part1-Lists-35754" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35779" href="../Lists/#plfa_plfa-part1-Lists-35763" class="Bound">x</a><a id="plfa_plfa-part1-Lists-35780" class="Symbol">)</a>
</pre>那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-35959" href="../Lists/#plfa_plfa-part1-Lists-35959" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35964" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35966" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35968" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35969" href="../Lists/#plfa_plfa-part1-Lists-35969" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35971" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35973" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35976" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35978" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35979" href="../Lists/#plfa_plfa-part1-Lists-35979" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35981" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35983" href="../Lists/#plfa_plfa-part1-Lists-35969" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35985" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35987" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35990" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35992" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35994" href="../Lists/#plfa_plfa-part1-Lists-35698" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-36004" href="../Lists/#plfa_plfa-part1-Lists-35979" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-36006" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-36008" href="../Lists/#plfa_plfa-part1-Lists-35698" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-36018" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36019" href="../Lists/#plfa_plfa-part1-Lists-27916" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-36023" href="../Lists/#plfa_plfa-part1-Lists-35979" class="Bound">P</a><a id="plfa_plfa-part1-Lists-36024" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-36026" href="../Lists/#plfa_plfa-part1-Lists-35959" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-36031" href="../Lists/#plfa_plfa-part1-Lists-36031" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-36034" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-36069" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-36072" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-36076" href="../Lists/#plfa_plfa-part1-Lists-27967" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-36079" href="../Lists/#plfa_plfa-part1-Lists-35959" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-36084" href="../Lists/#plfa_plfa-part1-Lists-36084" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-36087" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36088" href="../Lists/#plfa_plfa-part1-Lists-36088" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-36090" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-36092" href="../Lists/#plfa_plfa-part1-Lists-36092" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-36094" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-36096" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-36101" href="../Lists/#plfa_plfa-part1-Lists-36084" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-36104" href="../Lists/#plfa_plfa-part1-Lists-36088" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-36108" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-36110" href="../Lists/#plfa_plfa-part1-Lists-35959" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-36115" href="../Lists/#plfa_plfa-part1-Lists-36084" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-36118" href="../Lists/#plfa_plfa-part1-Lists-36092" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-36121" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-36141" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-36143" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-36147" href="../Lists/#plfa_plfa-part1-Lists-36147" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-36150" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-36152" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-36156" href="../Lists/#plfa_plfa-part1-Lists-36156" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-36164" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-36167" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-36171" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36172" href="../Lists/#plfa_plfa-part1-Lists-36147" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-36175" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-36177" href="../Lists/#plfa_plfa-part1-Lists-36156" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-36180" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-36182" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-36202" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-36204" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-36207" href="../Lists/#plfa_plfa-part1-Lists-36207" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-36211" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-36213" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-36225" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-36228" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-36231" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-36234" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36235" href="../Lists/#plfa_plfa-part1-Lists-36235" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-36238" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-36240" href="../Lists/#plfa_plfa-part1-Lists-36240" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-36243" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-36245" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-36247" href="../Lists/#plfa_plfa-part1-Lists-36207" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-36251" href="../Lists/#plfa_plfa-part1-Lists-36235" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-36256" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-36258" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-36261" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-36278" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-36279" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-36280" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-36281" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-36287" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-36288" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-36289" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-36291" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-36292" href="../Lists/#plfa_plfa-part1-Lists-36292" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-36301" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-36304" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-36307" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-36310" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36311" href="../Lists/#plfa_plfa-part1-Lists-36311" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-36314" href="../Lists/#plfa_plfa-part1-Lists-27984" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-36316" href="../Lists/#plfa_plfa-part1-Lists-36316" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-36319" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-36321" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-36323" href="../Lists/#plfa_plfa-part1-Lists-36292" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-36328" href="../Lists/#plfa_plfa-part1-Lists-36316" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-36332" class="Symbol">}</a>
</pre><p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p><h4 id="练习-any延伸">练习 <code>Any?</code>（延伸）</h4><p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37207" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-split延伸">练习 <code>split</code>（延伸）</h4><p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37411" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-37416" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37422" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37423" href="../Lists/#plfa_plfa-part1-Lists-37423" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-37425" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37427" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-37430" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-37432" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37434" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37435" href="../Lists/#plfa_plfa-part1-Lists-37435" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37438" href="../Lists/#plfa_plfa-part1-Lists-37438" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37441" href="../Lists/#plfa_plfa-part1-Lists-37441" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-37444" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37446" href="../Lists/#plfa_plfa-part1-Lists-1232" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-37451" href="../Lists/#plfa_plfa-part1-Lists-37423" class="Bound">A</a><a id="plfa_plfa-part1-Lists-37452" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37454" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37456" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-37460" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-37469" href="../Lists/#plfa_plfa-part1-Lists-37469" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37472" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-37480" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-37501" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37507" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37510" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37513" href="../Lists/#plfa_plfa-part1-Lists-1261" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-37519" href="../Lists/#plfa_plfa-part1-Lists-37519" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37526" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37528" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37530" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37531" href="../Lists/#plfa_plfa-part1-Lists-37531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37533" href="../Lists/#plfa_plfa-part1-Lists-37533" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37536" href="../Lists/#plfa_plfa-part1-Lists-37536" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37539" href="../Lists/#plfa_plfa-part1-Lists-37539" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37541" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37547" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37549" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37555" href="../Lists/#plfa_plfa-part1-Lists-37533" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37558" href="../Lists/#plfa_plfa-part1-Lists-37536" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37561" href="../Lists/#plfa_plfa-part1-Lists-37539" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37570" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37601" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37603" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37609" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37610" href="../Lists/#plfa_plfa-part1-Lists-37531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37612" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37614" href="../Lists/#plfa_plfa-part1-Lists-37533" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-37616" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37618" href="../Lists/#plfa_plfa-part1-Lists-37536" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37621" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37622" href="../Lists/#plfa_plfa-part1-Lists-37531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37624" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37626" href="../Lists/#plfa_plfa-part1-Lists-37539" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37628" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-37633" href="../Lists/#plfa_plfa-part1-Lists-37633" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37641" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37643" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37645" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37646" href="../Lists/#plfa_plfa-part1-Lists-37646" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37648" href="../Lists/#plfa_plfa-part1-Lists-37648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37651" href="../Lists/#plfa_plfa-part1-Lists-37651" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37654" href="../Lists/#plfa_plfa-part1-Lists-37654" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37656" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37662" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37664" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37670" href="../Lists/#plfa_plfa-part1-Lists-37648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37673" href="../Lists/#plfa_plfa-part1-Lists-37651" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37676" href="../Lists/#plfa_plfa-part1-Lists-37654" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37685" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37716" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37718" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37724" href="../Lists/#plfa_plfa-part1-Lists-37648" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37727" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37728" href="../Lists/#plfa_plfa-part1-Lists-37646" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37730" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37732" href="../Lists/#plfa_plfa-part1-Lists-37651" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-37734" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37736" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37737" href="../Lists/#plfa_plfa-part1-Lists-37646" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37739" href="../Lists/#plfa_plfa-part1-Lists-1276" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37741" href="../Lists/#plfa_plfa-part1-Lists-37654" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37743" class="Symbol">)</a>
</pre><p>例如</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37785" href="../Lists/#plfa_plfa-part1-Lists-37785" class="Function">_</a> <a id="plfa_plfa-part1-Lists-37787" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37789" href="../Lists/#plfa_plfa-part1-Lists-37416" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37795" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37797" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37799" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37801" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37803" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37805" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37807" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37809" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37811" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37813" href="../Lists/#plfa_plfa-part1-Lists-3990" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37815" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37817" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37819" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37821" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37823" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37825" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37827" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37829" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37831" href="../Lists/#plfa_plfa-part1-Lists-4060" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-37833" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-37835" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-37837" href="../Lists/#plfa_plfa-part1-Lists-37519" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37844" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37845" href="../Lists/#plfa_plfa-part1-Lists-37633" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37853" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37854" href="../Lists/#plfa_plfa-part1-Lists-37633" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37862" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37863" href="../Lists/#plfa_plfa-part1-Lists-37519" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37870" href="../Lists/#plfa_plfa-part1-Lists-37469" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-37872" class="Symbol">)))</a>
</pre><p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p><p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-38706" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-38884" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38891" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-38901" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38907" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38908" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.List.html#147" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-38912" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38914" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#1734" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-38918" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38920" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#5044" class="Function">length</a><a id="plfa_plfa-part1-Lists-38926" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38928" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#7225" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-38935" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38937" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#1634" class="Function">map</a><a id="plfa_plfa-part1-Lists-38940" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38942" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#4148" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-38947" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38949" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Base.html#6728" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-38957" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38959" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38966" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-38995" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39001" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39002" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.All.html#1644" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-39005" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39007" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.All.html#1707" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-39009" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39011" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.All.html#1724" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-39014" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39016" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39023" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-39052" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39058" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39059" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.Any.html#1148" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-39062" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39064" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.Any.html#1211" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-39068" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39070" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Relation.Unary.Any.html#1264" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-39075" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39077" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39084" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-39119" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39125" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39126" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Membership.Setoid.html#925" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-39129" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39131" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39138" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-39161" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39167" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39168" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html#59207" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-39186" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39188" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html#58625" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-39199" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39201" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html#58756" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-39215" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39217" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html#22620" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-39225" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-39227" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.List.Properties.html#22811" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-39239" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39241" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39248" href="https://agda.github.io/agda-stdlib/v2.2-dev/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-39267" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39273" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39274" href="https://agda.github.io/agda-stdlib/v2.2-dev/Algebra.Structures.html#4825" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-39282" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39284" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39291" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-39306" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39312" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39313" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Unary.html#4543" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-39322" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-39324" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-39331" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-39347" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-39353" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39354" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Definitions.html#6713" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-39363" class="Symbol">)</a>
</pre><p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p><p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p><h2 id="unicode">Unicode</h2><p>本章使用了下列 Unicode：</p><pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>