<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Lists: 列表与高阶函数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-112" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-119" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-136" class="Keyword">where</a>
</pre><p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-497" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-542" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-545" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-548" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-556" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-566" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a><a id="plfa_plfa-part1-Lists-584" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-586" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Lists-590" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-592" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-597" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-612" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-617" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-624" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-634" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-641" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-645" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-651" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-653" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-658" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-660" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Lists-661" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-663" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-666" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-668" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-671" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-673" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Lists-676" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-678" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-683" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-690" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-699" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-707" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-713" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-718" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-720" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-723" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-728" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-730" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-733" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-735" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-738" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-740" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-743" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-745" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-748" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-750" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-755" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-762" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-782" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-791" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-798" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-800" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-811" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-813" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-824" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-826" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-833" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-835" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-846" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-848" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-859" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-861" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20560" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-873" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-875" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-880" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-887" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-904" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-910" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-911" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-913" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-915" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-918" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-920" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-923" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-925" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-927" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-929" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-934" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-941" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-954" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-960" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-961" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-964" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-966" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1369" class="Function">∃</a><a id="plfa_plfa-part1-Lists-967" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-969" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1806" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-977" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-979" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-988" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-989" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-993" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-1001" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1003" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1008" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1015" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-1024" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1030" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1031" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-1034" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1036" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1041" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1048" href="https://agda.github.io/agda-stdlib/v1.7.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-1054" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1060" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1061" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#597" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-1066" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1068" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1073" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1080" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-1103" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1109" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1110" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-1113" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-1115" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-1118" class="Symbol">)</a>
</pre><h2 id="列表">列表</h2>Agda 中的列表如下定义：<pre class="Agda"><a id="plfa_plfa-part1-Lists-1223" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1228" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1233" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1234" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1236" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1238" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1241" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1243" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1245" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1249" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1257" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1261" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1263" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1268" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1272" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1276" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1278" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1280" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1282" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1287" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1289" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1291" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1296" href="../Lists/#plfa_plfa-part1-Lists-1234" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1299" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1306" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1308" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a>
</pre><p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-1977" href="../Lists/#plfa_plfa-part1-Lists-1977" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1979" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1981" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1986" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1988" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1990" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1992" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1994" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1996" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1998" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2000" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2002" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2004" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p><p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-2751" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2756" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2762" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2764" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2768" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2770" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2774" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2782" href="../Lists/#plfa_plfa-part1-Lists-2782" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2787" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2789" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2791" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2792" href="../Lists/#plfa_plfa-part1-Lists-2792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2794" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2796" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2799" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2801" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2803" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2809" href="../Lists/#plfa_plfa-part1-Lists-2792" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2813" href="../Lists/#plfa_plfa-part1-Lists-2813" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2818" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2820" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2822" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2823" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2825" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2827" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2830" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2832" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2834" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2836" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2838" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2844" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2846" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2848" href="../Lists/#plfa_plfa-part1-Lists-2756" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2854" href="../Lists/#plfa_plfa-part1-Lists-2823" class="Bound">A</a>
</pre><p>每个构造子将参数作为隐式参数。因此我们列表的例子也可以写作：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3019" href="../Lists/#plfa_plfa-part1-Lists-3019" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3021" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3023" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3028" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-3030" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-3032" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3034" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3038" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3039" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3040" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3042" class="Number">0</a> <a id="plfa_plfa-part1-Lists-3044" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3045" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3049" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3050" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3051" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3053" class="Number">1</a> <a id="plfa_plfa-part1-Lists-3055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3056" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3060" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3061" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3062" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3064" class="Number">2</a> <a id="plfa_plfa-part1-Lists-3066" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3067" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-3070" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3071" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3072" class="Symbol">})))</a>
</pre><p>此处我们将隐式参数显式地声明。</p><p>包含下面的编译器指令</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p><h2 id="列表语法">列表语法</h2><p>我们可以用下面的定义，更简便地表示列表：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3696" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3704" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3708" href="../Lists/#plfa_plfa-part1-Lists-3712" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3710" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3712" href="../Lists/#plfa_plfa-part1-Lists-3712" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3714" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3716" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3719" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3727" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3733" href="../Lists/#plfa_plfa-part1-Lists-3739" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3735" href="../Lists/#plfa_plfa-part1-Lists-3743" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3737" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3739" href="../Lists/#plfa_plfa-part1-Lists-3739" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3741" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3743" href="../Lists/#plfa_plfa-part1-Lists-3743" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3745" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3747" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3750" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3758" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3766" href="../Lists/#plfa_plfa-part1-Lists-3774" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3768" href="../Lists/#plfa_plfa-part1-Lists-3778" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3770" href="../Lists/#plfa_plfa-part1-Lists-3782" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3772" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3774" href="../Lists/#plfa_plfa-part1-Lists-3774" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3776" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3778" href="../Lists/#plfa_plfa-part1-Lists-3778" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3780" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3782" href="../Lists/#plfa_plfa-part1-Lists-3782" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3784" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3786" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3789" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3797" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3807" href="../Lists/#plfa_plfa-part1-Lists-3817" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3809" href="../Lists/#plfa_plfa-part1-Lists-3821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3811" href="../Lists/#plfa_plfa-part1-Lists-3825" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3813" href="../Lists/#plfa_plfa-part1-Lists-3829" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3815" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3817" href="../Lists/#plfa_plfa-part1-Lists-3817" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3819" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3821" href="../Lists/#plfa_plfa-part1-Lists-3821" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3823" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3825" href="../Lists/#plfa_plfa-part1-Lists-3825" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3827" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3829" href="../Lists/#plfa_plfa-part1-Lists-3829" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3831" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3833" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3836" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3844" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3856" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3858" href="../Lists/#plfa_plfa-part1-Lists-3872" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3860" href="../Lists/#plfa_plfa-part1-Lists-3876" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3862" href="../Lists/#plfa_plfa-part1-Lists-3880" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3864" href="../Lists/#plfa_plfa-part1-Lists-3884" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3866" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3868" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3870" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3872" href="../Lists/#plfa_plfa-part1-Lists-3872" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3874" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3876" href="../Lists/#plfa_plfa-part1-Lists-3876" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3878" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3880" href="../Lists/#plfa_plfa-part1-Lists-3880" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3882" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3884" href="../Lists/#plfa_plfa-part1-Lists-3884" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3886" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3888" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3891" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3899" href="../Lists/#plfa_plfa-part1-Lists-3899" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3913" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3915" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3917" href="../Lists/#plfa_plfa-part1-Lists-3935" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3919" href="../Lists/#plfa_plfa-part1-Lists-3939" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3921" href="../Lists/#plfa_plfa-part1-Lists-3943" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3923" href="../Lists/#plfa_plfa-part1-Lists-3947" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3925" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3927" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3929" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3931" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3933" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3935" href="../Lists/#plfa_plfa-part1-Lists-3935" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3937" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3939" href="../Lists/#plfa_plfa-part1-Lists-3939" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3941" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3943" href="../Lists/#plfa_plfa-part1-Lists-3943" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3945" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3947" href="../Lists/#plfa_plfa-part1-Lists-3947" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3949" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3951" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p><h2 id="附加">附加</h2><p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-4504" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-4511" class="Number">5</a> <a id="plfa_plfa-part1-Lists-4513" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-4519" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-4524" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4526" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4528" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4529" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4531" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4533" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4536" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4538" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4540" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4545" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4547" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4549" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4554" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4556" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4558" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4563" href="../Lists/#plfa_plfa-part1-Lists-4529" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-4565" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-4574" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4577" href="../Lists/#plfa_plfa-part1-Lists-4577" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4581" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4584" href="../Lists/#plfa_plfa-part1-Lists-4577" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-4587" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4588" href="../Lists/#plfa_plfa-part1-Lists-4588" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4590" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4592" href="../Lists/#plfa_plfa-part1-Lists-4592" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4594" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4596" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4599" href="../Lists/#plfa_plfa-part1-Lists-4599" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4603" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4606" href="../Lists/#plfa_plfa-part1-Lists-4588" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4608" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4610" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4611" href="../Lists/#plfa_plfa-part1-Lists-4592" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4614" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4617" href="../Lists/#plfa_plfa-part1-Lists-4599" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4619" class="Symbol">)</a>
</pre><p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p><p>我们举个例子，来展示将两个列表附加的计算过程：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-5246" href="../Lists/#plfa_plfa-part1-Lists-5246" class="Function">_</a> <a id="plfa_plfa-part1-Lists-5248" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5250" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5252" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5254" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5256" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5258" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5260" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5262" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5264" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5267" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5269" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5271" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5273" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5275" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5277" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5279" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5281" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5283" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5285" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5287" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5289" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5291" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5293" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5295" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5297" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5299" href="../Lists/#plfa_plfa-part1-Lists-3844" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-5301" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-5303" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5307" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5317" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5319" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5321" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5323" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5325" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5327" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5329" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5332" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5335" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5337" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5339" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5341" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5343" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5348" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5356" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5358" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5360" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5361" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5363" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5365" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5367" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5369" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5372" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5375" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5377" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5379" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5381" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5383" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5385" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5389" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5397" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5399" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5401" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5403" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5405" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5406" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5408" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5410" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5413" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5416" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5418" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5420" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5422" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5424" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5426" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5438" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5440" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5442" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5444" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5446" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5448" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5450" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5451" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5454" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5457" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5459" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5461" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5463" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5465" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5467" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5471" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5479" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5481" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5483" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5485" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5487" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5489" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5491" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5493" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5495" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5497" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5499" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>附加两个列表需要对于第一个列表元素个数线性的时间。</p><h2 id="论证附加">论证附加</h2>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-5859" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5868" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5870" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5872" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5873" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5875" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5880" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5882" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5883" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5886" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5889" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5892" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5894" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5899" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5900" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5904" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5906" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5907" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5910" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5913" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5915" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5917" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5920" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5923" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5925" href="../Lists/#plfa_plfa-part1-Lists-5883" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5928" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5931" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5932" href="../Lists/#plfa_plfa-part1-Lists-5886" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5935" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5938" href="../Lists/#plfa_plfa-part1-Lists-5889" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5940" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-5942" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5951" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5954" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5957" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5960" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5964" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5974" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5975" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5978" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5981" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5983" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5985" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5988" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5993" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6001" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6004" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6007" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6012" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6020" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6023" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6026" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6027" href="../Lists/#plfa_plfa-part1-Lists-5954" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6030" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6033" href="../Lists/#plfa_plfa-part1-Lists-5957" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6035" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6039" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6041" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6050" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6051" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6053" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6055" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6057" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6059" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6062" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6065" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6069" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6079" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6080" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6082" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6084" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6087" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6090" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6092" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6094" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6097" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6102" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6110" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6112" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6114" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6115" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6118" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6121" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6123" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6125" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6128" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6133" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6141" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6143" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6145" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-6147" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6150" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6153" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6155" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6157" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6160" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6162" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6166" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6169" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6174" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6175" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6177" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6179" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6181" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6182" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6191" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6194" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6197" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6199" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6201" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6207" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6209" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6211" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6212" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6215" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6218" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6219" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6222" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6225" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6227" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6232" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6240" href="../Lists/#plfa_plfa-part1-Lists-6051" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6242" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6244" href="../Lists/#plfa_plfa-part1-Lists-6055" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6247" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6251" href="../Lists/#plfa_plfa-part1-Lists-6059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6254" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6257" href="../Lists/#plfa_plfa-part1-Lists-6062" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6259" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6263" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p><p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>提升至等式：</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>即证明中所需。</p><p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-7363" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7376" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7378" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7380" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7381" href="../Lists/#plfa_plfa-part1-Lists-7381" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7383" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7385" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7388" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7390" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7391" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7394" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7396" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7401" href="../Lists/#plfa_plfa-part1-Lists-7381" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7402" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7404" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7406" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7409" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7412" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7415" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7417" href="../Lists/#plfa_plfa-part1-Lists-7391" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7420" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7433" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7436" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7440" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7450" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7453" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7456" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7461" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7469" href="../Lists/#plfa_plfa-part1-Lists-7433" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7474" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>右幺元的证明可由简单的归纳得到：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-7573" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7586" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7588" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7590" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7591" href="../Lists/#plfa_plfa-part1-Lists-7591" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7593" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7598" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7601" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7604" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7606" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7611" href="../Lists/#plfa_plfa-part1-Lists-7591" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7612" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7614" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7616" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7619" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7622" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7627" href="../Lists/#plfa_plfa-part1-Lists-7601" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7630" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7643" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7646" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7650" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7660" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7663" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7666" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7671" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7679" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7684" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7686" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7699" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7700" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7702" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7704" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7706" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7708" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7712" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7722" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7723" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7725" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7727" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7729" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7731" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7734" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7739" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7747" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7749" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7751" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7752" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7755" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7758" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7760" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7764" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7767" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7772" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7773" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7775" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-7777" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7779" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7780" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7793" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7795" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7797" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7803" href="../Lists/#plfa_plfa-part1-Lists-7700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7805" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7807" href="../Lists/#plfa_plfa-part1-Lists-7704" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7812" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p><h2 id="长度">长度</h2><p>在下一个函数里，我们来寻找列表的长度：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-8104" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8111" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8113" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8115" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8116" href="../Lists/#plfa_plfa-part1-Lists-8116" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8118" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8120" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8123" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8125" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8127" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8132" href="../Lists/#plfa_plfa-part1-Lists-8116" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8134" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8136" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-8138" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8145" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8155" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8158" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-8163" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8171" href="../Lists/#plfa_plfa-part1-Lists-8171" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8173" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8175" href="../Lists/#plfa_plfa-part1-Lists-8175" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8177" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8180" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8187" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8188" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8195" href="../Lists/#plfa_plfa-part1-Lists-8175" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8197" class="Symbol">)</a>
</pre><p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>我们用下面的例子来展示如何计算列表的长度：<pre class="Agda"><a id="plfa_plfa-part1-Lists-8531" href="../Lists/#plfa_plfa-part1-Lists-8531" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8533" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8535" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8542" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8544" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8546" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8548" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8550" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8552" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8554" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8558" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-8560" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8562" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8566" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8576" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8583" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8584" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8586" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8588" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8590" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8592" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8594" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8596" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8598" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8602" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8614" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8615" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8622" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8623" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8625" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8627" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8629" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8631" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8633" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8638" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8646" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8650" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8655" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8656" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8663" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8664" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8666" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8668" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8670" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8676" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8689" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8693" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8698" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8699" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8706" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8707" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-8708" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8710" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8712" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8718" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8730" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8735" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8736" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-8744" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8749" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>计算列表的长度需要关于列表元素个数线性的时间。</p><p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p><h2 id="论证长度">论证长度</h2><p>两个附加在一起的列表的长度是两列表长度之和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-9348" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9358" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9360" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-9362" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9363" href="../Lists/#plfa_plfa-part1-Lists-9363" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-9365" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9367" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-9370" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9372" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9373" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9376" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9379" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9381" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-9386" href="../Lists/#plfa_plfa-part1-Lists-9363" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9387" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9391" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-9393" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9400" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9401" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9404" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9407" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9409" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9411" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-9413" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9420" href="../Lists/#plfa_plfa-part1-Lists-9373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9423" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9425" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9432" href="../Lists/#plfa_plfa-part1-Lists-9376" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-9435" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9445" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9446" href="../Lists/#plfa_plfa-part1-Lists-9446" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9447" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9449" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9452" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9455" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9459" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9469" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9476" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9477" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9480" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9483" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9485" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9489" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9497" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9504" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9509" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9517" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9524" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9525" href="../Lists/#plfa_plfa-part1-Lists-9446" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9526" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9528" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9531" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9533" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9540" href="../Lists/#plfa_plfa-part1-Lists-9452" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9545" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-9547" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9557" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9558" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9560" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9562" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9564" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9566" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9569" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9573" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9583" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9590" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9592" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9594" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9596" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9598" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9600" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9603" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9605" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9609" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9617" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9621" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9622" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9630" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9633" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9636" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9638" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9643" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-9646" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-9651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9655" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9656" href="../Lists/#plfa_plfa-part1-Lists-9348" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9666" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9669" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9671" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9673" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-9679" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9683" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9684" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9691" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9696" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9703" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9705" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9709" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9717" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9725" href="../Lists/#plfa_plfa-part1-Lists-9558" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9727" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9729" href="../Lists/#plfa_plfa-part1-Lists-9562" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9731" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9733" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9735" href="../Lists/#plfa_plfa-part1-Lists-8104" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9742" href="../Lists/#plfa_plfa-part1-Lists-9566" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p><h2 id="反转">反转</h2>我们可以使用附加，来简单地构造一个函数来反转一个列表：<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-10630" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10638" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10640" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10642" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10643" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10645" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10650" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10652" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10654" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10659" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10661" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10663" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10668" href="../Lists/#plfa_plfa-part1-Lists-10643" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10670" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10678" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-10688" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10691" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-10694" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10702" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10703" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10705" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10707" href="../Lists/#plfa_plfa-part1-Lists-10707" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10709" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-10712" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10715" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10723" href="../Lists/#plfa_plfa-part1-Lists-10707" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10726" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10729" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10731" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10733" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
</pre><p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>下面的例子展示了如何反转一个列表。<pre class="Agda"><a id="plfa_plfa-part1-Lists-11037" href="../Lists/#plfa_plfa-part1-Lists-11037" class="Function">_</a> <a id="plfa_plfa-part1-Lists-11039" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11041" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11049" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11051" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11053" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11055" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11057" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11059" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11061" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11063" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-11065" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11067" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11069" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11071" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11073" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11075" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11077" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-11079" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-11081" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11085" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11095" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11103" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11104" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11106" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11108" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11110" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11112" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11114" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11116" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11118" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11122" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11130" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11138" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11139" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11141" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11143" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11145" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11147" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11149" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11151" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11154" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11156" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11158" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11162" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11171" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11179" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11180" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11182" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11184" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11186" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11188" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11191" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11193" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11195" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11196" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11198" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11201" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11203" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11205" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11209" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11217" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11219" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11227" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11230" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11233" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11235" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11237" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11238" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11240" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11243" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11245" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11247" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11248" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11250" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11253" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11255" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11257" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11261" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11269" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11271" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11274" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11277" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11279" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11281" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11282" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11284" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11287" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11289" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11291" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11292" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11294" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11297" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11299" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11301" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11305" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11313" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11315" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11318" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11321" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11323" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11325" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11327" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11329" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11332" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11334" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11336" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11338" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11340" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11343" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11345" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11347" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11352" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11360" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11361" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11363" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11365" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11368" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11371" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11373" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11375" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11377" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11379" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11382" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11384" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11386" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11391" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11399" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11401" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11403" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11404" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11407" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11410" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11412" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11414" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11416" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11418" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11421" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11423" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11425" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11438" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11439" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11441" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11443" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11445" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11447" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11449" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11451" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11454" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11456" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11458" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11463" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11471" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11473" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11475" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11476" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11478" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11480" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11483" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11486" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11488" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11490" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11492" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11496" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11504" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11506" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11508" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11510" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11512" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11513" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11516" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11519" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11521" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11523" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11525" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11529" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11537" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11539" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11541" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11543" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11545" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11547" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11549" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11554" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11562" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11564" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11566" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11568" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11570" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11572" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11574" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11578" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p><h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4><p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4><p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><h2 id="更快地反转">更快地反转</h2><p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-13143" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13149" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13151" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13153" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13154" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13156" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13158" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13161" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13163" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13165" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13170" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13172" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13174" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13179" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13181" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13183" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13188" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-13190" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13196" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-13205" href="../Lists/#plfa_plfa-part1-Lists-13205" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13209" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13212" href="../Lists/#plfa_plfa-part1-Lists-13205" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13215" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13221" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13222" href="../Lists/#plfa_plfa-part1-Lists-13222" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13224" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13226" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13228" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13230" href="../Lists/#plfa_plfa-part1-Lists-13230" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13234" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13237" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13243" href="../Lists/#plfa_plfa-part1-Lists-13226" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13246" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13247" href="../Lists/#plfa_plfa-part1-Lists-13222" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13249" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13251" href="../Lists/#plfa_plfa-part1-Lists-13230" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13253" class="Symbol">)</a>
</pre><p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>转移（Shunt）与反转的关系如下：<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-13588" href="../Lists/#plfa_plfa-part1-Lists-13588" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13602" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13604" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13606" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13607" href="../Lists/#plfa_plfa-part1-Lists-13607" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13609" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13614" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13616" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13617" href="../Lists/#plfa_plfa-part1-Lists-13617" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13620" href="../Lists/#plfa_plfa-part1-Lists-13620" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13623" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13625" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13630" href="../Lists/#plfa_plfa-part1-Lists-13607" class="Bound">A</a><a id="plfa_plfa-part1-Lists-13631" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13635" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13637" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13643" href="../Lists/#plfa_plfa-part1-Lists-13617" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13646" href="../Lists/#plfa_plfa-part1-Lists-13620" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13649" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13651" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13659" href="../Lists/#plfa_plfa-part1-Lists-13617" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13662" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13665" href="../Lists/#plfa_plfa-part1-Lists-13620" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13668" href="../Lists/#plfa_plfa-part1-Lists-13588" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13682" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13685" href="../Lists/#plfa_plfa-part1-Lists-13685" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13688" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13692" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13702" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13708" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13711" href="../Lists/#plfa_plfa-part1-Lists-13685" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13716" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13724" href="../Lists/#plfa_plfa-part1-Lists-13685" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13729" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13737" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13745" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13748" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13751" href="../Lists/#plfa_plfa-part1-Lists-13685" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13756" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-13758" href="../Lists/#plfa_plfa-part1-Lists-13588" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13772" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13773" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13775" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13777" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13779" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13781" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13784" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13788" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13798" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13804" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13805" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13807" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13809" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13811" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13813" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13818" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13826" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13832" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13835" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13836" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13838" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13840" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13842" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13846" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13849" href="../Lists/#plfa_plfa-part1-Lists-13588" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13863" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13866" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13867" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13869" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13871" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13873" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13875" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13881" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13889" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13892" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13895" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13896" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13898" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13900" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13902" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13906" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13914" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13922" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13925" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13928" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13929" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13931" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13933" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13935" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13938" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13940" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13944" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13947" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-13951" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13952" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-13961" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13962" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13970" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13972" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13974" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13976" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13978" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13980" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13982" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13984" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13990" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13991" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13999" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14002" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14005" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14007" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14009" href="../Lists/#plfa_plfa-part1-Lists-3704" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-14010" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14012" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14015" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14020" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14028" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14037" href="../Lists/#plfa_plfa-part1-Lists-13773" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14039" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14041" href="../Lists/#plfa_plfa-part1-Lists-13777" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14043" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14045" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14048" href="../Lists/#plfa_plfa-part1-Lists-13781" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14053" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p><p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p><p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-15074" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15083" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15085" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15087" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15088" href="../Lists/#plfa_plfa-part1-Lists-15088" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15090" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15092" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15095" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15097" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15099" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15104" href="../Lists/#plfa_plfa-part1-Lists-15088" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15106" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15108" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15113" href="../Lists/#plfa_plfa-part1-Lists-15088" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-15115" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15124" href="../Lists/#plfa_plfa-part1-Lists-15124" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15127" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-15129" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15135" href="../Lists/#plfa_plfa-part1-Lists-15124" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15138" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
</pre><p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-15284" href="../Lists/#plfa_plfa-part1-Lists-15284" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15293" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15295" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15297" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15298" href="../Lists/#plfa_plfa-part1-Lists-15298" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15300" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15302" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15305" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15307" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15308" href="../Lists/#plfa_plfa-part1-Lists-15308" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15311" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15313" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15318" href="../Lists/#plfa_plfa-part1-Lists-15298" class="Bound">A</a><a id="plfa_plfa-part1-Lists-15319" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15323" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15325" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15334" href="../Lists/#plfa_plfa-part1-Lists-15308" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15339" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15347" href="../Lists/#plfa_plfa-part1-Lists-15308" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-15350" href="../Lists/#plfa_plfa-part1-Lists-15284" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15359" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15362" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15366" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15376" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15385" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15390" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15398" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15404" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15407" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15412" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15415" href="../Lists/#plfa_plfa-part1-Lists-13588" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-15429" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15432" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15435" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15441" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15449" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15452" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-15455" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15460" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15463" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-15476" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15477" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15485" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15487" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15489" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15495" href="../Lists/#plfa_plfa-part1-Lists-10630" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15503" href="../Lists/#plfa_plfa-part1-Lists-15359" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15508" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-15637" href="../Lists/#plfa_plfa-part1-Lists-15637" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15639" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15641" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15650" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15652" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15654" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15656" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15658" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15660" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15662" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15664" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15666" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15668" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15670" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15672" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15674" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15676" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15678" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-15680" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15682" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15686" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15696" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15706" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15708" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15710" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15712" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15714" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15716" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15718" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15720" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15724" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15732" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15738" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15739" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15741" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15743" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15745" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15747" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15749" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15751" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15753" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15755" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15760" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15768" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15774" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15775" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15777" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15779" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15781" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15783" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15785" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15787" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15788" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15790" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15792" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15794" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15798" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15806" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15812" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15813" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15815" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15817" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15819" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15821" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15822" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15824" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15826" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15828" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15830" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15832" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15836" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15844" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15850" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15853" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15854" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15856" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15858" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15860" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15862" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15864" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15866" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15868" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15872" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15880" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15882" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15884" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15886" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15888" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15890" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15892" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15897" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>现在反转一个列表需要的时间与列表的长度线性相关。</p><h2 id="Map">映射</h2><p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-16367" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16371" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16373" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-16375" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-16376" href="../Lists/#plfa_plfa-part1-Lists-16376" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16378" href="../Lists/#plfa_plfa-part1-Lists-16378" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-16380" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16382" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-16385" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-16387" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16389" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16390" href="../Lists/#plfa_plfa-part1-Lists-16376" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16392" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16394" href="../Lists/#plfa_plfa-part1-Lists-16378" class="Bound">B</a><a id="plfa_plfa-part1-Lists-16395" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16397" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16399" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16404" href="../Lists/#plfa_plfa-part1-Lists-16376" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16406" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16408" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16413" href="../Lists/#plfa_plfa-part1-Lists-16378" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-16415" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16419" href="../Lists/#plfa_plfa-part1-Lists-16419" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16421" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-16431" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16434" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-16437" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16441" href="../Lists/#plfa_plfa-part1-Lists-16441" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16444" href="../Lists/#plfa_plfa-part1-Lists-16444" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16446" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16448" href="../Lists/#plfa_plfa-part1-Lists-16448" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-16450" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-16453" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16456" href="../Lists/#plfa_plfa-part1-Lists-16441" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16458" href="../Lists/#plfa_plfa-part1-Lists-16444" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16460" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16462" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16466" href="../Lists/#plfa_plfa-part1-Lists-16441" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16468" href="../Lists/#plfa_plfa-part1-Lists-16448" class="Bound">xs</a>
</pre><p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p><p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-16917" href="../Lists/#plfa_plfa-part1-Lists-16917" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16919" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16921" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16925" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-16929" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16931" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16933" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16935" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16937" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16939" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16941" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16943" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16945" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16947" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16949" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16951" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16953" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16955" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16957" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-16959" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16961" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16965" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16975" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16979" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-16983" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16984" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16986" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16988" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16990" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16992" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16994" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16996" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16998" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17002" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17010" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17014" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17016" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17018" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17022" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17026" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17027" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17029" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17031" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17033" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17035" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17037" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17041" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17049" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17053" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17055" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17057" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17061" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17063" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17065" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17069" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17073" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17074" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17076" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17078" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17080" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17084" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17092" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17096" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17098" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17100" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17104" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17106" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17108" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17112" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17114" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17116" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17120" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17124" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17129" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17137" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17141" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17143" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17145" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17149" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17151" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17153" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17157" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17159" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17161" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17166" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17174" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17176" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17178" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17180" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17182" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17184" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17186" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17191" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>映射需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-17497" href="../Lists/#plfa_plfa-part1-Lists-17497" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17502" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17504" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17509" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-17511" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17513" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17518" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-17520" href="../Lists/#plfa_plfa-part1-Lists-17497" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17525" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-17527" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17531" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-17536" href="../Lists/#plfa_plfa-part1-Lists-17536" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17538" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17540" href="../Lists/#plfa_plfa-part1-Lists-17497" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17545" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17547" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17549" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17551" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17553" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17555" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17557" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17561" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17563" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17565" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17567" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17569" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17571" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17573" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17575" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17577" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17581" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17591" href="../Lists/#plfa_plfa-part1-Lists-17497" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17596" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17598" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17600" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17602" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17604" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17606" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17608" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17612" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17620" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17624" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17628" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17630" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17632" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17634" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17636" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17638" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17640" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17644" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17652" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17654" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17656" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17658" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17660" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17662" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17664" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17668" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p><h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4><p>证明函数组合的映射是两个映射的组合：</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>证明的最后一步需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18471" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4><p>证明下列关于映射与附加的关系：</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18714" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4><p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18935" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-18940" href="../Lists/#plfa_plfa-part1-Lists-18940" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18945" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18946" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18948" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-18950" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18952" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-18955" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18957" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18959" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-18963" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-18971" href="../Lists/#plfa_plfa-part1-Lists-18971" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-18976" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18978" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18980" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18982" href="../Lists/#plfa_plfa-part1-Lists-18940" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18987" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18989" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-18993" href="../Lists/#plfa_plfa-part1-Lists-18993" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-18998" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19000" href="../Lists/#plfa_plfa-part1-Lists-18940" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19005" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19007" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19009" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19011" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19013" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19015" href="../Lists/#plfa_plfa-part1-Lists-18940" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19020" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19022" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19024" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19026" href="../Lists/#plfa_plfa-part1-Lists-18940" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19031" href="../Lists/#plfa_plfa-part1-Lists-18946" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19033" href="../Lists/#plfa_plfa-part1-Lists-18948" class="Bound">B</a>
</pre><p>定义一个对于树的映射运算符：</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19193" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="Fold">折叠</h2><p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-19484" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19490" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19492" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19494" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19495" href="../Lists/#plfa_plfa-part1-Lists-19495" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19497" href="../Lists/#plfa_plfa-part1-Lists-19497" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19499" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19501" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19504" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19506" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19508" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19509" href="../Lists/#plfa_plfa-part1-Lists-19495" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19511" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19513" href="../Lists/#plfa_plfa-part1-Lists-19497" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19515" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19517" href="../Lists/#plfa_plfa-part1-Lists-19497" class="Bound">B</a><a id="plfa_plfa-part1-Lists-19518" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19520" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19522" href="../Lists/#plfa_plfa-part1-Lists-19497" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19524" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19526" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19531" href="../Lists/#plfa_plfa-part1-Lists-19495" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19533" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19535" href="../Lists/#plfa_plfa-part1-Lists-19497" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-19537" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19543" href="../Lists/#plfa_plfa-part1-Lists-19543" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19547" href="../Lists/#plfa_plfa-part1-Lists-19547" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19549" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-19559" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19562" href="../Lists/#plfa_plfa-part1-Lists-19547" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-19564" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19570" href="../Lists/#plfa_plfa-part1-Lists-19570" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19574" href="../Lists/#plfa_plfa-part1-Lists-19574" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19576" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19577" href="../Lists/#plfa_plfa-part1-Lists-19577" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19579" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19581" href="../Lists/#plfa_plfa-part1-Lists-19581" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19583" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-19586" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19589" href="../Lists/#plfa_plfa-part1-Lists-19577" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19591" href="../Lists/#plfa_plfa-part1-Lists-19570" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19593" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19599" href="../Lists/#plfa_plfa-part1-Lists-19570" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19603" href="../Lists/#plfa_plfa-part1-Lists-19574" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19605" href="../Lists/#plfa_plfa-part1-Lists-19581" class="Bound">xs</a>
</pre><p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p><p>下面的例子展示了如何使用折叠来对一个列表求和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-19939" href="../Lists/#plfa_plfa-part1-Lists-19939" class="Function">_</a> <a id="plfa_plfa-part1-Lists-19941" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19943" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19949" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19953" class="Number">0</a> <a id="plfa_plfa-part1-Lists-19955" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-19957" class="Number">1</a> <a id="plfa_plfa-part1-Lists-19959" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19961" class="Number">2</a> <a id="plfa_plfa-part1-Lists-19963" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19965" class="Number">3</a> <a id="plfa_plfa-part1-Lists-19967" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19969" class="Number">4</a> <a id="plfa_plfa-part1-Lists-19971" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-19973" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19975" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-19978" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-19980" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19984" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-19994" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20000" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20004" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20006" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20007" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20009" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20011" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20013" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20015" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20017" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20019" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20021" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20023" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20025" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20029" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20037" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20039" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20041" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20051" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20053" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20054" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20056" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20058" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20060" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20062" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20064" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20066" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20068" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20072" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20080" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20082" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20084" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20085" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20087" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20089" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20095" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20099" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20101" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20102" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20104" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20106" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20108" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20110" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20112" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-20117" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20125" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20127" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20129" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20130" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20132" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20134" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20135" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20137" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20139" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20145" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20149" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20151" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20152" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20154" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20156" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20158" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20164" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20172" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20174" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20176" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20177" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20181" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20182" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20184" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20186" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20187" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20189" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20191" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20197" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20201" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20203" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20205" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20211" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20219" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20221" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20223" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20224" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20226" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20228" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20229" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20231" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20233" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20234" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20236" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20238" class="Number">0</a><a id="plfa_plfa-part1-Lists-20239" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20245" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>折叠需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-20640" href="../Lists/#plfa_plfa-part1-Lists-20640" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20644" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20646" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-20653" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20655" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-20657" href="../Lists/#plfa_plfa-part1-Lists-20640" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20661" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-20663" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20669" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20673" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-20676" href="../Lists/#plfa_plfa-part1-Lists-20676" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20678" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20680" href="../Lists/#plfa_plfa-part1-Lists-20640" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20684" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20686" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20688" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20690" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20692" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20694" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20696" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20698" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20700" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20702" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20704" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20707" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20709" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20713" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20723" href="../Lists/#plfa_plfa-part1-Lists-20640" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20727" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20729" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20731" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20733" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20735" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20737" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20739" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20741" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20743" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20755" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20761" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20765" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20767" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20769" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20771" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20773" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20775" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20777" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20779" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20781" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20783" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20787" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20795" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-20800" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p><p>举另外一个例子，观察</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>二者相等的证明留作练习。</p><h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4><p>使用折叠来定义一个计算列表数字之积的函数。例如：</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21840" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4><p>证明折叠和附加有如下的关系：</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22076" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4><p>证明映射可以用折叠定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22378" class="Comment">-- 请将代码写在此处。</a>
</pre><p>此证明需要外延性。</p><h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4><p>请证明 map 可使用 fold 来定义：</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>此证明需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22705" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4><p>请为预先给定的三个类型定义一个合适的折叠函数：</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22986" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4><p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23210" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4><p>定义一个向下数数的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-23385" href="../Lists/#plfa_plfa-part1-Lists-23385" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23394" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23396" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-23398" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23400" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23405" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-23407" href="../Lists/#plfa_plfa-part1-Lists-23385" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23416" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-23425" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23428" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-23431" href="../Lists/#plfa_plfa-part1-Lists-23385" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23440" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23441" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-23445" href="../Lists/#plfa_plfa-part1-Lists-23445" class="Bound">n</a><a id="plfa_plfa-part1-Lists-23446" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-23449" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23452" href="../Lists/#plfa_plfa-part1-Lists-23445" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-23454" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23456" href="../Lists/#plfa_plfa-part1-Lists-23385" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23465" href="../Lists/#plfa_plfa-part1-Lists-23445" class="Bound">n</a>
</pre><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23508" href="../Lists/#plfa_plfa-part1-Lists-23508" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23510" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23512" href="../Lists/#plfa_plfa-part1-Lists-23385" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23521" class="Number">3</a> <a id="plfa_plfa-part1-Lists-23523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-23525" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23527" class="Number">2</a> <a id="plfa_plfa-part1-Lists-23529" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23531" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23533" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23535" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23537" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-23539" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-23541" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23543" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23742" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="幺半群">幺半群</h2><p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p><p>我们可以用一个合适的记录类型来定义幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24134" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-24141" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24150" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24151" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24153" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24155" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24158" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24160" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24161" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-24165" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24167" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24169" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24171" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24173" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24175" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24176" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24178" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24179" href="../Lists/#plfa_plfa-part1-Lists-24179" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24181" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24183" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24184" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24186" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-24192" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-24200" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-24210" href="../Lists/#plfa_plfa-part1-Lists-24210" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24216" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24218" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24220" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24221" href="../Lists/#plfa_plfa-part1-Lists-24221" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24223" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24225" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24227" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24229" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24230" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24232" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24234" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24235" href="../Lists/#plfa_plfa-part1-Lists-24221" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24237" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24239" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">y</a><a id="plfa_plfa-part1-Lists-24240" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24242" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24244" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24246" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24248" href="../Lists/#plfa_plfa-part1-Lists-24221" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24250" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24252" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24253" href="../Lists/#plfa_plfa-part1-Lists-24223" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24255" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24257" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">z</a><a id="plfa_plfa-part1-Lists-24258" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-24264" href="../Lists/#plfa_plfa-part1-Lists-24264" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24274" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24276" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24279" href="../Lists/#plfa_plfa-part1-Lists-24279" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24281" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24283" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24284" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24286" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24288" href="../Lists/#plfa_plfa-part1-Lists-24179" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24290" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24292" href="../Lists/#plfa_plfa-part1-Lists-24279" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24294" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24296" href="../Lists/#plfa_plfa-part1-Lists-24279" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-24302" href="../Lists/#plfa_plfa-part1-Lists-24302" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24312" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24314" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24316" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24317" href="../Lists/#plfa_plfa-part1-Lists-24317" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24319" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24321" href="../Lists/#plfa_plfa-part1-Lists-24151" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24322" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24324" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24326" href="../Lists/#plfa_plfa-part1-Lists-24317" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24328" href="../Lists/#plfa_plfa-part1-Lists-24161" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24330" href="../Lists/#plfa_plfa-part1-Lists-24179" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24334" href="../Lists/#plfa_plfa-part1-Lists-24317" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-24337" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-24342" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Module">IsMonoid</a>
</pre><p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-24515" href="../Lists/#plfa_plfa-part1-Lists-24515" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24524" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24526" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24535" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-24539" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-24541" href="../Lists/#plfa_plfa-part1-Lists-24515" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24550" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24554" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24565" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24567" href="../Lists/#plfa_plfa-part1-Lists-24210" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24573" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24575" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-24587" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24589" href="../Lists/#plfa_plfa-part1-Lists-24264" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24599" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24601" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24617" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24619" href="../Lists/#plfa_plfa-part1-Lists-24302" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24629" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24631" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24647" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-24650" href="../Lists/#plfa_plfa-part1-Lists-24650" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24659" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24661" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24670" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-24674" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-24676" href="../Lists/#plfa_plfa-part1-Lists-24650" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24685" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24689" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24700" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24702" href="../Lists/#plfa_plfa-part1-Lists-24210" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24708" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24710" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-24722" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24724" href="../Lists/#plfa_plfa-part1-Lists-24264" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24734" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24736" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24752" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24754" href="../Lists/#plfa_plfa-part1-Lists-24302" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24764" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24766" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24782" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-24785" href="../Lists/#plfa_plfa-part1-Lists-24785" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24795" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24797" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24799" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24800" href="../Lists/#plfa_plfa-part1-Lists-24800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24802" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24804" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24807" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24809" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24811" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24820" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24821" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24826" href="../Lists/#plfa_plfa-part1-Lists-24800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24827" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24829" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-24834" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-24837" href="../Lists/#plfa_plfa-part1-Lists-24785" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24847" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24851" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24862" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24864" href="../Lists/#plfa_plfa-part1-Lists-24210" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24870" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24872" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-24885" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24887" href="../Lists/#plfa_plfa-part1-Lists-24264" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24897" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24899" href="../Lists/#plfa_plfa-part1-Lists-7363" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24916" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24918" href="../Lists/#plfa_plfa-part1-Lists-24302" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24928" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24930" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24947" class="Symbol">}</a>
</pre><p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-25128" href="../Lists/#plfa_plfa-part1-Lists-25128" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25141" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25143" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25145" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25146" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25148" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25150" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25153" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25155" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25156" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25160" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25162" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25164" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25166" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25168" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25170" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25171" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25173" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25174" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25176" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25178" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25179" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25181" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25183" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25192" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25196" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25198" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25202" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25204" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25205" href="../Lists/#plfa_plfa-part1-Lists-25205" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25208" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25210" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25215" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25216" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25218" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25219" href="../Lists/#plfa_plfa-part1-Lists-25219" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25221" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25223" href="../Lists/#plfa_plfa-part1-Lists-25146" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25224" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25226" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25228" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25234" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25238" href="../Lists/#plfa_plfa-part1-Lists-25219" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25240" href="../Lists/#plfa_plfa-part1-Lists-25205" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25243" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25245" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25251" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25255" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25257" href="../Lists/#plfa_plfa-part1-Lists-25205" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25260" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25262" href="../Lists/#plfa_plfa-part1-Lists-25219" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-25264" href="../Lists/#plfa_plfa-part1-Lists-25128" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25277" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25281" href="../Lists/#plfa_plfa-part1-Lists-25281" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25283" href="../Lists/#plfa_plfa-part1-Lists-25283" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25292" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25295" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25297" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25301" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25311" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25317" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25321" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25323" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-25328" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25336" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25340" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25343" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25347" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25348" href="../Lists/#plfa_plfa-part1-Lists-24264" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25358" href="../Lists/#plfa_plfa-part1-Lists-25283" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25367" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25368" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25370" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25376" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25377" href="../Lists/#plfa_plfa-part1-Lists-25281" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25379" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25381" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25382" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25386" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25394" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25400" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25404" href="../Lists/#plfa_plfa-part1-Lists-25281" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25406" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25409" href="../Lists/#plfa_plfa-part1-Lists-25277" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25411" href="../Lists/#plfa_plfa-part1-Lists-25295" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25415" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-25417" href="../Lists/#plfa_plfa-part1-Lists-25128" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25430" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25434" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25436" href="../Lists/#plfa_plfa-part1-Lists-25436" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25445" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25446" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25448" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25450" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25452" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25454" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25456" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25460" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25470" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25476" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25480" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25482" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25483" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25485" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25487" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25489" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25493" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25501" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25503" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25505" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25506" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25512" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25516" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25518" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25520" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25524" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25527" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-25532" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25533" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25535" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-25537" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25539" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25540" href="../Lists/#plfa_plfa-part1-Lists-25128" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25553" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25557" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25559" href="../Lists/#plfa_plfa-part1-Lists-25436" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25568" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25571" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25572" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25574" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25580" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25582" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25584" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25585" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25591" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25595" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25597" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25600" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25602" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25603" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25607" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25610" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25614" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25615" href="../Lists/#plfa_plfa-part1-Lists-24210" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25621" href="../Lists/#plfa_plfa-part1-Lists-25436" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25630" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25632" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25633" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25639" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25643" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25645" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25647" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25649" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25650" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25652" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25658" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25659" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25661" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25663" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25669" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25673" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25675" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25677" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25679" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25681" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25685" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25693" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25699" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25703" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25706" href="../Lists/#plfa_plfa-part1-Lists-25446" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25708" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25710" href="../Lists/#plfa_plfa-part1-Lists-25450" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25712" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25714" href="../Lists/#plfa_plfa-part1-Lists-25430" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25716" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25720" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在之前的练习中，我们证明了以下定理：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25813" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-25825" href="../Lists/#plfa_plfa-part1-Lists-25825" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-25834" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25836" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25838" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25839" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25841" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25843" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25846" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25848" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25849" href="../Lists/#plfa_plfa-part1-Lists-25849" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25853" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25855" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25857" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25859" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25861" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25863" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25864" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25866" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25867" href="../Lists/#plfa_plfa-part1-Lists-25867" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25869" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25871" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25872" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25874" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25875" href="../Lists/#plfa_plfa-part1-Lists-25875" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25878" href="../Lists/#plfa_plfa-part1-Lists-25878" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25881" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25883" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25888" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25889" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25891" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25897" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25903" href="../Lists/#plfa_plfa-part1-Lists-25849" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25907" href="../Lists/#plfa_plfa-part1-Lists-25867" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25909" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25910" href="../Lists/#plfa_plfa-part1-Lists-25875" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25913" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25916" href="../Lists/#plfa_plfa-part1-Lists-25878" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25918" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25920" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25922" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25928" href="../Lists/#plfa_plfa-part1-Lists-25849" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25932" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25933" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25939" href="../Lists/#plfa_plfa-part1-Lists-25849" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25943" href="../Lists/#plfa_plfa-part1-Lists-25867" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25945" href="../Lists/#plfa_plfa-part1-Lists-25878" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25947" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25949" href="../Lists/#plfa_plfa-part1-Lists-25875" class="Bound">xs</a>
</pre><p>由此，我们可以将幺半群中附加的折叠如下分解成两个折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-26094" href="../Lists/#plfa_plfa-part1-Lists-26094" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26110" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26112" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26114" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26115" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26117" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26122" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26124" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26125" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26129" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26131" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26133" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26135" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26137" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26139" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26140" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26142" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26143" href="../Lists/#plfa_plfa-part1-Lists-26143" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26145" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26147" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26148" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26150" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26152" href="../Lists/#plfa_plfa-part1-Lists-24141" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-26161" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26165" href="../Lists/#plfa_plfa-part1-Lists-26143" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26167" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-26171" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26173" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26174" href="../Lists/#plfa_plfa-part1-Lists-26174" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26177" href="../Lists/#plfa_plfa-part1-Lists-26177" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26180" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26182" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26187" href="../Lists/#plfa_plfa-part1-Lists-26115" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26188" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26190" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26192" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26198" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26202" href="../Lists/#plfa_plfa-part1-Lists-26143" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26204" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26205" href="../Lists/#plfa_plfa-part1-Lists-26174" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26208" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26211" href="../Lists/#plfa_plfa-part1-Lists-26177" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26213" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26215" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-26217" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26223" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26227" href="../Lists/#plfa_plfa-part1-Lists-26143" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26229" href="../Lists/#plfa_plfa-part1-Lists-26174" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26232" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26234" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26240" href="../Lists/#plfa_plfa-part1-Lists-26125" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26244" href="../Lists/#plfa_plfa-part1-Lists-26143" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26246" href="../Lists/#plfa_plfa-part1-Lists-26177" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-26249" href="../Lists/#plfa_plfa-part1-Lists-26094" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26265" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26269" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26271" href="../Lists/#plfa_plfa-part1-Lists-26271" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26280" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26283" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26286" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-26290" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-26300" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26306" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26310" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26312" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26313" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26316" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26319" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26321" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26325" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26328" href="../Lists/#plfa_plfa-part1-Lists-25825" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-26337" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26341" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26343" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26346" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26349" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26355" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26361" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26365" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26366" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26372" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26376" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26378" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26380" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26382" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-26387" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26390" href="../Lists/#plfa_plfa-part1-Lists-25128" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26403" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26407" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26409" href="../Lists/#plfa_plfa-part1-Lists-26271" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26418" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26421" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26422" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26428" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26432" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26434" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26436" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26438" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26444" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26450" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26454" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26456" href="../Lists/#plfa_plfa-part1-Lists-26280" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26459" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26461" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26467" href="../Lists/#plfa_plfa-part1-Lists-26265" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26471" href="../Lists/#plfa_plfa-part1-Lists-26269" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26473" href="../Lists/#plfa_plfa-part1-Lists-26283" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-26478" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4><p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-26860" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4><p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27158" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="All">所有</h2><p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p><p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27488" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-27493" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27497" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27498" href="../Lists/#plfa_plfa-part1-Lists-27498" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27500" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27502" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27505" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27507" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27508" href="../Lists/#plfa_plfa-part1-Lists-27508" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27510" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27512" href="../Lists/#plfa_plfa-part1-Lists-27498" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27514" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27516" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27519" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27521" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27523" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27528" href="../Lists/#plfa_plfa-part1-Lists-27498" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27530" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27532" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-27536" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-27544" href="../Lists/#plfa_plfa-part1-Lists-27544" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-27548" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27550" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27554" href="../Lists/#plfa_plfa-part1-Lists-27508" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27556" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-27561" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-27565" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27567" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27569" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27570" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27572" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27574" href="../Lists/#plfa_plfa-part1-Lists-27498" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27575" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27577" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27578" href="../Lists/#plfa_plfa-part1-Lists-27578" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27581" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27583" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27588" href="../Lists/#plfa_plfa-part1-Lists-27498" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27589" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27591" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27593" href="../Lists/#plfa_plfa-part1-Lists-27508" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27595" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27597" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27599" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27603" href="../Lists/#plfa_plfa-part1-Lists-27508" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27605" href="../Lists/#plfa_plfa-part1-Lists-27578" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27608" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27610" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27614" href="../Lists/#plfa_plfa-part1-Lists-27508" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27616" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27617" href="../Lists/#plfa_plfa-part1-Lists-27570" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27619" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27621" href="../Lists/#plfa_plfa-part1-Lists-27578" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27623" class="Symbol">)</a>
</pre><p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p><p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28604" href="../Lists/#plfa_plfa-part1-Lists-28604" class="Function">_</a> <a id="plfa_plfa-part1-Lists-28606" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28608" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28612" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28613" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-28616" class="Number">2</a><a id="plfa_plfa-part1-Lists-28617" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28619" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-28621" class="Number">0</a> <a id="plfa_plfa-part1-Lists-28623" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28625" class="Number">1</a> <a id="plfa_plfa-part1-Lists-28627" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28629" class="Number">2</a> <a id="plfa_plfa-part1-Lists-28631" href="../Lists/#plfa_plfa-part1-Lists-3758" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-28633" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-28635" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-28637" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28641" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28643" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28647" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28651" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28653" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28657" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28658" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28662" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-28665" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28667" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28669" href="../Lists/#plfa_plfa-part1-Lists-27544" class="InductiveConstructor">[]</a>
</pre><p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p><p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p><h2 id="任意">任意</h2><p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-29594" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-29599" href="../Lists/#plfa_plfa-part1-Lists-29599" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29603" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29604" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29606" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29608" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29611" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29613" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29614" href="../Lists/#plfa_plfa-part1-Lists-29614" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29616" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29618" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29620" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29622" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29625" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29627" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29629" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29634" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29636" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29638" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29642" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-29650" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-29656" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29658" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29660" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29661" href="../Lists/#plfa_plfa-part1-Lists-29661" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29663" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29665" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29666" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29668" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29669" href="../Lists/#plfa_plfa-part1-Lists-29669" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29672" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29674" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29679" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29680" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29682" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29684" href="../Lists/#plfa_plfa-part1-Lists-29614" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29686" href="../Lists/#plfa_plfa-part1-Lists-29661" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29688" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29690" href="../Lists/#plfa_plfa-part1-Lists-29599" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29694" href="../Lists/#plfa_plfa-part1-Lists-29614" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29696" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29697" href="../Lists/#plfa_plfa-part1-Lists-29661" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29699" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29701" href="../Lists/#plfa_plfa-part1-Lists-29669" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29703" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-29707" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-29713" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29715" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29717" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29718" href="../Lists/#plfa_plfa-part1-Lists-29718" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29720" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29722" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29723" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29725" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29726" href="../Lists/#plfa_plfa-part1-Lists-29726" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29729" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29731" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29736" href="../Lists/#plfa_plfa-part1-Lists-29604" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29737" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29739" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29741" href="../Lists/#plfa_plfa-part1-Lists-29599" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29745" href="../Lists/#plfa_plfa-part1-Lists-29614" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29747" href="../Lists/#plfa_plfa-part1-Lists-29726" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29750" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29752" href="../Lists/#plfa_plfa-part1-Lists-29599" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29756" href="../Lists/#plfa_plfa-part1-Lists-29614" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29759" href="../Lists/#plfa_plfa-part1-Lists-29718" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29761" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29763" href="../Lists/#plfa_plfa-part1-Lists-29726" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29765" class="Symbol">)</a>
</pre><p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30093" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-30099" class="Number">4</a> <a id="plfa_plfa-part1-Lists-30101" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30105" href="../Lists/#plfa_plfa-part1-Lists-30180" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-30110" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30114" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30116" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30118" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30119" href="../Lists/#plfa_plfa-part1-Lists-30119" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30121" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30123" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30126" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30128" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30129" href="../Lists/#plfa_plfa-part1-Lists-30129" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30131" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30133" href="../Lists/#plfa_plfa-part1-Lists-30119" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30134" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30136" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30137" href="../Lists/#plfa_plfa-part1-Lists-30137" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30140" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30142" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30147" href="../Lists/#plfa_plfa-part1-Lists-30119" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30148" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30150" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30152" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30156" href="../Lists/#plfa_plfa-part1-Lists-30156" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30158" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30160" href="../Lists/#plfa_plfa-part1-Lists-30160" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30163" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30165" href="../Lists/#plfa_plfa-part1-Lists-29599" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30169" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30170" href="../Lists/#plfa_plfa-part1-Lists-30156" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30172" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-30174" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30176" href="../Lists/#plfa_plfa-part1-Lists-30160" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-30180" href="../Lists/#plfa_plfa-part1-Lists-30180" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-30184" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30186" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30188" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30189" href="../Lists/#plfa_plfa-part1-Lists-30189" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30196" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30198" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30199" href="../Lists/#plfa_plfa-part1-Lists-30199" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30201" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30203" href="../Lists/#plfa_plfa-part1-Lists-30189" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30204" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30206" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30207" href="../Lists/#plfa_plfa-part1-Lists-30207" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30210" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30212" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30217" href="../Lists/#plfa_plfa-part1-Lists-30189" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30218" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30220" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30222" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30226" href="../Lists/#plfa_plfa-part1-Lists-30226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30228" href="../Lists/#plfa_plfa-part1-Lists-30180" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30230" href="../Lists/#plfa_plfa-part1-Lists-30230" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30233" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30235" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-30237" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30238" href="../Lists/#plfa_plfa-part1-Lists-30226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30240" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30242" href="../Lists/#plfa_plfa-part1-Lists-30230" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30244" class="Symbol">)</a>
</pre><p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30591" href="../Lists/#plfa_plfa-part1-Lists-30591" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30593" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30595" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30597" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30599" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30601" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30603" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30605" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30607" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30609" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30611" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30613" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30615" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30617" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30619" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30621" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30626" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-30632" href="../Lists/#plfa_plfa-part1-Lists-30632" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30634" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30636" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30638" href="../Lists/#plfa_plfa-part1-Lists-30110" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30640" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30642" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30644" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30646" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30648" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30650" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30652" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30654" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30656" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30658" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30660" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30662" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30668" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30669" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30675" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30676" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30681" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-30685" class="Symbol">))</a>
</pre><p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-30884" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30891" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30893" class="Number">3</a> <a id="plfa_plfa-part1-Lists-30895" href="../Lists/#plfa_plfa-part1-Lists-30180" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30897" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30899" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30901" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30903" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30905" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30907" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30909" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30911" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30913" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30915" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30922" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30923" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30928" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-30932" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30940" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30947" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30952" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-30957" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30964" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30965" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30971" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30972" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30978" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30979" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30984" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-30990" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30997" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30998" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31004" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31005" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31011" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31012" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31018" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31019" href="../Lists/#plfa_plfa-part1-Lists-29650" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31024" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-31031" href="../Lists/#plfa_plfa-part1-Lists-30884" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31038" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31039" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31045" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31046" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31052" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31053" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31059" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31060" href="../Lists/#plfa_plfa-part1-Lists-29707" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31066" class="Symbol">()))))</a>
</pre><p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p><h2 id="所有和附加">所有和附加</h2><p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-31538" href="../Lists/#plfa_plfa-part1-Lists-31538" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31547" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31549" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31551" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31552" href="../Lists/#plfa_plfa-part1-Lists-31552" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31554" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31559" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31561" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31562" href="../Lists/#plfa_plfa-part1-Lists-31562" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31564" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31566" href="../Lists/#plfa_plfa-part1-Lists-31552" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31568" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31570" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31573" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31575" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31576" href="../Lists/#plfa_plfa-part1-Lists-31576" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31579" href="../Lists/#plfa_plfa-part1-Lists-31579" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31582" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31584" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31589" href="../Lists/#plfa_plfa-part1-Lists-31552" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31590" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31592" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-31596" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31600" href="../Lists/#plfa_plfa-part1-Lists-31562" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31602" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31603" href="../Lists/#plfa_plfa-part1-Lists-31576" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31606" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31609" href="../Lists/#plfa_plfa-part1-Lists-31579" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31611" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31613" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-31615" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31616" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31620" href="../Lists/#plfa_plfa-part1-Lists-31562" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31622" href="../Lists/#plfa_plfa-part1-Lists-31576" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31625" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31627" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31631" href="../Lists/#plfa_plfa-part1-Lists-31562" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31633" href="../Lists/#plfa_plfa-part1-Lists-31579" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31635" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-31637" href="../Lists/#plfa_plfa-part1-Lists-31538" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31646" href="../Lists/#plfa_plfa-part1-Lists-31646" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31649" href="../Lists/#plfa_plfa-part1-Lists-31649" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31652" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-31656" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-31667" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31669" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15016" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-31678" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31681" href="../Lists/#plfa_plfa-part1-Lists-31736" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31684" href="../Lists/#plfa_plfa-part1-Lists-31646" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31687" href="../Lists/#plfa_plfa-part1-Lists-31649" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31694" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-31696" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15033" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-31705" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31708" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31713" href="../Lists/#plfa_plfa-part1-Lists-31646" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31716" href="../Lists/#plfa_plfa-part1-Lists-31649" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31723" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-31727" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-31736" href="../Lists/#plfa_plfa-part1-Lists-31736" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31739" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31741" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31743" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31744" href="../Lists/#plfa_plfa-part1-Lists-31744" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31746" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31748" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31751" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31753" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31754" href="../Lists/#plfa_plfa-part1-Lists-31754" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31756" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31758" href="../Lists/#plfa_plfa-part1-Lists-31744" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31760" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31762" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31765" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31767" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31768" href="../Lists/#plfa_plfa-part1-Lists-31768" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31771" href="../Lists/#plfa_plfa-part1-Lists-31771" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31774" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31776" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31781" href="../Lists/#plfa_plfa-part1-Lists-31744" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31782" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31784" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-31790" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31794" href="../Lists/#plfa_plfa-part1-Lists-31754" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31796" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31797" href="../Lists/#plfa_plfa-part1-Lists-31768" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31800" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31803" href="../Lists/#plfa_plfa-part1-Lists-31771" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31805" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31807" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31809" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31810" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31814" href="../Lists/#plfa_plfa-part1-Lists-31754" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31816" href="../Lists/#plfa_plfa-part1-Lists-31768" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31819" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31821" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31825" href="../Lists/#plfa_plfa-part1-Lists-31754" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31827" href="../Lists/#plfa_plfa-part1-Lists-31771" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31829" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-31833" href="../Lists/#plfa_plfa-part1-Lists-31736" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31836" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31839" href="../Lists/#plfa_plfa-part1-Lists-31839" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31842" href="../Lists/#plfa_plfa-part1-Lists-31842" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31846" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31848" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31850" href="../Lists/#plfa_plfa-part1-Lists-27544" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31853" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31855" href="../Lists/#plfa_plfa-part1-Lists-31842" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31859" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-31863" href="../Lists/#plfa_plfa-part1-Lists-31736" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31866" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31867" href="../Lists/#plfa_plfa-part1-Lists-31867" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-31869" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31871" href="../Lists/#plfa_plfa-part1-Lists-31871" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-31873" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31875" href="../Lists/#plfa_plfa-part1-Lists-31875" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31878" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31879" href="../Lists/#plfa_plfa-part1-Lists-31879" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31882" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31884" href="../Lists/#plfa_plfa-part1-Lists-31884" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-31891" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31893" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-31898" href="../Lists/#plfa_plfa-part1-Lists-31736" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31901" href="../Lists/#plfa_plfa-part1-Lists-31871" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31904" href="../Lists/#plfa_plfa-part1-Lists-31875" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31907" href="../Lists/#plfa_plfa-part1-Lists-31884" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-31917" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-31921" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-31923" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31925" href="../Lists/#plfa_plfa-part1-Lists-31925" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31929" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31931" href="../Lists/#plfa_plfa-part1-Lists-31931" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31935" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-31937" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31939" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31941" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31944" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31946" href="../Lists/#plfa_plfa-part1-Lists-31925" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31950" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31952" href="../Lists/#plfa_plfa-part1-Lists-31931" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31956" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-31961" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31966" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31968" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31970" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31972" href="../Lists/#plfa_plfa-part1-Lists-31972" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31974" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31976" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31979" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31981" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31982" href="../Lists/#plfa_plfa-part1-Lists-31982" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31984" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31986" href="../Lists/#plfa_plfa-part1-Lists-31972" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31988" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31990" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31993" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31995" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31996" href="../Lists/#plfa_plfa-part1-Lists-31996" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31999" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32002" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32004" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32009" href="../Lists/#plfa_plfa-part1-Lists-31972" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32010" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32012" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-32018" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32022" href="../Lists/#plfa_plfa-part1-Lists-31982" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32024" href="../Lists/#plfa_plfa-part1-Lists-31996" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32027" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32029" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32033" href="../Lists/#plfa_plfa-part1-Lists-31982" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32035" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32038" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32040" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32044" href="../Lists/#plfa_plfa-part1-Lists-31982" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32046" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32047" href="../Lists/#plfa_plfa-part1-Lists-31996" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32050" href="../Lists/#plfa_plfa-part1-Lists-4519" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32053" href="../Lists/#plfa_plfa-part1-Lists-31999" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32055" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32059" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32064" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32067" href="../Lists/#plfa_plfa-part1-Lists-32067" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32070" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32072" href="../Lists/#plfa_plfa-part1-Lists-27544" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32075" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32077" href="../Lists/#plfa_plfa-part1-Lists-32077" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32081" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32083" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32085" href="../Lists/#plfa_plfa-part1-Lists-32077" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-32091" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32096" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32097" href="../Lists/#plfa_plfa-part1-Lists-32097" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32099" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32101" href="../Lists/#plfa_plfa-part1-Lists-32101" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32103" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32105" href="../Lists/#plfa_plfa-part1-Lists-32105" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32108" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32110" href="../Lists/#plfa_plfa-part1-Lists-32110" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32113" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32115" href="../Lists/#plfa_plfa-part1-Lists-32115" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32119" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32121" href="../Lists/#plfa_plfa-part1-Lists-32121" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32125" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32127" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32130" href="../Lists/#plfa_plfa-part1-Lists-32110" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32133" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32135" href="../Lists/#plfa_plfa-part1-Lists-31961" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32140" href="../Lists/#plfa_plfa-part1-Lists-32101" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32143" href="../Lists/#plfa_plfa-part1-Lists-32105" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32146" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32148" href="../Lists/#plfa_plfa-part1-Lists-32115" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32152" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32154" href="../Lists/#plfa_plfa-part1-Lists-32121" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32158" href="../Lists/#plfa_plfa-part1-Lists-996" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4><p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32535" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4><p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32749" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4><p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p><p>以下定律是否也成立？</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>若成立，请证明；否则请解释原因。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33391" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4><p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33652" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4><p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33854" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4><p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34063" class="Comment">-- 请将代码写在此处</a>
</pre><p>如果成立，请证明；如果不成立，请解释原因。</p><h2 id="所有的可判定性">所有的可判定性</h2><p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-34474" href="../Lists/#plfa_plfa-part1-Lists-34474" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34478" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34480" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-34482" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-34483" href="../Lists/#plfa_plfa-part1-Lists-34483" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34485" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34487" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-34490" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-34492" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34494" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-34495" href="../Lists/#plfa_plfa-part1-Lists-34483" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34497" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34499" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-34503" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-34505" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34507" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-34512" href="../Lists/#plfa_plfa-part1-Lists-34483" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34514" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34516" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-34521" href="../Lists/#plfa_plfa-part1-Lists-34474" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34525" href="../Lists/#plfa_plfa-part1-Lists-34525" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-34528" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-34531" href="../Lists/#plfa_plfa-part1-Lists-19484" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-34537" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-34541" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-34546" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-34548" href="../Lists/#plfa_plfa-part1-Lists-16367" class="Function">map</a> <a id="plfa_plfa-part1-Lists-34552" href="../Lists/#plfa_plfa-part1-Lists-34525" class="Bound">p</a>
</pre><p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p><p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-35278" href="../Lists/#plfa_plfa-part1-Lists-35278" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35288" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35290" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35292" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35293" href="../Lists/#plfa_plfa-part1-Lists-35293" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35295" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35297" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35300" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35302" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35304" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35305" href="../Lists/#plfa_plfa-part1-Lists-35293" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35307" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35309" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35312" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35314" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-35320" href="../Lists/#plfa_plfa-part1-Lists-35278" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35330" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35331" href="../Lists/#plfa_plfa-part1-Lists-35331" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35332" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35334" href="../Lists/#plfa_plfa-part1-Lists-35334" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-35337" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35340" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35342" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35343" href="../Lists/#plfa_plfa-part1-Lists-35343" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35345" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35347" href="../Lists/#plfa_plfa-part1-Lists-35331" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35348" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35350" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35352" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-35356" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35357" href="../Lists/#plfa_plfa-part1-Lists-35334" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35359" href="../Lists/#plfa_plfa-part1-Lists-35343" class="Bound">x</a><a id="plfa_plfa-part1-Lists-35360" class="Symbol">)</a>
</pre>那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-35539" href="../Lists/#plfa_plfa-part1-Lists-35539" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35544" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35546" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35548" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35549" href="../Lists/#plfa_plfa-part1-Lists-35549" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35551" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35553" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35556" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35558" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35559" href="../Lists/#plfa_plfa-part1-Lists-35559" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35561" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35563" href="../Lists/#plfa_plfa-part1-Lists-35549" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35565" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35567" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35570" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35572" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35574" href="../Lists/#plfa_plfa-part1-Lists-35278" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35584" href="../Lists/#plfa_plfa-part1-Lists-35559" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35586" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35588" href="../Lists/#plfa_plfa-part1-Lists-35278" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35598" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35599" href="../Lists/#plfa_plfa-part1-Lists-27493" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-35603" href="../Lists/#plfa_plfa-part1-Lists-35559" class="Bound">P</a><a id="plfa_plfa-part1-Lists-35604" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35606" href="../Lists/#plfa_plfa-part1-Lists-35539" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35611" href="../Lists/#plfa_plfa-part1-Lists-35611" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35614" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-35649" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35652" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35656" href="../Lists/#plfa_plfa-part1-Lists-27544" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-35659" href="../Lists/#plfa_plfa-part1-Lists-35539" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35664" href="../Lists/#plfa_plfa-part1-Lists-35664" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35667" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35668" href="../Lists/#plfa_plfa-part1-Lists-35668" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35670" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35672" href="../Lists/#plfa_plfa-part1-Lists-35672" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-35674" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35676" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-35681" href="../Lists/#plfa_plfa-part1-Lists-35664" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35684" href="../Lists/#plfa_plfa-part1-Lists-35668" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-35688" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35690" href="../Lists/#plfa_plfa-part1-Lists-35539" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35695" href="../Lists/#plfa_plfa-part1-Lists-35664" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35698" href="../Lists/#plfa_plfa-part1-Lists-35672" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-35701" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35721" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35723" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35727" href="../Lists/#plfa_plfa-part1-Lists-35727" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35730" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35732" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35736" href="../Lists/#plfa_plfa-part1-Lists-35736" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-35744" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35751" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35752" href="../Lists/#plfa_plfa-part1-Lists-35727" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35755" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35757" href="../Lists/#plfa_plfa-part1-Lists-35736" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35760" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35762" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35782" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35784" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35787" href="../Lists/#plfa_plfa-part1-Lists-35787" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35791" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35793" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-35805" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35808" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35811" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35814" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35815" href="../Lists/#plfa_plfa-part1-Lists-35815" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35818" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35820" href="../Lists/#plfa_plfa-part1-Lists-35820" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35823" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35825" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35827" href="../Lists/#plfa_plfa-part1-Lists-35787" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35831" href="../Lists/#plfa_plfa-part1-Lists-35815" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-35836" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-35838" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-35841" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-35858" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35859" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35860" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-35861" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-35867" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35868" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35869" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-35871" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35872" href="../Lists/#plfa_plfa-part1-Lists-35872" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-35881" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35884" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35887" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35890" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35891" href="../Lists/#plfa_plfa-part1-Lists-35891" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35894" href="../Lists/#plfa_plfa-part1-Lists-27561" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35896" href="../Lists/#plfa_plfa-part1-Lists-35896" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35899" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35901" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35903" href="../Lists/#plfa_plfa-part1-Lists-35872" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-35908" href="../Lists/#plfa_plfa-part1-Lists-35896" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-35912" class="Symbol">}</a>
</pre><p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p><h4 id="练习-any扩展">练习 <code>Any?</code>（扩展）</h4><p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36787" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-split扩展">练习 <code>split</code>（扩展）</h4><p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36992" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-36997" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37003" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37004" href="../Lists/#plfa_plfa-part1-Lists-37004" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-37006" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37008" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-37011" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-37013" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37015" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37016" href="../Lists/#plfa_plfa-part1-Lists-37016" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37019" href="../Lists/#plfa_plfa-part1-Lists-37019" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37022" href="../Lists/#plfa_plfa-part1-Lists-37022" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-37025" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37027" href="../Lists/#plfa_plfa-part1-Lists-1228" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-37032" href="../Lists/#plfa_plfa-part1-Lists-37004" class="Bound">A</a><a id="plfa_plfa-part1-Lists-37033" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37035" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37037" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-37041" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-37050" href="../Lists/#plfa_plfa-part1-Lists-37050" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37053" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-37061" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-37082" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37088" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37091" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37094" href="../Lists/#plfa_plfa-part1-Lists-1257" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-37100" href="../Lists/#plfa_plfa-part1-Lists-37100" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37107" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37109" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37111" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37112" href="../Lists/#plfa_plfa-part1-Lists-37112" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37114" href="../Lists/#plfa_plfa-part1-Lists-37114" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37117" href="../Lists/#plfa_plfa-part1-Lists-37117" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37120" href="../Lists/#plfa_plfa-part1-Lists-37120" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37122" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37128" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37130" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37136" href="../Lists/#plfa_plfa-part1-Lists-37114" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37139" href="../Lists/#plfa_plfa-part1-Lists-37117" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37142" href="../Lists/#plfa_plfa-part1-Lists-37120" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37151" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37182" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37184" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37190" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37191" href="../Lists/#plfa_plfa-part1-Lists-37112" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37193" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37195" href="../Lists/#plfa_plfa-part1-Lists-37114" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-37197" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37199" href="../Lists/#plfa_plfa-part1-Lists-37117" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37202" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37203" href="../Lists/#plfa_plfa-part1-Lists-37112" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37205" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37207" href="../Lists/#plfa_plfa-part1-Lists-37120" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37209" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-37214" href="../Lists/#plfa_plfa-part1-Lists-37214" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37222" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37224" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37226" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37227" href="../Lists/#plfa_plfa-part1-Lists-37227" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37229" href="../Lists/#plfa_plfa-part1-Lists-37229" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37232" href="../Lists/#plfa_plfa-part1-Lists-37232" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37235" href="../Lists/#plfa_plfa-part1-Lists-37235" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37237" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37243" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37245" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37251" href="../Lists/#plfa_plfa-part1-Lists-37229" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37254" href="../Lists/#plfa_plfa-part1-Lists-37232" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37257" href="../Lists/#plfa_plfa-part1-Lists-37235" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37266" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37297" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37299" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37305" href="../Lists/#plfa_plfa-part1-Lists-37229" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37308" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37309" href="../Lists/#plfa_plfa-part1-Lists-37227" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37311" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37313" href="../Lists/#plfa_plfa-part1-Lists-37232" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-37315" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37317" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37318" href="../Lists/#plfa_plfa-part1-Lists-37227" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37320" href="../Lists/#plfa_plfa-part1-Lists-1272" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37322" href="../Lists/#plfa_plfa-part1-Lists-37235" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37324" class="Symbol">)</a>
</pre><p>例如</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37366" href="../Lists/#plfa_plfa-part1-Lists-37366" class="Function">_</a> <a id="plfa_plfa-part1-Lists-37368" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37370" href="../Lists/#plfa_plfa-part1-Lists-36997" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37376" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37378" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37380" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37382" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37384" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37386" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37388" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37390" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37392" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37394" href="../Lists/#plfa_plfa-part1-Lists-3727" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37396" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37398" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37400" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37402" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37404" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37406" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37408" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37410" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37412" href="../Lists/#plfa_plfa-part1-Lists-3797" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-37414" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-37416" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-37418" href="../Lists/#plfa_plfa-part1-Lists-37100" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37425" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37426" href="../Lists/#plfa_plfa-part1-Lists-37214" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37434" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37435" href="../Lists/#plfa_plfa-part1-Lists-37214" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37444" href="../Lists/#plfa_plfa-part1-Lists-37100" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37451" href="../Lists/#plfa_plfa-part1-Lists-37050" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-37453" class="Symbol">)))</a>
</pre><p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p><p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-38287" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-38465" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38472" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-38482" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38488" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38489" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-38493" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38495" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-38499" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38501" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4864" class="Function">length</a><a id="plfa_plfa-part1-Lists-38507" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38509" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#9817" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-38516" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38518" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1544" class="Function">map</a><a id="plfa_plfa-part1-Lists-38521" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38523" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4192" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-38528" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38530" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#6273" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-38538" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38540" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38547" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-38576" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38582" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38583" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-38586" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38588" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-38590" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38592" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-38595" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38597" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38604" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-38633" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38640" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-38643" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38645" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-38649" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38651" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-38656" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38658" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38665" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-38700" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38706" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38707" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-38710" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38712" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38719" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-38742" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38748" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38749" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#34556" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-38767" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38769" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3768" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-38780" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38782" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3085" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-38796" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38798" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#16280" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-38806" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-38810" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-38819" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38820" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#40456" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-38830" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-38833" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-38845" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38847" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38854" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-38873" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38879" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38880" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html#2801" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-38888" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38890" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38897" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-38912" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38918" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38919" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html#3536" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-38928" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38930" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38937" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-38953" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38959" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38960" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-38969" class="Symbol">)</a>
</pre><p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p><p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p><h2 id="unicode">Unicode</h2><p>本章使用了下列 Unicode：</p><pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>