<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: 列表与高阶函数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-96" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-103" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-120" class="Keyword">where</a>
</pre><p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-481" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-488" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-526" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-529" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-532" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-537" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-540" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-546" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-547" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-550" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-552" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-556" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-558" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Lists-561" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a><a id="plfa_plfa-part1-Lists-568" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-570" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Lists-574" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-576" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-581" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-596" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-601" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-608" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-618" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-624" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-629" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-635" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-642" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-644" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Lists-645" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-647" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-650" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-652" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-657" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Lists-660" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-662" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-667" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-674" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-683" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-689" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-690" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-691" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-693" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-697" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-699" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-702" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-704" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-707" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-712" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-714" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-717" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-719" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-722" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-724" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-727" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-729" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-732" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-734" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-739" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-746" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-766" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-774" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-775" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-782" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-784" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-795" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-797" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-808" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-810" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-817" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-819" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-830" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-832" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-843" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-845" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20560" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-857" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-859" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-864" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-871" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-888" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-894" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-895" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-897" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-899" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-902" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-904" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-907" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-909" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-911" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-913" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-918" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-925" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-938" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-944" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-945" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-948" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-950" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1369" class="Function">∃</a><a id="plfa_plfa-part1-Lists-951" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-953" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1806" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-961" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-963" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-972" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-973" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-977" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-985" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-987" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-992" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-999" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-1008" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1014" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1015" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-1018" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1020" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1025" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1032" href="https://agda.github.io/agda-stdlib/v1.7.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-1038" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1044" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1045" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#591" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-1050" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1052" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1057" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1064" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-1087" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1093" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1094" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-1097" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-1099" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14960" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-1102" class="Symbol">)</a>
</pre><h2 id="列表">列表</h2>Agda 中的列表如下定义：<pre class="Agda"><a id="plfa_plfa-part1-Lists-1207" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1212" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1217" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1218" href="../Lists/#plfa_plfa-part1-Lists-1218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1220" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1222" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1225" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1227" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1229" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1233" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1241" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1245" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1247" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1252" href="../Lists/#plfa_plfa-part1-Lists-1218" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1256" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1260" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1262" href="../Lists/#plfa_plfa-part1-Lists-1218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1264" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1266" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1271" href="../Lists/#plfa_plfa-part1-Lists-1218" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1273" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1275" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1280" href="../Lists/#plfa_plfa-part1-Lists-1218" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1283" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1290" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1292" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">_∷_</a>
</pre><p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-1961" href="../Lists/#plfa_plfa-part1-Lists-1961" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1963" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1965" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1970" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1972" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1974" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1976" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1978" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1980" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1982" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1984" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1986" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1988" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
</pre><p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p><p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-2735" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2740" href="../Lists/#plfa_plfa-part1-Lists-2740" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2746" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2748" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2752" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2754" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2758" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2766" href="../Lists/#plfa_plfa-part1-Lists-2766" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2771" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2773" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2775" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2776" href="../Lists/#plfa_plfa-part1-Lists-2776" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2778" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2780" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2783" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2785" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2787" href="../Lists/#plfa_plfa-part1-Lists-2740" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2793" href="../Lists/#plfa_plfa-part1-Lists-2776" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2797" href="../Lists/#plfa_plfa-part1-Lists-2797" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2802" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2804" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2806" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2807" href="../Lists/#plfa_plfa-part1-Lists-2807" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2809" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2811" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2814" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2816" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2818" href="../Lists/#plfa_plfa-part1-Lists-2807" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2820" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2822" href="../Lists/#plfa_plfa-part1-Lists-2740" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2828" href="../Lists/#plfa_plfa-part1-Lists-2807" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2830" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2832" href="../Lists/#plfa_plfa-part1-Lists-2740" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2838" href="../Lists/#plfa_plfa-part1-Lists-2807" class="Bound">A</a>
</pre><p>每个构造子将参数作为隐式参数。因此我们列表的例子也可以写作：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3003" href="../Lists/#plfa_plfa-part1-Lists-3003" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3005" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3007" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3012" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-3014" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-3016" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3018" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3022" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3023" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3024" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3026" class="Number">0</a> <a id="plfa_plfa-part1-Lists-3028" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3029" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3033" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3034" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3035" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3037" class="Number">1</a> <a id="plfa_plfa-part1-Lists-3039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3040" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3044" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3045" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3046" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3048" class="Number">2</a> <a id="plfa_plfa-part1-Lists-3050" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3051" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-3054" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3055" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3056" class="Symbol">})))</a>
</pre><p>此处我们将隐式参数显式地声明。</p><p>包含下面的编译器指令</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p><h2 id="列表语法">列表语法</h2><p>我们可以用下面的定义，更简便地表示列表：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3680" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3688" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3692" href="../Lists/#plfa_plfa-part1-Lists-3696" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3694" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3696" href="../Lists/#plfa_plfa-part1-Lists-3696" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3698" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3700" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3703" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3711" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3717" href="../Lists/#plfa_plfa-part1-Lists-3723" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3719" href="../Lists/#plfa_plfa-part1-Lists-3727" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3721" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3723" href="../Lists/#plfa_plfa-part1-Lists-3723" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3725" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3727" href="../Lists/#plfa_plfa-part1-Lists-3727" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3729" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3731" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3734" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3742" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3750" href="../Lists/#plfa_plfa-part1-Lists-3758" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3752" href="../Lists/#plfa_plfa-part1-Lists-3762" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3754" href="../Lists/#plfa_plfa-part1-Lists-3766" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3756" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3758" href="../Lists/#plfa_plfa-part1-Lists-3758" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3760" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3762" href="../Lists/#plfa_plfa-part1-Lists-3762" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3764" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3766" href="../Lists/#plfa_plfa-part1-Lists-3766" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3768" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3770" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3773" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3781" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3791" href="../Lists/#plfa_plfa-part1-Lists-3801" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3793" href="../Lists/#plfa_plfa-part1-Lists-3805" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3795" href="../Lists/#plfa_plfa-part1-Lists-3809" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3797" href="../Lists/#plfa_plfa-part1-Lists-3813" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3799" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3801" href="../Lists/#plfa_plfa-part1-Lists-3801" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3803" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3805" href="../Lists/#plfa_plfa-part1-Lists-3805" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3807" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3809" href="../Lists/#plfa_plfa-part1-Lists-3809" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3811" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3813" href="../Lists/#plfa_plfa-part1-Lists-3813" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3815" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3817" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3820" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3828" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3840" href="../Lists/#plfa_plfa-part1-Lists-3852" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3842" href="../Lists/#plfa_plfa-part1-Lists-3856" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3844" href="../Lists/#plfa_plfa-part1-Lists-3860" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3846" href="../Lists/#plfa_plfa-part1-Lists-3864" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3848" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3850" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3852" href="../Lists/#plfa_plfa-part1-Lists-3852" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3854" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3856" href="../Lists/#plfa_plfa-part1-Lists-3856" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3858" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3860" href="../Lists/#plfa_plfa-part1-Lists-3860" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3862" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3864" href="../Lists/#plfa_plfa-part1-Lists-3864" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3866" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3868" href="../Lists/#plfa_plfa-part1-Lists-3868" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3870" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3872" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3875" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3883" href="../Lists/#plfa_plfa-part1-Lists-3883" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3897" href="../Lists/#plfa_plfa-part1-Lists-3911" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3899" href="../Lists/#plfa_plfa-part1-Lists-3915" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3901" href="../Lists/#plfa_plfa-part1-Lists-3919" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3903" href="../Lists/#plfa_plfa-part1-Lists-3923" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3905" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3907" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3909" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3911" href="../Lists/#plfa_plfa-part1-Lists-3911" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3913" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3915" href="../Lists/#plfa_plfa-part1-Lists-3915" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3917" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3919" href="../Lists/#plfa_plfa-part1-Lists-3919" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3921" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3923" href="../Lists/#plfa_plfa-part1-Lists-3923" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3925" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3927" href="../Lists/#plfa_plfa-part1-Lists-3927" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3929" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3931" href="../Lists/#plfa_plfa-part1-Lists-3931" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3933" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3935" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
</pre><p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p><h2 id="附加">附加</h2><p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-4488" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-4495" class="Number">5</a> <a id="plfa_plfa-part1-Lists-4497" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-4503" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-4508" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4510" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4512" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4513" href="../Lists/#plfa_plfa-part1-Lists-4513" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4515" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4517" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4520" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4522" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4524" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4529" href="../Lists/#plfa_plfa-part1-Lists-4513" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4531" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4533" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4538" href="../Lists/#plfa_plfa-part1-Lists-4513" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4540" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4542" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4547" href="../Lists/#plfa_plfa-part1-Lists-4513" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-4549" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-4558" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4561" href="../Lists/#plfa_plfa-part1-Lists-4561" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4565" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4568" href="../Lists/#plfa_plfa-part1-Lists-4561" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-4571" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4572" href="../Lists/#plfa_plfa-part1-Lists-4572" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4574" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4576" href="../Lists/#plfa_plfa-part1-Lists-4576" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4578" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4580" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4583" href="../Lists/#plfa_plfa-part1-Lists-4583" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4587" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4590" href="../Lists/#plfa_plfa-part1-Lists-4572" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4592" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4594" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4595" href="../Lists/#plfa_plfa-part1-Lists-4576" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4598" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4601" href="../Lists/#plfa_plfa-part1-Lists-4583" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4603" class="Symbol">)</a>
</pre><p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p><p>我们举个例子，来展示将两个列表附加的计算过程：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-5230" href="../Lists/#plfa_plfa-part1-Lists-5230" class="Function">_</a> <a id="plfa_plfa-part1-Lists-5232" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5234" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5236" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5238" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5240" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5242" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5244" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5246" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5248" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5251" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5253" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5255" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5257" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5259" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5261" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5263" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5265" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5267" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5269" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5271" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5273" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5275" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5277" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5279" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5281" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5283" href="../Lists/#plfa_plfa-part1-Lists-3828" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-5285" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-5287" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5291" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5301" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5303" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5305" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5307" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5309" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5311" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5313" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5316" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5319" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5321" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5323" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5325" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5327" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5332" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5340" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5342" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5344" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5345" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5347" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5349" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5351" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5353" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5356" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5359" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5361" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5363" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5365" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5367" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5369" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5373" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5381" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5383" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5385" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5387" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5389" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5390" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5392" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5394" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5397" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5400" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5402" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5404" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5406" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5408" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5410" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5414" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5422" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5424" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5426" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5428" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5430" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5432" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5434" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5435" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5438" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5441" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5443" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5445" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5447" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5449" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5451" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5455" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5463" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5465" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5467" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5469" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5471" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5473" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5475" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5477" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5479" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5481" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5483" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5488" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>附加两个列表需要对于第一个列表元素个数线性的时间。</p><h2 id="论证附加">论证附加</h2>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-5843" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5852" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5854" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5856" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5857" href="../Lists/#plfa_plfa-part1-Lists-5857" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5859" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5861" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5864" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5866" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5867" href="../Lists/#plfa_plfa-part1-Lists-5867" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5870" href="../Lists/#plfa_plfa-part1-Lists-5870" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5873" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5876" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5878" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5883" href="../Lists/#plfa_plfa-part1-Lists-5857" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5884" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5888" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5890" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5891" href="../Lists/#plfa_plfa-part1-Lists-5867" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5894" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5897" href="../Lists/#plfa_plfa-part1-Lists-5870" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5899" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5901" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5904" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5907" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5909" href="../Lists/#plfa_plfa-part1-Lists-5867" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5912" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5915" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5916" href="../Lists/#plfa_plfa-part1-Lists-5870" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5919" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5922" href="../Lists/#plfa_plfa-part1-Lists-5873" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5924" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-5926" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5935" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5938" href="../Lists/#plfa_plfa-part1-Lists-5938" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5941" href="../Lists/#plfa_plfa-part1-Lists-5941" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5944" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5948" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5959" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5962" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5965" href="../Lists/#plfa_plfa-part1-Lists-5938" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5967" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5969" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5972" href="../Lists/#plfa_plfa-part1-Lists-5941" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5977" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5985" href="../Lists/#plfa_plfa-part1-Lists-5938" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5988" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5991" href="../Lists/#plfa_plfa-part1-Lists-5941" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5996" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6004" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6007" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6010" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6011" href="../Lists/#plfa_plfa-part1-Lists-5938" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6014" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6017" href="../Lists/#plfa_plfa-part1-Lists-5941" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6019" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6023" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6025" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6034" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6035" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6037" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6039" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6041" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6043" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6046" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6049" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6053" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6063" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6064" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6066" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6068" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6071" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6074" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6076" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6078" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6081" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6086" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6094" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6096" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6099" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6102" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6105" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6107" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6109" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6112" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6117" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6125" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6127" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6129" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-6131" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6134" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6137" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6139" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6141" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6144" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6146" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6150" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6153" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6158" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6159" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6161" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6163" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6166" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6175" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6178" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6181" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6183" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6185" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6191" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6193" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6195" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6196" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6199" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6202" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6203" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6206" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6209" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6211" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6216" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6224" href="../Lists/#plfa_plfa-part1-Lists-6035" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6226" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6228" href="../Lists/#plfa_plfa-part1-Lists-6039" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6231" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6234" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6235" href="../Lists/#plfa_plfa-part1-Lists-6043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6238" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6241" href="../Lists/#plfa_plfa-part1-Lists-6046" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6243" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6247" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p><p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>提升至等式：</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>即证明中所需。</p><p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-7347" href="../Lists/#plfa_plfa-part1-Lists-7347" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7360" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7362" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7364" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7365" href="../Lists/#plfa_plfa-part1-Lists-7365" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7367" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7369" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7372" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7374" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7375" href="../Lists/#plfa_plfa-part1-Lists-7375" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7378" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7380" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7385" href="../Lists/#plfa_plfa-part1-Lists-7365" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7386" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7388" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7390" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7393" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7396" href="../Lists/#plfa_plfa-part1-Lists-7375" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7399" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7401" href="../Lists/#plfa_plfa-part1-Lists-7375" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7404" href="../Lists/#plfa_plfa-part1-Lists-7347" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7417" href="../Lists/#plfa_plfa-part1-Lists-7417" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7420" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7424" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7434" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7437" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7440" href="../Lists/#plfa_plfa-part1-Lists-7417" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7445" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7453" href="../Lists/#plfa_plfa-part1-Lists-7417" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7458" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>右幺元的证明可由简单的归纳得到：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-7557" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7570" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7572" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7574" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7575" href="../Lists/#plfa_plfa-part1-Lists-7575" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7577" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7579" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7582" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7584" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7585" href="../Lists/#plfa_plfa-part1-Lists-7585" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7588" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7590" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7595" href="../Lists/#plfa_plfa-part1-Lists-7575" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7596" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7598" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7600" href="../Lists/#plfa_plfa-part1-Lists-7585" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7603" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7606" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7609" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7611" href="../Lists/#plfa_plfa-part1-Lists-7585" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7614" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7627" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7630" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7634" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7644" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7647" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7650" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7655" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7663" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7668" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7670" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7683" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7684" href="../Lists/#plfa_plfa-part1-Lists-7684" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7686" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7688" href="../Lists/#plfa_plfa-part1-Lists-7688" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7690" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7692" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7696" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7706" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7707" href="../Lists/#plfa_plfa-part1-Lists-7684" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7709" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7711" href="../Lists/#plfa_plfa-part1-Lists-7688" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7713" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7715" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7718" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7723" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7731" href="../Lists/#plfa_plfa-part1-Lists-7684" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7733" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7735" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7736" href="../Lists/#plfa_plfa-part1-Lists-7688" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7739" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7742" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7744" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7748" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7751" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7756" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7757" href="../Lists/#plfa_plfa-part1-Lists-7684" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7759" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-7761" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7763" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7764" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7777" href="../Lists/#plfa_plfa-part1-Lists-7688" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7779" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7781" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7787" href="../Lists/#plfa_plfa-part1-Lists-7684" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7789" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7791" href="../Lists/#plfa_plfa-part1-Lists-7688" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7796" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p><h2 id="长度">长度</h2><p>在下一个函数里，我们来寻找列表的长度：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-8088" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8095" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8097" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8099" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8100" href="../Lists/#plfa_plfa-part1-Lists-8100" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8102" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8104" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8107" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8109" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8111" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8116" href="../Lists/#plfa_plfa-part1-Lists-8100" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8118" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8120" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-8122" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8129" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8139" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8142" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-8147" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8154" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8155" href="../Lists/#plfa_plfa-part1-Lists-8155" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8157" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8159" href="../Lists/#plfa_plfa-part1-Lists-8159" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8161" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8164" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8167" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8171" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8172" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8179" href="../Lists/#plfa_plfa-part1-Lists-8159" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8181" class="Symbol">)</a>
</pre><p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>我们用下面的例子来展示如何计算列表的长度：<pre class="Agda"><a id="plfa_plfa-part1-Lists-8515" href="../Lists/#plfa_plfa-part1-Lists-8515" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8517" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8519" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8526" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8528" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8530" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8532" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8534" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8536" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8538" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8540" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8542" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-8544" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8546" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8550" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8560" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8567" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8568" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8570" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8572" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8574" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8576" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8578" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8580" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8582" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8586" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8598" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8599" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8606" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8607" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8609" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8611" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8613" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8615" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8617" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8622" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8630" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8634" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8635" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8640" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8647" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8648" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8650" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8652" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8654" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8660" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8672" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8673" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8677" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8678" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8682" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8683" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8690" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8691" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-8692" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8694" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8696" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8702" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8714" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8719" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8720" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8724" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-8728" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8733" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>计算列表的长度需要关于列表元素个数线性的时间。</p><p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p><h2 id="论证长度">论证长度</h2><p>两个附加在一起的列表的长度是两列表长度之和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-9332" href="../Lists/#plfa_plfa-part1-Lists-9332" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9342" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9344" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-9346" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9347" href="../Lists/#plfa_plfa-part1-Lists-9347" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-9349" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-9354" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9356" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9357" href="../Lists/#plfa_plfa-part1-Lists-9357" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9360" href="../Lists/#plfa_plfa-part1-Lists-9360" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9363" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9365" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-9370" href="../Lists/#plfa_plfa-part1-Lists-9347" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9371" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9375" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-9377" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9384" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9385" href="../Lists/#plfa_plfa-part1-Lists-9357" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9388" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9391" href="../Lists/#plfa_plfa-part1-Lists-9360" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9393" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9395" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-9397" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9404" href="../Lists/#plfa_plfa-part1-Lists-9357" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9407" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9409" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9416" href="../Lists/#plfa_plfa-part1-Lists-9360" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-9419" href="../Lists/#plfa_plfa-part1-Lists-9332" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9429" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9430" href="../Lists/#plfa_plfa-part1-Lists-9430" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9431" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9433" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9436" href="../Lists/#plfa_plfa-part1-Lists-9436" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9439" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9443" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9453" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9460" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9461" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9464" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9467" href="../Lists/#plfa_plfa-part1-Lists-9436" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9469" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9473" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9481" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9488" href="../Lists/#plfa_plfa-part1-Lists-9436" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9493" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9501" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9508" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9509" href="../Lists/#plfa_plfa-part1-Lists-9430" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9510" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9512" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9515" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9517" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9524" href="../Lists/#plfa_plfa-part1-Lists-9436" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9529" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-9531" href="../Lists/#plfa_plfa-part1-Lists-9332" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9541" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9542" href="../Lists/#plfa_plfa-part1-Lists-9542" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9544" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9546" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9548" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9550" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9553" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9557" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9567" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9574" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9576" href="../Lists/#plfa_plfa-part1-Lists-9542" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9578" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9580" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9582" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9584" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9587" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9589" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9593" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9601" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9605" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9606" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9613" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9614" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9617" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9620" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9622" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9627" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-9630" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-9635" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9640" href="../Lists/#plfa_plfa-part1-Lists-9332" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9650" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9653" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9655" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9657" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-9663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9667" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9668" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9675" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9678" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9680" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9687" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9689" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9693" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9701" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9708" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9709" href="../Lists/#plfa_plfa-part1-Lists-9542" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9711" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9713" href="../Lists/#plfa_plfa-part1-Lists-9546" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9715" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9717" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9719" href="../Lists/#plfa_plfa-part1-Lists-8088" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9726" href="../Lists/#plfa_plfa-part1-Lists-9550" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9731" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p><h2 id="反转">反转</h2>我们可以使用附加，来简单地构造一个函数来反转一个列表：<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-10614" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10622" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10624" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10626" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10627" href="../Lists/#plfa_plfa-part1-Lists-10627" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10629" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10634" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10636" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10638" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10643" href="../Lists/#plfa_plfa-part1-Lists-10627" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10645" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10647" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10652" href="../Lists/#plfa_plfa-part1-Lists-10627" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10654" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10662" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-10672" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10675" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-10678" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10686" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10687" href="../Lists/#plfa_plfa-part1-Lists-10687" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10689" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10691" href="../Lists/#plfa_plfa-part1-Lists-10691" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10693" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-10696" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10699" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10707" href="../Lists/#plfa_plfa-part1-Lists-10691" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10710" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10713" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10715" href="../Lists/#plfa_plfa-part1-Lists-10687" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10717" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a>
</pre><p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>下面的例子展示了如何反转一个列表。<pre class="Agda"><a id="plfa_plfa-part1-Lists-11021" href="../Lists/#plfa_plfa-part1-Lists-11021" class="Function">_</a> <a id="plfa_plfa-part1-Lists-11023" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11025" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11033" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11035" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11037" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11039" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11041" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11043" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11045" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-11049" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11051" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11053" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11055" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11057" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11059" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11061" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-11063" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-11065" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11069" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11079" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11087" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11088" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11090" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11092" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11094" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11096" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11098" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11100" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11102" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11106" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11114" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11122" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11123" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11125" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11127" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11129" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11131" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11133" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11135" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11138" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11140" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11142" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11146" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11154" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11155" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11163" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11164" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11166" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11168" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11170" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11172" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11175" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11177" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11179" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11180" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11182" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11185" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11187" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11189" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11193" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11201" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11203" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11211" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11214" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11217" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11219" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11221" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11222" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11224" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11227" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11229" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11231" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11232" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11234" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11237" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11239" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11241" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11245" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11253" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11255" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11258" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11261" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11263" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11265" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11266" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11268" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11271" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11273" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11275" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11276" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11278" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11281" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11283" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11285" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11289" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11297" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11299" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11302" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11305" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11307" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11309" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11311" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11313" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11316" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11318" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11320" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11322" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11324" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11327" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11329" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11331" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11336" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11344" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11345" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11347" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11349" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11352" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11355" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11357" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11359" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11361" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11363" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11366" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11368" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11370" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11375" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11383" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11385" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11387" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11388" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11391" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11394" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11396" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11398" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11400" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11402" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11405" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11407" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11409" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11414" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11422" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11423" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11425" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11427" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11429" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11431" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11433" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11435" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11438" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11440" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11442" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11447" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11455" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11457" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11459" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11460" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11462" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11464" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11467" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11470" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11472" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11474" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11476" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11480" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11488" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11490" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11492" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11494" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11496" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11497" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11500" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11503" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11505" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11507" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11509" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11513" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11521" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11523" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11525" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11527" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11529" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11531" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11533" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11538" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11546" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11548" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11550" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11552" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11554" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11556" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11558" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11562" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p><h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4><p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-12467" class="Comment">-- Your code goes here</a>
</pre><h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4><p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-12822" class="Comment">-- Your code goes here</a>
</pre><h2 id="更快地反转">更快地反转</h2><p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-13199" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13205" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13207" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13209" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13210" href="../Lists/#plfa_plfa-part1-Lists-13210" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13212" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13214" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13217" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13219" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13221" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13226" href="../Lists/#plfa_plfa-part1-Lists-13210" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13228" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13230" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13235" href="../Lists/#plfa_plfa-part1-Lists-13210" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13237" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13239" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13244" href="../Lists/#plfa_plfa-part1-Lists-13210" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-13246" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13252" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-13261" href="../Lists/#plfa_plfa-part1-Lists-13261" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13265" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13268" href="../Lists/#plfa_plfa-part1-Lists-13261" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13271" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13277" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13278" href="../Lists/#plfa_plfa-part1-Lists-13278" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13280" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13282" href="../Lists/#plfa_plfa-part1-Lists-13282" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13284" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13286" href="../Lists/#plfa_plfa-part1-Lists-13286" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13290" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13293" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13299" href="../Lists/#plfa_plfa-part1-Lists-13282" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13302" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13303" href="../Lists/#plfa_plfa-part1-Lists-13278" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13305" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13307" href="../Lists/#plfa_plfa-part1-Lists-13286" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13309" class="Symbol">)</a>
</pre><p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>转移（Shunt）与反转的关系如下：<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-13644" href="../Lists/#plfa_plfa-part1-Lists-13644" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13658" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13660" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13662" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13663" href="../Lists/#plfa_plfa-part1-Lists-13663" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13665" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13667" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13670" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13672" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13673" href="../Lists/#plfa_plfa-part1-Lists-13673" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13676" href="../Lists/#plfa_plfa-part1-Lists-13676" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13679" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13681" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13686" href="../Lists/#plfa_plfa-part1-Lists-13663" class="Bound">A</a><a id="plfa_plfa-part1-Lists-13687" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13691" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13693" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13699" href="../Lists/#plfa_plfa-part1-Lists-13673" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13702" href="../Lists/#plfa_plfa-part1-Lists-13676" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13707" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13715" href="../Lists/#plfa_plfa-part1-Lists-13673" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13718" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13721" href="../Lists/#plfa_plfa-part1-Lists-13676" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13724" href="../Lists/#plfa_plfa-part1-Lists-13644" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13738" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13741" href="../Lists/#plfa_plfa-part1-Lists-13741" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13744" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13748" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13758" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13764" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13767" href="../Lists/#plfa_plfa-part1-Lists-13741" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13772" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13780" href="../Lists/#plfa_plfa-part1-Lists-13741" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13785" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13793" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13801" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13804" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13807" href="../Lists/#plfa_plfa-part1-Lists-13741" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13812" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-13814" href="../Lists/#plfa_plfa-part1-Lists-13644" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13828" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13829" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13831" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13833" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13835" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13837" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13840" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13844" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13854" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13860" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13861" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13863" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13865" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13867" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13869" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13874" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13882" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13888" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13891" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13892" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13894" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13896" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13898" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13902" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13905" href="../Lists/#plfa_plfa-part1-Lists-13644" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13919" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13922" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13923" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13925" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13927" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13929" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13931" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13937" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13945" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13948" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13951" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13952" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13954" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13956" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13958" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13962" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13970" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13978" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13981" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13984" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13985" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13987" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13989" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13991" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13994" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13996" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-14000" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-14003" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-14007" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14008" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-14017" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14018" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14026" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14028" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14030" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14032" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14034" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14036" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-14038" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14040" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-14046" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14047" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14055" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-14058" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14061" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14063" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14065" href="../Lists/#plfa_plfa-part1-Lists-3688" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-14066" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14068" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14071" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14076" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14084" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14092" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14093" href="../Lists/#plfa_plfa-part1-Lists-13829" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14095" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14097" href="../Lists/#plfa_plfa-part1-Lists-13833" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14099" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14101" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14104" href="../Lists/#plfa_plfa-part1-Lists-13837" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14109" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p><p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p><p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-15130" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15139" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15141" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15143" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15144" href="../Lists/#plfa_plfa-part1-Lists-15144" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15146" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15151" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15153" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15155" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15160" href="../Lists/#plfa_plfa-part1-Lists-15144" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15162" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15164" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15169" href="../Lists/#plfa_plfa-part1-Lists-15144" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-15171" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15180" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15183" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-15185" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15191" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15194" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
</pre><p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-15340" href="../Lists/#plfa_plfa-part1-Lists-15340" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15349" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15351" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15353" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15354" href="../Lists/#plfa_plfa-part1-Lists-15354" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15356" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15358" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15361" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15363" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15364" href="../Lists/#plfa_plfa-part1-Lists-15364" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15367" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15369" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15374" href="../Lists/#plfa_plfa-part1-Lists-15354" class="Bound">A</a><a id="plfa_plfa-part1-Lists-15375" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15379" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15381" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15390" href="../Lists/#plfa_plfa-part1-Lists-15364" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15393" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15395" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15403" href="../Lists/#plfa_plfa-part1-Lists-15364" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-15406" href="../Lists/#plfa_plfa-part1-Lists-15340" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15415" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15418" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15422" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15432" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15441" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15446" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15454" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15460" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15463" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15468" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15471" href="../Lists/#plfa_plfa-part1-Lists-13644" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-15485" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15488" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15491" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15497" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15505" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15508" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-15511" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15516" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15519" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-15532" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15533" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15541" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15543" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15545" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15551" href="../Lists/#plfa_plfa-part1-Lists-10614" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15559" href="../Lists/#plfa_plfa-part1-Lists-15415" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15564" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-15693" href="../Lists/#plfa_plfa-part1-Lists-15693" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15695" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15697" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15706" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15708" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15710" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15712" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15714" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15716" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15718" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15720" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15722" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15724" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15726" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15728" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15730" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15732" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15734" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-15736" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15738" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15742" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15752" href="../Lists/#plfa_plfa-part1-Lists-15130" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15761" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15762" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15764" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15766" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15768" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15770" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15772" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15774" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15776" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15780" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15788" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15794" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15795" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15797" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15799" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15801" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15803" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15805" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15807" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15809" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15811" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15816" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15824" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15830" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15831" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15833" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15835" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15837" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15839" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15841" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15843" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15844" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15846" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15848" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15850" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15854" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15862" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15868" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15869" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15871" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15873" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15875" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15877" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15878" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15880" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15882" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15884" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15886" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15888" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15892" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15900" href="../Lists/#plfa_plfa-part1-Lists-13199" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15906" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15909" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15910" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15912" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15914" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15916" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15918" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15920" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15922" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15924" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15928" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15936" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15938" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15940" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15942" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15944" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15946" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15948" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15953" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>现在反转一个列表需要的时间与列表的长度线性相关。</p><h2 id="Map">映射</h2><p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-16423" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16427" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16429" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-16431" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-16432" href="../Lists/#plfa_plfa-part1-Lists-16432" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16434" href="../Lists/#plfa_plfa-part1-Lists-16434" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-16436" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16438" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-16441" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-16443" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16445" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16446" href="../Lists/#plfa_plfa-part1-Lists-16432" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16448" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16450" href="../Lists/#plfa_plfa-part1-Lists-16434" class="Bound">B</a><a id="plfa_plfa-part1-Lists-16451" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16453" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16455" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16460" href="../Lists/#plfa_plfa-part1-Lists-16432" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16462" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16464" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16469" href="../Lists/#plfa_plfa-part1-Lists-16434" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-16471" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16475" href="../Lists/#plfa_plfa-part1-Lists-16475" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16477" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-16487" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16490" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-16493" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16497" href="../Lists/#plfa_plfa-part1-Lists-16497" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16499" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16500" href="../Lists/#plfa_plfa-part1-Lists-16500" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16502" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16504" href="../Lists/#plfa_plfa-part1-Lists-16504" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-16506" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-16509" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16512" href="../Lists/#plfa_plfa-part1-Lists-16497" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16514" href="../Lists/#plfa_plfa-part1-Lists-16500" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16516" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16518" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16522" href="../Lists/#plfa_plfa-part1-Lists-16497" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16524" href="../Lists/#plfa_plfa-part1-Lists-16504" class="Bound">xs</a>
</pre><p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p><p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-16973" href="../Lists/#plfa_plfa-part1-Lists-16973" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16975" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16977" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16981" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-16985" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16987" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16989" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16991" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16993" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16995" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16997" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16999" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17001" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17003" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17005" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17007" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17009" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17011" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17013" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17015" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17017" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17021" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17031" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17035" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17040" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17042" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17044" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17046" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17048" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17050" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17052" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17054" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17058" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17066" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17070" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17072" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17074" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17078" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17082" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17083" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17085" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17087" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17089" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17091" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17093" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17097" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17105" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17109" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17111" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17117" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17119" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17121" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17125" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17129" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17130" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17132" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17134" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17136" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17140" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17152" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17154" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17156" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17160" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17162" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17168" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17170" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17172" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17176" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17180" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17185" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17197" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17199" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17205" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17207" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17209" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17213" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17215" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17217" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17222" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17230" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17232" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17234" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17236" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17238" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17240" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17242" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17247" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>映射需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-17553" href="../Lists/#plfa_plfa-part1-Lists-17553" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17558" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17560" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17565" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-17567" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17569" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17574" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-17576" href="../Lists/#plfa_plfa-part1-Lists-17553" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17581" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-17583" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17587" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-17592" href="../Lists/#plfa_plfa-part1-Lists-17592" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17594" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17596" href="../Lists/#plfa_plfa-part1-Lists-17553" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17601" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17603" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17605" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17607" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17609" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17611" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17613" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17615" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17617" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17619" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17621" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17623" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17625" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17627" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17629" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17631" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17633" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17637" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17647" href="../Lists/#plfa_plfa-part1-Lists-17553" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17652" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17654" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17656" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17658" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17660" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17662" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17664" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17668" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17676" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17684" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17686" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17688" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17690" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17692" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17694" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17696" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17700" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17708" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17710" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17712" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17714" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17716" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17718" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17720" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17724" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p><h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4><p>证明函数组合的映射是两个映射的组合：</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>证明的最后一步需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18527" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4><p>证明下列关于映射与附加的关系：</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18769" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4><p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18989" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-18994" href="../Lists/#plfa_plfa-part1-Lists-18994" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18999" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19000" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19002" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19004" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19006" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19009" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19011" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19013" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19017" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-19025" href="../Lists/#plfa_plfa-part1-Lists-19025" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-19030" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19032" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19034" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19036" href="../Lists/#plfa_plfa-part1-Lists-18994" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19041" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19043" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-19047" href="../Lists/#plfa_plfa-part1-Lists-19047" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-19052" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19054" href="../Lists/#plfa_plfa-part1-Lists-18994" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19059" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19061" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19063" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19065" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19067" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19069" href="../Lists/#plfa_plfa-part1-Lists-18994" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19074" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19076" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19078" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19080" href="../Lists/#plfa_plfa-part1-Lists-18994" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19085" href="../Lists/#plfa_plfa-part1-Lists-19000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19087" href="../Lists/#plfa_plfa-part1-Lists-19002" class="Bound">B</a>
</pre><p>定义一个对于树的映射运算符：</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19247" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="Fold">折叠</h2><p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-19537" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19543" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19545" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19547" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19548" href="../Lists/#plfa_plfa-part1-Lists-19548" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19550" href="../Lists/#plfa_plfa-part1-Lists-19550" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19552" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19554" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19557" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19559" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19561" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19562" href="../Lists/#plfa_plfa-part1-Lists-19548" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19564" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19566" href="../Lists/#plfa_plfa-part1-Lists-19550" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19568" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19570" href="../Lists/#plfa_plfa-part1-Lists-19550" class="Bound">B</a><a id="plfa_plfa-part1-Lists-19571" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19573" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19575" href="../Lists/#plfa_plfa-part1-Lists-19550" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19577" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19579" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19584" href="../Lists/#plfa_plfa-part1-Lists-19548" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19586" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19588" href="../Lists/#plfa_plfa-part1-Lists-19550" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-19590" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19596" href="../Lists/#plfa_plfa-part1-Lists-19596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19600" href="../Lists/#plfa_plfa-part1-Lists-19600" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19602" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-19612" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19615" href="../Lists/#plfa_plfa-part1-Lists-19600" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-19617" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19623" href="../Lists/#plfa_plfa-part1-Lists-19623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19627" href="../Lists/#plfa_plfa-part1-Lists-19627" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19630" href="../Lists/#plfa_plfa-part1-Lists-19630" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19632" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19634" href="../Lists/#plfa_plfa-part1-Lists-19634" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19636" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-19639" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19642" href="../Lists/#plfa_plfa-part1-Lists-19630" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19644" href="../Lists/#plfa_plfa-part1-Lists-19623" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19646" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19652" href="../Lists/#plfa_plfa-part1-Lists-19623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19656" href="../Lists/#plfa_plfa-part1-Lists-19627" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19658" href="../Lists/#plfa_plfa-part1-Lists-19634" class="Bound">xs</a>
</pre><p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p><p>下面的例子展示了如何使用折叠来对一个列表求和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-19992" href="../Lists/#plfa_plfa-part1-Lists-19992" class="Function">_</a> <a id="plfa_plfa-part1-Lists-19994" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19996" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20002" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20006" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20008" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20010" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20012" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20014" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20016" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20018" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20020" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20022" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20024" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20026" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20028" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20031" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20033" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20037" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20047" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20053" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20057" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20059" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20060" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20062" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20064" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20066" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20068" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20070" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20072" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20074" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20076" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20078" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20082" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20090" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20092" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20094" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20100" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20104" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20106" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20107" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20109" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20111" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20113" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20115" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20117" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20119" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20121" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20125" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20133" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20135" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20137" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20138" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20140" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20142" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20152" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20154" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20155" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20157" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20159" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20161" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20163" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20165" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-20170" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20178" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20180" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20182" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20183" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20185" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20187" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20188" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20190" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20192" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20202" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20204" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20205" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20207" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20209" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20211" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20217" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20225" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20227" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20229" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20230" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20232" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20234" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20235" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20240" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20242" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20244" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20250" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20254" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20256" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20258" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20264" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20272" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20274" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20276" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20277" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20279" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20281" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20282" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20284" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20286" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20287" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20289" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20291" class="Number">0</a><a id="plfa_plfa-part1-Lists-20292" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20298" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>折叠需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-20693" href="../Lists/#plfa_plfa-part1-Lists-20693" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20697" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20699" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20704" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-20706" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20708" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-20710" href="../Lists/#plfa_plfa-part1-Lists-20693" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20714" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-20716" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20722" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20726" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-20729" href="../Lists/#plfa_plfa-part1-Lists-20729" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20731" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20733" href="../Lists/#plfa_plfa-part1-Lists-20693" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20737" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20739" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20741" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20743" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20745" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20747" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20749" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20751" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20753" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20755" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20757" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20760" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20762" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20766" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20776" href="../Lists/#plfa_plfa-part1-Lists-20693" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20780" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20782" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20784" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20786" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20788" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20790" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20792" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20794" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20796" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20800" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20808" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20814" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20818" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20820" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20822" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20824" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20826" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20828" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20830" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20832" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20834" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20836" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20840" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20848" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-20853" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p><p>举另外一个例子，观察</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>二者相等的证明留作练习。</p><h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4><p>使用折叠来定义一个计算列表数字之积的函数。例如：</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21893" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4><p>证明折叠和附加有如下的关系：</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22128" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4><p>证明映射可以用折叠定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22429" class="Comment">-- 请将代码写在此处</a>
</pre><p>此证明需要外延性。</p><h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4><p>请证明 map 可使用 fold 来定义：</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>此证明需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22755" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4><p>请为预先给定的三个类型定义一个合适的折叠函数：</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23035" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4><p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23258" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4><p>定义一个向下数数的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-23432" href="../Lists/#plfa_plfa-part1-Lists-23432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23441" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23443" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-23445" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23447" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23452" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-23454" href="../Lists/#plfa_plfa-part1-Lists-23432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-23472" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23475" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-23478" href="../Lists/#plfa_plfa-part1-Lists-23432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23487" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23488" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-23492" href="../Lists/#plfa_plfa-part1-Lists-23492" class="Bound">n</a><a id="plfa_plfa-part1-Lists-23493" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-23496" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23499" href="../Lists/#plfa_plfa-part1-Lists-23492" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-23501" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23503" href="../Lists/#plfa_plfa-part1-Lists-23432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23512" href="../Lists/#plfa_plfa-part1-Lists-23492" class="Bound">n</a>
</pre><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23555" href="../Lists/#plfa_plfa-part1-Lists-23555" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23557" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23559" href="../Lists/#plfa_plfa-part1-Lists-23432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23568" class="Number">3</a> <a id="plfa_plfa-part1-Lists-23570" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-23572" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23574" class="Number">2</a> <a id="plfa_plfa-part1-Lists-23576" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23578" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23580" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23582" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23584" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-23586" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-23588" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-23789" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="幺半群">幺半群</h2><p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p><p>我们可以用一个合适的记录类型来定义幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24180" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-24187" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24196" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24197" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24199" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24204" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24206" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24207" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-24211" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24213" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24215" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24217" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24219" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24221" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24222" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24224" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24225" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24227" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24229" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24230" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24232" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24234" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-24238" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-24246" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-24256" href="../Lists/#plfa_plfa-part1-Lists-24256" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24262" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24264" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24266" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24267" href="../Lists/#plfa_plfa-part1-Lists-24267" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24269" href="../Lists/#plfa_plfa-part1-Lists-24269" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24271" href="../Lists/#plfa_plfa-part1-Lists-24271" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24275" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24276" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24278" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24280" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24281" href="../Lists/#plfa_plfa-part1-Lists-24267" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24283" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24285" href="../Lists/#plfa_plfa-part1-Lists-24269" class="Bound">y</a><a id="plfa_plfa-part1-Lists-24286" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24288" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24290" href="../Lists/#plfa_plfa-part1-Lists-24271" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24292" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24294" href="../Lists/#plfa_plfa-part1-Lists-24267" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24296" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24298" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24299" href="../Lists/#plfa_plfa-part1-Lists-24269" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24301" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24303" href="../Lists/#plfa_plfa-part1-Lists-24271" class="Bound">z</a><a id="plfa_plfa-part1-Lists-24304" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-24310" href="../Lists/#plfa_plfa-part1-Lists-24310" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24320" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24322" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24324" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24325" href="../Lists/#plfa_plfa-part1-Lists-24325" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24327" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24329" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24330" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24332" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24334" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24336" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24338" href="../Lists/#plfa_plfa-part1-Lists-24325" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24340" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24342" href="../Lists/#plfa_plfa-part1-Lists-24325" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-24348" href="../Lists/#plfa_plfa-part1-Lists-24348" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24358" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24360" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24362" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24363" href="../Lists/#plfa_plfa-part1-Lists-24363" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24365" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24367" href="../Lists/#plfa_plfa-part1-Lists-24197" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24368" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24370" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24372" href="../Lists/#plfa_plfa-part1-Lists-24363" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24374" href="../Lists/#plfa_plfa-part1-Lists-24207" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24376" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24378" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24380" href="../Lists/#plfa_plfa-part1-Lists-24363" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-24383" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-24388" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Module">IsMonoid</a>
</pre><p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-24561" href="../Lists/#plfa_plfa-part1-Lists-24561" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24570" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24572" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24581" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-24585" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-24587" href="../Lists/#plfa_plfa-part1-Lists-24561" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24596" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24600" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24611" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24613" href="../Lists/#plfa_plfa-part1-Lists-24256" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24619" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24621" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-24633" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24635" href="../Lists/#plfa_plfa-part1-Lists-24310" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24645" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24647" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24663" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24665" href="../Lists/#plfa_plfa-part1-Lists-24348" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24675" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24677" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24693" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-24696" href="../Lists/#plfa_plfa-part1-Lists-24696" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24705" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24707" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24716" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-24720" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-24722" href="../Lists/#plfa_plfa-part1-Lists-24696" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24731" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24735" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24746" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24748" href="../Lists/#plfa_plfa-part1-Lists-24256" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24754" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24756" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-24768" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24770" href="../Lists/#plfa_plfa-part1-Lists-24310" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24780" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24782" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24798" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24800" href="../Lists/#plfa_plfa-part1-Lists-24348" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24810" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24812" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24828" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-24831" href="../Lists/#plfa_plfa-part1-Lists-24831" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24841" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24843" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24845" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24846" href="../Lists/#plfa_plfa-part1-Lists-24846" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24848" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24850" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24853" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24855" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24857" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24866" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24867" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24872" href="../Lists/#plfa_plfa-part1-Lists-24846" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24873" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24875" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-24880" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-24883" href="../Lists/#plfa_plfa-part1-Lists-24831" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24893" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24897" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24908" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24910" href="../Lists/#plfa_plfa-part1-Lists-24256" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24916" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24918" href="../Lists/#plfa_plfa-part1-Lists-5843" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-24931" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24933" href="../Lists/#plfa_plfa-part1-Lists-24310" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24943" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24945" href="../Lists/#plfa_plfa-part1-Lists-7347" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24962" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24964" href="../Lists/#plfa_plfa-part1-Lists-24348" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24974" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24976" href="../Lists/#plfa_plfa-part1-Lists-7557" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24993" class="Symbol">}</a>
</pre><p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-25174" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25187" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25189" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25191" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25192" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25194" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25196" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25199" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25201" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25202" href="../Lists/#plfa_plfa-part1-Lists-25202" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25206" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25208" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25210" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25212" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25214" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25216" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25217" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25220" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25222" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25224" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25225" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25227" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25229" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25238" href="../Lists/#plfa_plfa-part1-Lists-25202" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25242" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25244" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25248" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25251" href="../Lists/#plfa_plfa-part1-Lists-25251" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25254" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25256" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25261" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25262" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25264" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25265" href="../Lists/#plfa_plfa-part1-Lists-25265" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25267" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25269" href="../Lists/#plfa_plfa-part1-Lists-25192" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25270" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25272" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25274" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25280" href="../Lists/#plfa_plfa-part1-Lists-25202" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25284" href="../Lists/#plfa_plfa-part1-Lists-25265" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25286" href="../Lists/#plfa_plfa-part1-Lists-25251" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25289" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25291" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25297" href="../Lists/#plfa_plfa-part1-Lists-25202" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25301" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25303" href="../Lists/#plfa_plfa-part1-Lists-25251" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25306" href="../Lists/#plfa_plfa-part1-Lists-25202" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25308" href="../Lists/#plfa_plfa-part1-Lists-25265" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-25310" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25323" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25327" href="../Lists/#plfa_plfa-part1-Lists-25327" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25329" href="../Lists/#plfa_plfa-part1-Lists-25329" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25338" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25341" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25343" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25347" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25357" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25363" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25367" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25369" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-25374" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25382" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25386" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25389" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25393" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25394" href="../Lists/#plfa_plfa-part1-Lists-24310" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25404" href="../Lists/#plfa_plfa-part1-Lists-25329" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25413" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25414" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25416" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25422" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25423" href="../Lists/#plfa_plfa-part1-Lists-25327" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25425" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25427" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25428" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25432" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25440" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25446" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25450" href="../Lists/#plfa_plfa-part1-Lists-25327" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25452" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25455" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25457" href="../Lists/#plfa_plfa-part1-Lists-25341" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25461" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-25463" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25476" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25480" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25482" href="../Lists/#plfa_plfa-part1-Lists-25482" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25491" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25492" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25494" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25496" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25498" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25500" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25502" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25506" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25516" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25522" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25526" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25528" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25529" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25531" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25533" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25535" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25539" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25547" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25549" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25552" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25558" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25562" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25564" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25566" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25570" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25573" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-25578" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25579" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25581" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-25583" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25585" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25586" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25599" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25603" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25605" href="../Lists/#plfa_plfa-part1-Lists-25482" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25614" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25617" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25618" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25620" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25626" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25628" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25630" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25631" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25637" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25641" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25643" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25646" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25648" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25649" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25653" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25656" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25660" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25661" href="../Lists/#plfa_plfa-part1-Lists-24256" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25667" href="../Lists/#plfa_plfa-part1-Lists-25482" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25676" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25678" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25679" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25685" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25689" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25691" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25693" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25695" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25696" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25698" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25704" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25705" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25707" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25709" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25715" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25719" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25721" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25723" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25725" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25727" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25731" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25739" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25745" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25749" href="../Lists/#plfa_plfa-part1-Lists-25480" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25751" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25752" href="../Lists/#plfa_plfa-part1-Lists-25492" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25754" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25756" href="../Lists/#plfa_plfa-part1-Lists-25496" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25758" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25760" href="../Lists/#plfa_plfa-part1-Lists-25476" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25762" href="../Lists/#plfa_plfa-part1-Lists-25500" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25766" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在之前的练习中，我们证明了以下定理：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25859" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-25871" href="../Lists/#plfa_plfa-part1-Lists-25871" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-25880" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25882" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25884" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25885" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25887" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25892" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25894" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25895" href="../Lists/#plfa_plfa-part1-Lists-25895" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25899" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25901" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25903" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25905" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25907" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25909" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25910" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25912" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25913" href="../Lists/#plfa_plfa-part1-Lists-25913" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25915" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25917" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25918" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25920" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25921" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25924" href="../Lists/#plfa_plfa-part1-Lists-25924" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25927" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25929" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25934" href="../Lists/#plfa_plfa-part1-Lists-25885" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25935" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25937" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25943" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25949" href="../Lists/#plfa_plfa-part1-Lists-25895" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25953" href="../Lists/#plfa_plfa-part1-Lists-25913" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25955" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25956" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25959" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25962" href="../Lists/#plfa_plfa-part1-Lists-25924" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25964" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25966" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25968" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25974" href="../Lists/#plfa_plfa-part1-Lists-25895" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25978" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25979" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25985" href="../Lists/#plfa_plfa-part1-Lists-25895" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25989" href="../Lists/#plfa_plfa-part1-Lists-25913" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25991" href="../Lists/#plfa_plfa-part1-Lists-25924" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25993" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25995" href="../Lists/#plfa_plfa-part1-Lists-25921" class="Bound">xs</a>
</pre><p>由此，我们可以将幺半群中附加的折叠如下分解成两个折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-26140" href="../Lists/#plfa_plfa-part1-Lists-26140" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26156" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26158" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26160" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26161" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26163" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26165" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26168" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26171" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26175" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26177" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26179" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26181" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26183" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26185" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26186" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26188" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26189" href="../Lists/#plfa_plfa-part1-Lists-26189" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26193" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26194" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26196" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26198" href="../Lists/#plfa_plfa-part1-Lists-24187" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-26207" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26211" href="../Lists/#plfa_plfa-part1-Lists-26189" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26213" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-26217" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26220" href="../Lists/#plfa_plfa-part1-Lists-26220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26223" href="../Lists/#plfa_plfa-part1-Lists-26223" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26226" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26228" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26233" href="../Lists/#plfa_plfa-part1-Lists-26161" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26234" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26236" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26238" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26244" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26248" href="../Lists/#plfa_plfa-part1-Lists-26189" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26251" href="../Lists/#plfa_plfa-part1-Lists-26220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26254" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26257" href="../Lists/#plfa_plfa-part1-Lists-26223" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26259" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26261" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-26263" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26269" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26273" href="../Lists/#plfa_plfa-part1-Lists-26189" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26275" href="../Lists/#plfa_plfa-part1-Lists-26220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26278" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26280" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26286" href="../Lists/#plfa_plfa-part1-Lists-26171" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26290" href="../Lists/#plfa_plfa-part1-Lists-26189" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26292" href="../Lists/#plfa_plfa-part1-Lists-26223" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-26295" href="../Lists/#plfa_plfa-part1-Lists-26140" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26311" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26315" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26317" href="../Lists/#plfa_plfa-part1-Lists-26317" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26326" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26329" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26332" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-26336" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-26346" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26352" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26356" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26358" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26359" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26362" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26365" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26367" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26371" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26374" href="../Lists/#plfa_plfa-part1-Lists-25871" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-26383" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26387" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26389" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26392" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26395" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26401" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26407" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26411" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26412" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26418" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26422" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26424" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26426" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26428" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-26433" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26436" href="../Lists/#plfa_plfa-part1-Lists-25174" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26449" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26453" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26455" href="../Lists/#plfa_plfa-part1-Lists-26317" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26464" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26467" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26468" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26474" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26478" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26480" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26482" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26484" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26490" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26496" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26500" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26502" href="../Lists/#plfa_plfa-part1-Lists-26326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26505" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26507" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26513" href="../Lists/#plfa_plfa-part1-Lists-26311" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26517" href="../Lists/#plfa_plfa-part1-Lists-26315" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26519" href="../Lists/#plfa_plfa-part1-Lists-26329" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-26524" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4><p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-26906" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4><p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27203" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="All">所有</h2><p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p><p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27532" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-27537" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27541" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27542" href="../Lists/#plfa_plfa-part1-Lists-27542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27544" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27546" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27549" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27552" href="../Lists/#plfa_plfa-part1-Lists-27552" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27554" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27556" href="../Lists/#plfa_plfa-part1-Lists-27542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27558" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27560" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27563" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27565" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27567" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27572" href="../Lists/#plfa_plfa-part1-Lists-27542" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27574" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27576" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-27580" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-27588" href="../Lists/#plfa_plfa-part1-Lists-27588" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-27592" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27594" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27598" href="../Lists/#plfa_plfa-part1-Lists-27552" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27600" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-27605" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-27609" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27611" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27613" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27614" href="../Lists/#plfa_plfa-part1-Lists-27614" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27616" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27618" href="../Lists/#plfa_plfa-part1-Lists-27542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27619" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27621" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27622" href="../Lists/#plfa_plfa-part1-Lists-27622" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27625" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27627" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27632" href="../Lists/#plfa_plfa-part1-Lists-27542" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27633" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27635" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27637" href="../Lists/#plfa_plfa-part1-Lists-27552" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27639" href="../Lists/#plfa_plfa-part1-Lists-27614" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27641" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27643" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27647" href="../Lists/#plfa_plfa-part1-Lists-27552" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27649" href="../Lists/#plfa_plfa-part1-Lists-27622" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27652" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27654" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27658" href="../Lists/#plfa_plfa-part1-Lists-27552" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27660" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27661" href="../Lists/#plfa_plfa-part1-Lists-27614" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27663" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27665" href="../Lists/#plfa_plfa-part1-Lists-27622" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27667" class="Symbol">)</a>
</pre><p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p><p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28648" href="../Lists/#plfa_plfa-part1-Lists-28648" class="Function">_</a> <a id="plfa_plfa-part1-Lists-28650" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28652" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28656" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28657" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-28660" class="Number">2</a><a id="plfa_plfa-part1-Lists-28661" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28663" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-28665" class="Number">0</a> <a id="plfa_plfa-part1-Lists-28667" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28669" class="Number">1</a> <a id="plfa_plfa-part1-Lists-28671" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28673" class="Number">2</a> <a id="plfa_plfa-part1-Lists-28675" href="../Lists/#plfa_plfa-part1-Lists-3742" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-28677" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-28679" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-28681" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28685" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28687" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28691" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28695" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28697" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28701" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28702" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28706" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-28709" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28711" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28713" href="../Lists/#plfa_plfa-part1-Lists-27588" class="InductiveConstructor">[]</a>
</pre><p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p><p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p><h2 id="任意">任意</h2><p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-29638" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-29643" href="../Lists/#plfa_plfa-part1-Lists-29643" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29647" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29648" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29650" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29652" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29655" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29657" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29658" href="../Lists/#plfa_plfa-part1-Lists-29658" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29660" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29662" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29664" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29666" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29669" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29671" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29673" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29678" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29680" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29682" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29686" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-29694" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-29700" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29702" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29704" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29705" href="../Lists/#plfa_plfa-part1-Lists-29705" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29707" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29709" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29710" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29712" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29713" href="../Lists/#plfa_plfa-part1-Lists-29713" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29716" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29718" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29723" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29724" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29726" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29728" href="../Lists/#plfa_plfa-part1-Lists-29658" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29730" href="../Lists/#plfa_plfa-part1-Lists-29705" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29732" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29734" href="../Lists/#plfa_plfa-part1-Lists-29643" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29738" href="../Lists/#plfa_plfa-part1-Lists-29658" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29740" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29741" href="../Lists/#plfa_plfa-part1-Lists-29705" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29743" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29745" href="../Lists/#plfa_plfa-part1-Lists-29713" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29747" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-29751" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-29757" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29759" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29761" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29762" href="../Lists/#plfa_plfa-part1-Lists-29762" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29764" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29766" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29767" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29769" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29770" href="../Lists/#plfa_plfa-part1-Lists-29770" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29773" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29775" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29780" href="../Lists/#plfa_plfa-part1-Lists-29648" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29781" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29783" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29785" href="../Lists/#plfa_plfa-part1-Lists-29643" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29789" href="../Lists/#plfa_plfa-part1-Lists-29658" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29791" href="../Lists/#plfa_plfa-part1-Lists-29770" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29794" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29796" href="../Lists/#plfa_plfa-part1-Lists-29643" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29800" href="../Lists/#plfa_plfa-part1-Lists-29658" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29802" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29803" href="../Lists/#plfa_plfa-part1-Lists-29762" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29805" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29807" href="../Lists/#plfa_plfa-part1-Lists-29770" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29809" class="Symbol">)</a>
</pre><p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30137" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-30143" class="Number">4</a> <a id="plfa_plfa-part1-Lists-30145" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30149" href="../Lists/#plfa_plfa-part1-Lists-30224" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-30154" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30158" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30160" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30162" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30163" href="../Lists/#plfa_plfa-part1-Lists-30163" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30165" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30167" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30170" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30172" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30173" href="../Lists/#plfa_plfa-part1-Lists-30173" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30175" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30177" href="../Lists/#plfa_plfa-part1-Lists-30163" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30178" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30180" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30181" href="../Lists/#plfa_plfa-part1-Lists-30181" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30184" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30186" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30191" href="../Lists/#plfa_plfa-part1-Lists-30163" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30192" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30194" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30196" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30200" href="../Lists/#plfa_plfa-part1-Lists-30200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30202" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30204" href="../Lists/#plfa_plfa-part1-Lists-30204" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30207" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30209" href="../Lists/#plfa_plfa-part1-Lists-29643" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30213" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30214" href="../Lists/#plfa_plfa-part1-Lists-30200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30216" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-30218" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30220" href="../Lists/#plfa_plfa-part1-Lists-30204" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-30224" href="../Lists/#plfa_plfa-part1-Lists-30224" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-30228" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30230" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30232" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30233" href="../Lists/#plfa_plfa-part1-Lists-30233" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30235" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30240" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30242" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30243" href="../Lists/#plfa_plfa-part1-Lists-30243" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30245" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30247" href="../Lists/#plfa_plfa-part1-Lists-30233" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30248" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30250" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30251" href="../Lists/#plfa_plfa-part1-Lists-30251" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30254" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30256" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30261" href="../Lists/#plfa_plfa-part1-Lists-30233" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30262" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30264" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30266" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30270" href="../Lists/#plfa_plfa-part1-Lists-30270" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30272" href="../Lists/#plfa_plfa-part1-Lists-30224" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30274" href="../Lists/#plfa_plfa-part1-Lists-30274" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30277" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30279" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-30281" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30282" href="../Lists/#plfa_plfa-part1-Lists-30270" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30284" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30286" href="../Lists/#plfa_plfa-part1-Lists-30274" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30288" class="Symbol">)</a>
</pre><p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30635" href="../Lists/#plfa_plfa-part1-Lists-30635" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30637" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30639" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30641" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30643" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30645" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30647" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30649" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30651" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30653" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30655" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30657" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30659" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30661" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30663" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30665" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30670" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-30676" href="../Lists/#plfa_plfa-part1-Lists-30676" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30678" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30680" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30682" href="../Lists/#plfa_plfa-part1-Lists-30154" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30684" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30686" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30688" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30690" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30692" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30694" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30696" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30698" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30700" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30702" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30704" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30706" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30712" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30713" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30719" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30720" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-30729" class="Symbol">))</a>
</pre><p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-30928" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30935" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30937" class="Number">3</a> <a id="plfa_plfa-part1-Lists-30939" href="../Lists/#plfa_plfa-part1-Lists-30224" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30941" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30943" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30945" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30947" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30949" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30951" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30953" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30955" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30957" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30959" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30966" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30967" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30972" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-30976" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30983" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30984" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30990" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30991" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30996" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-31001" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31008" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31009" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31015" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31016" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31022" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31023" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31028" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-31034" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31041" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31042" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31048" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31049" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31056" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31062" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31063" href="../Lists/#plfa_plfa-part1-Lists-29694" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-31068" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-31075" href="../Lists/#plfa_plfa-part1-Lists-30928" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-31082" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31083" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31090" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31096" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31097" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31103" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31104" href="../Lists/#plfa_plfa-part1-Lists-29751" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31110" class="Symbol">()))))</a>
</pre><p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p><h2 id="所有和附加">所有和附加</h2><p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-31582" href="../Lists/#plfa_plfa-part1-Lists-31582" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31591" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31593" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31595" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31596" href="../Lists/#plfa_plfa-part1-Lists-31596" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31598" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31600" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31603" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31605" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31606" href="../Lists/#plfa_plfa-part1-Lists-31606" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31608" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31610" href="../Lists/#plfa_plfa-part1-Lists-31596" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31612" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31614" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31617" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31619" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31620" href="../Lists/#plfa_plfa-part1-Lists-31620" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31623" href="../Lists/#plfa_plfa-part1-Lists-31623" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31626" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31628" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31633" href="../Lists/#plfa_plfa-part1-Lists-31596" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31634" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31636" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-31640" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31644" href="../Lists/#plfa_plfa-part1-Lists-31606" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31646" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31647" href="../Lists/#plfa_plfa-part1-Lists-31620" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31650" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31653" href="../Lists/#plfa_plfa-part1-Lists-31623" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31655" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31657" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14960" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-31659" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31660" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31664" href="../Lists/#plfa_plfa-part1-Lists-31606" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31666" href="../Lists/#plfa_plfa-part1-Lists-31620" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31669" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31671" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31675" href="../Lists/#plfa_plfa-part1-Lists-31606" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31677" href="../Lists/#plfa_plfa-part1-Lists-31623" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31679" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-31681" href="../Lists/#plfa_plfa-part1-Lists-31582" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31690" href="../Lists/#plfa_plfa-part1-Lists-31690" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31693" href="../Lists/#plfa_plfa-part1-Lists-31693" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31696" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-31700" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-31711" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31713" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15000" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-31722" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31725" href="../Lists/#plfa_plfa-part1-Lists-31780" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31728" href="../Lists/#plfa_plfa-part1-Lists-31690" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31731" href="../Lists/#plfa_plfa-part1-Lists-31693" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31738" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-31740" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15017" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-31749" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31752" href="../Lists/#plfa_plfa-part1-Lists-32005" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31757" href="../Lists/#plfa_plfa-part1-Lists-31690" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31760" href="../Lists/#plfa_plfa-part1-Lists-31693" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31767" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-31771" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-31780" href="../Lists/#plfa_plfa-part1-Lists-31780" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31783" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31785" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31787" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31788" href="../Lists/#plfa_plfa-part1-Lists-31788" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31790" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31792" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31795" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31797" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31798" href="../Lists/#plfa_plfa-part1-Lists-31798" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31800" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31802" href="../Lists/#plfa_plfa-part1-Lists-31788" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31804" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31806" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31809" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31811" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31812" href="../Lists/#plfa_plfa-part1-Lists-31812" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31815" href="../Lists/#plfa_plfa-part1-Lists-31815" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31818" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31820" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31825" href="../Lists/#plfa_plfa-part1-Lists-31788" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31826" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31828" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-31834" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31838" href="../Lists/#plfa_plfa-part1-Lists-31798" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31840" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31841" href="../Lists/#plfa_plfa-part1-Lists-31812" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31844" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31847" href="../Lists/#plfa_plfa-part1-Lists-31815" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31849" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31851" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31853" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31854" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31858" href="../Lists/#plfa_plfa-part1-Lists-31798" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31860" href="../Lists/#plfa_plfa-part1-Lists-31812" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31863" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31865" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31869" href="../Lists/#plfa_plfa-part1-Lists-31798" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31871" href="../Lists/#plfa_plfa-part1-Lists-31815" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31873" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-31877" href="../Lists/#plfa_plfa-part1-Lists-31780" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31880" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31883" href="../Lists/#plfa_plfa-part1-Lists-31883" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31886" href="../Lists/#plfa_plfa-part1-Lists-31886" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31890" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31892" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31894" href="../Lists/#plfa_plfa-part1-Lists-27588" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31897" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31899" href="../Lists/#plfa_plfa-part1-Lists-31886" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31903" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-31907" href="../Lists/#plfa_plfa-part1-Lists-31780" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31910" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31911" href="../Lists/#plfa_plfa-part1-Lists-31911" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-31913" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31915" href="../Lists/#plfa_plfa-part1-Lists-31915" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-31917" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31919" href="../Lists/#plfa_plfa-part1-Lists-31919" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31922" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31923" href="../Lists/#plfa_plfa-part1-Lists-31923" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31926" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31928" href="../Lists/#plfa_plfa-part1-Lists-31928" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-31935" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31937" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-31942" href="../Lists/#plfa_plfa-part1-Lists-31780" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31945" href="../Lists/#plfa_plfa-part1-Lists-31915" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31948" href="../Lists/#plfa_plfa-part1-Lists-31919" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31951" href="../Lists/#plfa_plfa-part1-Lists-31928" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-31961" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-31965" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-31967" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31969" href="../Lists/#plfa_plfa-part1-Lists-31969" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31973" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31975" href="../Lists/#plfa_plfa-part1-Lists-31975" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31979" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-31981" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31983" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31985" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31988" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31990" href="../Lists/#plfa_plfa-part1-Lists-31969" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31994" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31996" href="../Lists/#plfa_plfa-part1-Lists-31975" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32000" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-32005" href="../Lists/#plfa_plfa-part1-Lists-32005" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32010" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32012" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-32014" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-32016" href="../Lists/#plfa_plfa-part1-Lists-32016" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32018" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32020" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32023" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32025" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-32026" href="../Lists/#plfa_plfa-part1-Lists-32026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32028" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32030" href="../Lists/#plfa_plfa-part1-Lists-32016" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-32032" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32034" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-32037" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-32039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32040" href="../Lists/#plfa_plfa-part1-Lists-32040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32043" href="../Lists/#plfa_plfa-part1-Lists-32043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-32048" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-32053" href="../Lists/#plfa_plfa-part1-Lists-32016" class="Bound">A</a><a id="plfa_plfa-part1-Lists-32054" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32056" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-32062" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32066" href="../Lists/#plfa_plfa-part1-Lists-32026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32068" href="../Lists/#plfa_plfa-part1-Lists-32040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32071" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-32073" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32077" href="../Lists/#plfa_plfa-part1-Lists-32026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32079" href="../Lists/#plfa_plfa-part1-Lists-32043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32082" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32084" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32088" href="../Lists/#plfa_plfa-part1-Lists-32026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32090" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32091" href="../Lists/#plfa_plfa-part1-Lists-32040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32094" href="../Lists/#plfa_plfa-part1-Lists-4503" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32097" href="../Lists/#plfa_plfa-part1-Lists-32043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32099" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32103" href="../Lists/#plfa_plfa-part1-Lists-32005" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32108" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32111" href="../Lists/#plfa_plfa-part1-Lists-32111" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32114" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32116" href="../Lists/#plfa_plfa-part1-Lists-27588" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32119" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32121" href="../Lists/#plfa_plfa-part1-Lists-32121" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32125" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32127" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32129" href="../Lists/#plfa_plfa-part1-Lists-32121" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-32135" href="../Lists/#plfa_plfa-part1-Lists-32005" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32140" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32141" href="../Lists/#plfa_plfa-part1-Lists-32141" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32143" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32145" href="../Lists/#plfa_plfa-part1-Lists-32145" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32147" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32149" href="../Lists/#plfa_plfa-part1-Lists-32149" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32152" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32154" href="../Lists/#plfa_plfa-part1-Lists-32154" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32157" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32159" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32163" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32165" href="../Lists/#plfa_plfa-part1-Lists-32165" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32169" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32171" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32174" href="../Lists/#plfa_plfa-part1-Lists-32154" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32177" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32179" href="../Lists/#plfa_plfa-part1-Lists-32005" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32184" href="../Lists/#plfa_plfa-part1-Lists-32145" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32187" href="../Lists/#plfa_plfa-part1-Lists-32149" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32190" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32192" href="../Lists/#plfa_plfa-part1-Lists-32159" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32196" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32198" href="../Lists/#plfa_plfa-part1-Lists-32165" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32202" href="../Lists/#plfa_plfa-part1-Lists-980" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4><p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32579" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4><p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32792" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4><p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p><p>以下定律是否也成立？</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>若成立，请证明；否则请解释原因。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33433" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4><p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33693" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4><p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33895" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4><p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34104" class="Comment">-- 请将代码写在此处</a>
</pre><p>如果成立，请证明；如果不成立，请解释原因。</p><h2 id="所有的可判定性">所有的可判定性</h2><p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-34515" href="../Lists/#plfa_plfa-part1-Lists-34515" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34519" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34521" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-34523" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-34524" href="../Lists/#plfa_plfa-part1-Lists-34524" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34526" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34528" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-34531" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-34533" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34535" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-34536" href="../Lists/#plfa_plfa-part1-Lists-34524" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34538" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34540" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-34544" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-34546" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34548" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-34553" href="../Lists/#plfa_plfa-part1-Lists-34524" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34555" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34557" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-34562" href="../Lists/#plfa_plfa-part1-Lists-34515" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34566" href="../Lists/#plfa_plfa-part1-Lists-34566" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-34569" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-34572" href="../Lists/#plfa_plfa-part1-Lists-19537" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-34578" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-34582" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-34587" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-34589" href="../Lists/#plfa_plfa-part1-Lists-16423" class="Function">map</a> <a id="plfa_plfa-part1-Lists-34593" href="../Lists/#plfa_plfa-part1-Lists-34566" class="Bound">p</a>
</pre><p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p><p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-35319" href="../Lists/#plfa_plfa-part1-Lists-35319" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35329" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35331" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35333" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35334" href="../Lists/#plfa_plfa-part1-Lists-35334" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35336" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35338" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35341" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35343" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35345" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35346" href="../Lists/#plfa_plfa-part1-Lists-35334" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35348" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35350" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35353" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35355" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35357" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-35361" href="../Lists/#plfa_plfa-part1-Lists-35319" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35371" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35372" href="../Lists/#plfa_plfa-part1-Lists-35372" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35373" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35375" href="../Lists/#plfa_plfa-part1-Lists-35375" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-35378" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35381" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35383" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35384" href="../Lists/#plfa_plfa-part1-Lists-35384" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35386" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35388" href="../Lists/#plfa_plfa-part1-Lists-35372" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35389" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35391" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35393" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-35397" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35398" href="../Lists/#plfa_plfa-part1-Lists-35375" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35400" href="../Lists/#plfa_plfa-part1-Lists-35384" class="Bound">x</a><a id="plfa_plfa-part1-Lists-35401" class="Symbol">)</a>
</pre>那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-35580" href="../Lists/#plfa_plfa-part1-Lists-35580" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35585" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35587" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35589" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35590" href="../Lists/#plfa_plfa-part1-Lists-35590" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35592" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35597" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35599" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35600" href="../Lists/#plfa_plfa-part1-Lists-35600" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35602" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35604" href="../Lists/#plfa_plfa-part1-Lists-35590" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35606" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35608" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35611" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35613" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35615" href="../Lists/#plfa_plfa-part1-Lists-35319" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35625" href="../Lists/#plfa_plfa-part1-Lists-35600" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35627" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35629" href="../Lists/#plfa_plfa-part1-Lists-35319" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35640" href="../Lists/#plfa_plfa-part1-Lists-27537" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-35644" href="../Lists/#plfa_plfa-part1-Lists-35600" class="Bound">P</a><a id="plfa_plfa-part1-Lists-35645" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35647" href="../Lists/#plfa_plfa-part1-Lists-35580" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35652" href="../Lists/#plfa_plfa-part1-Lists-35652" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35655" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-35690" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35693" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35697" href="../Lists/#plfa_plfa-part1-Lists-27588" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-35700" href="../Lists/#plfa_plfa-part1-Lists-35580" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35705" href="../Lists/#plfa_plfa-part1-Lists-35705" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35708" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35709" href="../Lists/#plfa_plfa-part1-Lists-35709" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35711" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35713" href="../Lists/#plfa_plfa-part1-Lists-35713" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-35715" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35717" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-35722" href="../Lists/#plfa_plfa-part1-Lists-35705" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35725" href="../Lists/#plfa_plfa-part1-Lists-35709" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-35729" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35731" href="../Lists/#plfa_plfa-part1-Lists-35580" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35736" href="../Lists/#plfa_plfa-part1-Lists-35705" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35739" href="../Lists/#plfa_plfa-part1-Lists-35713" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-35742" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35762" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35764" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35768" href="../Lists/#plfa_plfa-part1-Lists-35768" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35771" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35773" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35777" href="../Lists/#plfa_plfa-part1-Lists-35777" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-35785" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35788" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35792" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35793" href="../Lists/#plfa_plfa-part1-Lists-35768" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35796" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35798" href="../Lists/#plfa_plfa-part1-Lists-35777" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35801" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35803" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35823" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35825" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35828" href="../Lists/#plfa_plfa-part1-Lists-35828" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35832" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35834" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-35846" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35849" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35852" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35855" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35856" href="../Lists/#plfa_plfa-part1-Lists-35856" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35859" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35861" href="../Lists/#plfa_plfa-part1-Lists-35861" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35864" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35866" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35868" href="../Lists/#plfa_plfa-part1-Lists-35828" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35872" href="../Lists/#plfa_plfa-part1-Lists-35856" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-35877" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-35879" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-35882" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-35899" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35900" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35901" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-35902" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-35908" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35909" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35910" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-35912" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35913" href="../Lists/#plfa_plfa-part1-Lists-35913" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-35922" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35925" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35928" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35931" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35932" href="../Lists/#plfa_plfa-part1-Lists-35932" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35935" href="../Lists/#plfa_plfa-part1-Lists-27605" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35937" href="../Lists/#plfa_plfa-part1-Lists-35937" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35940" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35942" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35944" href="../Lists/#plfa_plfa-part1-Lists-35913" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-35949" href="../Lists/#plfa_plfa-part1-Lists-35937" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-35953" class="Symbol">}</a>
</pre><p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p><h4 id="练习-any延伸">练习 <code>Any?</code>（延伸）</h4><p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36828" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-split延伸">练习 <code>split</code>（延伸）</h4><p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37032" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-37037" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37043" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37044" href="../Lists/#plfa_plfa-part1-Lists-37044" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-37046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37048" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-37051" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-37053" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37056" href="../Lists/#plfa_plfa-part1-Lists-37056" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37059" href="../Lists/#plfa_plfa-part1-Lists-37059" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37062" href="../Lists/#plfa_plfa-part1-Lists-37062" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-37065" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37067" href="../Lists/#plfa_plfa-part1-Lists-1212" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-37072" href="../Lists/#plfa_plfa-part1-Lists-37044" class="Bound">A</a><a id="plfa_plfa-part1-Lists-37073" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37075" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37077" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-37081" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-37090" href="../Lists/#plfa_plfa-part1-Lists-37090" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37093" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-37101" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-37122" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37128" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37131" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37134" href="../Lists/#plfa_plfa-part1-Lists-1241" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-37140" href="../Lists/#plfa_plfa-part1-Lists-37140" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37147" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37149" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37151" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37152" href="../Lists/#plfa_plfa-part1-Lists-37152" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37154" href="../Lists/#plfa_plfa-part1-Lists-37154" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37157" href="../Lists/#plfa_plfa-part1-Lists-37157" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37160" href="../Lists/#plfa_plfa-part1-Lists-37160" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37162" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37168" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37170" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37176" href="../Lists/#plfa_plfa-part1-Lists-37154" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37179" href="../Lists/#plfa_plfa-part1-Lists-37157" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37182" href="../Lists/#plfa_plfa-part1-Lists-37160" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37191" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37222" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37224" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37230" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37231" href="../Lists/#plfa_plfa-part1-Lists-37152" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37233" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37235" href="../Lists/#plfa_plfa-part1-Lists-37154" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-37237" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37239" href="../Lists/#plfa_plfa-part1-Lists-37157" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37242" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37243" href="../Lists/#plfa_plfa-part1-Lists-37152" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37245" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37247" href="../Lists/#plfa_plfa-part1-Lists-37160" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37249" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-37254" href="../Lists/#plfa_plfa-part1-Lists-37254" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37262" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37264" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37266" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37267" href="../Lists/#plfa_plfa-part1-Lists-37267" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37269" href="../Lists/#plfa_plfa-part1-Lists-37269" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37272" href="../Lists/#plfa_plfa-part1-Lists-37272" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37275" href="../Lists/#plfa_plfa-part1-Lists-37275" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37277" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37283" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37285" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37291" href="../Lists/#plfa_plfa-part1-Lists-37269" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37294" href="../Lists/#plfa_plfa-part1-Lists-37272" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37297" href="../Lists/#plfa_plfa-part1-Lists-37275" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37306" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37337" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37339" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37345" href="../Lists/#plfa_plfa-part1-Lists-37269" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37348" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37349" href="../Lists/#plfa_plfa-part1-Lists-37267" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37351" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37353" href="../Lists/#plfa_plfa-part1-Lists-37272" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-37355" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37357" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37358" href="../Lists/#plfa_plfa-part1-Lists-37267" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37360" href="../Lists/#plfa_plfa-part1-Lists-1256" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37362" href="../Lists/#plfa_plfa-part1-Lists-37275" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37364" class="Symbol">)</a>
</pre><p>例如</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37406" href="../Lists/#plfa_plfa-part1-Lists-37406" class="Function">_</a> <a id="plfa_plfa-part1-Lists-37408" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37410" href="../Lists/#plfa_plfa-part1-Lists-37037" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37416" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37418" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37420" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37422" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37424" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37426" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37428" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37430" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37432" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37434" href="../Lists/#plfa_plfa-part1-Lists-3711" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37436" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37438" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37440" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37442" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37444" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37446" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37448" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37450" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37452" href="../Lists/#plfa_plfa-part1-Lists-3781" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-37454" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-37456" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-37458" href="../Lists/#plfa_plfa-part1-Lists-37140" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37465" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37466" href="../Lists/#plfa_plfa-part1-Lists-37254" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37474" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37475" href="../Lists/#plfa_plfa-part1-Lists-37254" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37483" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37484" href="../Lists/#plfa_plfa-part1-Lists-37140" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37491" href="../Lists/#plfa_plfa-part1-Lists-37090" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-37493" class="Symbol">)))</a>
</pre><p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p><p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-38327" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-38505" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38512" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-38522" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38528" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#130" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-38533" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38535" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-38539" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38541" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4864" class="Function">length</a><a id="plfa_plfa-part1-Lists-38547" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38549" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#9817" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-38556" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38558" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1544" class="Function">map</a><a id="plfa_plfa-part1-Lists-38561" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38563" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4192" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-38568" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38570" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#6273" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-38578" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38580" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38587" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-38616" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38622" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38623" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-38626" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38628" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-38630" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38632" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-38635" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38637" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38644" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-38673" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38679" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38680" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-38683" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38685" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-38689" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38691" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-38696" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38698" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38705" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-38740" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38746" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38747" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-38750" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38752" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38759" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-38782" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38788" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38789" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#34556" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-38807" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38809" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3768" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-38820" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38822" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3085" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-38836" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38838" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#16280" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-38846" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-38850" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-38859" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38860" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#40456" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-38870" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-38873" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-38885" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38887" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38894" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-38913" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38919" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38920" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html#2801" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-38928" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38930" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38937" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-38952" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38959" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html#3536" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-38968" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38970" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38977" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-38993" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38999" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-39000" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-39009" class="Symbol">)</a>
</pre><p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p><p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p><h2 id="unicode">Unicode</h2><p>本章使用了下列 Unicode：</p><pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>