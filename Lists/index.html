<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Lists: 列表与高阶函数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-112" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-119" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-136" class="Keyword">where</a>
</pre><p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-497" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-542" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-545" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-548" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-556" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-566" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a><a id="plfa_plfa-part1-Lists-584" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-586" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Lists-590" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-592" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-597" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-612" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-617" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-624" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-634" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-641" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-645" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-651" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-653" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-658" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-660" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Lists-661" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-663" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-666" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-668" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-671" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-673" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Lists-676" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-678" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-683" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-690" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-699" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-705" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-707" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-713" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-718" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-720" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-723" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-728" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-730" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-733" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-735" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-738" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-740" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-743" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-745" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-748" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-750" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-755" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-762" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-782" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-791" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-798" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-800" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-811" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-813" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-824" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-826" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-833" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-835" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-846" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-848" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-859" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-861" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-866" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-873" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-890" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-896" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-897" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-899" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-901" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-904" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-906" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-909" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-911" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-913" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-915" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-920" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-927" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-940" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-947" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-950" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-952" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1369" class="Function">∃</a><a id="plfa_plfa-part1-Lists-953" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-955" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1806" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-963" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-965" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-974" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-975" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-979" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-987" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-989" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-994" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1001" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-1010" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1016" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1017" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-1020" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1022" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1027" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1034" href="https://agda.github.io/agda-stdlib/v1.7.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-1040" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1046" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#597" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-1052" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-1054" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-1059" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-1066" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-1089" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-1095" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1096" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-1099" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-1101" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-1104" class="Symbol">)</a>
</pre><h2 id="列表">列表</h2>Agda 中的列表如下定义：<pre class="Agda"><a id="plfa_plfa-part1-Lists-1209" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1214" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1220" href="../Lists/#plfa_plfa-part1-Lists-1220" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1222" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1224" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1227" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1229" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1231" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1235" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1243" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1247" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1249" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1254" href="../Lists/#plfa_plfa-part1-Lists-1220" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1258" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1262" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1264" href="../Lists/#plfa_plfa-part1-Lists-1220" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1266" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1268" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1273" href="../Lists/#plfa_plfa-part1-Lists-1220" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1275" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1277" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1282" href="../Lists/#plfa_plfa-part1-Lists-1220" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1285" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1292" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1294" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">_∷_</a>
</pre><p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-1963" href="../Lists/#plfa_plfa-part1-Lists-1963" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1965" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1967" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1972" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1974" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1976" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1978" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1980" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1982" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1984" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1986" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1988" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1990" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
</pre><p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p><p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-2737" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2742" href="../Lists/#plfa_plfa-part1-Lists-2742" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2748" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2750" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2754" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2760" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2768" href="../Lists/#plfa_plfa-part1-Lists-2768" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2773" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2775" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2777" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2778" href="../Lists/#plfa_plfa-part1-Lists-2778" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2780" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2785" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2787" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2789" href="../Lists/#plfa_plfa-part1-Lists-2742" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2795" href="../Lists/#plfa_plfa-part1-Lists-2778" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2799" href="../Lists/#plfa_plfa-part1-Lists-2799" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2804" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2806" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2808" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2809" href="../Lists/#plfa_plfa-part1-Lists-2809" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2811" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2813" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2816" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2818" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2820" href="../Lists/#plfa_plfa-part1-Lists-2809" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2822" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2824" href="../Lists/#plfa_plfa-part1-Lists-2742" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2830" href="../Lists/#plfa_plfa-part1-Lists-2809" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2832" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2834" href="../Lists/#plfa_plfa-part1-Lists-2742" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2840" href="../Lists/#plfa_plfa-part1-Lists-2809" class="Bound">A</a>
</pre><p>每个构造子将参数作为隐式参数。因此我们列表的例子也可以写作：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3005" href="../Lists/#plfa_plfa-part1-Lists-3005" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3007" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3009" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3014" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-3016" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-3018" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3020" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3024" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3025" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3026" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3028" class="Number">0</a> <a id="plfa_plfa-part1-Lists-3030" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3031" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3035" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3036" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3037" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3039" class="Number">1</a> <a id="plfa_plfa-part1-Lists-3041" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3042" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-3046" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3048" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3050" class="Number">2</a> <a id="plfa_plfa-part1-Lists-3052" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3053" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-3056" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3057" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-3058" class="Symbol">})))</a>
</pre><p>此处我们将隐式参数显式地声明。</p><p>包含下面的编译器指令</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p><h2 id="列表语法">列表语法</h2><p>我们可以用下面的定义，更简便地表示列表：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3682" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3690" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3694" href="../Lists/#plfa_plfa-part1-Lists-3698" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3696" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3698" href="../Lists/#plfa_plfa-part1-Lists-3698" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3700" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3702" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3705" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3713" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3719" href="../Lists/#plfa_plfa-part1-Lists-3725" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3721" href="../Lists/#plfa_plfa-part1-Lists-3729" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3723" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3725" href="../Lists/#plfa_plfa-part1-Lists-3725" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3727" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3729" href="../Lists/#plfa_plfa-part1-Lists-3729" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3731" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3733" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3736" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3744" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3752" href="../Lists/#plfa_plfa-part1-Lists-3760" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3754" href="../Lists/#plfa_plfa-part1-Lists-3764" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3756" href="../Lists/#plfa_plfa-part1-Lists-3768" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3758" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3760" href="../Lists/#plfa_plfa-part1-Lists-3760" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3762" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3764" href="../Lists/#plfa_plfa-part1-Lists-3764" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3766" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3768" href="../Lists/#plfa_plfa-part1-Lists-3768" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3770" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3772" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3775" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3783" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3793" href="../Lists/#plfa_plfa-part1-Lists-3803" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3795" href="../Lists/#plfa_plfa-part1-Lists-3807" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3797" href="../Lists/#plfa_plfa-part1-Lists-3811" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3799" href="../Lists/#plfa_plfa-part1-Lists-3815" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3801" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3803" href="../Lists/#plfa_plfa-part1-Lists-3803" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3805" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3807" href="../Lists/#plfa_plfa-part1-Lists-3807" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3809" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3811" href="../Lists/#plfa_plfa-part1-Lists-3811" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3813" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3815" href="../Lists/#plfa_plfa-part1-Lists-3815" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3817" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3819" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3822" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3830" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3842" href="../Lists/#plfa_plfa-part1-Lists-3854" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3844" href="../Lists/#plfa_plfa-part1-Lists-3858" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3846" href="../Lists/#plfa_plfa-part1-Lists-3862" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3848" href="../Lists/#plfa_plfa-part1-Lists-3866" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3850" href="../Lists/#plfa_plfa-part1-Lists-3870" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3852" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3854" href="../Lists/#plfa_plfa-part1-Lists-3854" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3856" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3858" href="../Lists/#plfa_plfa-part1-Lists-3858" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3860" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3862" href="../Lists/#plfa_plfa-part1-Lists-3862" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3864" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3866" href="../Lists/#plfa_plfa-part1-Lists-3866" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3868" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3870" href="../Lists/#plfa_plfa-part1-Lists-3870" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3872" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3874" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3877" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3885" href="../Lists/#plfa_plfa-part1-Lists-3885" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3899" href="../Lists/#plfa_plfa-part1-Lists-3913" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3901" href="../Lists/#plfa_plfa-part1-Lists-3917" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3903" href="../Lists/#plfa_plfa-part1-Lists-3921" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3905" href="../Lists/#plfa_plfa-part1-Lists-3925" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3907" href="../Lists/#plfa_plfa-part1-Lists-3929" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3909" href="../Lists/#plfa_plfa-part1-Lists-3933" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3911" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3913" href="../Lists/#plfa_plfa-part1-Lists-3913" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3915" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3917" href="../Lists/#plfa_plfa-part1-Lists-3917" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3919" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3921" href="../Lists/#plfa_plfa-part1-Lists-3921" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3923" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3925" href="../Lists/#plfa_plfa-part1-Lists-3925" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3927" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3929" href="../Lists/#plfa_plfa-part1-Lists-3929" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3931" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3933" href="../Lists/#plfa_plfa-part1-Lists-3933" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3935" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3937" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
</pre><p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p><h2 id="附加">附加</h2><p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-4490" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-4497" class="Number">5</a> <a id="plfa_plfa-part1-Lists-4499" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-4505" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-4510" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4512" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4514" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4515" href="../Lists/#plfa_plfa-part1-Lists-4515" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4517" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4519" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4522" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4524" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4526" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4531" href="../Lists/#plfa_plfa-part1-Lists-4515" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4533" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4535" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4540" href="../Lists/#plfa_plfa-part1-Lists-4515" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4542" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4544" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4549" href="../Lists/#plfa_plfa-part1-Lists-4515" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-4551" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-4560" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4563" href="../Lists/#plfa_plfa-part1-Lists-4563" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4567" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4570" href="../Lists/#plfa_plfa-part1-Lists-4563" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-4573" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4574" href="../Lists/#plfa_plfa-part1-Lists-4574" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4576" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4578" href="../Lists/#plfa_plfa-part1-Lists-4578" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4580" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4582" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4585" href="../Lists/#plfa_plfa-part1-Lists-4585" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-4589" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-4592" href="../Lists/#plfa_plfa-part1-Lists-4574" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4594" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4596" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4597" href="../Lists/#plfa_plfa-part1-Lists-4578" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4600" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4603" href="../Lists/#plfa_plfa-part1-Lists-4585" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4605" class="Symbol">)</a>
</pre><p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p><p>我们举个例子，来展示将两个列表附加的计算过程：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-5232" href="../Lists/#plfa_plfa-part1-Lists-5232" class="Function">_</a> <a id="plfa_plfa-part1-Lists-5234" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5236" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5238" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5240" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5242" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5244" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5246" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5248" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5250" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5253" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5255" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5257" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5259" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5261" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-5263" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5265" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-5267" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5269" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5271" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5273" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5275" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5277" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5279" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5281" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-5283" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5285" href="../Lists/#plfa_plfa-part1-Lists-3830" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-5287" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-5289" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5293" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5303" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5305" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5307" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5309" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5311" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5313" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5315" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5318" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5321" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5323" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5325" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5327" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5329" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5334" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5342" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5344" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5346" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5347" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5349" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5351" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5353" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5355" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5358" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5361" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5363" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5365" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5367" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5369" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5371" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5375" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5383" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5385" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5387" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5389" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5391" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5392" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5394" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5396" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5399" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5402" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5404" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5406" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5408" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5410" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5412" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5416" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5424" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5426" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5428" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5430" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5432" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5434" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5436" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5437" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5440" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5443" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5445" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5447" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5449" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5451" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-5453" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5457" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5465" class="Number">0</a> <a id="plfa_plfa-part1-Lists-5467" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5469" class="Number">1</a> <a id="plfa_plfa-part1-Lists-5471" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5473" class="Number">2</a> <a id="plfa_plfa-part1-Lists-5475" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5477" class="Number">3</a> <a id="plfa_plfa-part1-Lists-5479" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5481" class="Number">4</a> <a id="plfa_plfa-part1-Lists-5483" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5485" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5490" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>附加两个列表需要对于第一个列表元素个数线性的时间。</p><h2 id="论证附加">论证附加</h2>我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-5845" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5854" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5856" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5858" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5859" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5861" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5863" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5866" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5868" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5869" href="../Lists/#plfa_plfa-part1-Lists-5869" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5872" href="../Lists/#plfa_plfa-part1-Lists-5872" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5875" href="../Lists/#plfa_plfa-part1-Lists-5875" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5878" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5880" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5885" href="../Lists/#plfa_plfa-part1-Lists-5859" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5886" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5890" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5892" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5893" href="../Lists/#plfa_plfa-part1-Lists-5869" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5896" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5899" href="../Lists/#plfa_plfa-part1-Lists-5872" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5901" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5903" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5906" href="../Lists/#plfa_plfa-part1-Lists-5875" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5909" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5911" href="../Lists/#plfa_plfa-part1-Lists-5869" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5914" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5917" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5918" href="../Lists/#plfa_plfa-part1-Lists-5872" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5921" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5924" href="../Lists/#plfa_plfa-part1-Lists-5875" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5926" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-5928" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5937" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5940" href="../Lists/#plfa_plfa-part1-Lists-5940" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5943" href="../Lists/#plfa_plfa-part1-Lists-5943" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-5946" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5950" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5960" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5961" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5964" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5967" href="../Lists/#plfa_plfa-part1-Lists-5940" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5969" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5971" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5974" href="../Lists/#plfa_plfa-part1-Lists-5943" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5979" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5987" href="../Lists/#plfa_plfa-part1-Lists-5940" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5990" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5993" href="../Lists/#plfa_plfa-part1-Lists-5943" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-5998" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6006" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6009" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6012" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6013" href="../Lists/#plfa_plfa-part1-Lists-5940" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6016" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6019" href="../Lists/#plfa_plfa-part1-Lists-5943" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6021" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6025" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6027" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6037" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6039" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6041" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6043" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6045" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6048" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-6051" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6055" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6065" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6066" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6068" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6070" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6073" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6076" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6078" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6080" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6083" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6088" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6096" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6098" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6100" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6101" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6104" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6107" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6109" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6111" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6114" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-6119" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6127" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6129" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6131" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-6133" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6136" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6139" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-6141" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6143" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6146" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6148" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6152" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6155" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6160" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6161" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6163" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6165" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6167" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6168" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-6177" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6180" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6183" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6185" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6187" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6193" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6195" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6197" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6198" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6201" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6204" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6205" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6208" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6211" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6213" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6218" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6226" href="../Lists/#plfa_plfa-part1-Lists-6037" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6228" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6230" href="../Lists/#plfa_plfa-part1-Lists-6041" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6233" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6236" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6237" href="../Lists/#plfa_plfa-part1-Lists-6045" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-6240" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6243" href="../Lists/#plfa_plfa-part1-Lists-6048" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-6245" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6249" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p><p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>提升至等式：</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>即证明中所需。</p><p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-7349" href="../Lists/#plfa_plfa-part1-Lists-7349" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7362" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7364" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7366" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7367" href="../Lists/#plfa_plfa-part1-Lists-7367" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7369" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7371" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7374" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7376" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7377" href="../Lists/#plfa_plfa-part1-Lists-7377" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7380" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7382" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7387" href="../Lists/#plfa_plfa-part1-Lists-7367" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7388" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7390" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7392" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7395" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7398" href="../Lists/#plfa_plfa-part1-Lists-7377" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7401" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7403" href="../Lists/#plfa_plfa-part1-Lists-7377" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7406" href="../Lists/#plfa_plfa-part1-Lists-7349" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-7419" href="../Lists/#plfa_plfa-part1-Lists-7419" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7422" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7426" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7436" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7439" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7442" href="../Lists/#plfa_plfa-part1-Lists-7419" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7447" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7455" href="../Lists/#plfa_plfa-part1-Lists-7419" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7460" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>右幺元的证明可由简单的归纳得到：<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-7559" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7572" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7574" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7576" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7577" href="../Lists/#plfa_plfa-part1-Lists-7577" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7579" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7581" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7584" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7586" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7587" href="../Lists/#plfa_plfa-part1-Lists-7587" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7590" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7592" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7597" href="../Lists/#plfa_plfa-part1-Lists-7577" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7598" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7600" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7602" href="../Lists/#plfa_plfa-part1-Lists-7587" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7605" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7608" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7613" href="../Lists/#plfa_plfa-part1-Lists-7587" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-7616" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7629" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7632" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7636" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7646" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7649" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7652" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7657" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7665" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7670" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7672" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7685" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7686" href="../Lists/#plfa_plfa-part1-Lists-7686" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7688" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7690" href="../Lists/#plfa_plfa-part1-Lists-7690" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7692" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7694" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7698" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7708" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7709" href="../Lists/#plfa_plfa-part1-Lists-7686" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7711" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7713" href="../Lists/#plfa_plfa-part1-Lists-7690" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7715" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7717" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7720" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-7725" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7733" href="../Lists/#plfa_plfa-part1-Lists-7686" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7735" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7737" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7738" href="../Lists/#plfa_plfa-part1-Lists-7690" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7741" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7744" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7746" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7750" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7753" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7759" href="../Lists/#plfa_plfa-part1-Lists-7686" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7761" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-7763" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7765" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7766" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-7779" href="../Lists/#plfa_plfa-part1-Lists-7690" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7781" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7783" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7789" href="../Lists/#plfa_plfa-part1-Lists-7686" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7791" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7793" href="../Lists/#plfa_plfa-part1-Lists-7690" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-7798" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p><h2 id="长度">长度</h2><p>在下一个函数里，我们来寻找列表的长度：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-8090" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8097" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8099" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8101" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8102" href="../Lists/#plfa_plfa-part1-Lists-8102" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8104" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8106" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8109" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8111" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8113" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8118" href="../Lists/#plfa_plfa-part1-Lists-8102" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8120" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8122" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-8124" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8131" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8141" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8144" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-8149" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8156" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8157" href="../Lists/#plfa_plfa-part1-Lists-8157" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8159" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8161" href="../Lists/#plfa_plfa-part1-Lists-8161" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8163" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8166" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8169" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8173" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8174" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8181" href="../Lists/#plfa_plfa-part1-Lists-8161" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8183" class="Symbol">)</a>
</pre><p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>我们用下面的例子来展示如何计算列表的长度：<pre class="Agda"><a id="plfa_plfa-part1-Lists-8517" href="../Lists/#plfa_plfa-part1-Lists-8517" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8519" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8521" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8528" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8530" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8532" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8534" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8536" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8538" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8540" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8542" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8544" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-8546" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8548" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8552" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8562" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8569" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8570" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8572" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8574" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8576" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8578" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8580" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8582" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8584" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8588" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8601" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8608" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8609" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8611" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8613" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8615" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8617" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8619" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8624" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8632" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8636" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8641" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8642" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8649" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8650" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8652" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8654" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8656" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8662" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8670" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8674" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8675" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8679" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8684" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8685" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-8692" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8693" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-8694" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8696" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8698" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-8704" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8712" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8716" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8717" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8721" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8722" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-8726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-8730" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-8735" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>计算列表的长度需要关于列表元素个数线性的时间。</p><p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p><h2 id="论证长度">论证长度</h2><p>两个附加在一起的列表的长度是两列表长度之和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-9334" href="../Lists/#plfa_plfa-part1-Lists-9334" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9344" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9346" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-9348" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9349" href="../Lists/#plfa_plfa-part1-Lists-9349" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-9351" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9353" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-9356" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9358" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9359" href="../Lists/#plfa_plfa-part1-Lists-9359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9362" href="../Lists/#plfa_plfa-part1-Lists-9362" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9365" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-9367" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-9372" href="../Lists/#plfa_plfa-part1-Lists-9349" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9373" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9377" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-9379" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9386" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9387" href="../Lists/#plfa_plfa-part1-Lists-9359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9390" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9393" href="../Lists/#plfa_plfa-part1-Lists-9362" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9395" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9397" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-9399" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9406" href="../Lists/#plfa_plfa-part1-Lists-9359" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9409" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9411" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9418" href="../Lists/#plfa_plfa-part1-Lists-9362" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-9421" href="../Lists/#plfa_plfa-part1-Lists-9334" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9431" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9432" href="../Lists/#plfa_plfa-part1-Lists-9432" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9433" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9435" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9438" href="../Lists/#plfa_plfa-part1-Lists-9438" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9441" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9445" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9455" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9462" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9463" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9466" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9469" href="../Lists/#plfa_plfa-part1-Lists-9438" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9471" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9483" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9490" href="../Lists/#plfa_plfa-part1-Lists-9438" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9495" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9503" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9510" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-9511" href="../Lists/#plfa_plfa-part1-Lists-9432" class="Bound">A</a><a id="plfa_plfa-part1-Lists-9512" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-9514" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9517" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9519" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9526" href="../Lists/#plfa_plfa-part1-Lists-9438" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9531" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-9533" href="../Lists/#plfa_plfa-part1-Lists-9334" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9543" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9544" href="../Lists/#plfa_plfa-part1-Lists-9544" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9546" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9548" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9550" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9552" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-9555" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-9559" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-9569" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9576" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9578" href="../Lists/#plfa_plfa-part1-Lists-9544" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9580" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9582" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9584" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9586" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9589" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9591" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9595" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9603" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9607" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9608" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9615" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9616" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9619" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9622" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9624" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-9629" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-9632" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-9637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9641" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9642" href="../Lists/#plfa_plfa-part1-Lists-9334" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-9652" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9655" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9657" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9659" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-9665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-9669" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9670" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9677" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-9680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9682" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9689" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-9691" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9695" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9703" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9710" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9711" href="../Lists/#plfa_plfa-part1-Lists-9544" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-9713" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9715" href="../Lists/#plfa_plfa-part1-Lists-9548" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-9717" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9719" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-9721" href="../Lists/#plfa_plfa-part1-Lists-8090" class="Function">length</a> <a id="plfa_plfa-part1-Lists-9728" href="../Lists/#plfa_plfa-part1-Lists-9552" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-9733" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p><h2 id="反转">反转</h2>我们可以使用附加，来简单地构造一个函数来反转一个列表：<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-10616" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10624" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10626" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10628" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10629" href="../Lists/#plfa_plfa-part1-Lists-10629" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10631" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10633" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10636" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10638" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10640" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10645" href="../Lists/#plfa_plfa-part1-Lists-10629" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10647" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10649" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10654" href="../Lists/#plfa_plfa-part1-Lists-10629" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10656" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10664" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-10674" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10677" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-10680" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10689" href="../Lists/#plfa_plfa-part1-Lists-10689" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10691" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10693" href="../Lists/#plfa_plfa-part1-Lists-10693" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10695" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-10698" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10701" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10709" href="../Lists/#plfa_plfa-part1-Lists-10693" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10712" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10715" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10717" href="../Lists/#plfa_plfa-part1-Lists-10689" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10719" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a>
</pre><p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>下面的例子展示了如何反转一个列表。<pre class="Agda"><a id="plfa_plfa-part1-Lists-11023" href="../Lists/#plfa_plfa-part1-Lists-11023" class="Function">_</a> <a id="plfa_plfa-part1-Lists-11025" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11027" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11035" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11037" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11039" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11041" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11043" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11045" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11047" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11049" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-11051" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11053" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11055" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11057" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11059" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11061" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11063" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-11065" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-11067" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11071" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11081" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11090" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11092" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11094" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11096" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11098" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11100" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11102" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11104" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11108" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11116" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11124" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11125" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11127" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11129" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11131" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11133" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11135" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11137" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11140" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11142" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11144" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11148" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11156" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11157" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11166" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11168" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11170" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11172" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11174" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11177" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11179" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11181" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11182" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11184" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11187" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11189" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11191" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11195" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11203" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11205" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11213" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11216" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11219" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11221" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11223" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11224" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11226" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11229" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11231" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11233" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11234" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11236" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11239" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11241" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11243" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11247" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11255" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11257" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11260" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11263" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11265" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11267" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11268" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11270" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11273" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11275" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11277" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11278" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11280" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11283" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11285" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11287" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11291" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11299" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-11301" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11304" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11307" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11309" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11311" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11313" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11315" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11318" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11320" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11322" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11324" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11326" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11329" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11331" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11333" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11338" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11346" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11347" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11349" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11351" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11354" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11357" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11359" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11361" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11363" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11365" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11368" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11370" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11372" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11377" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11385" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11387" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11389" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11390" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11393" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11396" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11398" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11400" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11402" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11404" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11407" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11409" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11411" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11416" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11424" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11425" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11427" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11429" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11431" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11433" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11435" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11437" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11440" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11442" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11444" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11449" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11457" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11459" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11461" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11462" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11464" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11466" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11469" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11472" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11474" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11476" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11478" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11482" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11490" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11492" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11494" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11496" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11498" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11499" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11502" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11505" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11507" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11509" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-11511" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11515" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11523" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11525" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11527" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11529" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11531" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11533" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11535" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-11540" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11548" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11550" class="Number">2</a> <a id="plfa_plfa-part1-Lists-11552" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11554" class="Number">1</a> <a id="plfa_plfa-part1-Lists-11556" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-11558" class="Number">0</a> <a id="plfa_plfa-part1-Lists-11560" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-11564" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p><h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4><p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4><p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><h2 id="更快地反转">更快地反转</h2><p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-13129" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13135" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13137" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13139" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13140" href="../Lists/#plfa_plfa-part1-Lists-13140" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13142" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13144" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13147" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13149" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13151" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13156" href="../Lists/#plfa_plfa-part1-Lists-13140" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13158" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13160" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13165" href="../Lists/#plfa_plfa-part1-Lists-13140" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13167" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13169" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13174" href="../Lists/#plfa_plfa-part1-Lists-13140" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-13176" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13182" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-13191" href="../Lists/#plfa_plfa-part1-Lists-13191" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13195" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13198" href="../Lists/#plfa_plfa-part1-Lists-13191" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13201" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13207" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13208" href="../Lists/#plfa_plfa-part1-Lists-13208" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13210" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13212" href="../Lists/#plfa_plfa-part1-Lists-13212" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13214" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13216" href="../Lists/#plfa_plfa-part1-Lists-13216" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-13220" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13223" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13229" href="../Lists/#plfa_plfa-part1-Lists-13212" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13232" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13233" href="../Lists/#plfa_plfa-part1-Lists-13208" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13235" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13237" href="../Lists/#plfa_plfa-part1-Lists-13216" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13239" class="Symbol">)</a>
</pre><p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>转移（Shunt）与反转的关系如下：<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-13574" href="../Lists/#plfa_plfa-part1-Lists-13574" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13588" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13590" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13592" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13593" href="../Lists/#plfa_plfa-part1-Lists-13593" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13595" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13597" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13600" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13602" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13603" href="../Lists/#plfa_plfa-part1-Lists-13603" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13606" href="../Lists/#plfa_plfa-part1-Lists-13606" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13609" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13611" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13616" href="../Lists/#plfa_plfa-part1-Lists-13593" class="Bound">A</a><a id="plfa_plfa-part1-Lists-13617" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13621" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13623" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13629" href="../Lists/#plfa_plfa-part1-Lists-13603" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13632" href="../Lists/#plfa_plfa-part1-Lists-13606" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13635" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13637" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13645" href="../Lists/#plfa_plfa-part1-Lists-13603" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13648" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13651" href="../Lists/#plfa_plfa-part1-Lists-13606" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-13654" href="../Lists/#plfa_plfa-part1-Lists-13574" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13668" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13671" href="../Lists/#plfa_plfa-part1-Lists-13671" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13674" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13678" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13688" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13694" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13697" href="../Lists/#plfa_plfa-part1-Lists-13671" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13702" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13710" href="../Lists/#plfa_plfa-part1-Lists-13671" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13715" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13723" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13731" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-13734" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13737" href="../Lists/#plfa_plfa-part1-Lists-13671" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13742" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-13744" href="../Lists/#plfa_plfa-part1-Lists-13574" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13759" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13761" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13763" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13765" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13767" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-13770" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13774" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13784" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13791" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13793" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13795" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13797" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13799" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-13804" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13812" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-13818" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13821" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13822" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13824" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13826" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13828" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13832" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13835" href="../Lists/#plfa_plfa-part1-Lists-13574" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-13849" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13852" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13853" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13855" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13857" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13859" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13861" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13867" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13875" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13878" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13881" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13882" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13884" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13886" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13888" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13892" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13900" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13908" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13911" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13914" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13915" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13917" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13919" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13921" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13924" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13926" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13930" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-13933" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-13937" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13938" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-13947" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13948" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13956" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13958" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13960" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13962" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13964" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13966" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-13968" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13970" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-13976" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13977" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-13985" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-13988" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-13991" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13993" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13995" href="../Lists/#plfa_plfa-part1-Lists-3690" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-13996" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13998" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14001" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14006" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14014" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-14022" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14023" href="../Lists/#plfa_plfa-part1-Lists-13759" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-14025" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-14027" href="../Lists/#plfa_plfa-part1-Lists-13763" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-14029" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14031" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-14034" href="../Lists/#plfa_plfa-part1-Lists-13767" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-14039" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p><p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p><p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-15060" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15069" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15071" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15073" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15074" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15076" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15078" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15081" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15083" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15085" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15090" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15092" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15094" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15099" href="../Lists/#plfa_plfa-part1-Lists-15074" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-15101" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15110" href="../Lists/#plfa_plfa-part1-Lists-15110" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15113" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-15115" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15121" href="../Lists/#plfa_plfa-part1-Lists-15110" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15124" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
</pre><p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-15270" href="../Lists/#plfa_plfa-part1-Lists-15270" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15279" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15281" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15283" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15284" href="../Lists/#plfa_plfa-part1-Lists-15284" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15286" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15288" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15291" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15293" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15294" href="../Lists/#plfa_plfa-part1-Lists-15294" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15297" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15299" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15304" href="../Lists/#plfa_plfa-part1-Lists-15284" class="Bound">A</a><a id="plfa_plfa-part1-Lists-15305" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15309" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15311" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15320" href="../Lists/#plfa_plfa-part1-Lists-15294" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15323" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15325" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15333" href="../Lists/#plfa_plfa-part1-Lists-15294" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-15336" href="../Lists/#plfa_plfa-part1-Lists-15270" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-15345" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15348" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15352" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15362" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15371" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15376" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15384" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15390" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15393" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15398" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15401" href="../Lists/#plfa_plfa-part1-Lists-13574" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-15415" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15418" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15421" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15427" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15435" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-15438" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-15441" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15446" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-15449" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-15462" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15463" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15471" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15473" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-15481" href="../Lists/#plfa_plfa-part1-Lists-10616" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-15489" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-15494" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-15623" href="../Lists/#plfa_plfa-part1-Lists-15623" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15625" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15627" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15636" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15638" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15640" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15642" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15644" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15646" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15648" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15650" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15652" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15654" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15656" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15658" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15660" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15662" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15664" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-15666" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15668" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15672" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15682" href="../Lists/#plfa_plfa-part1-Lists-15060" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-15691" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15692" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15694" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15696" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15698" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15700" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15702" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15704" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15706" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15710" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15718" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15725" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15727" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15729" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15731" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15733" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15735" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15737" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15739" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15741" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15746" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15754" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15760" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15761" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15763" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15765" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15767" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15769" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15771" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15773" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15774" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15776" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15778" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15780" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15784" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15792" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15798" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15799" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15801" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15803" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15805" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15807" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15808" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15810" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15812" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15814" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15816" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15818" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15822" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15830" href="../Lists/#plfa_plfa-part1-Lists-13129" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-15836" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-15839" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15840" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15842" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15844" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15846" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15848" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15850" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15852" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15854" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15858" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15866" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15868" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15870" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15872" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15874" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15876" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15878" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-15883" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>现在反转一个列表需要的时间与列表的长度线性相关。</p><h2 id="Map">映射</h2><p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-16353" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16357" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16359" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-16361" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-16362" href="../Lists/#plfa_plfa-part1-Lists-16362" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16364" href="../Lists/#plfa_plfa-part1-Lists-16364" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-16366" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16368" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-16371" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-16373" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16375" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16376" href="../Lists/#plfa_plfa-part1-Lists-16362" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16378" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16380" href="../Lists/#plfa_plfa-part1-Lists-16364" class="Bound">B</a><a id="plfa_plfa-part1-Lists-16381" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-16383" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16385" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16390" href="../Lists/#plfa_plfa-part1-Lists-16362" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-16392" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16394" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16399" href="../Lists/#plfa_plfa-part1-Lists-16364" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-16401" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16405" href="../Lists/#plfa_plfa-part1-Lists-16405" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16407" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-16417" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16420" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-16423" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16427" href="../Lists/#plfa_plfa-part1-Lists-16427" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16429" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16430" href="../Lists/#plfa_plfa-part1-Lists-16430" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16432" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16434" href="../Lists/#plfa_plfa-part1-Lists-16434" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-16436" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-16439" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-16442" href="../Lists/#plfa_plfa-part1-Lists-16427" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16444" href="../Lists/#plfa_plfa-part1-Lists-16430" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-16446" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16448" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16452" href="../Lists/#plfa_plfa-part1-Lists-16427" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-16454" href="../Lists/#plfa_plfa-part1-Lists-16434" class="Bound">xs</a>
</pre><p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p><p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-16903" href="../Lists/#plfa_plfa-part1-Lists-16903" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16905" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16907" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16911" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-16915" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16917" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16919" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16921" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16923" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16925" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16927" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16929" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16931" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16933" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16935" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16937" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16939" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16941" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16943" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-16945" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16947" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16951" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16961" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-16965" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-16969" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16970" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16972" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16974" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16976" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16978" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16980" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16982" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16984" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16988" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16996" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17000" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17002" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17004" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17008" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17012" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17013" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17015" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17017" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17019" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17021" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17023" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17027" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17035" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17039" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17041" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17043" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17047" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17049" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17051" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17055" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17059" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17060" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17062" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17064" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-17066" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-17070" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17078" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17082" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17084" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17086" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17090" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17092" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17094" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17098" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17100" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17102" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17106" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17110" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17115" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17123" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17127" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17129" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17131" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17135" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17137" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17139" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17143" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17145" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17147" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17152" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17160" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17162" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17164" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17166" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17168" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17170" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-17172" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-17177" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>映射需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-17483" href="../Lists/#plfa_plfa-part1-Lists-17483" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17488" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17490" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17495" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-17497" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17499" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17504" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-17506" href="../Lists/#plfa_plfa-part1-Lists-17483" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17511" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-17513" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17517" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-17522" href="../Lists/#plfa_plfa-part1-Lists-17522" class="Function">_</a> <a id="plfa_plfa-part1-Lists-17524" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17526" href="../Lists/#plfa_plfa-part1-Lists-17483" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17531" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17533" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17535" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17537" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17539" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17541" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17543" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-17545" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17547" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17549" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17551" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17553" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17555" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17557" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17559" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-17561" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-17563" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-17567" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-17577" href="../Lists/#plfa_plfa-part1-Lists-17483" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-17582" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17584" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17586" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17588" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17590" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17592" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17594" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17598" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17606" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-17610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-17614" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17616" class="Number">0</a> <a id="plfa_plfa-part1-Lists-17618" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17620" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17622" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17624" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17626" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17630" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-17638" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-17640" class="Number">1</a> <a id="plfa_plfa-part1-Lists-17642" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17644" class="Number">2</a> <a id="plfa_plfa-part1-Lists-17646" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-17648" class="Number">3</a> <a id="plfa_plfa-part1-Lists-17650" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-17654" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p><h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4><p>证明函数组合的映射是两个映射的组合：</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>证明的最后一步需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18457" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4><p>证明下列关于映射与附加的关系：</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18700" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4><p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18921" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-18926" href="../Lists/#plfa_plfa-part1-Lists-18926" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18931" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18932" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18934" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-18936" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18938" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-18941" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18943" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18945" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-18949" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-18957" href="../Lists/#plfa_plfa-part1-Lists-18957" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-18962" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18964" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18966" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18968" href="../Lists/#plfa_plfa-part1-Lists-18926" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18973" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18975" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-18979" href="../Lists/#plfa_plfa-part1-Lists-18979" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-18984" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18986" href="../Lists/#plfa_plfa-part1-Lists-18926" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-18991" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18993" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-18995" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18997" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-18999" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19001" href="../Lists/#plfa_plfa-part1-Lists-18926" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19006" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19008" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19010" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19012" href="../Lists/#plfa_plfa-part1-Lists-18926" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-19017" href="../Lists/#plfa_plfa-part1-Lists-18932" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19019" href="../Lists/#plfa_plfa-part1-Lists-18934" class="Bound">B</a>
</pre><p>定义一个对于树的映射运算符：</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-19179" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="Fold">折叠</h2><p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-19470" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19476" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19478" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19480" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19481" href="../Lists/#plfa_plfa-part1-Lists-19481" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19483" href="../Lists/#plfa_plfa-part1-Lists-19483" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19485" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19487" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19490" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19492" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19494" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19495" href="../Lists/#plfa_plfa-part1-Lists-19481" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19497" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19499" href="../Lists/#plfa_plfa-part1-Lists-19483" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19501" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19503" href="../Lists/#plfa_plfa-part1-Lists-19483" class="Bound">B</a><a id="plfa_plfa-part1-Lists-19504" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19506" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19508" href="../Lists/#plfa_plfa-part1-Lists-19483" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-19510" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19512" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19517" href="../Lists/#plfa_plfa-part1-Lists-19481" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19519" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19521" href="../Lists/#plfa_plfa-part1-Lists-19483" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-19523" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19529" href="../Lists/#plfa_plfa-part1-Lists-19529" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19533" href="../Lists/#plfa_plfa-part1-Lists-19533" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19535" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-19545" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19548" href="../Lists/#plfa_plfa-part1-Lists-19533" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-19550" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19556" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19560" href="../Lists/#plfa_plfa-part1-Lists-19560" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19563" href="../Lists/#plfa_plfa-part1-Lists-19563" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19565" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19567" href="../Lists/#plfa_plfa-part1-Lists-19567" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19569" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-19572" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-19575" href="../Lists/#plfa_plfa-part1-Lists-19563" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19577" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19579" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19585" href="../Lists/#plfa_plfa-part1-Lists-19556" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19589" href="../Lists/#plfa_plfa-part1-Lists-19560" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19591" href="../Lists/#plfa_plfa-part1-Lists-19567" class="Bound">xs</a>
</pre><p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p><p>下面的例子展示了如何使用折叠来对一个列表求和：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-19925" href="../Lists/#plfa_plfa-part1-Lists-19925" class="Function">_</a> <a id="plfa_plfa-part1-Lists-19927" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19929" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19935" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19939" class="Number">0</a> <a id="plfa_plfa-part1-Lists-19941" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-19943" class="Number">1</a> <a id="plfa_plfa-part1-Lists-19945" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19947" class="Number">2</a> <a id="plfa_plfa-part1-Lists-19949" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19951" class="Number">3</a> <a id="plfa_plfa-part1-Lists-19953" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-19955" class="Number">4</a> <a id="plfa_plfa-part1-Lists-19957" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-19959" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19961" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-19964" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-19966" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19970" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-19980" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19986" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19990" class="Number">0</a> <a id="plfa_plfa-part1-Lists-19992" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19993" class="Number">1</a> <a id="plfa_plfa-part1-Lists-19995" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19997" class="Number">2</a> <a id="plfa_plfa-part1-Lists-19999" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20001" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20003" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20005" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20007" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20009" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20011" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20015" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20023" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20025" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20027" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20033" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20037" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20040" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20042" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20044" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20046" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20048" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20050" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20052" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20054" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20058" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20066" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20068" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20070" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20071" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20073" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20075" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20081" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20085" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20087" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20088" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20090" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20092" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20094" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20096" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20098" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-20103" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20111" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20115" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20116" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20118" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20120" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20121" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20123" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20125" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20131" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20135" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20137" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20138" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20140" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20142" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20144" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20150" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20158" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20160" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20162" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20163" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20165" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20167" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20168" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20170" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20172" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20173" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20175" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20177" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20187" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20189" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-20191" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20197" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20205" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20207" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20209" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20210" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20212" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20214" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20215" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20220" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20222" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-20224" class="Number">0</a><a id="plfa_plfa-part1-Lists-20225" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-20231" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>折叠需要关于列表长度线性的时间。</p><p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-20626" href="../Lists/#plfa_plfa-part1-Lists-20626" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20630" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20632" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-20639" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20641" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-20643" href="../Lists/#plfa_plfa-part1-Lists-20626" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20647" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-20649" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20655" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20659" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-20662" href="../Lists/#plfa_plfa-part1-Lists-20662" class="Function">_</a> <a id="plfa_plfa-part1-Lists-20664" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20666" href="../Lists/#plfa_plfa-part1-Lists-20626" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20670" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20672" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20674" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20676" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20678" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20680" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20682" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20684" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20686" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-20688" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20690" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-20693" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-20695" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20699" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20709" href="../Lists/#plfa_plfa-part1-Lists-20626" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-20713" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20715" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20717" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20719" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20721" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20723" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20725" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20727" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20729" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20733" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20741" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20747" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-20751" class="Number">0</a> <a id="plfa_plfa-part1-Lists-20753" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-20755" class="Number">1</a> <a id="plfa_plfa-part1-Lists-20757" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20759" class="Number">2</a> <a id="plfa_plfa-part1-Lists-20761" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20763" class="Number">3</a> <a id="plfa_plfa-part1-Lists-20765" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-20767" class="Number">4</a> <a id="plfa_plfa-part1-Lists-20769" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-20773" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20781" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-20786" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p><p>举另外一个例子，观察</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>二者相等的证明留作练习。</p><h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4><p>使用折叠来定义一个计算列表数字之积的函数。例如：</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21826" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4><p>证明折叠和附加有如下的关系：</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22062" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4><p>证明映射可以用折叠定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22364" class="Comment">-- 请将代码写在此处。</a>
</pre><p>此证明需要外延性。</p><h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4><p>请证明 map 可使用 fold 来定义：</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>此证明需要外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-22691" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4><p>请为预先给定的三个类型定义一个合适的折叠函数：</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-22972" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4><p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23196" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4><p>定义一个向下数数的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-23371" href="../Lists/#plfa_plfa-part1-Lists-23371" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23380" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23382" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-23384" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23386" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23391" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-23393" href="../Lists/#plfa_plfa-part1-Lists-23371" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23402" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-23411" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23414" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-23417" href="../Lists/#plfa_plfa-part1-Lists-23371" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23426" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23427" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-23431" href="../Lists/#plfa_plfa-part1-Lists-23431" class="Bound">n</a><a id="plfa_plfa-part1-Lists-23432" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-23435" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-23438" href="../Lists/#plfa_plfa-part1-Lists-23431" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-23440" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23442" href="../Lists/#plfa_plfa-part1-Lists-23371" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23451" href="../Lists/#plfa_plfa-part1-Lists-23431" class="Bound">n</a>
</pre><p>例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-23494" href="../Lists/#plfa_plfa-part1-Lists-23494" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23496" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23498" href="../Lists/#plfa_plfa-part1-Lists-23371" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-23507" class="Number">3</a> <a id="plfa_plfa-part1-Lists-23509" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-23511" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23513" class="Number">2</a> <a id="plfa_plfa-part1-Lists-23515" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23517" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23519" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23521" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23523" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-23525" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-23527" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><h2 id="幺半群">幺半群</h2><p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p><p>我们可以用一个合适的记录类型来定义幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-24095" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-24102" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24111" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24112" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24114" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24116" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24119" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24121" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24122" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-24126" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24128" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24130" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24132" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24134" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24136" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24137" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24139" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24140" href="../Lists/#plfa_plfa-part1-Lists-24140" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24142" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24144" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24145" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24147" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24149" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-24153" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-24161" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-24171" href="../Lists/#plfa_plfa-part1-Lists-24171" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24177" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24179" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24181" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24182" href="../Lists/#plfa_plfa-part1-Lists-24182" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24184" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24186" href="../Lists/#plfa_plfa-part1-Lists-24186" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24188" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24190" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24191" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24193" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24195" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24196" href="../Lists/#plfa_plfa-part1-Lists-24182" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24198" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24200" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Bound">y</a><a id="plfa_plfa-part1-Lists-24201" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24203" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24205" href="../Lists/#plfa_plfa-part1-Lists-24186" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-24207" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24209" href="../Lists/#plfa_plfa-part1-Lists-24182" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24211" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24213" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24214" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-24216" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24218" href="../Lists/#plfa_plfa-part1-Lists-24186" class="Bound">z</a><a id="plfa_plfa-part1-Lists-24219" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-24225" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24235" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24237" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24240" href="../Lists/#plfa_plfa-part1-Lists-24240" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24242" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24244" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24245" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24247" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24249" href="../Lists/#plfa_plfa-part1-Lists-24140" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24251" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24253" href="../Lists/#plfa_plfa-part1-Lists-24240" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24255" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24257" href="../Lists/#plfa_plfa-part1-Lists-24240" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-24263" href="../Lists/#plfa_plfa-part1-Lists-24263" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24275" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24277" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24278" href="../Lists/#plfa_plfa-part1-Lists-24278" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24280" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24282" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24283" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24285" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24287" href="../Lists/#plfa_plfa-part1-Lists-24278" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24289" href="../Lists/#plfa_plfa-part1-Lists-24122" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-24291" href="../Lists/#plfa_plfa-part1-Lists-24140" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-24293" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-24295" href="../Lists/#plfa_plfa-part1-Lists-24278" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-24298" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-24303" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Module">IsMonoid</a>
</pre><p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-24476" href="../Lists/#plfa_plfa-part1-Lists-24476" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24485" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24487" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24496" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-24500" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-24502" href="../Lists/#plfa_plfa-part1-Lists-24476" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-24511" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24515" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24526" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24528" href="../Lists/#plfa_plfa-part1-Lists-24171" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24534" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24536" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-24548" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24550" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24560" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24562" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24578" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24580" href="../Lists/#plfa_plfa-part1-Lists-24263" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24590" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24592" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24608" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-24611" href="../Lists/#plfa_plfa-part1-Lists-24611" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24620" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24622" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-24635" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-24637" href="../Lists/#plfa_plfa-part1-Lists-24611" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-24646" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24650" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24661" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24663" href="../Lists/#plfa_plfa-part1-Lists-24171" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24669" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24671" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-24683" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24685" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24695" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24697" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24713" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24715" href="../Lists/#plfa_plfa-part1-Lists-24263" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24725" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24727" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24743" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-24746" href="../Lists/#plfa_plfa-part1-Lists-24746" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24756" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24758" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24760" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24761" href="../Lists/#plfa_plfa-part1-Lists-24761" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24763" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24765" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24768" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24770" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24772" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-24781" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24782" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24787" href="../Lists/#plfa_plfa-part1-Lists-24761" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24788" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24790" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-24795" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-24798" href="../Lists/#plfa_plfa-part1-Lists-24746" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-24808" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24812" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24823" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24825" href="../Lists/#plfa_plfa-part1-Lists-24171" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-24831" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24833" href="../Lists/#plfa_plfa-part1-Lists-5845" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-24846" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24848" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-24858" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24860" href="../Lists/#plfa_plfa-part1-Lists-7349" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-24877" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24879" href="../Lists/#plfa_plfa-part1-Lists-24263" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-24889" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24891" href="../Lists/#plfa_plfa-part1-Lists-7559" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-24908" class="Symbol">}</a>
</pre><p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-25089" href="../Lists/#plfa_plfa-part1-Lists-25089" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25102" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25104" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25106" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25107" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25109" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25111" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25114" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25116" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25117" href="../Lists/#plfa_plfa-part1-Lists-25117" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25121" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25123" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25125" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25127" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25129" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25131" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25132" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25134" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25135" href="../Lists/#plfa_plfa-part1-Lists-25135" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25137" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25139" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25140" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25142" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25144" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-25153" href="../Lists/#plfa_plfa-part1-Lists-25117" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25157" href="../Lists/#plfa_plfa-part1-Lists-25135" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25159" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25163" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25166" href="../Lists/#plfa_plfa-part1-Lists-25166" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25169" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25171" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25176" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25177" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25179" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25180" href="../Lists/#plfa_plfa-part1-Lists-25180" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25182" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25184" href="../Lists/#plfa_plfa-part1-Lists-25107" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25185" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25187" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25189" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25195" href="../Lists/#plfa_plfa-part1-Lists-25117" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25199" href="../Lists/#plfa_plfa-part1-Lists-25180" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25201" href="../Lists/#plfa_plfa-part1-Lists-25166" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25204" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25206" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25212" href="../Lists/#plfa_plfa-part1-Lists-25117" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25216" href="../Lists/#plfa_plfa-part1-Lists-25135" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25218" href="../Lists/#plfa_plfa-part1-Lists-25166" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25221" href="../Lists/#plfa_plfa-part1-Lists-25117" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25223" href="../Lists/#plfa_plfa-part1-Lists-25180" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-25225" href="../Lists/#plfa_plfa-part1-Lists-25089" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25238" href="../Lists/#plfa_plfa-part1-Lists-25238" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25242" href="../Lists/#plfa_plfa-part1-Lists-25242" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25244" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25253" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25256" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25258" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25262" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25272" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25278" href="../Lists/#plfa_plfa-part1-Lists-25238" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25282" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25284" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-25289" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25297" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25301" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25304" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25308" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25309" href="../Lists/#plfa_plfa-part1-Lists-24225" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-25319" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25328" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25329" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25331" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25337" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25338" href="../Lists/#plfa_plfa-part1-Lists-25242" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25340" href="../Lists/#plfa_plfa-part1-Lists-25238" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25342" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25343" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25347" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25355" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25361" href="../Lists/#plfa_plfa-part1-Lists-25238" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25365" href="../Lists/#plfa_plfa-part1-Lists-25242" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25367" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25370" href="../Lists/#plfa_plfa-part1-Lists-25238" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25372" href="../Lists/#plfa_plfa-part1-Lists-25256" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25376" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-25378" href="../Lists/#plfa_plfa-part1-Lists-25089" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25391" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25395" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25397" href="../Lists/#plfa_plfa-part1-Lists-25397" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25407" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25409" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25411" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25413" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25415" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25417" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25421" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-25431" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25437" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25441" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25444" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25446" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25448" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25450" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25454" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25462" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25464" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25466" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25467" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25473" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25477" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-25479" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25481" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25485" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25488" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-25493" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25494" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25496" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-25498" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25500" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25501" href="../Lists/#plfa_plfa-part1-Lists-25089" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-25514" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25518" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25520" href="../Lists/#plfa_plfa-part1-Lists-25397" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25529" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25532" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25533" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25535" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25541" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25543" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25545" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25546" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25552" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25556" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25558" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25561" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25563" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25564" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25568" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-25571" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-25575" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25576" href="../Lists/#plfa_plfa-part1-Lists-24171" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-25582" href="../Lists/#plfa_plfa-part1-Lists-25397" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-25591" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25593" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25594" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25600" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25604" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25606" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25608" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25610" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a><a id="plfa_plfa-part1-Lists-25611" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25613" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-25619" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25620" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25622" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25624" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25630" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25634" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25636" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25638" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25640" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25642" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25646" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-25654" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25660" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25664" href="../Lists/#plfa_plfa-part1-Lists-25395" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25666" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25667" href="../Lists/#plfa_plfa-part1-Lists-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25669" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25671" href="../Lists/#plfa_plfa-part1-Lists-25411" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25673" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25675" href="../Lists/#plfa_plfa-part1-Lists-25391" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-25677" href="../Lists/#plfa_plfa-part1-Lists-25415" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-25681" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在之前的练习中，我们证明了以下定理：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25774" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-25786" href="../Lists/#plfa_plfa-part1-Lists-25786" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-25795" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25797" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25799" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25800" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25802" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25804" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25807" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25809" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25810" href="../Lists/#plfa_plfa-part1-Lists-25810" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25814" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25816" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25818" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25820" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25822" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25824" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25825" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25827" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25828" href="../Lists/#plfa_plfa-part1-Lists-25828" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25830" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25832" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25833" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25835" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25836" href="../Lists/#plfa_plfa-part1-Lists-25836" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25839" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25842" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25844" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25849" href="../Lists/#plfa_plfa-part1-Lists-25800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25850" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25852" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25858" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25864" href="../Lists/#plfa_plfa-part1-Lists-25810" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25868" href="../Lists/#plfa_plfa-part1-Lists-25828" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25870" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25871" href="../Lists/#plfa_plfa-part1-Lists-25836" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25874" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25877" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25879" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25881" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-25883" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25889" href="../Lists/#plfa_plfa-part1-Lists-25810" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25893" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25894" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-25900" href="../Lists/#plfa_plfa-part1-Lists-25810" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-25904" href="../Lists/#plfa_plfa-part1-Lists-25828" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-25906" href="../Lists/#plfa_plfa-part1-Lists-25839" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25908" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25910" href="../Lists/#plfa_plfa-part1-Lists-25836" class="Bound">xs</a>
</pre><p>由此，我们可以将幺半群中附加的折叠如下分解成两个折叠：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-26055" href="../Lists/#plfa_plfa-part1-Lists-26055" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26071" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26073" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26075" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26076" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26078" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26080" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26083" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26085" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26086" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26090" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26092" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26094" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26096" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26098" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26100" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26101" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26103" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26104" href="../Lists/#plfa_plfa-part1-Lists-26104" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26106" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26108" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26109" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26111" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26113" href="../Lists/#plfa_plfa-part1-Lists-24102" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-26122" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26126" href="../Lists/#plfa_plfa-part1-Lists-26104" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26128" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-26132" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26134" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26135" href="../Lists/#plfa_plfa-part1-Lists-26135" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26138" href="../Lists/#plfa_plfa-part1-Lists-26138" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26141" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26143" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26148" href="../Lists/#plfa_plfa-part1-Lists-26076" class="Bound">A</a><a id="plfa_plfa-part1-Lists-26149" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26151" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26153" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26159" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26163" href="../Lists/#plfa_plfa-part1-Lists-26104" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26166" href="../Lists/#plfa_plfa-part1-Lists-26135" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26169" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26172" href="../Lists/#plfa_plfa-part1-Lists-26138" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26174" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26176" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-26178" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26184" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26188" href="../Lists/#plfa_plfa-part1-Lists-26104" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26190" href="../Lists/#plfa_plfa-part1-Lists-26135" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26193" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26195" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26201" href="../Lists/#plfa_plfa-part1-Lists-26086" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26205" href="../Lists/#plfa_plfa-part1-Lists-26104" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26207" href="../Lists/#plfa_plfa-part1-Lists-26138" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-26210" href="../Lists/#plfa_plfa-part1-Lists-26055" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-26226" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26230" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26232" href="../Lists/#plfa_plfa-part1-Lists-26232" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26241" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26244" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26247" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-26251" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-26261" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26267" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26271" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26273" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26274" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26277" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-26280" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26282" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-26286" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26289" href="../Lists/#plfa_plfa-part1-Lists-25786" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-26298" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26302" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26304" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26307" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-26310" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26316" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26322" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26326" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26327" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26333" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26337" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26339" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26341" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26343" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-26348" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-26351" href="../Lists/#plfa_plfa-part1-Lists-25089" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-26364" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26368" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26370" href="../Lists/#plfa_plfa-part1-Lists-26232" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-26379" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26382" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26383" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26389" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26393" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26395" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-26397" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26399" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-26405" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26411" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26415" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26417" href="../Lists/#plfa_plfa-part1-Lists-26241" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-26420" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-26422" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26428" href="../Lists/#plfa_plfa-part1-Lists-26226" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-26432" href="../Lists/#plfa_plfa-part1-Lists-26230" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-26434" href="../Lists/#plfa_plfa-part1-Lists-26244" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-26439" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4><p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-26821" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4><p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27119" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="All">所有</h2><p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p><p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-27449" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-27454" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27458" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27459" href="../Lists/#plfa_plfa-part1-Lists-27459" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27461" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27466" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27468" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27469" href="../Lists/#plfa_plfa-part1-Lists-27469" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27471" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27473" href="../Lists/#plfa_plfa-part1-Lists-27459" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27475" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27480" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27482" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27484" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27489" href="../Lists/#plfa_plfa-part1-Lists-27459" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27491" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-27497" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-27505" href="../Lists/#plfa_plfa-part1-Lists-27505" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-27509" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27511" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27515" href="../Lists/#plfa_plfa-part1-Lists-27469" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27517" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-27522" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-27526" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27528" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27530" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27531" href="../Lists/#plfa_plfa-part1-Lists-27531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27533" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27535" href="../Lists/#plfa_plfa-part1-Lists-27459" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27536" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27538" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27539" href="../Lists/#plfa_plfa-part1-Lists-27539" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27542" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27544" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27549" href="../Lists/#plfa_plfa-part1-Lists-27459" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27550" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27552" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27554" href="../Lists/#plfa_plfa-part1-Lists-27469" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27556" href="../Lists/#plfa_plfa-part1-Lists-27531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27558" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27560" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27564" href="../Lists/#plfa_plfa-part1-Lists-27469" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27566" href="../Lists/#plfa_plfa-part1-Lists-27539" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-27569" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27571" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27575" href="../Lists/#plfa_plfa-part1-Lists-27469" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27577" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27578" href="../Lists/#plfa_plfa-part1-Lists-27531" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27580" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27582" href="../Lists/#plfa_plfa-part1-Lists-27539" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27584" class="Symbol">)</a>
</pre><p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p><p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28565" href="../Lists/#plfa_plfa-part1-Lists-28565" class="Function">_</a> <a id="plfa_plfa-part1-Lists-28567" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28569" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28573" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28574" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-28577" class="Number">2</a><a id="plfa_plfa-part1-Lists-28578" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28580" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-28582" class="Number">0</a> <a id="plfa_plfa-part1-Lists-28584" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28586" class="Number">1</a> <a id="plfa_plfa-part1-Lists-28588" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-28590" class="Number">2</a> <a id="plfa_plfa-part1-Lists-28592" href="../Lists/#plfa_plfa-part1-Lists-3744" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-28594" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-28596" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-28598" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28602" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28604" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28608" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-28612" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28614" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28618" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28619" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-28623" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-28626" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28628" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28630" href="../Lists/#plfa_plfa-part1-Lists-27505" class="InductiveConstructor">[]</a>
</pre><p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p><p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p><h2 id="任意">任意</h2><p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-29555" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-29560" href="../Lists/#plfa_plfa-part1-Lists-29560" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29564" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29565" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29567" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29569" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29572" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29574" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29575" href="../Lists/#plfa_plfa-part1-Lists-29575" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29577" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29579" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29581" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29583" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29586" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29588" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29590" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29595" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29597" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29599" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29603" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-29611" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-29617" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29619" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29621" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29622" href="../Lists/#plfa_plfa-part1-Lists-29622" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29624" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29626" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29627" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29629" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29630" href="../Lists/#plfa_plfa-part1-Lists-29630" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29633" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29635" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29640" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29641" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29643" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29645" href="../Lists/#plfa_plfa-part1-Lists-29575" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29647" href="../Lists/#plfa_plfa-part1-Lists-29622" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29649" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29651" href="../Lists/#plfa_plfa-part1-Lists-29560" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29655" href="../Lists/#plfa_plfa-part1-Lists-29575" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29657" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29658" href="../Lists/#plfa_plfa-part1-Lists-29622" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29660" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29662" href="../Lists/#plfa_plfa-part1-Lists-29630" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29664" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-29668" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-29674" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29676" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29678" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29679" href="../Lists/#plfa_plfa-part1-Lists-29679" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29681" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29683" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29684" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29686" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29687" href="../Lists/#plfa_plfa-part1-Lists-29687" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29690" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29692" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29697" href="../Lists/#plfa_plfa-part1-Lists-29565" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29698" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29700" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29702" href="../Lists/#plfa_plfa-part1-Lists-29560" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29706" href="../Lists/#plfa_plfa-part1-Lists-29575" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29708" href="../Lists/#plfa_plfa-part1-Lists-29687" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29711" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29713" href="../Lists/#plfa_plfa-part1-Lists-29560" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-29717" href="../Lists/#plfa_plfa-part1-Lists-29575" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-29719" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29720" href="../Lists/#plfa_plfa-part1-Lists-29679" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29722" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29724" href="../Lists/#plfa_plfa-part1-Lists-29687" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29726" class="Symbol">)</a>
</pre><p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30054" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-30060" class="Number">4</a> <a id="plfa_plfa-part1-Lists-30062" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30066" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-30071" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-30075" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30077" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30079" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30080" href="../Lists/#plfa_plfa-part1-Lists-30080" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30082" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30084" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30087" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30090" href="../Lists/#plfa_plfa-part1-Lists-30090" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30092" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30094" href="../Lists/#plfa_plfa-part1-Lists-30080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30095" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30097" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30098" href="../Lists/#plfa_plfa-part1-Lists-30098" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30101" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30103" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30108" href="../Lists/#plfa_plfa-part1-Lists-30080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30109" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30111" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30117" href="../Lists/#plfa_plfa-part1-Lists-30117" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30119" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30121" href="../Lists/#plfa_plfa-part1-Lists-30121" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30124" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30126" href="../Lists/#plfa_plfa-part1-Lists-29560" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-30130" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30131" href="../Lists/#plfa_plfa-part1-Lists-30117" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30133" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-30135" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30137" href="../Lists/#plfa_plfa-part1-Lists-30121" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-30141" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-30145" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30147" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-30149" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-30150" href="../Lists/#plfa_plfa-part1-Lists-30150" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-30152" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30154" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-30157" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-30159" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30160" href="../Lists/#plfa_plfa-part1-Lists-30160" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30162" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30164" href="../Lists/#plfa_plfa-part1-Lists-30150" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30165" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30167" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30168" href="../Lists/#plfa_plfa-part1-Lists-30168" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30171" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30173" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-30178" href="../Lists/#plfa_plfa-part1-Lists-30150" class="Bound">A</a><a id="plfa_plfa-part1-Lists-30179" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-30181" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-30183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-30187" href="../Lists/#plfa_plfa-part1-Lists-30187" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30189" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30191" href="../Lists/#plfa_plfa-part1-Lists-30191" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-30194" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30196" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-30198" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30199" href="../Lists/#plfa_plfa-part1-Lists-30187" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-30201" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30203" href="../Lists/#plfa_plfa-part1-Lists-30191" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-30205" class="Symbol">)</a>
</pre><p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-30552" href="../Lists/#plfa_plfa-part1-Lists-30552" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30554" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30556" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30558" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30560" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30562" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30564" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30566" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30568" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30570" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30572" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30574" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30576" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30578" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30580" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30582" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30587" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-30593" href="../Lists/#plfa_plfa-part1-Lists-30593" class="Function">_</a> <a id="plfa_plfa-part1-Lists-30595" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30597" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30599" href="../Lists/#plfa_plfa-part1-Lists-30071" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-30601" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30603" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30605" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30607" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30609" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30611" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30613" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30615" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30617" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30619" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-30621" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-30623" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30629" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30630" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30636" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30637" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30642" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-30646" class="Symbol">))</a>
</pre><p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-30845" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30852" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-30854" class="Number">3</a> <a id="plfa_plfa-part1-Lists-30856" href="../Lists/#plfa_plfa-part1-Lists-30141" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-30858" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-30860" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30862" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30864" class="Number">1</a> <a id="plfa_plfa-part1-Lists-30866" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30868" class="Number">0</a> <a id="plfa_plfa-part1-Lists-30870" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-30872" class="Number">2</a> <a id="plfa_plfa-part1-Lists-30874" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-30876" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30883" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30884" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30889" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-30893" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30900" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30901" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30907" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30908" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30913" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-30918" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30925" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30926" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30932" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30933" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30940" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30945" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-30951" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30959" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30965" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30966" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30972" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30973" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-30979" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30980" href="../Lists/#plfa_plfa-part1-Lists-29611" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-30985" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-30992" href="../Lists/#plfa_plfa-part1-Lists-30845" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-30999" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31000" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31006" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31007" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31013" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31014" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31020" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31021" href="../Lists/#plfa_plfa-part1-Lists-29668" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-31027" class="Symbol">()))))</a>
</pre><p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p><h2 id="所有和附加">所有和附加</h2><p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-31499" href="../Lists/#plfa_plfa-part1-Lists-31499" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31508" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31510" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31512" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31513" href="../Lists/#plfa_plfa-part1-Lists-31513" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31515" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31517" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31520" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31522" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31523" href="../Lists/#plfa_plfa-part1-Lists-31523" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31525" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31527" href="../Lists/#plfa_plfa-part1-Lists-31513" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31529" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31531" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31534" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31536" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31537" href="../Lists/#plfa_plfa-part1-Lists-31537" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31540" href="../Lists/#plfa_plfa-part1-Lists-31540" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31543" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31545" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31550" href="../Lists/#plfa_plfa-part1-Lists-31513" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31551" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31553" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-31557" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31561" href="../Lists/#plfa_plfa-part1-Lists-31523" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31563" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31564" href="../Lists/#plfa_plfa-part1-Lists-31537" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31567" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31570" href="../Lists/#plfa_plfa-part1-Lists-31540" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31572" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31574" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-31576" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31577" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31581" href="../Lists/#plfa_plfa-part1-Lists-31523" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31583" href="../Lists/#plfa_plfa-part1-Lists-31537" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31586" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31588" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31592" href="../Lists/#plfa_plfa-part1-Lists-31523" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31594" href="../Lists/#plfa_plfa-part1-Lists-31540" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31596" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-31598" href="../Lists/#plfa_plfa-part1-Lists-31499" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-31607" href="../Lists/#plfa_plfa-part1-Lists-31607" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31610" href="../Lists/#plfa_plfa-part1-Lists-31610" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31613" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-31617" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-31628" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31630" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15016" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-31639" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31642" href="../Lists/#plfa_plfa-part1-Lists-31697" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31645" href="../Lists/#plfa_plfa-part1-Lists-31607" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31648" href="../Lists/#plfa_plfa-part1-Lists-31610" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-31657" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-15033" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-31666" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-31669" href="../Lists/#plfa_plfa-part1-Lists-31922" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31674" href="../Lists/#plfa_plfa-part1-Lists-31607" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31677" href="../Lists/#plfa_plfa-part1-Lists-31610" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-31684" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-31688" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-31697" href="../Lists/#plfa_plfa-part1-Lists-31697" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31700" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31702" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31704" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31705" href="../Lists/#plfa_plfa-part1-Lists-31705" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31707" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31712" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31714" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31715" href="../Lists/#plfa_plfa-part1-Lists-31715" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31717" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31719" href="../Lists/#plfa_plfa-part1-Lists-31705" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31721" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31723" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31726" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31728" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31729" href="../Lists/#plfa_plfa-part1-Lists-31729" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31732" href="../Lists/#plfa_plfa-part1-Lists-31732" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31735" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31737" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31742" href="../Lists/#plfa_plfa-part1-Lists-31705" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31743" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31745" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-31751" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31755" href="../Lists/#plfa_plfa-part1-Lists-31715" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31757" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31758" href="../Lists/#plfa_plfa-part1-Lists-31729" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31761" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-31764" href="../Lists/#plfa_plfa-part1-Lists-31732" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31766" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31768" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31770" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31771" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31775" href="../Lists/#plfa_plfa-part1-Lists-31715" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31777" href="../Lists/#plfa_plfa-part1-Lists-31729" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31780" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31782" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31786" href="../Lists/#plfa_plfa-part1-Lists-31715" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31788" href="../Lists/#plfa_plfa-part1-Lists-31732" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-31790" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-31794" href="../Lists/#plfa_plfa-part1-Lists-31697" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31797" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31800" href="../Lists/#plfa_plfa-part1-Lists-31800" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31803" href="../Lists/#plfa_plfa-part1-Lists-31803" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31807" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31809" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31811" href="../Lists/#plfa_plfa-part1-Lists-27505" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-31814" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31816" href="../Lists/#plfa_plfa-part1-Lists-31803" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31820" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-31824" href="../Lists/#plfa_plfa-part1-Lists-31697" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31827" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31828" href="../Lists/#plfa_plfa-part1-Lists-31828" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-31830" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31832" href="../Lists/#plfa_plfa-part1-Lists-31832" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-31834" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31836" href="../Lists/#plfa_plfa-part1-Lists-31836" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31839" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31840" href="../Lists/#plfa_plfa-part1-Lists-31840" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31843" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31845" href="../Lists/#plfa_plfa-part1-Lists-31845" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-31852" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31854" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-31859" href="../Lists/#plfa_plfa-part1-Lists-31697" class="Function">to</a> <a id="plfa_plfa-part1-Lists-31862" href="../Lists/#plfa_plfa-part1-Lists-31832" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31865" href="../Lists/#plfa_plfa-part1-Lists-31836" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31868" href="../Lists/#plfa_plfa-part1-Lists-31845" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-31878" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-31882" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-31884" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31886" href="../Lists/#plfa_plfa-part1-Lists-31886" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31890" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31892" href="../Lists/#plfa_plfa-part1-Lists-31892" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31896" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-31898" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-31900" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-31902" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-31905" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-31907" href="../Lists/#plfa_plfa-part1-Lists-31886" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-31911" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-31913" href="../Lists/#plfa_plfa-part1-Lists-31892" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-31917" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-31922" href="../Lists/#plfa_plfa-part1-Lists-31922" class="Function">from</a> <a id="plfa_plfa-part1-Lists-31927" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31929" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-31931" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-31933" href="../Lists/#plfa_plfa-part1-Lists-31933" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31935" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31937" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31940" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31942" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-31943" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31945" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31947" href="../Lists/#plfa_plfa-part1-Lists-31933" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-31949" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-31951" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-31954" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-31956" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-31957" href="../Lists/#plfa_plfa-part1-Lists-31957" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31960" href="../Lists/#plfa_plfa-part1-Lists-31960" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31963" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-31965" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-31970" href="../Lists/#plfa_plfa-part1-Lists-31933" class="Bound">A</a><a id="plfa_plfa-part1-Lists-31971" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-31973" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-31979" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31983" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31985" href="../Lists/#plfa_plfa-part1-Lists-31957" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-31988" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-31990" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-31994" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-31996" href="../Lists/#plfa_plfa-part1-Lists-31960" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-31999" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-32001" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-32005" href="../Lists/#plfa_plfa-part1-Lists-31943" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-32007" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32008" href="../Lists/#plfa_plfa-part1-Lists-31957" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32011" href="../Lists/#plfa_plfa-part1-Lists-4505" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-32014" href="../Lists/#plfa_plfa-part1-Lists-31960" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-32016" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-32020" href="../Lists/#plfa_plfa-part1-Lists-31922" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32025" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32028" href="../Lists/#plfa_plfa-part1-Lists-32028" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32031" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32033" href="../Lists/#plfa_plfa-part1-Lists-27505" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-32036" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32038" href="../Lists/#plfa_plfa-part1-Lists-32038" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32042" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32044" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-32046" href="../Lists/#plfa_plfa-part1-Lists-32038" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-32052" href="../Lists/#plfa_plfa-part1-Lists-31922" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32057" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-32058" href="../Lists/#plfa_plfa-part1-Lists-32058" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-32060" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32062" href="../Lists/#plfa_plfa-part1-Lists-32062" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-32064" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-32066" href="../Lists/#plfa_plfa-part1-Lists-32066" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32069" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32071" href="../Lists/#plfa_plfa-part1-Lists-32071" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32074" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32076" href="../Lists/#plfa_plfa-part1-Lists-32076" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32080" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32082" href="../Lists/#plfa_plfa-part1-Lists-32082" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32086" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-32088" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-32091" href="../Lists/#plfa_plfa-part1-Lists-32071" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-32094" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-32096" href="../Lists/#plfa_plfa-part1-Lists-31922" class="Function">from</a> <a id="plfa_plfa-part1-Lists-32101" href="../Lists/#plfa_plfa-part1-Lists-32062" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-32104" href="../Lists/#plfa_plfa-part1-Lists-32066" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-32107" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-32109" href="../Lists/#plfa_plfa-part1-Lists-32076" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-32113" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-32115" href="../Lists/#plfa_plfa-part1-Lists-32082" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-32119" href="../Lists/#plfa_plfa-part1-Lists-982" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4><p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32496" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4><p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-32710" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4><p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p><p>以下定律是否也成立？</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>若成立，请证明；否则请解释原因。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33352" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4><p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33613" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4><p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-33815" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4><p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-34024" class="Comment">-- 请将代码写在此处</a>
</pre><p>如果成立，请证明；如果不成立，请解释原因。</p><h2 id="所有的可判定性">所有的可判定性</h2><p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-34435" href="../Lists/#plfa_plfa-part1-Lists-34435" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34439" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34441" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-34443" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-34444" href="../Lists/#plfa_plfa-part1-Lists-34444" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34446" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-34448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-34451" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-34453" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34455" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-34456" href="../Lists/#plfa_plfa-part1-Lists-34444" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34458" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34460" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-34464" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-34466" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34468" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-34473" href="../Lists/#plfa_plfa-part1-Lists-34444" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-34475" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-34477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-34482" href="../Lists/#plfa_plfa-part1-Lists-34435" class="Function">all</a> <a id="plfa_plfa-part1-Lists-34486" href="../Lists/#plfa_plfa-part1-Lists-34486" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-34489" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-34492" href="../Lists/#plfa_plfa-part1-Lists-19470" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-34498" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-34502" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-34507" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-34509" href="../Lists/#plfa_plfa-part1-Lists-16353" class="Function">map</a> <a id="plfa_plfa-part1-Lists-34513" href="../Lists/#plfa_plfa-part1-Lists-34486" class="Bound">p</a>
</pre><p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p><p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-35239" href="../Lists/#plfa_plfa-part1-Lists-35239" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35249" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35251" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35253" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35254" href="../Lists/#plfa_plfa-part1-Lists-35254" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35256" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35258" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35261" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35263" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35265" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35266" href="../Lists/#plfa_plfa-part1-Lists-35254" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35268" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35270" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35273" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35275" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35277" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-35281" href="../Lists/#plfa_plfa-part1-Lists-35239" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35291" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35292" href="../Lists/#plfa_plfa-part1-Lists-35292" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35293" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35295" href="../Lists/#plfa_plfa-part1-Lists-35295" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-35298" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35301" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35303" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35304" href="../Lists/#plfa_plfa-part1-Lists-35304" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35306" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35308" href="../Lists/#plfa_plfa-part1-Lists-35292" class="Bound">A</a><a id="plfa_plfa-part1-Lists-35309" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35311" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35313" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-35317" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35318" href="../Lists/#plfa_plfa-part1-Lists-35295" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35320" href="../Lists/#plfa_plfa-part1-Lists-35304" class="Bound">x</a><a id="plfa_plfa-part1-Lists-35321" class="Symbol">)</a>
</pre>那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-35500" href="../Lists/#plfa_plfa-part1-Lists-35500" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35505" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35507" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-35509" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35510" href="../Lists/#plfa_plfa-part1-Lists-35510" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35512" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35514" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35517" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35519" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-35520" href="../Lists/#plfa_plfa-part1-Lists-35520" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35522" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-35524" href="../Lists/#plfa_plfa-part1-Lists-35510" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-35526" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35528" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-35531" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-35533" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35535" href="../Lists/#plfa_plfa-part1-Lists-35239" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35545" href="../Lists/#plfa_plfa-part1-Lists-35520" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-35547" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35549" href="../Lists/#plfa_plfa-part1-Lists-35239" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-35559" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35560" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-35564" href="../Lists/#plfa_plfa-part1-Lists-35520" class="Bound">P</a><a id="plfa_plfa-part1-Lists-35565" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35567" href="../Lists/#plfa_plfa-part1-Lists-35500" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35572" href="../Lists/#plfa_plfa-part1-Lists-35572" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35575" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-35610" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35613" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35617" href="../Lists/#plfa_plfa-part1-Lists-27505" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-35620" href="../Lists/#plfa_plfa-part1-Lists-35500" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35625" href="../Lists/#plfa_plfa-part1-Lists-35625" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35628" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35629" href="../Lists/#plfa_plfa-part1-Lists-35629" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-35631" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35633" href="../Lists/#plfa_plfa-part1-Lists-35633" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-35635" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35637" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-35642" href="../Lists/#plfa_plfa-part1-Lists-35625" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35645" href="../Lists/#plfa_plfa-part1-Lists-35629" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-35649" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35651" href="../Lists/#plfa_plfa-part1-Lists-35500" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-35656" href="../Lists/#plfa_plfa-part1-Lists-35625" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-35659" href="../Lists/#plfa_plfa-part1-Lists-35633" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-35662" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35682" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35684" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35688" href="../Lists/#plfa_plfa-part1-Lists-35688" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35691" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35693" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35697" href="../Lists/#plfa_plfa-part1-Lists-35697" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-35705" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35708" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-35712" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35713" href="../Lists/#plfa_plfa-part1-Lists-35688" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35716" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35718" href="../Lists/#plfa_plfa-part1-Lists-35697" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35721" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-35723" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-35743" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35745" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35748" href="../Lists/#plfa_plfa-part1-Lists-35748" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35752" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-35754" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-35766" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35769" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35772" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35775" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35776" href="../Lists/#plfa_plfa-part1-Lists-35776" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35779" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35781" href="../Lists/#plfa_plfa-part1-Lists-35781" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35784" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35786" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35788" href="../Lists/#plfa_plfa-part1-Lists-35748" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-35792" href="../Lists/#plfa_plfa-part1-Lists-35776" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-35797" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-35799" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-35802" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-35819" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35820" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35821" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-35822" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-35828" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-35829" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35830" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-35832" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-35833" href="../Lists/#plfa_plfa-part1-Lists-35833" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-35842" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-35845" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-35848" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-35851" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-35852" href="../Lists/#plfa_plfa-part1-Lists-35852" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-35855" href="../Lists/#plfa_plfa-part1-Lists-27522" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-35857" href="../Lists/#plfa_plfa-part1-Lists-35857" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-35860" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-35862" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-35864" href="../Lists/#plfa_plfa-part1-Lists-35833" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-35869" href="../Lists/#plfa_plfa-part1-Lists-35857" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-35873" class="Symbol">}</a>
</pre><p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p><h4 id="练习-any扩展">练习 <code>Any?</code>（扩展）</h4><p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36748" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-split扩展">练习 <code>split</code>（扩展）</h4><p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-36953" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-36958" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-36964" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-36965" href="../Lists/#plfa_plfa-part1-Lists-36965" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-36967" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-36969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-36972" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-36974" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-36976" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-36977" href="../Lists/#plfa_plfa-part1-Lists-36977" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-36980" href="../Lists/#plfa_plfa-part1-Lists-36980" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-36983" href="../Lists/#plfa_plfa-part1-Lists-36983" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-36986" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-36988" href="../Lists/#plfa_plfa-part1-Lists-1214" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-36993" href="../Lists/#plfa_plfa-part1-Lists-36965" class="Bound">A</a><a id="plfa_plfa-part1-Lists-36994" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-36996" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-36998" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-37002" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-37011" href="../Lists/#plfa_plfa-part1-Lists-37011" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37014" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-37022" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-37043" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37049" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37052" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-37055" href="../Lists/#plfa_plfa-part1-Lists-1243" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-37061" href="../Lists/#plfa_plfa-part1-Lists-37061" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37068" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37070" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37072" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37073" href="../Lists/#plfa_plfa-part1-Lists-37073" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37075" href="../Lists/#plfa_plfa-part1-Lists-37075" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37078" href="../Lists/#plfa_plfa-part1-Lists-37078" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37081" href="../Lists/#plfa_plfa-part1-Lists-37081" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37083" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37089" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37091" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37097" href="../Lists/#plfa_plfa-part1-Lists-37075" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37100" href="../Lists/#plfa_plfa-part1-Lists-37078" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37103" href="../Lists/#plfa_plfa-part1-Lists-37081" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37112" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37143" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37145" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37151" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37152" href="../Lists/#plfa_plfa-part1-Lists-37073" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37154" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37156" href="../Lists/#plfa_plfa-part1-Lists-37075" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-37158" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37160" href="../Lists/#plfa_plfa-part1-Lists-37078" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37163" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37164" href="../Lists/#plfa_plfa-part1-Lists-37073" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-37166" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37168" href="../Lists/#plfa_plfa-part1-Lists-37081" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37170" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-37175" href="../Lists/#plfa_plfa-part1-Lists-37175" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37183" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37185" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-37187" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-37188" href="../Lists/#plfa_plfa-part1-Lists-37188" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37190" href="../Lists/#plfa_plfa-part1-Lists-37190" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37193" href="../Lists/#plfa_plfa-part1-Lists-37193" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37196" href="../Lists/#plfa_plfa-part1-Lists-37196" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37198" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-37204" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37206" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37212" href="../Lists/#plfa_plfa-part1-Lists-37190" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37215" href="../Lists/#plfa_plfa-part1-Lists-37193" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-37218" href="../Lists/#plfa_plfa-part1-Lists-37196" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-37227" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-37258" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-37260" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37266" href="../Lists/#plfa_plfa-part1-Lists-37190" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-37269" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37270" href="../Lists/#plfa_plfa-part1-Lists-37188" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37272" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37274" href="../Lists/#plfa_plfa-part1-Lists-37193" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-37276" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-37278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37279" href="../Lists/#plfa_plfa-part1-Lists-37188" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-37281" href="../Lists/#plfa_plfa-part1-Lists-1258" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-37283" href="../Lists/#plfa_plfa-part1-Lists-37196" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-37285" class="Symbol">)</a>
</pre><p>例如</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-37327" href="../Lists/#plfa_plfa-part1-Lists-37327" class="Function">_</a> <a id="plfa_plfa-part1-Lists-37329" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-37331" href="../Lists/#plfa_plfa-part1-Lists-36958" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-37337" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37339" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37341" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37343" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37345" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37347" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37349" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37351" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37353" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37355" href="../Lists/#plfa_plfa-part1-Lists-3713" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-37357" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-37359" class="Number">1</a> <a id="plfa_plfa-part1-Lists-37361" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37363" class="Number">2</a> <a id="plfa_plfa-part1-Lists-37365" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37367" class="Number">3</a> <a id="plfa_plfa-part1-Lists-37369" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-37371" class="Number">4</a> <a id="plfa_plfa-part1-Lists-37373" href="../Lists/#plfa_plfa-part1-Lists-3783" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-37375" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-37377" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-37379" href="../Lists/#plfa_plfa-part1-Lists-37061" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37386" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37387" href="../Lists/#plfa_plfa-part1-Lists-37175" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37395" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37396" href="../Lists/#plfa_plfa-part1-Lists-37175" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-37404" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-37405" href="../Lists/#plfa_plfa-part1-Lists-37061" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-37412" href="../Lists/#plfa_plfa-part1-Lists-37011" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-37414" class="Symbol">)))</a>
</pre><p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p><p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-38248" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-38426" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38433" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-38443" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38449" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38450" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-38454" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38456" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-38460" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38462" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4864" class="Function">length</a><a id="plfa_plfa-part1-Lists-38468" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38470" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#9817" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-38477" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38479" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1544" class="Function">map</a><a id="plfa_plfa-part1-Lists-38482" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38484" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4192" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-38489" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38491" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#6273" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-38499" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38501" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38508" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-38537" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38543" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38544" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-38547" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38549" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-38551" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38553" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-38556" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38558" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38565" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-38594" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38601" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-38604" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38606" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-38610" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38612" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-38617" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38619" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38626" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-38661" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38667" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38668" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-38671" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38673" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38680" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-38703" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38709" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38710" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#34556" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-38728" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38730" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3768" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-38741" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38743" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3085" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-38757" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-38759" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#16280" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-38767" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-38771" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-38780" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38781" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#40456" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-38791" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-38794" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-38806" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38808" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38815" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-38834" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38840" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38841" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html#2801" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-38849" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38851" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38858" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-38873" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38879" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38880" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html#3536" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-38889" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-38891" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-38898" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-38914" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-38920" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-38921" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-38930" class="Symbol">)</a>
</pre><p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p><p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p><h2 id="unicode">Unicode</h2><p>本章使用了下列 Unicode：</p><pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>