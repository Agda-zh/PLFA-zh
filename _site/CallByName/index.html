<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Call-by-name big-step evaluation | 编程语言基础：Agda 语言描述
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Call-by-name big-step evaluation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 语言描述" />
<meta property="og:description" content="编程语言基础：Agda 语言描述" />
<link rel="canonical" href="https://agda-zh.github.io/PLFA-zh/CallByName/" />
<meta property="og:url" content="https://agda-zh.github.io/PLFA-zh/CallByName/" />
<meta property="og:site_name" content="编程语言基础：Agda 语言描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 语言描述","@type":"WebPage","url":"https://agda-zh.github.io/PLFA-zh/CallByName/","headline":"Call-by-name big-step evaluation","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 语言描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">主页</a>
                <a class="page-link" href="/PLFA-zh/Announcements/">公告</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
                <a class="page-link" href="/PLFA-zh/Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Call-by-name big-step evaluation</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Confluence/">上一章</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/CallByName.lagda.md">源代码</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/PLFA-zh/Denotational/">下一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="155" class="Keyword">module</a> <a id="162" href="/PLFA-zh/CallByName/" class="Module">plfa.CallByName</a> <a id="178" class="Keyword">where</a>
</pre>
<h2 id="introduction">Introduction</h2>

<p>The call-by-name evaluation strategy is a deterministic method for
computing the value of a program in the lambda calculus.  That is,
call-by-name produces a value if and only if beta reduction can reduce
the program to a lambda abstraction. In this chapter we define
call-by-name evaluation and prove the forward direction of this
if-and-only-if. The backward direction is traditionally proved via
Curry-Feys standardisation, which is quite complex.  We give a sketch
of that proof, due to Plotkin, but postpone the proof in Agda until
after we have developed a denotational semantics for the lambda
calculus, at which point the proof is an easy corollary of properties
of the denotational semantics.</p>

<p>We present the call-by-name strategy as a relation between an an input
term and an output value. Such a relation is often called a <em>big-step
semantics</em>, written <code class="highlighter-rouge">M ⇓ V</code>, as it relates the input term <code class="highlighter-rouge">M</code> directly
to the final result <code class="highlighter-rouge">V</code>, in contrast to the small-step reduction
relation, <code class="highlighter-rouge">M —→ M′</code>, that maps <code class="highlighter-rouge">M</code> to another term <code class="highlighter-rouge">M′</code> in which a
single sub-computation has been completed.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="1313" class="Keyword">open</a> <a id="1318" class="Keyword">import</a> <a id="1325" href="/PLFA-zh/Untyped/" class="Module">plfa.Untyped</a>
  <a id="1340" class="Keyword">using</a> <a id="1346" class="Symbol">(</a><a id="1347" href="/PLFA-zh/Untyped/#3130" class="Datatype">Context</a><a id="1354" class="Symbol">;</a> <a id="1356" href="plfa.Untyped.html#4252" class="Datatype Operator">_⊢_</a><a id="1359" class="Symbol">;</a> <a id="1361" href="plfa.Untyped.html#3483" class="Datatype Operator">_∋_</a><a id="1364" class="Symbol">;</a> <a id="1366" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="1367" class="Symbol">;</a> <a id="1369" href="plfa.Untyped.html#3152" class="InductiveConstructor">∅</a><a id="1370" class="Symbol">;</a> <a id="1372" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">_,_</a><a id="1375" class="Symbol">;</a> <a id="1377" href="plfa.Untyped.html#3519" class="InductiveConstructor">Z</a><a id="1378" class="Symbol">;</a> <a id="1380" href="plfa.Untyped.html#3564" class="InductiveConstructor Operator">S_</a><a id="1382" class="Symbol">;</a> <a id="1384" href="plfa.Untyped.html#4288" class="InductiveConstructor Operator">`_</a><a id="1386" class="Symbol">;</a> <a id="1388" href="plfa.Untyped.html#5069" class="Function Operator">#_</a><a id="1390" class="Symbol">;</a> <a id="1392" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ_</a><a id="1394" class="Symbol">;</a> <a id="1396" href="plfa.Untyped.html#4400" class="InductiveConstructor Operator">_·_</a><a id="1399" class="Symbol">;</a>
         <a id="1410" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a><a id="1415" class="Symbol">;</a> <a id="1417" href="plfa.Untyped.html#7333" class="Function">subst-zero</a><a id="1427" class="Symbol">;</a> <a id="1429" href="plfa.Untyped.html#6629" class="Function">exts</a><a id="1433" class="Symbol">;</a> <a id="1435" href="plfa.Untyped.html#6193" class="Function">rename</a><a id="1441" class="Symbol">;</a> <a id="1443" href="plfa.Untyped.html#10335" class="InductiveConstructor">β</a><a id="1444" class="Symbol">;</a> <a id="1446" href="plfa.Untyped.html#10155" class="InductiveConstructor">ξ₁</a><a id="1448" class="Symbol">;</a> <a id="1450" href="plfa.Untyped.html#10245" class="InductiveConstructor">ξ₂</a><a id="1452" class="Symbol">;</a> <a id="1454" href="plfa.Untyped.html#10443" class="InductiveConstructor">ζ</a><a id="1455" class="Symbol">;</a> <a id="1457" href="plfa.Untyped.html#10105" class="Datatype Operator">_—→_</a><a id="1461" class="Symbol">;</a> <a id="1463" href="plfa.Untyped.html#11203" class="Datatype Operator">_—↠_</a><a id="1467" class="Symbol">;</a> <a id="1469" href="plfa.Untyped.html#11309" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="1476" class="Symbol">;</a> <a id="1478" href="plfa.Untyped.html#11253" class="InductiveConstructor Operator">_∎</a><a id="1480" class="Symbol">;</a>
         <a id="1491" href="/PLFA-zh/Untyped/#21544" class="Function">—↠-trans</a><a id="1499" class="Symbol">;</a> <a id="1501" href="plfa.Untyped.html#22728" class="Function">appL-cong</a><a id="1510" class="Symbol">)</a>
<a id="1512" class="Keyword">open</a> <a id="1517" class="Keyword">import</a> <a id="1524" href="/PLFA-zh/Substitution/" class="Module">plfa.Substitution</a> <a id="1542" class="Keyword">using</a> <a id="1548" class="Symbol">(</a><a id="1549" href="plfa.Substitution.html#2446" class="Function">Subst</a><a id="1554" class="Symbol">;</a> <a id="1556" href="plfa.Substitution.html#3087" class="Function">ids</a><a id="1559" class="Symbol">)</a>
<a id="1561" class="Keyword">import</a> <a id="1568" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1606" class="Symbol">as</a> <a id="1609" class="Module">Eq</a>
<a id="1612" class="Keyword">open</a> <a id="1617" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="1620" class="Keyword">using</a> <a id="1626" class="Symbol">(</a><a id="1627" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="1630" class="Symbol">;</a> <a id="1632" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1636" class="Symbol">;</a> <a id="1638" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a><a id="1643" class="Symbol">;</a> <a id="1645" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a><a id="1648" class="Symbol">;</a> <a id="1650" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a><a id="1658" class="Symbol">)</a>

<a id="1661" class="Keyword">open</a> <a id="1666" class="Keyword">import</a> <a id="1673" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="1686" class="Keyword">using</a> <a id="1692" class="Symbol">(</a><a id="1693" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_×_</a><a id="1696" class="Symbol">;</a> <a id="1698" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="1699" class="Symbol">;</a> <a id="1701" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ-syntax</a><a id="1709" class="Symbol">;</a> <a id="1711" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1364" class="Function">∃</a><a id="1712" class="Symbol">;</a> <a id="1714" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">∃-syntax</a><a id="1722" class="Symbol">;</a> <a id="1724" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="1729" class="Symbol">;</a> <a id="1731" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="1736" class="Symbol">)</a>
  <a id="1740" class="Keyword">renaming</a> <a id="1749" class="Symbol">(</a><a id="1750" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="1754" class="Symbol">to</a> <a id="1757" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1762" class="Symbol">)</a>
<a id="1764" class="Keyword">open</a> <a id="1769" class="Keyword">import</a> <a id="1776" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="1785" class="Keyword">using</a> <a id="1791" class="Symbol">(</a><a id="1792" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="1795" class="Symbol">)</a>
</pre>
<h2 id="environments">Environments</h2>

<p>To handle variables and function application, there is the choice
between using substitution, as in <code class="highlighter-rouge">—→</code>, or to use an <em>environment</em>.
An environment in call-by-name is a map from variables to closures,
that is, to terms paired with their environments. We choose to use
environments instead of substitution because the point of the
call-by-name strategy is to be closer to an implementation of the
language. Also, the denotational semantics introduced in later
chapters uses environments and the proof of adequacy
is made easier by aligning these choices.</p>

<p>We define environments and closures as follows.</p>

<pre class="Agda"><a id="ClosEnv"></a><a id="2428" href="/PLFA-zh/CallByName/#2428" class="Function">ClosEnv</a> <a id="2436" class="Symbol">:</a> <a id="2438" href="/PLFA-zh/Untyped/#3130" class="Datatype">Context</a> <a id="2446" class="Symbol">→</a> <a id="2448" class="PrimitiveType">Set</a>

<a id="2453" class="Keyword">data</a> <a id="Clos"></a><a id="2458" href="/PLFA-zh/CallByName/#2458" class="Datatype">Clos</a> <a id="2463" class="Symbol">:</a> <a id="2465" class="PrimitiveType">Set</a> <a id="2469" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="2477" href="/PLFA-zh/CallByName/#2477" class="InductiveConstructor">clos</a> <a id="2482" class="Symbol">:</a> <a id="2484" class="Symbol">∀{</a><a id="2486" href="plfa.CallByName.html#2486" class="Bound">Γ</a><a id="2487" class="Symbol">}</a> <a id="2489" class="Symbol">→</a> <a id="2491" class="Symbol">(</a><a id="2492" href="plfa.CallByName.html#2492" class="Bound">M</a> <a id="2494" class="Symbol">:</a> <a id="2496" href="plfa.CallByName.html#2486" class="Bound">Γ</a> <a id="2498" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="2500" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="2501" class="Symbol">)</a> <a id="2503" class="Symbol">→</a> <a id="2505" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="2513" href="plfa.CallByName.html#2486" class="Bound">Γ</a> <a id="2515" class="Symbol">→</a> <a id="2517" href="plfa.CallByName.html#2458" class="Datatype">Clos</a>

<a id="2523" href="/PLFA-zh/CallByName/#2428" class="Function">ClosEnv</a> <a id="2531" href="plfa.CallByName.html#2531" class="Bound">Γ</a> <a id="2533" class="Symbol">=</a> <a id="2535" class="Symbol">∀</a> <a id="2537" class="Symbol">(</a><a id="2538" href="plfa.CallByName.html#2538" class="Bound">x</a> <a id="2540" class="Symbol">:</a> <a id="2542" href="plfa.CallByName.html#2531" class="Bound">Γ</a> <a id="2544" href="/PLFA-zh/Untyped/#3483" class="Datatype Operator">∋</a> <a id="2546" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="2547" class="Symbol">)</a> <a id="2549" class="Symbol">→</a> <a id="2551" href="plfa.CallByName.html#2458" class="Datatype">Clos</a>
</pre>
<p>As usual, we have the empty environment, and we can extend an
environment.</p>

<pre class="Agda"><a id="∅&#39;"></a><a id="2641" href="/PLFA-zh/CallByName/#2641" class="Function">∅&#39;</a> <a id="2644" class="Symbol">:</a> <a id="2646" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="2654" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a>
<a id="2656" href="/PLFA-zh/CallByName/#2641" class="Function">∅&#39;</a> <a id="2659" class="Symbol">()</a>

<a id="_,&#39;_"></a><a id="2663" href="/PLFA-zh/CallByName/#2663" class="Function Operator">_,&#39;_</a> <a id="2668" class="Symbol">:</a> <a id="2670" class="Symbol">∀</a> <a id="2672" class="Symbol">{</a><a id="2673" href="plfa.CallByName.html#2673" class="Bound">Γ</a><a id="2674" class="Symbol">}</a> <a id="2676" class="Symbol">→</a> <a id="2678" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="2686" href="plfa.CallByName.html#2673" class="Bound">Γ</a> <a id="2688" class="Symbol">→</a> <a id="2690" href="plfa.CallByName.html#2458" class="Datatype">Clos</a> <a id="2695" class="Symbol">→</a> <a id="2697" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="2705" class="Symbol">(</a><a id="2706" href="plfa.CallByName.html#2673" class="Bound">Γ</a> <a id="2708" href="/PLFA-zh/Untyped/#3168" class="InductiveConstructor Operator">,</a> <a id="2710" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="2711" class="Symbol">)</a>
<a id="2713" class="Symbol">(</a><a id="2714" href="/PLFA-zh/CallByName/#2714" class="Bound">γ</a> <a id="2716" href="plfa.CallByName.html#2663" class="Function Operator">,&#39;</a> <a id="2719" href="plfa.CallByName.html#2719" class="Bound">c</a><a id="2720" class="Symbol">)</a> <a id="2722" href="/PLFA-zh/Untyped/#3519" class="InductiveConstructor">Z</a> <a id="2724" class="Symbol">=</a> <a id="2726" href="plfa.CallByName.html#2719" class="Bound">c</a>
<a id="2728" class="Symbol">(</a><a id="2729" href="/PLFA-zh/CallByName/#2729" class="Bound">γ</a> <a id="2731" href="plfa.CallByName.html#2663" class="Function Operator">,&#39;</a> <a id="2734" href="plfa.CallByName.html#2734" class="Bound">c</a><a id="2735" class="Symbol">)</a> <a id="2737" class="Symbol">(</a><a id="2738" href="/PLFA-zh/Untyped/#3564" class="InductiveConstructor Operator">S</a> <a id="2740" href="plfa.CallByName.html#2740" class="Bound">x</a><a id="2741" class="Symbol">)</a> <a id="2743" class="Symbol">=</a> <a id="2745" href="plfa.CallByName.html#2729" class="Bound">γ</a> <a id="2747" href="plfa.CallByName.html#2740" class="Bound">x</a>
</pre>
<h2 id="big-step-evaluation">Big-step evaluation</h2>

<p>The big-step semantics is represented as a ternary relation,
written <code class="highlighter-rouge">γ ⊢ M ⇓ V</code>, where <code class="highlighter-rouge">γ</code> is the environment, <code class="highlighter-rouge">M</code> is the input
term, and <code class="highlighter-rouge">V</code> is the result value.  A <em>value</em> is a closure whose term
is a lambda abstraction.</p>

<pre class="Agda"><a id="3007" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3012" href="/PLFA-zh/CallByName/#3012" class="Datatype Operator">_⊢_⇓_</a> <a id="3018" class="Symbol">:</a> <a id="3020" class="Symbol">∀{</a><a id="3022" href="plfa.CallByName.html#3022" class="Bound">Γ</a><a id="3023" class="Symbol">}</a> <a id="3025" class="Symbol">→</a> <a id="3027" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3035" href="plfa.CallByName.html#3022" class="Bound">Γ</a> <a id="3037" class="Symbol">→</a> <a id="3039" class="Symbol">(</a><a id="3040" href="plfa.CallByName.html#3022" class="Bound">Γ</a> <a id="3042" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="3044" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3045" class="Symbol">)</a> <a id="3047" class="Symbol">→</a> <a id="3049" href="plfa.CallByName.html#2458" class="Datatype">Clos</a> <a id="3054" class="Symbol">→</a> <a id="3056" class="PrimitiveType">Set</a> <a id="3060" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3069" href="/PLFA-zh/CallByName/#3069" class="InductiveConstructor">⇓-var</a> <a id="3075" class="Symbol">:</a> <a id="3077" class="Symbol">∀{</a><a id="3079" href="plfa.CallByName.html#3079" class="Bound">Γ</a><a id="3080" class="Symbol">}{</a><a id="3082" href="plfa.CallByName.html#3082" class="Bound">γ</a> <a id="3084" class="Symbol">:</a> <a id="3086" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3094" href="plfa.CallByName.html#3079" class="Bound">Γ</a><a id="3095" class="Symbol">}{</a><a id="3097" href="plfa.CallByName.html#3097" class="Bound">x</a> <a id="3099" class="Symbol">:</a> <a id="3101" href="plfa.CallByName.html#3079" class="Bound">Γ</a> <a id="3103" href="/PLFA-zh/Untyped/#3483" class="Datatype Operator">∋</a> <a id="3105" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3106" class="Symbol">}{</a><a id="3108" href="plfa.CallByName.html#3108" class="Bound">Δ</a><a id="3109" class="Symbol">}{</a><a id="3111" href="plfa.CallByName.html#3111" class="Bound">δ</a> <a id="3113" class="Symbol">:</a> <a id="3115" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3123" href="plfa.CallByName.html#3108" class="Bound">Δ</a><a id="3124" class="Symbol">}{</a><a id="3126" href="plfa.CallByName.html#3126" class="Bound">M</a> <a id="3128" class="Symbol">:</a> <a id="3130" href="plfa.CallByName.html#3108" class="Bound">Δ</a> <a id="3132" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="3134" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3135" class="Symbol">}{</a><a id="3137" href="plfa.CallByName.html#3137" class="Bound">V</a><a id="3138" class="Symbol">}</a>
        <a id="3148" class="Symbol">→</a> <a id="3150" href="/PLFA-zh/CallByName/#3082" class="Bound">γ</a> <a id="3152" href="plfa.CallByName.html#3097" class="Bound">x</a> <a id="3154" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3156" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="3161" href="plfa.CallByName.html#3126" class="Bound">M</a> <a id="3163" href="plfa.CallByName.html#3111" class="Bound">δ</a>
        <a id="3173" class="Symbol">→</a> <a id="3175" href="/PLFA-zh/CallByName/#3111" class="Bound">δ</a> <a id="3177" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3179" href="plfa.CallByName.html#3126" class="Bound">M</a> <a id="3181" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3183" href="plfa.CallByName.html#3137" class="Bound">V</a>
          <a id="3195" class="Comment">-----------</a>
        <a id="3215" class="Symbol">→</a> <a id="3217" href="/PLFA-zh/CallByName/#3082" class="Bound">γ</a> <a id="3219" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3221" href="/PLFA-zh/Untyped/#4288" class="InductiveConstructor Operator">`</a> <a id="3223" href="plfa.CallByName.html#3097" class="Bound">x</a> <a id="3225" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3227" href="plfa.CallByName.html#3137" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="3232" href="/PLFA-zh/CallByName/#3232" class="InductiveConstructor">⇓-lam</a> <a id="3238" class="Symbol">:</a> <a id="3240" class="Symbol">∀{</a><a id="3242" href="plfa.CallByName.html#3242" class="Bound">Γ</a><a id="3243" class="Symbol">}{</a><a id="3245" href="plfa.CallByName.html#3245" class="Bound">γ</a> <a id="3247" class="Symbol">:</a> <a id="3249" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3257" href="plfa.CallByName.html#3242" class="Bound">Γ</a><a id="3258" class="Symbol">}{</a><a id="3260" href="plfa.CallByName.html#3260" class="Bound">M</a> <a id="3262" class="Symbol">:</a> <a id="3264" href="plfa.CallByName.html#3242" class="Bound">Γ</a> <a id="3266" href="/PLFA-zh/Untyped/#3168" class="InductiveConstructor Operator">,</a> <a id="3268" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="3270" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="3272" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3273" class="Symbol">}</a>
        <a id="3283" class="Symbol">→</a> <a id="3285" href="/PLFA-zh/CallByName/#3245" class="Bound">γ</a> <a id="3287" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3289" href="/PLFA-zh/Untyped/#4340" class="InductiveConstructor Operator">ƛ</a> <a id="3291" href="plfa.CallByName.html#3260" class="Bound">M</a> <a id="3293" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3295" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="3300" class="Symbol">(</a><a id="3301" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ</a> <a id="3303" href="plfa.CallByName.html#3260" class="Bound">M</a><a id="3304" class="Symbol">)</a> <a id="3306" href="plfa.CallByName.html#3245" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="3311" href="/PLFA-zh/CallByName/#3311" class="InductiveConstructor">⇓-app</a> <a id="3317" class="Symbol">:</a> <a id="3319" class="Symbol">∀{</a><a id="3321" href="plfa.CallByName.html#3321" class="Bound">Γ</a><a id="3322" class="Symbol">}{</a><a id="3324" href="plfa.CallByName.html#3324" class="Bound">γ</a> <a id="3326" class="Symbol">:</a> <a id="3328" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3336" href="plfa.CallByName.html#3321" class="Bound">Γ</a><a id="3337" class="Symbol">}{</a><a id="3339" href="plfa.CallByName.html#3339" class="Bound">L</a> <a id="3341" href="plfa.CallByName.html#3341" class="Bound">M</a> <a id="3343" class="Symbol">:</a> <a id="3345" href="plfa.CallByName.html#3321" class="Bound">Γ</a> <a id="3347" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="3349" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3350" class="Symbol">}{</a><a id="3352" href="plfa.CallByName.html#3352" class="Bound">Δ</a><a id="3353" class="Symbol">}{</a><a id="3355" href="plfa.CallByName.html#3355" class="Bound">δ</a> <a id="3357" class="Symbol">:</a> <a id="3359" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="3367" href="plfa.CallByName.html#3352" class="Bound">Δ</a><a id="3368" class="Symbol">}{</a><a id="3370" href="plfa.CallByName.html#3370" class="Bound">N</a> <a id="3372" class="Symbol">:</a> <a id="3374" href="plfa.CallByName.html#3352" class="Bound">Δ</a> <a id="3376" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">,</a> <a id="3378" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="3380" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="3382" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="3383" class="Symbol">}{</a><a id="3385" href="plfa.CallByName.html#3385" class="Bound">V</a><a id="3386" class="Symbol">}</a>
       <a id="3395" class="Symbol">→</a> <a id="3397" href="/PLFA-zh/CallByName/#3324" class="Bound">γ</a> <a id="3399" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3401" href="plfa.CallByName.html#3339" class="Bound">L</a> <a id="3403" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3405" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="3410" class="Symbol">(</a><a id="3411" href="/PLFA-zh/Untyped/#4340" class="InductiveConstructor Operator">ƛ</a> <a id="3413" href="plfa.CallByName.html#3370" class="Bound">N</a><a id="3414" class="Symbol">)</a> <a id="3416" href="plfa.CallByName.html#3355" class="Bound">δ</a>   <a id="3420" class="Symbol">→</a>   <a id="3424" class="Symbol">(</a><a id="3425" href="plfa.CallByName.html#3355" class="Bound">δ</a> <a id="3427" href="plfa.CallByName.html#2663" class="Function Operator">,&#39;</a> <a id="3430" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="3435" href="plfa.CallByName.html#3341" class="Bound">M</a> <a id="3437" href="plfa.CallByName.html#3324" class="Bound">γ</a><a id="3438" class="Symbol">)</a> <a id="3440" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3442" href="plfa.CallByName.html#3370" class="Bound">N</a> <a id="3444" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3446" href="plfa.CallByName.html#3385" class="Bound">V</a>
         <a id="3457" class="Comment">---------------------------------------------------</a>
       <a id="3516" class="Symbol">→</a> <a id="3518" href="/PLFA-zh/CallByName/#3324" class="Bound">γ</a> <a id="3520" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="3522" href="plfa.CallByName.html#3339" class="Bound">L</a> <a id="3524" href="/PLFA-zh/Untyped/#4400" class="InductiveConstructor Operator">·</a> <a id="3526" href="plfa.CallByName.html#3341" class="Bound">M</a> <a id="3528" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="3530" href="plfa.CallByName.html#3385" class="Bound">V</a>
</pre>
<ul>
  <li>
    <p>The <code class="highlighter-rouge">⇓-var</code> rule evaluates a variable by finding the associated
closure in the environment and then evaluating the closure.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">⇓-lam</code> rule turns a lambda abstraction into a closure
by packaging it up with its environment.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">⇓-app</code> rule performs function application by first evaluating
the term <code class="highlighter-rouge">L</code> in operator position. If that produces a closure containing
a lambda abstraction <code class="highlighter-rouge">ƛ N</code>, then we evaluate the body <code class="highlighter-rouge">N</code> in an
environment extended with the argument <code class="highlighter-rouge">M</code>. Note that <code class="highlighter-rouge">M</code> is not
evaluated in rule <code class="highlighter-rouge">⇓-app</code> because this is call-by-name and not
call-by-value.</p>
  </li>
</ul>

<h4 id="exercise-big-step-eg">Exercise <code class="highlighter-rouge">big-step-eg</code></h4>

<p>Show that <code class="highlighter-rouge">(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))</code>
terminates under big-step call-by-name evaluation.</p>

<pre class="Agda"><a id="4273" class="Comment">-- Your code goes here</a>
</pre>

<h2 id="the-big-step-semantics-is-deterministic">The big-step semantics is deterministic</h2>

<p>If the big-step relation evaluates a term <code class="highlighter-rouge">M</code> to both <code class="highlighter-rouge">V</code> and
<code class="highlighter-rouge">V′</code>, then <code class="highlighter-rouge">V</code> and <code class="highlighter-rouge">V′</code> must be identical. In other words, the
call-by-name relation is a partial function. The proof is a
straightforward induction on the two big-step derivations.</p>

<pre class="Agda"><a id="⇓-determ"></a><a id="4595" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4604" class="Symbol">:</a> <a id="4606" class="Symbol">∀{</a><a id="4608" href="plfa.CallByName.html#4608" class="Bound">Γ</a><a id="4609" class="Symbol">}{</a><a id="4611" href="plfa.CallByName.html#4611" class="Bound">γ</a> <a id="4613" class="Symbol">:</a> <a id="4615" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="4623" href="plfa.CallByName.html#4608" class="Bound">Γ</a><a id="4624" class="Symbol">}{</a><a id="4626" href="plfa.CallByName.html#4626" class="Bound">M</a> <a id="4628" class="Symbol">:</a> <a id="4630" href="plfa.CallByName.html#4608" class="Bound">Γ</a> <a id="4632" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="4634" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="4635" class="Symbol">}{</a><a id="4637" href="plfa.CallByName.html#4637" class="Bound">V</a> <a id="4639" href="plfa.CallByName.html#4639" class="Bound">V&#39;</a> <a id="4642" class="Symbol">:</a> <a id="4644" href="plfa.CallByName.html#2458" class="Datatype">Clos</a><a id="4648" class="Symbol">}</a>
         <a id="4659" class="Symbol">→</a> <a id="4661" href="/PLFA-zh/CallByName/#4611" class="Bound">γ</a> <a id="4663" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="4665" href="plfa.CallByName.html#4626" class="Bound">M</a> <a id="4667" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="4669" href="plfa.CallByName.html#4637" class="Bound">V</a> <a id="4671" class="Symbol">→</a> <a id="4673" href="plfa.CallByName.html#4611" class="Bound">γ</a> <a id="4675" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="4677" href="plfa.CallByName.html#4626" class="Bound">M</a> <a id="4679" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="4681" href="plfa.CallByName.html#4639" class="Bound">V&#39;</a>
         <a id="4693" class="Symbol">→</a> <a id="4695" href="/PLFA-zh/CallByName/#4637" class="Bound">V</a> <a id="4697" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4699" href="plfa.CallByName.html#4639" class="Bound">V&#39;</a>
<a id="4702" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4711" class="Symbol">(</a><a id="4712" href="plfa.CallByName.html#3069" class="InductiveConstructor">⇓-var</a> <a id="4718" href="plfa.CallByName.html#4718" class="Bound">eq1</a> <a id="4722" href="plfa.CallByName.html#4722" class="Bound">mc</a><a id="4724" class="Symbol">)</a> <a id="4726" class="Symbol">(</a><a id="4727" href="plfa.CallByName.html#3069" class="InductiveConstructor">⇓-var</a> <a id="4733" href="plfa.CallByName.html#4733" class="Bound">eq2</a> <a id="4737" href="plfa.CallByName.html#4737" class="Bound">mc&#39;</a><a id="4740" class="Symbol">)</a>
      <a id="4748" class="Keyword">with</a> <a id="4753" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a> <a id="4759" class="Symbol">(</a><a id="4760" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="4764" href="/PLFA-zh/CallByName/#4718" class="Bound">eq1</a><a id="4767" class="Symbol">)</a> <a id="4769" href="plfa.CallByName.html#4733" class="Bound">eq2</a>
<a id="4773" class="Symbol">...</a> <a id="4777" class="Symbol">|</a> <a id="4779" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4784" class="Symbol">=</a> <a id="4786" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4795" class="Bound">mc</a> <a id="4798" class="Bound">mc&#39;</a>
<a id="4802" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4811" href="plfa.CallByName.html#3232" class="InductiveConstructor">⇓-lam</a> <a id="4817" href="plfa.CallByName.html#3232" class="InductiveConstructor">⇓-lam</a> <a id="4823" class="Symbol">=</a> <a id="4825" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="4830" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4839" class="Symbol">(</a><a id="4840" href="plfa.CallByName.html#3311" class="InductiveConstructor">⇓-app</a> <a id="4846" href="plfa.CallByName.html#4846" class="Bound">mc</a> <a id="4849" href="plfa.CallByName.html#4849" class="Bound">mc₁</a><a id="4852" class="Symbol">)</a> <a id="4854" class="Symbol">(</a><a id="4855" href="plfa.CallByName.html#3311" class="InductiveConstructor">⇓-app</a> <a id="4861" href="plfa.CallByName.html#4861" class="Bound">mc&#39;</a> <a id="4865" href="plfa.CallByName.html#4865" class="Bound">mc&#39;&#39;</a><a id="4869" class="Symbol">)</a>
    <a id="4875" class="Keyword">with</a> <a id="4880" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4889" href="plfa.CallByName.html#4846" class="Bound">mc</a> <a id="4892" href="plfa.CallByName.html#4861" class="Bound">mc&#39;</a>
<a id="4896" class="Symbol">...</a> <a id="4900" class="Symbol">|</a> <a id="4902" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4907" class="Symbol">=</a> <a id="4909" href="/PLFA-zh/CallByName/#4595" class="Function">⇓-determ</a> <a id="4918" class="Bound">mc₁</a> <a id="4922" class="Bound">mc&#39;&#39;</a>
</pre>

<h2 id="big-step-evaluation-implies-beta-reduction-to-a-lambda">Big-step evaluation implies beta reduction to a lambda</h2>

<p>If big-step evaluation produces a value, then the input term can
reduce to a lambda abstraction by beta reduction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
</code></pre></div></div>

<p>The proof is by induction on the big-step derivation. As is often
necessary, one must generalize the statement to get the induction to
go through. In the case for <code class="highlighter-rouge">⇓-app</code> (function application), the
argument is added to the environment, so the environment becomes
non-empty. The corresponding β reduction substitutes the argument into
the body of the lambda abstraction.  So we generalize the lemma to
allow an arbitrary environment <code class="highlighter-rouge">γ</code> and we add a premise that relates
the environment <code class="highlighter-rouge">γ</code> to an equivalent substitution <code class="highlighter-rouge">σ</code>.</p>

<p>The case for <code class="highlighter-rouge">⇓-app</code> also requires that we strengthen the
conclusion. In the case for <code class="highlighter-rouge">⇓-app</code> we have <code class="highlighter-rouge">γ ⊢ L ⇓ clos (λ N) δ</code> and
the induction hypothesis gives us <code class="highlighter-rouge">L —↠ ƛ N′</code>, but we need to know
that <code class="highlighter-rouge">N</code> and <code class="highlighter-rouge">N′</code> are equivalent. In particular, that <code class="highlighter-rouge">N ≡ subst τ N′</code>
where <code class="highlighter-rouge">τ</code> is the substitution that is equivalent to <code class="highlighter-rouge">δ</code>. Therefore we
expand the conclusion of the statement, stating that the results are
equivalent.</p>

<p>We make the two notions of equivalence precise by defining the
following two mutually-recursive predicates <code class="highlighter-rouge">V ≈ M</code> and <code class="highlighter-rouge">γ ≈ₑ σ</code>.</p>

<pre class="Agda"><a id="_≈_"></a><a id="6290" href="/PLFA-zh/CallByName/#6290" class="Function Operator">_≈_</a> <a id="6294" class="Symbol">:</a> <a id="6296" href="plfa.CallByName.html#2458" class="Datatype">Clos</a> <a id="6301" class="Symbol">→</a> <a id="6303" class="Symbol">(</a><a id="6304" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="6306" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="6308" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="6309" class="Symbol">)</a> <a id="6311" class="Symbol">→</a> <a id="6313" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="6317" href="/PLFA-zh/CallByName/#6317" class="Function Operator">_≈ₑ_</a> <a id="6322" class="Symbol">:</a> <a id="6324" class="Symbol">∀{</a><a id="6326" href="plfa.CallByName.html#6326" class="Bound">Γ</a><a id="6327" class="Symbol">}</a> <a id="6329" class="Symbol">→</a> <a id="6331" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="6339" href="plfa.CallByName.html#6326" class="Bound">Γ</a> <a id="6341" class="Symbol">→</a> <a id="6343" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="6349" href="plfa.CallByName.html#6326" class="Bound">Γ</a> <a id="6351" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="6353" class="Symbol">→</a> <a id="6355" class="PrimitiveType">Set</a>

<a id="6360" class="Symbol">(</a><a id="6361" href="/PLFA-zh/CallByName/#2477" class="InductiveConstructor">clos</a> <a id="6366" class="Symbol">{</a><a id="6367" href="plfa.CallByName.html#6367" class="Bound">Γ</a><a id="6368" class="Symbol">}</a> <a id="6370" href="plfa.CallByName.html#6370" class="Bound">M</a> <a id="6372" href="plfa.CallByName.html#6372" class="Bound">γ</a><a id="6373" class="Symbol">)</a> <a id="6375" href="plfa.CallByName.html#6290" class="Function Operator">≈</a> <a id="6377" href="plfa.CallByName.html#6377" class="Bound">N</a> <a id="6379" class="Symbol">=</a> <a id="6381" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="6384" href="plfa.CallByName.html#6384" class="Bound">σ</a> <a id="6386" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="6388" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="6394" href="plfa.CallByName.html#6367" class="Bound">Γ</a> <a id="6396" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="6398" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="6400" href="plfa.CallByName.html#6372" class="Bound">γ</a> <a id="6402" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="6405" href="plfa.CallByName.html#6384" class="Bound">σ</a> <a id="6407" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="6409" class="Symbol">(</a><a id="6410" href="plfa.CallByName.html#6377" class="Bound">N</a> <a id="6412" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="6414" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="6420" href="plfa.CallByName.html#6384" class="Bound">σ</a> <a id="6422" href="plfa.CallByName.html#6370" class="Bound">M</a><a id="6423" class="Symbol">)</a>

<a id="6426" href="/PLFA-zh/CallByName/#6426" class="Bound">γ</a> <a id="6428" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="6431" href="plfa.CallByName.html#6431" class="Bound">σ</a> <a id="6433" class="Symbol">=</a> <a id="6435" class="Symbol">∀{</a><a id="6437" href="plfa.CallByName.html#6437" class="Bound">x</a><a id="6438" class="Symbol">}</a> <a id="6440" class="Symbol">→</a> <a id="6442" class="Symbol">(</a><a id="6443" href="plfa.CallByName.html#6426" class="Bound">γ</a> <a id="6445" href="plfa.CallByName.html#6437" class="Bound">x</a><a id="6446" class="Symbol">)</a> <a id="6448" href="plfa.CallByName.html#6290" class="Function Operator">≈</a> <a id="6450" class="Symbol">(</a><a id="6451" href="plfa.CallByName.html#6431" class="Bound">σ</a> <a id="6453" href="plfa.CallByName.html#6437" class="Bound">x</a><a id="6454" class="Symbol">)</a>
</pre>
<p>We can now state the main lemma:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
then  subst σ M —↠ N  and  V ≈ N  for some N.
</code></pre></div></div>

<p>Before starting the proof, we establish a couple lemmas
about equivalent environments and substitutions.</p>

<p>The empty environment is equivalent to the identity substitution
<code class="highlighter-rouge">ids</code>, which we import from Chapter <a href="/PLFA-zh/Substitution/">Substitution</a>.</p>

<pre class="Agda"><a id="≈ₑ-id"></a><a id="6839" href="/PLFA-zh/CallByName/#6839" class="Function">≈ₑ-id</a> <a id="6845" class="Symbol">:</a> <a id="6847" href="plfa.CallByName.html#2641" class="Function">∅&#39;</a> <a id="6850" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="6853" href="/PLFA-zh/Substitution/#3087" class="Function">ids</a>
<a id="6857" href="/PLFA-zh/CallByName/#6839" class="Function">≈ₑ-id</a> <a id="6863" class="Symbol">{()}</a>
</pre>
<p>Of course, applying the identity substitution to a term returns
the same term.</p>

<pre class="Agda"><a id="sub-id"></a><a id="6957" href="/PLFA-zh/CallByName/#6957" class="Function">sub-id</a> <a id="6964" class="Symbol">:</a> <a id="6966" class="Symbol">∀{</a><a id="6968" href="plfa.CallByName.html#6968" class="Bound">Γ</a><a id="6969" class="Symbol">}</a> <a id="6971" class="Symbol">{</a><a id="6972" href="plfa.CallByName.html#6972" class="Bound">A</a><a id="6973" class="Symbol">}</a> <a id="6975" class="Symbol">{</a><a id="6976" href="plfa.CallByName.html#6976" class="Bound">M</a> <a id="6978" class="Symbol">:</a> <a id="6980" href="plfa.CallByName.html#6968" class="Bound">Γ</a> <a id="6982" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="6984" href="plfa.CallByName.html#6972" class="Bound">A</a><a id="6985" class="Symbol">}</a>
         <a id="6996" class="Symbol">→</a> <a id="6998" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="7004" href="/PLFA-zh/Substitution/#3087" class="Function">ids</a> <a id="7008" href="/PLFA-zh/CallByName/#6976" class="Bound">M</a> <a id="7010" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="7012" href="plfa.CallByName.html#6976" class="Bound">M</a>
<a id="7014" href="/PLFA-zh/CallByName/#6957" class="Function">sub-id</a> <a id="7021" class="Symbol">=</a> <a id="7023" href="/PLFA-zh/Substitution/#17027" class="Function">plfa.Substitution.sub-id</a>
</pre>

<p>We define an auxilliary function for extending a substitution.</p>

<pre class="Agda"><a id="ext-subst"></a><a id="7122" href="/PLFA-zh/CallByName/#7122" class="Function">ext-subst</a> <a id="7132" class="Symbol">:</a> <a id="7134" class="Symbol">∀{</a><a id="7136" href="plfa.CallByName.html#7136" class="Bound">Γ</a> <a id="7138" href="plfa.CallByName.html#7138" class="Bound">Δ</a><a id="7139" class="Symbol">}</a> <a id="7141" class="Symbol">→</a> <a id="7143" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="7149" href="plfa.CallByName.html#7136" class="Bound">Γ</a> <a id="7151" href="plfa.CallByName.html#7138" class="Bound">Δ</a> <a id="7153" class="Symbol">→</a> <a id="7155" href="plfa.CallByName.html#7138" class="Bound">Δ</a> <a id="7157" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="7159" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="7161" class="Symbol">→</a> <a id="7163" href="plfa.Substitution.html#2446" class="Function">Subst</a> <a id="7169" class="Symbol">(</a><a id="7170" href="plfa.CallByName.html#7136" class="Bound">Γ</a> <a id="7172" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">,</a> <a id="7174" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="7175" class="Symbol">)</a> <a id="7177" href="plfa.CallByName.html#7138" class="Bound">Δ</a>
<a id="7179" href="/PLFA-zh/CallByName/#7122" class="Function">ext-subst</a><a id="7188" class="Symbol">{</a><a id="7189" href="plfa.CallByName.html#7189" class="Bound">Γ</a><a id="7190" class="Symbol">}{</a><a id="7192" href="plfa.CallByName.html#7192" class="Bound">Δ</a><a id="7193" class="Symbol">}</a> <a id="7195" href="plfa.CallByName.html#7195" class="Bound">σ</a> <a id="7197" href="plfa.CallByName.html#7197" class="Bound">N</a> <a id="7199" class="Symbol">{</a><a id="7200" href="plfa.CallByName.html#7200" class="Bound">A</a><a id="7201" class="Symbol">}</a> <a id="7203" class="Symbol">=</a> <a id="7205" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="7211" class="Symbol">(</a><a id="7212" href="plfa.Untyped.html#7333" class="Function">subst-zero</a> <a id="7223" href="plfa.CallByName.html#7197" class="Bound">N</a><a id="7224" class="Symbol">)</a> <a id="7226" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7228" href="plfa.Untyped.html#6629" class="Function">exts</a> <a id="7233" href="plfa.CallByName.html#7195" class="Bound">σ</a>
</pre>
<p>The next lemma we need to prove states that if you start with an
equivalent environment and substitution <code class="highlighter-rouge">γ ≈ₑ σ</code>, extending them with
an equivalent closure and term <code class="highlighter-rouge">c ≈ N</code> produces an equivalent
environment and substitution: <code class="highlighter-rouge">(γ ,' V) ≈ₑ (ext-subst σ N)</code>,
or equivalently, <code class="highlighter-rouge">(γ ,' V) x ≈ₑ (ext-subst σ N) x</code> for any
variable <code class="highlighter-rouge">x</code>. The proof will be by induction on <code class="highlighter-rouge">x</code> and
for the induction step we need the following lemma,
which states that applying the composition of <code class="highlighter-rouge">exts σ</code>
and <code class="highlighter-rouge">subst-zero</code> to <code class="highlighter-rouge">S x</code> is the same as just <code class="highlighter-rouge">σ x</code>,
which is a corollary of a theorem in
Chapter <a href="/PLFA-zh/Substitution/">Substitution</a>.</p>

<pre class="Agda"><a id="subst-zero-exts"></a><a id="7873" href="/PLFA-zh/CallByName/#7873" class="Function">subst-zero-exts</a> <a id="7889" class="Symbol">:</a> <a id="7891" class="Symbol">∀{</a><a id="7893" href="plfa.CallByName.html#7893" class="Bound">Γ</a> <a id="7895" href="plfa.CallByName.html#7895" class="Bound">Δ</a><a id="7896" class="Symbol">}{</a><a id="7898" href="plfa.CallByName.html#7898" class="Bound">σ</a> <a id="7900" class="Symbol">:</a> <a id="7902" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="7908" href="plfa.CallByName.html#7893" class="Bound">Γ</a> <a id="7910" href="plfa.CallByName.html#7895" class="Bound">Δ</a><a id="7911" class="Symbol">}{</a><a id="7913" href="plfa.CallByName.html#7913" class="Bound">B</a><a id="7914" class="Symbol">}{</a><a id="7916" href="plfa.CallByName.html#7916" class="Bound">M</a> <a id="7918" class="Symbol">:</a> <a id="7920" href="plfa.CallByName.html#7895" class="Bound">Δ</a> <a id="7922" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="7924" href="plfa.CallByName.html#7913" class="Bound">B</a><a id="7925" class="Symbol">}{</a><a id="7927" href="plfa.CallByName.html#7927" class="Bound">x</a> <a id="7929" class="Symbol">:</a> <a id="7931" href="plfa.CallByName.html#7893" class="Bound">Γ</a> <a id="7933" href="plfa.Untyped.html#3483" class="Datatype Operator">∋</a> <a id="7935" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="7936" class="Symbol">}</a>
                <a id="7954" class="Symbol">→</a> <a id="7956" class="Symbol">(</a><a id="7957" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="7963" class="Symbol">(</a><a id="7964" href="plfa.Untyped.html#7333" class="Function">subst-zero</a> <a id="7975" href="/PLFA-zh/CallByName/#7916" class="Bound">M</a><a id="7976" class="Symbol">)</a> <a id="7978" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7980" href="plfa.Untyped.html#6629" class="Function">exts</a> <a id="7985" href="plfa.CallByName.html#7898" class="Bound">σ</a><a id="7986" class="Symbol">)</a> <a id="7988" class="Symbol">(</a><a id="7989" href="plfa.Untyped.html#3564" class="InductiveConstructor Operator">S</a> <a id="7991" href="plfa.CallByName.html#7927" class="Bound">x</a><a id="7992" class="Symbol">)</a> <a id="7994" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="7996" href="plfa.CallByName.html#7898" class="Bound">σ</a> <a id="7998" href="plfa.CallByName.html#7927" class="Bound">x</a>
<a id="8000" href="/PLFA-zh/CallByName/#7873" class="Function">subst-zero-exts</a> <a id="8016" class="Symbol">{</a><a id="8017" href="plfa.CallByName.html#8017" class="Bound">Γ</a><a id="8018" class="Symbol">}{</a><a id="8020" href="plfa.CallByName.html#8020" class="Bound">Δ</a><a id="8021" class="Symbol">}{</a><a id="8023" href="plfa.CallByName.html#8023" class="Bound">σ</a><a id="8024" class="Symbol">}{</a><a id="8026" href="plfa.CallByName.html#8026" class="Bound">B</a><a id="8027" class="Symbol">}{</a><a id="8029" href="plfa.CallByName.html#8029" class="Bound">M</a><a id="8030" class="Symbol">}{</a><a id="8032" href="plfa.CallByName.html#8032" class="Bound">x</a><a id="8033" class="Symbol">}</a> <a id="8035" class="Symbol">=</a>
   <a id="8040" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="8049" class="Symbol">(</a><a id="8050" href="/PLFA-zh/Substitution/#25239" class="Function">plfa.Substitution.subst-zero-exts-cons</a><a id="8088" class="Symbol">{</a><a id="8089" class="Argument">σ</a> <a id="8091" class="Symbol">=</a> <a id="8093" href="/PLFA-zh/CallByName/#8023" class="Bound">σ</a><a id="8094" class="Symbol">})</a> <a id="8097" class="Symbol">(</a><a id="8098" href="/PLFA-zh/Untyped/#3564" class="InductiveConstructor Operator">S</a> <a id="8100" href="plfa.CallByName.html#8032" class="Bound">x</a><a id="8101" class="Symbol">)</a>
</pre>
<p>So the proof of <code class="highlighter-rouge">≈ₑ-ext</code> is as follows.</p>

<pre class="Agda"><a id="≈ₑ-ext"></a><a id="8153" href="/PLFA-zh/CallByName/#8153" class="Function">≈ₑ-ext</a> <a id="8160" class="Symbol">:</a> <a id="8162" class="Symbol">∀</a> <a id="8164" class="Symbol">{</a><a id="8165" href="plfa.CallByName.html#8165" class="Bound">Γ</a><a id="8166" class="Symbol">}</a> <a id="8168" class="Symbol">{</a><a id="8169" href="plfa.CallByName.html#8169" class="Bound">γ</a> <a id="8171" class="Symbol">:</a> <a id="8173" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="8181" href="plfa.CallByName.html#8165" class="Bound">Γ</a><a id="8182" class="Symbol">}</a> <a id="8184" class="Symbol">{</a><a id="8185" href="plfa.CallByName.html#8185" class="Bound">σ</a> <a id="8187" class="Symbol">:</a> <a id="8189" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="8195" href="plfa.CallByName.html#8165" class="Bound">Γ</a> <a id="8197" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a><a id="8198" class="Symbol">}</a> <a id="8200" class="Symbol">{</a><a id="8201" href="plfa.CallByName.html#8201" class="Bound">V</a><a id="8202" class="Symbol">}</a> <a id="8204" class="Symbol">{</a><a id="8205" href="plfa.CallByName.html#8205" class="Bound">N</a> <a id="8207" class="Symbol">:</a> <a id="8209" href="plfa.Untyped.html#3152" class="InductiveConstructor">∅</a> <a id="8211" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="8213" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="8214" class="Symbol">}</a>
      <a id="8222" class="Symbol">→</a> <a id="8224" href="/PLFA-zh/CallByName/#8169" class="Bound">γ</a> <a id="8226" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="8229" href="plfa.CallByName.html#8185" class="Bound">σ</a>  <a id="8232" class="Symbol">→</a>  <a id="8235" href="plfa.CallByName.html#8201" class="Bound">V</a> <a id="8237" href="plfa.CallByName.html#6290" class="Function Operator">≈</a> <a id="8239" href="plfa.CallByName.html#8205" class="Bound">N</a>
        <a id="8249" class="Comment">--------------------------</a>
      <a id="8282" class="Symbol">→</a> <a id="8284" class="Symbol">(</a><a id="8285" href="/PLFA-zh/CallByName/#8169" class="Bound">γ</a> <a id="8287" href="plfa.CallByName.html#2663" class="Function Operator">,&#39;</a> <a id="8290" href="plfa.CallByName.html#8201" class="Bound">V</a><a id="8291" class="Symbol">)</a> <a id="8293" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="8296" class="Symbol">(</a><a id="8297" href="plfa.CallByName.html#7122" class="Function">ext-subst</a> <a id="8307" href="plfa.CallByName.html#8185" class="Bound">σ</a> <a id="8309" href="plfa.CallByName.html#8205" class="Bound">N</a><a id="8310" class="Symbol">)</a>
<a id="8312" href="/PLFA-zh/CallByName/#8153" class="Function">≈ₑ-ext</a> <a id="8319" class="Symbol">{</a><a id="8320" href="plfa.CallByName.html#8320" class="Bound">Γ</a><a id="8321" class="Symbol">}</a> <a id="8323" class="Symbol">{</a><a id="8324" href="plfa.CallByName.html#8324" class="Bound">γ</a><a id="8325" class="Symbol">}</a> <a id="8327" class="Symbol">{</a><a id="8328" href="plfa.CallByName.html#8328" class="Bound">σ</a><a id="8329" class="Symbol">}</a> <a id="8331" class="Symbol">{</a><a id="8332" href="plfa.CallByName.html#8332" class="Bound">V</a><a id="8333" class="Symbol">}</a> <a id="8335" class="Symbol">{</a><a id="8336" href="plfa.CallByName.html#8336" class="Bound">N</a><a id="8337" class="Symbol">}</a> <a id="8339" href="plfa.CallByName.html#8339" class="Bound">γ≈ₑσ</a> <a id="8344" href="plfa.CallByName.html#8344" class="Bound">V≈N</a> <a id="8348" class="Symbol">{</a><a id="8349" href="/PLFA-zh/Untyped/#3519" class="InductiveConstructor">Z</a><a id="8350" class="Symbol">}</a> <a id="8352" class="Symbol">=</a> <a id="8354" href="plfa.CallByName.html#8344" class="Bound">V≈N</a>
<a id="8358" href="/PLFA-zh/CallByName/#8153" class="Function">≈ₑ-ext</a> <a id="8365" class="Symbol">{</a><a id="8366" href="plfa.CallByName.html#8366" class="Bound">Γ</a><a id="8367" class="Symbol">}</a> <a id="8369" class="Symbol">{</a><a id="8370" href="plfa.CallByName.html#8370" class="Bound">γ</a><a id="8371" class="Symbol">}</a> <a id="8373" class="Symbol">{</a><a id="8374" href="plfa.CallByName.html#8374" class="Bound">σ</a><a id="8375" class="Symbol">}</a> <a id="8377" class="Symbol">{</a><a id="8378" href="plfa.CallByName.html#8378" class="Bound">V</a><a id="8379" class="Symbol">}</a> <a id="8381" class="Symbol">{</a><a id="8382" href="plfa.CallByName.html#8382" class="Bound">N</a><a id="8383" class="Symbol">}</a> <a id="8385" href="plfa.CallByName.html#8385" class="Bound">γ≈ₑσ</a> <a id="8390" href="plfa.CallByName.html#8390" class="Bound">V≈N</a> <a id="8394" class="Symbol">{</a><a id="8395" href="/PLFA-zh/Untyped/#3564" class="InductiveConstructor Operator">S</a> <a id="8397" href="plfa.CallByName.html#8397" class="Bound">x</a><a id="8398" class="Symbol">}</a>
  <a id="8402" class="Keyword">rewrite</a> <a id="8410" href="/PLFA-zh/CallByName/#7873" class="Function">subst-zero-exts</a> <a id="8426" class="Symbol">{</a><a id="8427" class="Argument">σ</a> <a id="8429" class="Symbol">=</a> <a id="8431" href="plfa.CallByName.html#8374" class="Bound">σ</a><a id="8432" class="Symbol">}{</a><a id="8434" class="Argument">M</a> <a id="8436" class="Symbol">=</a> <a id="8438" href="plfa.CallByName.html#8382" class="Bound">N</a><a id="8439" class="Symbol">}{</a><a id="8441" href="plfa.CallByName.html#8397" class="Bound">x</a><a id="8442" class="Symbol">}</a> <a id="8444" class="Symbol">=</a> <a id="8446" href="plfa.CallByName.html#8385" class="Bound">γ≈ₑσ</a>
</pre>
<p>We proceed by induction on the input variable.</p>

<ul>
  <li>
    <p>If it is <code class="highlighter-rouge">Z</code>, then we immediately conclude using the
premise <code class="highlighter-rouge">V ≈ N</code>.</p>
  </li>
  <li>
    <p>If it is <code class="highlighter-rouge">S x</code>, then we rewrite using the
<code class="highlighter-rouge">subst-zero-exts</code> lemma and use the premise <code class="highlighter-rouge">γ ≈ₑ σ</code>
to conclude.</p>
  </li>
</ul>

<p>To prove the main lemma, we need another technical lemma about
substitution. Applying one substitution after another is the same as
composing the two substitutions and then applying them.</p>

<pre class="Agda"><a id="sub-sub"></a><a id="8888" href="/PLFA-zh/CallByName/#8888" class="Function">sub-sub</a> <a id="8896" class="Symbol">:</a> <a id="8898" class="Symbol">∀{</a><a id="8900" href="plfa.CallByName.html#8900" class="Bound">Γ</a> <a id="8902" href="plfa.CallByName.html#8902" class="Bound">Δ</a> <a id="8904" href="plfa.CallByName.html#8904" class="Bound">Σ</a><a id="8905" class="Symbol">}{</a><a id="8907" href="plfa.CallByName.html#8907" class="Bound">A</a><a id="8908" class="Symbol">}{</a><a id="8910" href="plfa.CallByName.html#8910" class="Bound">M</a> <a id="8912" class="Symbol">:</a> <a id="8914" href="plfa.CallByName.html#8900" class="Bound">Γ</a> <a id="8916" href="/PLFA-zh/Untyped/#4252" class="Datatype Operator">⊢</a> <a id="8918" href="plfa.CallByName.html#8907" class="Bound">A</a><a id="8919" class="Symbol">}</a> <a id="8921" class="Symbol">{</a><a id="8922" href="plfa.CallByName.html#8922" class="Bound">σ₁</a> <a id="8925" class="Symbol">:</a> <a id="8927" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="8933" href="plfa.CallByName.html#8900" class="Bound">Γ</a> <a id="8935" href="plfa.CallByName.html#8902" class="Bound">Δ</a><a id="8936" class="Symbol">}{</a><a id="8938" href="plfa.CallByName.html#8938" class="Bound">σ₂</a> <a id="8941" class="Symbol">:</a> <a id="8943" href="plfa.Substitution.html#2446" class="Function">Subst</a> <a id="8949" href="plfa.CallByName.html#8902" class="Bound">Δ</a> <a id="8951" href="plfa.CallByName.html#8904" class="Bound">Σ</a><a id="8952" class="Symbol">}</a>
            <a id="8966" class="Symbol">→</a> <a id="8968" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="8974" href="/PLFA-zh/CallByName/#8938" class="Bound">σ₂</a> <a id="8977" class="Symbol">(</a><a id="8978" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="8984" href="plfa.CallByName.html#8922" class="Bound">σ₁</a> <a id="8987" href="plfa.CallByName.html#8910" class="Bound">M</a><a id="8988" class="Symbol">)</a> <a id="8990" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8992" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="8998" class="Symbol">(</a><a id="8999" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="9005" href="plfa.CallByName.html#8938" class="Bound">σ₂</a> <a id="9008" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="9010" href="plfa.CallByName.html#8922" class="Bound">σ₁</a><a id="9012" class="Symbol">)</a> <a id="9014" href="plfa.CallByName.html#8910" class="Bound">M</a>
<a id="9016" href="/PLFA-zh/CallByName/#8888" class="Function">sub-sub</a> <a id="9024" class="Symbol">{</a><a id="9025" class="Argument">M</a> <a id="9027" class="Symbol">=</a> <a id="9029" href="plfa.CallByName.html#9029" class="Bound">M</a><a id="9030" class="Symbol">}</a> <a id="9032" class="Symbol">=</a> <a id="9034" href="/PLFA-zh/Substitution/#23016" class="Function">plfa.Substitution.sub-sub</a> <a id="9060" class="Symbol">{</a><a id="9061" class="Argument">M</a> <a id="9063" class="Symbol">=</a> <a id="9065" href="plfa.CallByName.html#9029" class="Bound">M</a><a id="9066" class="Symbol">}</a>
</pre>
<p>We arive at the main lemma: if <code class="highlighter-rouge">M</code> big steps to a
closure <code class="highlighter-rouge">V</code> in environment <code class="highlighter-rouge">γ</code>, and if <code class="highlighter-rouge">γ ≈ₑ σ</code>, then <code class="highlighter-rouge">subst σ M</code> reduces
to some term <code class="highlighter-rouge">N</code> that is equivalent to <code class="highlighter-rouge">V</code>. We describe the proof
below.</p>

<pre class="Agda"><a id="⇓→—↠×𝔹"></a><a id="9275" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a> <a id="9282" class="Symbol">:</a> <a id="9284" class="Symbol">∀{</a><a id="9286" href="plfa.CallByName.html#9286" class="Bound">Γ</a><a id="9287" class="Symbol">}{</a><a id="9289" href="plfa.CallByName.html#9289" class="Bound">γ</a> <a id="9291" class="Symbol">:</a> <a id="9293" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="9301" href="plfa.CallByName.html#9286" class="Bound">Γ</a><a id="9302" class="Symbol">}{</a><a id="9304" href="plfa.CallByName.html#9304" class="Bound">σ</a> <a id="9306" class="Symbol">:</a> <a id="9308" href="/PLFA-zh/Substitution/#2446" class="Function">Subst</a> <a id="9314" href="plfa.CallByName.html#9286" class="Bound">Γ</a> <a id="9316" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a><a id="9317" class="Symbol">}{</a><a id="9319" href="plfa.CallByName.html#9319" class="Bound">M</a> <a id="9321" class="Symbol">:</a> <a id="9323" href="plfa.CallByName.html#9286" class="Bound">Γ</a> <a id="9325" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="9327" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="9328" class="Symbol">}{</a><a id="9330" href="plfa.CallByName.html#9330" class="Bound">V</a> <a id="9332" class="Symbol">:</a> <a id="9334" href="plfa.CallByName.html#2458" class="Datatype">Clos</a><a id="9338" class="Symbol">}</a>
       <a id="9347" class="Symbol">→</a> <a id="9349" href="/PLFA-zh/CallByName/#9289" class="Bound">γ</a> <a id="9351" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="9353" href="plfa.CallByName.html#9319" class="Bound">M</a> <a id="9355" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="9357" href="plfa.CallByName.html#9330" class="Bound">V</a>  <a id="9360" class="Symbol">→</a>  <a id="9363" href="plfa.CallByName.html#9289" class="Bound">γ</a> <a id="9365" href="plfa.CallByName.html#6317" class="Function Operator">≈ₑ</a> <a id="9368" href="plfa.CallByName.html#9304" class="Bound">σ</a>
         <a id="9379" class="Comment">---------------------------------------</a>
       <a id="9426" class="Symbol">→</a> <a id="9428" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="9431" href="/PLFA-zh/CallByName/#9431" class="Bound">N</a> <a id="9433" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="9435" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="9437" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="9439" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="9441" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="9443" class="Symbol">(</a><a id="9444" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="9450" href="plfa.CallByName.html#9304" class="Bound">σ</a> <a id="9452" href="plfa.CallByName.html#9319" class="Bound">M</a> <a id="9454" href="plfa.Untyped.html#11203" class="Datatype Operator">—↠</a> <a id="9457" href="plfa.CallByName.html#9431" class="Bound">N</a><a id="9458" class="Symbol">)</a> <a id="9460" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="9462" href="plfa.CallByName.html#9330" class="Bound">V</a> <a id="9464" href="plfa.CallByName.html#6290" class="Function Operator">≈</a> <a id="9466" href="plfa.CallByName.html#9431" class="Bound">N</a>
<a id="9468" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a> <a id="9475" class="Symbol">{</a><a id="9476" class="Argument">γ</a> <a id="9478" class="Symbol">=</a> <a id="9480" href="plfa.CallByName.html#9480" class="Bound">γ</a><a id="9481" class="Symbol">}</a> <a id="9483" class="Symbol">(</a><a id="9484" href="plfa.CallByName.html#3069" class="InductiveConstructor">⇓-var</a><a id="9489" class="Symbol">{</a><a id="9490" class="Argument">x</a> <a id="9492" class="Symbol">=</a> <a id="9494" href="plfa.CallByName.html#9494" class="Bound">x</a><a id="9495" class="Symbol">}</a> <a id="9497" href="plfa.CallByName.html#9497" class="Bound">γx≡Lδ</a> <a id="9503" href="plfa.CallByName.html#9503" class="Bound">δ⊢L⇓V</a><a id="9508" class="Symbol">)</a> <a id="9510" href="plfa.CallByName.html#9510" class="Bound">γ≈ₑσ</a>
    <a id="9519" class="Keyword">with</a> <a id="9524" href="/PLFA-zh/CallByName/#9480" class="Bound">γ</a> <a id="9526" href="plfa.CallByName.html#9494" class="Bound">x</a> <a id="9528" class="Symbol">|</a> <a id="9530" href="plfa.CallByName.html#9510" class="Bound">γ≈ₑσ</a> <a id="9535" class="Symbol">{</a><a id="9536" href="plfa.CallByName.html#9494" class="Bound">x</a><a id="9537" class="Symbol">}</a> <a id="9539" class="Symbol">|</a> <a id="9541" href="plfa.CallByName.html#9497" class="Bound">γx≡Lδ</a>
<a id="9547" class="Symbol">...</a> <a id="9551" class="Symbol">|</a> <a id="9553" href="/PLFA-zh/CallByName/#2477" class="InductiveConstructor">clos</a> <a id="9558" href="plfa.CallByName.html#9558" class="Bound">L</a> <a id="9560" href="plfa.CallByName.html#9560" class="Bound">δ</a> <a id="9562" class="Symbol">|</a> <a id="9564" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9566" href="plfa.CallByName.html#9566" class="Bound">τ</a> <a id="9568" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9570" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9572" href="plfa.CallByName.html#9572" class="Bound">δ≈ₑτ</a> <a id="9577" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9579" href="plfa.CallByName.html#9579" class="Bound">σx≡τL</a> <a id="9585" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9587" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9589" class="Symbol">|</a> <a id="9591" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
    <a id="9600" class="Keyword">with</a> <a id="9605" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a><a id="9611" class="Symbol">{</a><a id="9612" class="Argument">σ</a> <a id="9614" class="Symbol">=</a> <a id="9616" href="plfa.CallByName.html#9566" class="Bound">τ</a><a id="9617" class="Symbol">}</a> <a id="9619" class="Bound">δ⊢L⇓V</a> <a id="9625" href="plfa.CallByName.html#9572" class="Bound">δ≈ₑτ</a>
<a id="9630" class="Symbol">...</a> <a id="9634" class="Symbol">|</a> <a id="9636" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9638" href="/PLFA-zh/CallByName/#9638" class="Bound">N</a> <a id="9640" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9642" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9644" href="plfa.CallByName.html#9644" class="Bound">τL—↠N</a> <a id="9650" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9652" href="plfa.CallByName.html#9652" class="Bound">V≈N</a> <a id="9656" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9658" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9660" class="Keyword">rewrite</a> <a id="9668" class="Bound">σx≡τL</a> <a id="9674" class="Symbol">=</a>
      <a id="9682" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9684" href="/PLFA-zh/CallByName/#9638" class="Bound">N</a> <a id="9686" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9688" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9690" href="plfa.CallByName.html#9644" class="Bound">τL—↠N</a> <a id="9696" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9698" href="plfa.CallByName.html#9652" class="Bound">V≈N</a> <a id="9702" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9704" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9706" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a> <a id="9713" class="Symbol">{</a><a id="9714" class="Argument">σ</a> <a id="9716" class="Symbol">=</a> <a id="9718" href="plfa.CallByName.html#9718" class="Bound">σ</a><a id="9719" class="Symbol">}</a> <a id="9721" class="Symbol">{</a><a id="9722" class="Argument">V</a> <a id="9724" class="Symbol">=</a> <a id="9726" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="9731" class="Symbol">(</a><a id="9732" href="/PLFA-zh/Untyped/#4340" class="InductiveConstructor Operator">ƛ</a> <a id="9734" href="plfa.CallByName.html#9734" class="Bound">N</a><a id="9735" class="Symbol">)</a> <a id="9737" href="plfa.CallByName.html#9737" class="Bound">γ</a><a id="9738" class="Symbol">}</a> <a id="9740" href="plfa.CallByName.html#3232" class="InductiveConstructor">⇓-lam</a> <a id="9746" href="plfa.CallByName.html#9746" class="Bound">γ≈ₑσ</a> <a id="9751" class="Symbol">=</a>
    <a id="9757" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9759" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="9765" href="/PLFA-zh/CallByName/#9718" class="Bound">σ</a> <a id="9767" class="Symbol">(</a><a id="9768" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ</a> <a id="9770" href="plfa.CallByName.html#9734" class="Bound">N</a><a id="9771" class="Symbol">)</a> <a id="9773" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9775" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9777" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="9783" href="plfa.CallByName.html#9718" class="Bound">σ</a> <a id="9785" class="Symbol">(</a><a id="9786" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ</a> <a id="9788" href="plfa.CallByName.html#9734" class="Bound">N</a><a id="9789" class="Symbol">)</a> <a id="9791" href="plfa.Untyped.html#11253" class="InductiveConstructor Operator">∎</a> <a id="9793" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9795" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9797" href="plfa.CallByName.html#9718" class="Bound">σ</a> <a id="9799" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9801" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9803" href="plfa.CallByName.html#9746" class="Bound">γ≈ₑσ</a> <a id="9808" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9810" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="9815" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9817" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9819" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9821" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9823" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a><a id="9829" class="Symbol">{</a><a id="9830" href="plfa.CallByName.html#9830" class="Bound">Γ</a><a id="9831" class="Symbol">}{</a><a id="9833" href="plfa.CallByName.html#9833" class="Bound">γ</a><a id="9834" class="Symbol">}</a> <a id="9836" class="Symbol">{</a><a id="9837" class="Argument">σ</a> <a id="9839" class="Symbol">=</a> <a id="9841" href="plfa.CallByName.html#9841" class="Bound">σ</a><a id="9842" class="Symbol">}</a> <a id="9844" class="Symbol">{</a><a id="9845" href="plfa.CallByName.html#9845" class="Bound">L</a> <a id="9847" href="/PLFA-zh/Untyped/#4400" class="InductiveConstructor Operator">·</a> <a id="9849" href="plfa.CallByName.html#9849" class="Bound">M</a><a id="9850" class="Symbol">}</a> <a id="9852" class="Symbol">{</a><a id="9853" href="plfa.CallByName.html#9853" class="Bound">V</a><a id="9854" class="Symbol">}</a> <a id="9856" class="Symbol">(</a><a id="9857" href="plfa.CallByName.html#3311" class="InductiveConstructor">⇓-app</a> <a id="9863" class="Symbol">{</a><a id="9864" class="Argument">N</a> <a id="9866" class="Symbol">=</a> <a id="9868" href="plfa.CallByName.html#9868" class="Bound">N</a><a id="9869" class="Symbol">}</a> <a id="9871" href="plfa.CallByName.html#9871" class="Bound">L⇓ƛNδ</a> <a id="9877" href="plfa.CallByName.html#9877" class="Bound">N⇓V</a><a id="9880" class="Symbol">)</a> <a id="9882" href="plfa.CallByName.html#9882" class="Bound">γ≈ₑσ</a>
    <a id="9891" class="Keyword">with</a> <a id="9896" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a><a id="9902" class="Symbol">{</a><a id="9903" class="Argument">σ</a> <a id="9905" class="Symbol">=</a> <a id="9907" href="plfa.CallByName.html#9841" class="Bound">σ</a><a id="9908" class="Symbol">}</a> <a id="9910" href="plfa.CallByName.html#9871" class="Bound">L⇓ƛNδ</a> <a id="9916" href="plfa.CallByName.html#9882" class="Bound">γ≈ₑσ</a>
<a id="9921" class="Symbol">...</a> <a id="9925" class="Symbol">|</a> <a id="9927" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9929" class="Symbol">_</a> <a id="9931" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9933" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9935" href="/PLFA-zh/CallByName/#9935" class="Bound">σL—↠ƛτN</a> <a id="9943" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9945" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9947" href="plfa.CallByName.html#9947" class="Bound">τ</a> <a id="9949" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9951" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9953" href="plfa.CallByName.html#9953" class="Bound">δ≈ₑτ</a> <a id="9958" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9960" href="plfa.CallByName.html#9960" class="Bound">≡ƛτN</a> <a id="9965" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9967" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9969" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9971" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9973" class="Keyword">rewrite</a> <a id="9981" href="plfa.CallByName.html#9960" class="Bound">≡ƛτN</a>
    <a id="9990" class="Keyword">with</a> <a id="9995" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a> <a id="10002" class="Symbol">{</a><a id="10003" class="Argument">σ</a> <a id="10005" class="Symbol">=</a> <a id="10007" href="plfa.CallByName.html#7122" class="Function">ext-subst</a> <a id="10017" href="plfa.CallByName.html#9947" class="Bound">τ</a> <a id="10019" class="Symbol">(</a><a id="10020" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="10026" class="Bound">σ</a> <a id="10028" class="Bound">M</a><a id="10029" class="Symbol">)}</a> <a id="10032" class="Bound">N⇓V</a>
           <a id="10047" class="Symbol">(λ</a> <a id="10050" class="Symbol">{</a><a id="10051" href="/PLFA-zh/CallByName/#10051" class="Bound">x</a><a id="10052" class="Symbol">}</a> <a id="10054" class="Symbol">→</a> <a id="10056" href="plfa.CallByName.html#8153" class="Function">≈ₑ-ext</a><a id="10062" class="Symbol">{</a><a id="10063" class="Argument">σ</a> <a id="10065" class="Symbol">=</a> <a id="10067" href="plfa.CallByName.html#9947" class="Bound">τ</a><a id="10068" class="Symbol">}</a> <a id="10070" href="plfa.CallByName.html#9953" class="Bound">δ≈ₑτ</a> <a id="10075" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10077" class="Bound">σ</a> <a id="10079" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10081" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10083" class="Bound">γ≈ₑσ</a> <a id="10088" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10090" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10095" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10097" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10099" class="Symbol">{</a><a id="10100" href="plfa.CallByName.html#10051" class="Bound">x</a><a id="10101" class="Symbol">})</a>
       <a id="10111" class="Symbol">|</a> <a id="10113" href="/PLFA-zh/Untyped/#10335" class="InductiveConstructor">β</a><a id="10114" class="Symbol">{</a><a id="10115" href="plfa.Untyped.html#3152" class="InductiveConstructor">∅</a><a id="10116" class="Symbol">}{</a><a id="10118" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="10124" class="Symbol">(</a><a id="10125" href="plfa.Untyped.html#6629" class="Function">exts</a> <a id="10130" href="/PLFA-zh/CallByName/#9947" class="Bound">τ</a><a id="10131" class="Symbol">)</a> <a id="10133" class="Bound">N</a><a id="10134" class="Symbol">}{</a><a id="10136" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="10142" class="Bound">σ</a> <a id="10144" class="Bound">M</a><a id="10145" class="Symbol">}</a>
<a id="10147" class="Symbol">...</a> <a id="10151" class="Symbol">|</a> <a id="10153" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10155" href="/PLFA-zh/CallByName/#10155" class="Bound">N&#39;</a> <a id="10158" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10160" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10162" href="plfa.CallByName.html#10162" class="Bound">—↠N&#39;</a> <a id="10167" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10169" href="plfa.CallByName.html#10169" class="Bound">V≈N&#39;</a> <a id="10174" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10176" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10178" class="Symbol">|</a> <a id="10180" href="plfa.CallByName.html#10180" class="Bound">ƛτN·σM—→</a>
    <a id="10193" class="Keyword">rewrite</a> <a id="10201" href="/PLFA-zh/CallByName/#8888" class="Function">sub-sub</a><a id="10208" class="Symbol">{</a><a id="10209" class="Argument">M</a> <a id="10211" class="Symbol">=</a> <a id="10213" class="Bound">N</a><a id="10214" class="Symbol">}{</a><a id="10216" class="Argument">σ₁</a> <a id="10219" class="Symbol">=</a> <a id="10221" href="/PLFA-zh/Untyped/#6629" class="Function">exts</a> <a id="10226" class="Bound">τ</a><a id="10227" class="Symbol">}{</a><a id="10229" class="Argument">σ₂</a> <a id="10232" class="Symbol">=</a> <a id="10234" href="plfa.Untyped.html#7333" class="Function">subst-zero</a> <a id="10245" class="Symbol">(</a><a id="10246" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="10252" class="Bound">σ</a> <a id="10254" class="Bound">M</a><a id="10255" class="Symbol">)}</a> <a id="10258" class="Symbol">=</a>
    <a id="10264" class="Keyword">let</a> <a id="10268" href="/PLFA-zh/CallByName/#10268" class="Bound">rs</a> <a id="10271" class="Symbol">=</a> <a id="10273" class="Symbol">(</a><a id="10274" href="/PLFA-zh/Untyped/#4340" class="InductiveConstructor Operator">ƛ</a> <a id="10276" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="10282" class="Symbol">(</a><a id="10283" href="plfa.Untyped.html#6629" class="Function">exts</a> <a id="10288" class="Bound">τ</a><a id="10289" class="Symbol">)</a> <a id="10291" class="Bound">N</a><a id="10292" class="Symbol">)</a> <a id="10294" href="plfa.Untyped.html#4400" class="InductiveConstructor Operator">·</a> <a id="10296" href="plfa.Untyped.html#6921" class="Function">subst</a> <a id="10302" class="Bound">σ</a> <a id="10304" class="Bound">M</a> <a id="10306" href="plfa.Untyped.html#11309" class="InductiveConstructor Operator">—→⟨</a> <a id="10310" href="plfa.CallByName.html#10180" class="Bound">ƛτN·σM—→</a> <a id="10319" href="plfa.Untyped.html#11309" class="InductiveConstructor Operator">⟩</a> <a id="10321" href="plfa.CallByName.html#10162" class="Bound">—↠N&#39;</a> <a id="10326" class="Keyword">in</a>
    <a id="10333" class="Keyword">let</a> <a id="10337" href="/PLFA-zh/CallByName/#10337" class="Bound">g</a> <a id="10339" class="Symbol">=</a> <a id="10341" href="/PLFA-zh/Untyped/#21544" class="Function">—↠-trans</a> <a id="10350" class="Symbol">(</a><a id="10351" href="plfa.Untyped.html#22728" class="Function">appL-cong</a> <a id="10361" class="Bound">σL—↠ƛτN</a><a id="10368" class="Symbol">)</a> <a id="10370" href="plfa.CallByName.html#10268" class="Bound">rs</a> <a id="10373" class="Keyword">in</a>
    <a id="10380" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10382" href="/PLFA-zh/CallByName/#10155" class="Bound">N&#39;</a> <a id="10385" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10387" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10389" href="plfa.CallByName.html#10337" class="Bound">g</a> <a id="10391" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10393" href="plfa.CallByName.html#10169" class="Bound">V≈N&#39;</a> <a id="10398" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10400" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre>
<p>The proof is by induction on <code class="highlighter-rouge">γ ⊢ M ⇓ V</code>. We have three cases
to consider.</p>

<ul>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-var</code>.
So we have <code class="highlighter-rouge">γ x ≡ clos L δ</code> and <code class="highlighter-rouge">δ ⊢ L ⇓ V</code>.
We need to show that <code class="highlighter-rouge">subst σ x —↠ N</code> and <code class="highlighter-rouge">V ≈ N</code> for some <code class="highlighter-rouge">N</code>.
The premise <code class="highlighter-rouge">γ ≈ₑ σ</code> tells us that <code class="highlighter-rouge">γ x ≈ σ x</code>, so <code class="highlighter-rouge">clos L δ ≈ σ x</code>.
By the definition of <code class="highlighter-rouge">≈</code>, there exists a <code class="highlighter-rouge">τ</code> such that
<code class="highlighter-rouge">δ ≈ₑ τ</code> and <code class="highlighter-rouge">σ x ≡ subst τ L </code>.
Using <code class="highlighter-rouge">δ ⊢ L ⇓ V</code> and <code class="highlighter-rouge">δ ≈ₑ τ</code>,
the induction hypothesis gives us
<code class="highlighter-rouge">subst τ L —↠ N</code> and <code class="highlighter-rouge">V ≈ N</code> for some <code class="highlighter-rouge">N</code>.
So we have shown that <code class="highlighter-rouge">subst σ x —↠ N</code> and <code class="highlighter-rouge">V ≈ N</code> for some <code class="highlighter-rouge">N</code>.</p>
  </li>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-lam</code>.
We immediately have <code class="highlighter-rouge">subst σ (ƛ N) —↠ subst σ (ƛ N)</code>
and <code class="highlighter-rouge">clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)</code>.</p>
  </li>
  <li>
    <p>Case <code class="highlighter-rouge">⇓-app</code>.
Using <code class="highlighter-rouge">γ ⊢ L ⇓ clos N δ</code> and <code class="highlighter-rouge">γ ≈ₑ σ</code>,
the induction hypothesis gives us</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L —↠ ƛ subst (exts τ) N                                     (1)
</code></pre></div>    </div>

    <p>and <code class="highlighter-rouge">δ ≈ₑ τ</code> for some <code class="highlighter-rouge">τ</code>.
From <code class="highlighter-rouge">γ≈ₑσ</code> we have <code class="highlighter-rouge">clos M γ ≈ subst σ M</code>.
Then with <code class="highlighter-rouge">(δ ,' clos M γ) ⊢ N ⇓ V</code>,
the induction hypothesis gives us <code class="highlighter-rouge">V ≈ N'</code> and</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)
</code></pre></div>    </div>

    <p>Meanwhile, by <code class="highlighter-rouge">β</code>, we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)
</code></pre></div>    </div>

    <p>which is the same as the following, by <code class="highlighter-rouge">sub-sub</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)
</code></pre></div>    </div>

    <p>Using (3) and (2) we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)
</code></pre></div>    </div>

    <p>From (1) we have</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M
</code></pre></div>    </div>

    <p>which we combine with (4) to conclude that</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ N'
</code></pre></div>    </div>
  </li>
</ul>

<p>With the main lemma complete, we establish the forward direction
of the equivalence between the big-step semantics and beta reduction.</p>

<pre class="Agda"><a id="cbn→reduce"></a><a id="12222" href="/PLFA-zh/CallByName/#12222" class="Function">cbn→reduce</a> <a id="12233" class="Symbol">:</a>  <a id="12236" class="Symbol">∀{</a><a id="12238" href="plfa.CallByName.html#12238" class="Bound">M</a> <a id="12240" class="Symbol">:</a> <a id="12242" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="12244" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="12246" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="12247" class="Symbol">}{</a><a id="12249" href="plfa.CallByName.html#12249" class="Bound">Δ</a><a id="12250" class="Symbol">}{</a><a id="12252" href="plfa.CallByName.html#12252" class="Bound">δ</a> <a id="12254" class="Symbol">:</a> <a id="12256" href="plfa.CallByName.html#2428" class="Function">ClosEnv</a> <a id="12264" href="plfa.CallByName.html#12249" class="Bound">Δ</a><a id="12265" class="Symbol">}{</a><a id="12267" href="plfa.CallByName.html#12267" class="Bound">N′</a> <a id="12270" class="Symbol">:</a> <a id="12272" href="plfa.CallByName.html#12249" class="Bound">Δ</a> <a id="12274" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">,</a> <a id="12276" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="12278" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="12280" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a><a id="12281" class="Symbol">}</a>
     <a id="12288" class="Symbol">→</a> <a id="12290" href="/PLFA-zh/CallByName/#2641" class="Function">∅&#39;</a> <a id="12293" href="plfa.CallByName.html#3012" class="Datatype Operator">⊢</a> <a id="12295" href="plfa.CallByName.html#12238" class="Bound">M</a> <a id="12297" href="plfa.CallByName.html#3012" class="Datatype Operator">⇓</a> <a id="12299" href="plfa.CallByName.html#2477" class="InductiveConstructor">clos</a> <a id="12304" class="Symbol">(</a><a id="12305" href="/PLFA-zh/Untyped/#4340" class="InductiveConstructor Operator">ƛ</a> <a id="12307" href="plfa.CallByName.html#12267" class="Bound">N′</a><a id="12309" class="Symbol">)</a> <a id="12311" href="plfa.CallByName.html#12252" class="Bound">δ</a>
       <a id="12320" class="Comment">-----------------------------</a>
     <a id="12355" class="Symbol">→</a> <a id="12357" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="12360" href="/PLFA-zh/CallByName/#12360" class="Bound">N</a> <a id="12362" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="12364" href="/PLFA-zh/Untyped/#3152" class="InductiveConstructor">∅</a> <a id="12366" href="plfa.Untyped.html#3168" class="InductiveConstructor Operator">,</a> <a id="12368" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="12370" href="plfa.Untyped.html#4252" class="Datatype Operator">⊢</a> <a id="12372" href="plfa.Untyped.html#2876" class="InductiveConstructor">★</a> <a id="12374" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="12376" class="Symbol">(</a><a id="12377" href="plfa.CallByName.html#12238" class="Bound">M</a> <a id="12379" href="plfa.Untyped.html#11203" class="Datatype Operator">—↠</a> <a id="12382" href="plfa.Untyped.html#4340" class="InductiveConstructor Operator">ƛ</a> <a id="12384" href="plfa.CallByName.html#12360" class="Bound">N</a><a id="12385" class="Symbol">)</a>
<a id="12387" href="/PLFA-zh/CallByName/#12222" class="Function">cbn→reduce</a> <a id="12398" class="Symbol">{</a><a id="12399" href="plfa.CallByName.html#12399" class="Bound">M</a><a id="12400" class="Symbol">}{</a><a id="12402" href="plfa.CallByName.html#12402" class="Bound">Δ</a><a id="12403" class="Symbol">}{</a><a id="12405" href="plfa.CallByName.html#12405" class="Bound">δ</a><a id="12406" class="Symbol">}{</a><a id="12408" href="plfa.CallByName.html#12408" class="Bound">N′</a><a id="12410" class="Symbol">}</a> <a id="12412" href="plfa.CallByName.html#12412" class="Bound">M⇓c</a>
    <a id="12420" class="Keyword">with</a> <a id="12425" href="/PLFA-zh/CallByName/#9275" class="Function">⇓→—↠×𝔹</a><a id="12431" class="Symbol">{</a><a id="12432" class="Argument">σ</a> <a id="12434" class="Symbol">=</a> <a id="12436" href="/PLFA-zh/Substitution/#3087" class="Function">ids</a><a id="12439" class="Symbol">}</a> <a id="12441" href="plfa.CallByName.html#12412" class="Bound">M⇓c</a> <a id="12445" href="plfa.CallByName.html#6839" class="Function">≈ₑ-id</a>
<a id="12451" class="Symbol">...</a> <a id="12455" class="Symbol">|</a> <a id="12457" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12459" href="/PLFA-zh/CallByName/#12459" class="Bound">N</a> <a id="12461" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12463" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12465" href="plfa.CallByName.html#12465" class="Bound">rs</a> <a id="12468" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12470" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12472" href="plfa.CallByName.html#12472" class="Bound">σ</a> <a id="12474" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12476" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12478" href="plfa.CallByName.html#12478" class="Bound">h</a> <a id="12480" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12482" href="plfa.CallByName.html#12482" class="Bound">eq2</a> <a id="12486" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12488" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12490" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12492" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
    <a id="12498" class="Keyword">rewrite</a> <a id="12506" href="/PLFA-zh/CallByName/#6957" class="Function">sub-id</a><a id="12512" class="Symbol">{</a><a id="12513" class="Argument">M</a> <a id="12515" class="Symbol">=</a> <a id="12517" class="Bound">M</a><a id="12518" class="Symbol">}</a> <a id="12520" class="Symbol">|</a> <a id="12522" href="plfa.CallByName.html#12482" class="Bound">eq2</a> <a id="12526" class="Symbol">=</a>
    <a id="12532" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12534" href="/PLFA-zh/Untyped/#6921" class="Function">subst</a> <a id="12540" class="Symbol">(</a><a id="12541" href="plfa.Untyped.html#6629" class="Function">exts</a> <a id="12546" href="/PLFA-zh/CallByName/#12472" class="Bound">σ</a><a id="12547" class="Symbol">)</a> <a id="12549" class="Bound">N′</a> <a id="12552" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12554" href="plfa.CallByName.html#12465" class="Bound">rs</a> <a id="12557" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre>
<h4 id="exercise-big-alt-implies-multi">Exercise <code class="highlighter-rouge">big-alt-implies-multi</code></h4>

<p>Formulate an alternative big-step semantics, of the form <code class="highlighter-rouge">M ↓ N</code>,
for call-by-name that uses substitution instead of environments.
Prove that <code class="highlighter-rouge">M ↓ N</code> implies <code class="highlighter-rouge">M —↠ N</code>.</p>

<pre class="Agda"><a id="12776" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="beta-reduction-to-a-lambda-implies-big-step-evaluation">Beta reduction to a lambda implies big-step evaluation</h2>

<p>The proof of the backward direction, that beta reduction to a lambda
implies that the call-by-name semantics produces a result, is more
difficult to prove. The difficulty stems from reduction proceeding
underneath lambda abstractions via the <code class="highlighter-rouge">ζ</code> rule. The call-by-name
semantics does not reduce under lambda, so a straightforward proof by
induction on the reduction sequence is impossible.  In the article
<em>Call-by-name, call-by-value, and the λ-calculus</em>, Plotkin proves the
theorem in two steps, using two auxilliary reduction relations. The
first step uses a classic technique called Curry-Feys standardisation.
It relies on the notion of <em>standard reduction sequence</em>, which acts
as a half-way point between full beta reduction and call-by-name by
expanding call-by-name to also include reduction underneath
lambda. Plotkin proves that <code class="highlighter-rouge">M</code> reduces to <code class="highlighter-rouge">L</code> if and only if <code class="highlighter-rouge">M</code> is
related to <code class="highlighter-rouge">L</code> by a standard reduction sequence.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 1 (Standardisation)
`M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.
</code></pre></div></div>

<p>Plotkin then introduces <em>left reduction</em>, a small-step version of
call-by-name and uses the above theorem to prove that beta reduction
and left reduction are equivalent in the following sense.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 1
`M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.
</code></pre></div></div>

<p>The second step of the proof connects left reduction to call-by-name
evaluation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 2
`M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`.
</code></pre></div></div>

<p>(Plotkin’s call-by-name evaluator uses substitution instead of
environments, which explains why the environment is omitted in <code class="highlighter-rouge">⊢ M ⇓
ƛ N</code> in the above theorem statement.)</p>

<p>Putting Corollary 1 and Theorem 2 together, Plotkin proves that
call-by-name evaluation is equivalent to beta reduction.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 2
`M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.
</code></pre></div></div>

<p>Plotkin also proves an analogous result for the λᵥ calculus, relating
it to call-by-value evaluation. For a nice exposition of that proof,
we recommend Chapter 5 of <em>Semantics Engineering with PLT Redex</em> by
Felleisen, Findler, and Flatt.</p>

<p>Instead of proving the backwards direction via standardisation, as
sketched above, we defer the proof until after we define a
denotational semantics for the lambda calculus, at which point the
proof of the backwards direction will fall out as a corollary to the
soundness and adequacy of the denotational semantics.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Confluence/">上一章</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/CallByName.lagda.md">源代码</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/PLFA-zh/Denotational/">下一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 语言描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章暂无翻译</h3>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">创作共用-署名 4.0 国际（CC BY 4.0）许可协议</a>授权。<br />
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<!-- Script which draws background for progress tags -->
<script type="text/javascript">
$('span.progress').each(function(){
    const progress = parseInt($(this).text());
    $(this).css({
        'border-style': 'solid',
        'border-radius': '5px',
        'border-width': 'thin',
        'border-color': progress === 100 ? 'limegreen' : 'dimgray',
        'font-size': '70%',
        'padding': '0% 0.5% 0% 0.5%',
        'margin': '0em 0em 0em 0.5em',
        'box-sizing': 'border-box',
        'vertical-align': '10%'
    });
    $(this).text(progress.toString() + " %");
})
</script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">

 // Makes sandwhich menu works
 $('.menu-icon').click(function(){
   $('.trigger').toggle();
 });

 // Script which allows for foldable code blocks
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
