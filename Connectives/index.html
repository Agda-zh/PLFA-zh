<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Connectives</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Connectives: 合取、析取与蕴涵</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Connectives-110" class="Keyword">module</a> <a id="plfa_plfa-part1-Connectives-117" href="../Connectives/#" class="Module">plfa.part1.Connectives</a> <a id="plfa_plfa-part1-Connectives-140" class="Keyword">where</a>
</pre><p>本章节介绍基础的逻辑运算符。我们使用逻辑运算符与数据类型之间的对应关系， 即<strong>命题即类型（Propositions as Types）</strong>原理。</p><ul><li><strong>合取（Conjunction）</strong>即是<strong>积（Product）</strong></li><li><strong>析取（Disjunction）</strong>即是<strong>和（Sum）</strong></li><li><strong>真（True）</strong>即是<strong>单元类型（Unit Type）</strong></li><li><strong>假（False）</strong>即是<strong>空类型（Empty Type）</strong></li><li><strong>蕴涵（Implication）</strong>即是<strong>函数空间（Function Space）</strong></li></ul><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1070" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1077" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Connectives-1115" class="Symbol">as</a> <a id="plfa_plfa-part1-Connectives-1118" class="Module">Eq</a>
<a id="plfa_plfa-part1-Connectives-1121" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1126" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Connectives-1129" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1135" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1136" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Connectives-1139" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1141" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Connectives-1145" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1147" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1152" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Connectives-1167" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1172" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1179" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Connectives-1188" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1194" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1195" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Connectives-1196" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1198" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1203" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1210" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Connectives-1219" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1225" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1226" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Connectives-1229" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1231" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1236" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1243" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Connectives-1266" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1272" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1273" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Connectives-1276" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1278" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11699" class="Record Operator">_≲_</a><a id="plfa_plfa-part1-Connectives-1281" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1283" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Connectives-1297" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1299" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14960" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-1302" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1304" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1309" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10785" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre><h2 id="合取即是积">合取即是积</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其合取 <code>A × B</code> 成立当 <code>A</code> 成立和 <code>B</code> 成立。 我们用一个合适的数据类型将这样的概念形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1644" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_×_"></a><a id="plfa_plfa-part1-Connectives-1649" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">_×_</a> <a id="plfa_plfa-part1-Connectives-1653" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1654" href="../Connectives/#plfa_plfa-part1-Connectives-1654" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1656" href="../Connectives/#plfa_plfa-part1-Connectives-1656" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-1658" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1660" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-1663" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-1665" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1667" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-1671" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_×_.⟨_,_⟩"></a><a id="plfa_plfa-part1-Connectives-1680" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="plfa_plfa-part1-Connectives-1686" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-1694" href="../Connectives/#plfa_plfa-part1-Connectives-1654" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-1700" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1702" href="../Connectives/#plfa_plfa-part1-Connectives-1656" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-1710" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-1720" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1722" href="../Connectives/#plfa_plfa-part1-Connectives-1654" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1724" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-1726" href="../Connectives/#plfa_plfa-part1-Connectives-1656" class="Bound">B</a>
</pre><p><code>A × B</code> 成立的证明由 <code>⟨ M , N ⟩</code> 的形式表现，其中 <code>M</code> 是 <code>A</code> 成立的证明， <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A × B</code> 成立的证明，我们可以得出 <code>A</code> 成立和 <code>B</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-proj₁"></a><a id="plfa_plfa-part1-Connectives-2100" href="../Connectives/#plfa_plfa-part1-Connectives-2100" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2106" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2108" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2110" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2111" href="../Connectives/#plfa_plfa-part1-Connectives-2111" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2113" href="../Connectives/#plfa_plfa-part1-Connectives-2113" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2115" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2117" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2120" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2124" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2126" href="../Connectives/#plfa_plfa-part1-Connectives-2111" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2128" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2130" href="../Connectives/#plfa_plfa-part1-Connectives-2113" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2136" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2144" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2146" href="../Connectives/#plfa_plfa-part1-Connectives-2111" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-2148" href="../Connectives/#plfa_plfa-part1-Connectives-2100" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2154" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2156" href="../Connectives/#plfa_plfa-part1-Connectives-2156" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2158" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2160" href="../Connectives/#plfa_plfa-part1-Connectives-2160" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2162" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2164" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2166" href="../Connectives/#plfa_plfa-part1-Connectives-2156" class="Bound">x</a>

<a id="plfa_plfa-part1-Connectives-proj₂"></a><a id="plfa_plfa-part1-Connectives-2169" href="../Connectives/#plfa_plfa-part1-Connectives-2169" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2175" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2177" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2179" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2180" href="../Connectives/#plfa_plfa-part1-Connectives-2180" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2182" href="../Connectives/#plfa_plfa-part1-Connectives-2182" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2184" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2186" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2189" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2193" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2195" href="../Connectives/#plfa_plfa-part1-Connectives-2180" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2197" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2199" href="../Connectives/#plfa_plfa-part1-Connectives-2182" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2205" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2213" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2215" href="../Connectives/#plfa_plfa-part1-Connectives-2182" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-2217" href="../Connectives/#plfa_plfa-part1-Connectives-2169" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2223" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2225" href="../Connectives/#plfa_plfa-part1-Connectives-2225" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2227" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2229" href="../Connectives/#plfa_plfa-part1-Connectives-2229" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2231" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2233" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2235" href="../Connectives/#plfa_plfa-part1-Connectives-2229" class="Bound">y</a>
</pre><p>如果 <code>L</code> 是 <code>A × B</code> 成立的证据, 那么 <code>proj₁ L</code> 是 <code>A</code> 成立的证据， <code>proj₂ L</code> 是 <code>B</code> 成立的证据。</p><p>当 <code>⟨_,_⟩</code> 在等式右手边的项中出现的时候，我们将其称作<strong>构造子（Constructor）</strong>， 当它出现在等式左边时，我们将其称作<strong>解构子（Destructor）</strong>。我们亦可将 <code>proj₁</code> 和 <code>proj₂</code> 称作解构子，因为它们起到相似的效果。</p><p>其他的术语将 <code>⟨_,_⟩</code> 称作<strong>引入（Introduce）</strong>合取，将 <code>proj₁</code> 和 <code>proj₂</code> 称作<strong>消去（Eliminate）</strong>合取。 前者亦记作 <code>×-I</code>，后者 <code>×-E₁</code> 和 <code>×-E₂</code>。如果我们从上到下来阅读这些规则，引入和消去 正如其名字所说的那样：第一条<strong>引入</strong>一个运算符，所以运算符出现在结论中，而不是假设中； 第二条<strong>消去</strong>一个带有运算符的式子，而运算符出现在假设中，而不是结论中。引入规则描述了 运算符在什么情况下成立——即怎么样<strong>定义</strong>一个运算符。消去规则描述了运算符成立时，可以得出 什么样的结论——即怎么样<strong>使用</strong>一个运算符。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>在这样的情况下，先使用解构子，再使用构造子将结果重组，得到还是原来的积。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×"></a><a id="plfa_plfa-part1-Connectives-4202" href="../Connectives/#plfa_plfa-part1-Connectives-4202" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4206" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4208" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-4210" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-4211" href="../Connectives/#plfa_plfa-part1-Connectives-4211" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4213" href="../Connectives/#plfa_plfa-part1-Connectives-4213" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4215" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4220" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-4222" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4223" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4225" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4227" href="../Connectives/#plfa_plfa-part1-Connectives-4211" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4229" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-4231" href="../Connectives/#plfa_plfa-part1-Connectives-4213" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-4232" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4234" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-4236" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4238" href="../Connectives/#plfa_plfa-part1-Connectives-2100" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-4244" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4246" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4248" href="../Connectives/#plfa_plfa-part1-Connectives-2169" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-4254" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4256" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4258" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-4260" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-4262" href="../Connectives/#plfa_plfa-part1-Connectives-4202" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4266" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4268" href="../Connectives/#plfa_plfa-part1-Connectives-4268" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-4270" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4272" href="../Connectives/#plfa_plfa-part1-Connectives-4272" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-4274" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4276" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-4278" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>⟨ x , y ⟩</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项。</p><p>我们设置合取的优先级，使它与除了析取之外结合的都不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4668" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-4675" class="Number">2</a> <a id="plfa_plfa-part1-Connectives-4677" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">_×_</a>
</pre><p>因此，<code>m ≤ n × n ≤ p</code> 解析为 <code>(m ≤ n) × (n ≤ p)</code>。</p><p>Alternatively, we can declare conjunction as a record type:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4863" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-_×′_"></a><a id="plfa_plfa-part1-Connectives-4870" href="../Connectives/#plfa_plfa-part1-Connectives-4870" class="Record Operator">_×′_</a> <a id="plfa_plfa-part1-Connectives-4875" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4876" href="../Connectives/#plfa_plfa-part1-Connectives-4876" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4878" href="../Connectives/#plfa_plfa-part1-Connectives-4878" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4880" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4885" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4887" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-4893" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-4901" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-⟨_,_⟩′"></a><a id="plfa_plfa-part1-Connectives-4913" href="../Connectives/#plfa_plfa-part1-Connectives-4913" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="plfa_plfa-part1-Connectives-4922" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₁′"></a><a id="plfa_plfa-part1-Connectives-4932" href="../Connectives/#plfa_plfa-part1-Connectives-4932" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-4939" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4941" href="../Connectives/#plfa_plfa-part1-Connectives-4876" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₂′"></a><a id="plfa_plfa-part1-Connectives-4947" href="../Connectives/#plfa_plfa-part1-Connectives-4947" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-4954" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4956" href="../Connectives/#plfa_plfa-part1-Connectives-4878" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-4958" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-4963" href="../Connectives/#plfa_plfa-part1-Connectives-4870" class="Module Operator">_×′_</a>
</pre><p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p><p>The data type <code>_×_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×′"></a><a id="plfa_plfa-part1-Connectives-5520" href="../Connectives/#plfa_plfa-part1-Connectives-5520" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5525" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5527" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-5529" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-5530" href="../Connectives/#plfa_plfa-part1-Connectives-5530" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5532" href="../Connectives/#plfa_plfa-part1-Connectives-5532" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-5534" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5536" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-5539" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-5541" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-5542" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5544" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5546" href="../Connectives/#plfa_plfa-part1-Connectives-5530" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5548" href="../Connectives/#plfa_plfa-part1-Connectives-4870" class="Record Operator">×′</a> <a id="plfa_plfa-part1-Connectives-5551" href="../Connectives/#plfa_plfa-part1-Connectives-5532" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-5552" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-5554" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-5556" href="../Connectives/#plfa_plfa-part1-Connectives-4913" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-5558" href="../Connectives/#plfa_plfa-part1-Connectives-4932" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-5565" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5567" href="../Connectives/#plfa_plfa-part1-Connectives-4913" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-5569" href="../Connectives/#plfa_plfa-part1-Connectives-4947" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-5576" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5578" href="../Connectives/#plfa_plfa-part1-Connectives-4913" class="InductiveConstructor Operator">⟩′</a> <a id="plfa_plfa-part1-Connectives-5581" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-5583" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-5585" href="../Connectives/#plfa_plfa-part1-Connectives-5520" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5590" href="../Connectives/#plfa_plfa-part1-Connectives-5590" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5592" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-5594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A × B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>积</strong>。 在集合论中它也被称作<strong>笛卡尔积（Cartesian Product）</strong>，在计算机科学中它对应<strong>记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A × B</code> 有 <code>m * n</code> 个不同的成员。这也是它被称为积的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-6532" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Bool"></a><a id="plfa_plfa-part1-Connectives-6537" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-6542" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6544" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6548" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Bool.true"></a><a id="plfa_plfa-part1-Connectives-6556" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-6562" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6564" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Connectives-Bool.false"></a><a id="plfa_plfa-part1-Connectives-6571" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-6577" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6579" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a>

<a id="plfa_plfa-part1-Connectives-6585" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Tri"></a><a id="plfa_plfa-part1-Connectives-6590" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-6594" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6600" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Tri.aa"></a><a id="plfa_plfa-part1-Connectives-6608" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-6611" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6613" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.bb"></a><a id="plfa_plfa-part1-Connectives-6619" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-6622" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6624" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.cc"></a><a id="plfa_plfa-part1-Connectives-6630" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-6633" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6635" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a>
</pre><p>那么，<code>Bool × Tri</code> 类型有如下的六个成员：</p><pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre><p>下面的函数枚举了所有类型为 <code>Bool × Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-count"></a><a id="plfa_plfa-part1-Connectives-6981" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-6989" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6991" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-6996" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-6998" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-7002" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-7004" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-7006" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7014" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7016" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7022" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7024" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7027" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7030" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7033" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-7035" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7043" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7045" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7051" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7053" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7056" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7059" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7062" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-7064" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7072" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7074" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7080" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7082" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7085" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7088" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7091" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-7093" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7101" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7103" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7109" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7111" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7114" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7117" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7120" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-7122" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7130" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7132" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7138" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7140" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7143" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7146" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7149" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-7151" href="../Connectives/#plfa_plfa-part1-Connectives-6981" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7159" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7161" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7167" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7169" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7172" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7175" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7178" class="Number">6</a>
</pre><p>类型上的积与数的积有相似的性质——它们满足交换律和结合律。 更确切地说，积在<strong>在同构意义下</strong>满足交换律和结合率。</p><p>对于交换律，<code>to</code> 函数将有序对交换，将 <code>⟨ x , y ⟩</code> 变为 <code>⟨ y , x ⟩</code>，<code>from</code> 函数亦是如此（忽略命名）。 在 <code>from∘to</code> 和 <code>to∘from</code> 中正确地实例化要匹配的模式是很重要的。 使用 <code>λ w → refl</code> 作为 <code>from∘to</code> 的定义是不可行的，<code>to∘from</code> 同理。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-comm"></a><a id="plfa_plfa-part1-Connectives-7967" href="../Connectives/#plfa_plfa-part1-Connectives-7967" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-7974" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7976" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-7978" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-7979" href="../Connectives/#plfa_plfa-part1-Connectives-7979" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-7981" href="../Connectives/#plfa_plfa-part1-Connectives-7981" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-7983" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7985" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-7988" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-7990" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-7992" href="../Connectives/#plfa_plfa-part1-Connectives-7979" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-7994" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-7996" href="../Connectives/#plfa_plfa-part1-Connectives-7981" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-7998" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-8000" href="../Connectives/#plfa_plfa-part1-Connectives-7981" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-8002" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-8004" href="../Connectives/#plfa_plfa-part1-Connectives-7979" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-8006" href="../Connectives/#plfa_plfa-part1-Connectives-7967" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-8013" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-8017" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-8028" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-8030" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>       <a id="plfa_plfa-part1-Connectives-8039" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8042" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8045" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8047" href="../Connectives/#plfa_plfa-part1-Connectives-8047" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8049" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8051" href="../Connectives/#plfa_plfa-part1-Connectives-8051" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8053" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8055" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8057" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8059" href="../Connectives/#plfa_plfa-part1-Connectives-8051" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8061" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8063" href="../Connectives/#plfa_plfa-part1-Connectives-8047" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8065" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8067" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8073" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8075" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>     <a id="plfa_plfa-part1-Connectives-8084" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8087" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8090" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8092" href="../Connectives/#plfa_plfa-part1-Connectives-8092" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8094" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8096" href="../Connectives/#plfa_plfa-part1-Connectives-8096" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8098" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8100" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8102" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8104" href="../Connectives/#plfa_plfa-part1-Connectives-8096" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8106" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8108" href="../Connectives/#plfa_plfa-part1-Connectives-8092" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8110" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8112" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8118" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8120" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a>  <a id="plfa_plfa-part1-Connectives-8129" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8132" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8135" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8137" href="../Connectives/#plfa_plfa-part1-Connectives-8137" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8139" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8141" href="../Connectives/#plfa_plfa-part1-Connectives-8141" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8143" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8145" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8147" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8152" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8158" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8160" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a>  <a id="plfa_plfa-part1-Connectives-8169" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8172" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8175" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8177" href="../Connectives/#plfa_plfa-part1-Connectives-8177" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8179" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8181" href="../Connectives/#plfa_plfa-part1-Connectives-8181" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8183" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8185" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8192" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8198" class="Symbol">}</a>
</pre><p>满足<strong>交换律</strong>和<strong>在同构意义下满足交换律</strong>是不一样的。比较下列两个命题：</p><pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre><p>在第一个情况下，我们可能有 <code>m</code> 是 <code>2</code>、<code>n</code> 是 <code>3</code>，那么 <code>m * n</code> 和 <code>n * m</code> 都是 <code>6</code>。 在第二个情况下，我们可能有 <code>A</code> 是 <code>Bool</code> 和 <code>B</code> 是 <code>Tri</code>，但是 <code>Bool × Tri</code> 和 <code>Tri × Bool</code> <strong>不是</strong>一样的。但是存在一个两者之间的同构。例如：<code>⟨ true , aa ⟩</code> 是前者的成员， 其对应后者的成员 <code>⟨ aa , true ⟩</code>。</p><p>对于结合律来说，<code>to</code> 函数将两个有序对进行重组：将 <code>⟨ ⟨ x , y ⟩ , z ⟩</code> 转换为 <code>⟨ x , ⟨ y , z ⟩ ⟩</code>， <code>from</code> 函数则为其逆。同样，左逆和右逆的证明需要在一个合适的模式来匹配，从而可以直接化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-assoc"></a><a id="plfa_plfa-part1-Connectives-9464" href="../Connectives/#plfa_plfa-part1-Connectives-9464" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9472" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9474" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-9476" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-9477" href="../Connectives/#plfa_plfa-part1-Connectives-9477" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9479" href="../Connectives/#plfa_plfa-part1-Connectives-9479" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9481" href="../Connectives/#plfa_plfa-part1-Connectives-9481" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9483" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9485" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-9488" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-9490" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9492" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9493" href="../Connectives/#plfa_plfa-part1-Connectives-9477" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9495" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9497" href="../Connectives/#plfa_plfa-part1-Connectives-9479" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-9498" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-9500" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9502" href="../Connectives/#plfa_plfa-part1-Connectives-9481" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9504" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-9506" href="../Connectives/#plfa_plfa-part1-Connectives-9477" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9508" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9510" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9511" href="../Connectives/#plfa_plfa-part1-Connectives-9479" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9513" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9515" href="../Connectives/#plfa_plfa-part1-Connectives-9481" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-9516" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-9518" href="../Connectives/#plfa_plfa-part1-Connectives-9464" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9526" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-9530" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-9541" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-9543" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-9551" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9553" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9556" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9558" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9560" href="../Connectives/#plfa_plfa-part1-Connectives-9560" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9562" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9564" href="../Connectives/#plfa_plfa-part1-Connectives-9564" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9566" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9568" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9570" href="../Connectives/#plfa_plfa-part1-Connectives-9570" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9572" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9574" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9576" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9578" href="../Connectives/#plfa_plfa-part1-Connectives-9560" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9580" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9582" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9584" href="../Connectives/#plfa_plfa-part1-Connectives-9564" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9586" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9588" href="../Connectives/#plfa_plfa-part1-Connectives-9570" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9590" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9592" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9594" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9600" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9602" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-9610" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9612" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9615" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9617" href="../Connectives/#plfa_plfa-part1-Connectives-9617" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9619" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9621" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9623" href="../Connectives/#plfa_plfa-part1-Connectives-9623" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9625" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9627" href="../Connectives/#plfa_plfa-part1-Connectives-9627" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9629" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9631" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9633" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9635" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9637" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9639" href="../Connectives/#plfa_plfa-part1-Connectives-9617" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9641" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9643" href="../Connectives/#plfa_plfa-part1-Connectives-9623" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9645" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9647" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9649" href="../Connectives/#plfa_plfa-part1-Connectives-9627" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9651" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9653" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9659" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9661" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-9669" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9671" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9674" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9676" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9678" href="../Connectives/#plfa_plfa-part1-Connectives-9678" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9680" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9682" href="../Connectives/#plfa_plfa-part1-Connectives-9682" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9684" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9686" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9688" href="../Connectives/#plfa_plfa-part1-Connectives-9688" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9690" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9692" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9699" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9705" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9707" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-9715" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9717" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9720" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9722" href="../Connectives/#plfa_plfa-part1-Connectives-9722" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9724" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9726" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9728" href="../Connectives/#plfa_plfa-part1-Connectives-9728" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9730" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9732" href="../Connectives/#plfa_plfa-part1-Connectives-9732" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9734" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9736" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9738" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9745" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9751" class="Symbol">}</a>
</pre><p>满足<strong>结合律</strong>和<strong>在同构意义下满足结合律</strong>是不一样的。比较下列两个命题：</p><pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre><p>举个例子，<code>(ℕ × Bool) × Tri</code> 与 <code>ℕ × (Bool × Tri)</code> <strong>不同</strong>，但是两个类型之间 存在同构。例如 <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>，一个前者的成员，与 <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>， 一个后者的成员，相对应。</p><h4 id="练习-实践">练习 <code>⇔≃×</code>（实践）</h4><p>证明<a href="../Isomorphism/#iff">之前</a>定义的 <code>A ⇔ B</code> 与 <code>(A → B) × (B → A)</code> 同构。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10645" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="真即是单元类型">真即是单元类型</h2><p>恒真 <code>⊤</code> 恒成立。我们将这个概念用合适的数据类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10833" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊤"></a><a id="plfa_plfa-part1-Connectives-10838" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-10840" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-10842" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-10846" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-⊤.tt"></a><a id="plfa_plfa-part1-Connectives-10855" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-10858" class="Symbol">:</a>
    <a id="plfa_plfa-part1-Connectives-10864" class="Comment">--</a>
    <a id="plfa_plfa-part1-Connectives-10871" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a>
</pre><p><code>⊤</code> 成立的证明由 <code>tt</code> 的形式构成。</p><p>恒真有引入规则，但没有消去规则。给定一个 <code>⊤</code> 成立的证明，我们不能得出任何有趣的结论。 因为恒真恒成立，知道恒真成立不会给我们带来新的知识。</p><p><code>η-×</code> 的 零元形式是 <code>η-⊤</code>，其断言了任何 <code>⊤</code> 类型的值一定等于 <code>tt</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤"></a><a id="plfa_plfa-part1-Connectives-11415" href="../Connectives/#plfa_plfa-part1-Connectives-11415" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11419" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11421" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-11423" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-11424" href="../Connectives/#plfa_plfa-part1-Connectives-11424" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-11426" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11428" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-11429" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-11431" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-11433" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11436" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-11438" href="../Connectives/#plfa_plfa-part1-Connectives-11424" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-11440" href="../Connectives/#plfa_plfa-part1-Connectives-11415" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11444" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11447" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-11449" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。将 <code>w</code> 替换为 <code>tt</code> 让等式两边可以化简为相同的值。</p>Alternatively, we can declare truth as an empty record:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-11735" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-⊤′"></a><a id="plfa_plfa-part1-Connectives-11742" href="../Connectives/#plfa_plfa-part1-Connectives-11742" class="Record">⊤′</a> <a id="plfa_plfa-part1-Connectives-11745" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11747" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-11751" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-11759" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-tt′"></a><a id="plfa_plfa-part1-Connectives-11771" href="../Connectives/#plfa_plfa-part1-Connectives-11771" class="InductiveConstructor">tt′</a>
</pre><p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤′"></a><a id="plfa_plfa-part1-Connectives-12146" href="../Connectives/#plfa_plfa-part1-Connectives-12146" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12151" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12153" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-12155" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-12156" href="../Connectives/#plfa_plfa-part1-Connectives-12156" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12158" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12160" href="../Connectives/#plfa_plfa-part1-Connectives-11742" class="Record">⊤′</a><a id="plfa_plfa-part1-Connectives-12162" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-12164" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12166" href="../Connectives/#plfa_plfa-part1-Connectives-11771" class="InductiveConstructor">tt′</a> <a id="plfa_plfa-part1-Connectives-12170" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-12172" href="../Connectives/#plfa_plfa-part1-Connectives-12156" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-12174" href="../Connectives/#plfa_plfa-part1-Connectives-12146" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12179" href="../Connectives/#plfa_plfa-part1-Connectives-12179" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12181" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre>Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-truth′"></a><a id="plfa_plfa-part1-Connectives-12333" href="../Connectives/#plfa_plfa-part1-Connectives-12333" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12340" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12342" href="../Connectives/#plfa_plfa-part1-Connectives-11742" class="Record">⊤′</a>
<a id="plfa_plfa-part1-Connectives-12345" href="../Connectives/#plfa_plfa-part1-Connectives-12333" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12352" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12354" class="Symbol">_</a>
</pre><p>我们将 <code>⊤</code> 称为<strong>单元（Unit Type）</strong>类型。实际上，<code>⊤</code> 类型只有一个成员 <code>tt</code>。 例如，下面的函数枚举了所有 <code>⊤</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-count"></a><a id="plfa_plfa-part1-Connectives-12630" href="../Connectives/#plfa_plfa-part1-Connectives-12630" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12638" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12640" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-12642" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12644" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-12646" href="../Connectives/#plfa_plfa-part1-Connectives-12630" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12654" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-12657" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12659" class="Number">1</a>
</pre><p>对于数来说，1 是乘法的幺元。对应地，单元是积的幺元（<strong>在同构意义下</strong>）。对于左幺元来说， <code>to</code> 函数将 <code>⟨ tt , x ⟩</code> 转换成 <code>x</code>， <code>from</code> 函数则是其反函数。左逆的证明需要 匹配一个合适的模式来化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityˡ"></a><a id="plfa_plfa-part1-Connectives-13132" href="../Connectives/#plfa_plfa-part1-Connectives-13132" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13144" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13146" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-13148" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-13149" href="../Connectives/#plfa_plfa-part1-Connectives-13149" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13151" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13153" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-13156" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-13158" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13160" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-13162" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-13164" href="../Connectives/#plfa_plfa-part1-Connectives-13149" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13166" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-13168" href="../Connectives/#plfa_plfa-part1-Connectives-13149" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-13170" href="../Connectives/#plfa_plfa-part1-Connectives-13132" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13182" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-13186" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-13197" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-13199" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-13207" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13209" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13212" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13214" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13217" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13219" href="../Connectives/#plfa_plfa-part1-Connectives-13219" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13221" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13223" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13225" href="../Connectives/#plfa_plfa-part1-Connectives-13219" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13227" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13233" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13235" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-13243" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13245" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13248" href="../Connectives/#plfa_plfa-part1-Connectives-13248" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13250" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13252" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13254" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13257" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13259" href="../Connectives/#plfa_plfa-part1-Connectives-13248" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13261" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13263" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13269" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13271" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-13279" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13281" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13284" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13286" href="../Connectives/#plfa_plfa-part1-Connectives-10855" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13289" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13291" href="../Connectives/#plfa_plfa-part1-Connectives-13291" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13293" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13295" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13297" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13302" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13308" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13310" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-13318" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13320" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13323" href="../Connectives/#plfa_plfa-part1-Connectives-13323" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13325" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13327" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13332" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13338" class="Symbol">}</a>
</pre><p><strong>幺元</strong>和<strong>在同构意义下的幺元</strong>是不一样的。比较下列两个命题：</p><pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre><p>在第一种情况下，我们可能有 <code>m</code> 是 <code>2</code>，那么 <code>1 * m</code> 和 <code>m</code> 都为 <code>2</code>。 在第二种情况下，我们可能有 <code>A</code> 是 <code>Bool</code>，但是 <code>⊤ × Bool</code> 和 <code>Bool</code> 是不同的。 例如：<code>⟨ tt , true ⟩</code> 是前者的成员，其对应后者的成员 <code>true</code>。</p><p>右幺元可以由积的交换律得来：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityʳ"></a><a id="plfa_plfa-part1-Connectives-14158" href="../Connectives/#plfa_plfa-part1-Connectives-14158" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14170" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14172" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-14174" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14175" href="../Connectives/#plfa_plfa-part1-Connectives-14175" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14177" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14182" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14184" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14186" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14187" href="../Connectives/#plfa_plfa-part1-Connectives-14175" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14189" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14191" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14192" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14194" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-14196" href="../Connectives/#plfa_plfa-part1-Connectives-14175" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-14198" href="../Connectives/#plfa_plfa-part1-Connectives-14158" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14210" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14211" href="../Connectives/#plfa_plfa-part1-Connectives-14211" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14212" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14214" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-14218" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10861" class="Function Operator">≃-begin</a>
    <a id="plfa_plfa-part1-Connectives-14230" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14231" href="../Connectives/#plfa_plfa-part1-Connectives-14211" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14233" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14235" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14236" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14240" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10945" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14243" href="../Connectives/#plfa_plfa-part1-Connectives-7967" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-14250" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10945" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14256" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14257" href="../Connectives/#plfa_plfa-part1-Connectives-10838" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-14259" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14261" href="../Connectives/#plfa_plfa-part1-Connectives-14211" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14262" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14266" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10945" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14269" href="../Connectives/#plfa_plfa-part1-Connectives-13132" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-14281" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10945" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14287" href="../Connectives/#plfa_plfa-part1-Connectives-14211" class="Bound">A</a>
  <a id="plfa_plfa-part1-Connectives-14291" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11064" class="Function Operator">≃-∎</a>
</pre><p>我们在此使用了同构链，与等式链相似。</p><h2 id="析取即是和">析取即是和</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，析取 <code>A ⊎ B</code> 在 <code>A</code> 成立或者 <code>B</code> 成立时成立。 我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-14706" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_⊎_"></a><a id="plfa_plfa-part1-Connectives-14711" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">_⊎_</a> <a id="plfa_plfa-part1-Connectives-14715" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14716" href="../Connectives/#plfa_plfa-part1-Connectives-14716" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14718" href="../Connectives/#plfa_plfa-part1-Connectives-14718" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-14720" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14722" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14725" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14727" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14729" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-14733" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₁"></a><a id="plfa_plfa-part1-Connectives-14742" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-14747" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14755" href="../Connectives/#plfa_plfa-part1-Connectives-14716" class="Bound">A</a>
      <a id="plfa_plfa-part1-Connectives-14763" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14773" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14775" href="../Connectives/#plfa_plfa-part1-Connectives-14716" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14777" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14779" href="../Connectives/#plfa_plfa-part1-Connectives-14718" class="Bound">B</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₂"></a><a id="plfa_plfa-part1-Connectives-14784" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-14789" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14797" href="../Connectives/#plfa_plfa-part1-Connectives-14718" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-14805" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14815" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14817" href="../Connectives/#plfa_plfa-part1-Connectives-14716" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14819" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14821" href="../Connectives/#plfa_plfa-part1-Connectives-14718" class="Bound">B</a>
</pre><p><code>A ⊎ B</code> 成立的证明有两个形式： <code>inj₁ M</code>，其中 <code>M</code> 是 <code>A</code> 成立的证明，或者 <code>inj₂ N</code>，其中 <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A → C</code> 和 <code>B → C</code> 成立的证明，那么给定一个 <code>A ⊎ B</code> 的证明，我们可以得出 <code>C</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-case-⊎"></a><a id="plfa_plfa-part1-Connectives-15282" href="../Connectives/#plfa_plfa-part1-Connectives-15282" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15289" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15291" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-15293" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-15294" href="../Connectives/#plfa_plfa-part1-Connectives-15294" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15296" href="../Connectives/#plfa_plfa-part1-Connectives-15296" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15298" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-15300" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15302" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-15305" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-15309" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15311" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15312" href="../Connectives/#plfa_plfa-part1-Connectives-15294" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15314" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15316" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15317" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15321" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15323" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15324" href="../Connectives/#plfa_plfa-part1-Connectives-15296" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15326" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15328" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15329" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15333" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15335" href="../Connectives/#plfa_plfa-part1-Connectives-15294" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15337" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-15339" href="../Connectives/#plfa_plfa-part1-Connectives-15296" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-15345" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Connectives-15359" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15361" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Bound">C</a>
<a id="plfa_plfa-part1-Connectives-15363" href="../Connectives/#plfa_plfa-part1-Connectives-15282" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15370" href="../Connectives/#plfa_plfa-part1-Connectives-15370" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15372" href="../Connectives/#plfa_plfa-part1-Connectives-15372" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15374" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15375" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-15380" href="../Connectives/#plfa_plfa-part1-Connectives-15380" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-15381" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15383" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15385" href="../Connectives/#plfa_plfa-part1-Connectives-15370" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15387" href="../Connectives/#plfa_plfa-part1-Connectives-15380" class="Bound">x</a>
<a id="plfa_plfa-part1-Connectives-15389" href="../Connectives/#plfa_plfa-part1-Connectives-15282" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15396" href="../Connectives/#plfa_plfa-part1-Connectives-15396" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15398" href="../Connectives/#plfa_plfa-part1-Connectives-15398" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15400" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15401" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-15406" href="../Connectives/#plfa_plfa-part1-Connectives-15406" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-15407" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15409" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15411" href="../Connectives/#plfa_plfa-part1-Connectives-15398" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15413" href="../Connectives/#plfa_plfa-part1-Connectives-15406" class="Bound">y</a>
</pre><p>对 <code>inj₁</code> 和 <code>inj₂</code> 进行模式匹配，是我们使用析取成立的证明的常见方法。</p><p>当 <code>inj₁</code> 和 <code>inj₂</code> 在等式右手边出现的时候，我们将其称作<strong>构造子</strong>， 当它出现在等式左边时，我们将其称作<strong>解构子</strong>。我们亦可将 <code>case-⊎</code> 称作解构子，因为它们起到相似的效果。其他术语将 <code>inj₁</code> 和 <code>inj₂</code> 称为<strong>引入</strong>析取， 将 <code>case-⊎</code> 称为<strong>消去</strong>析取。前者亦被称为 <code>⊎-I₁</code> 和 <code>⊎-I₂</code>，后者 <code>⊎-E</code>。</p><p>对每个构造子使用解构子得到的是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊎"></a><a id="plfa_plfa-part1-Connectives-16375" href="../Connectives/#plfa_plfa-part1-Connectives-16375" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16379" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16381" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16383" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16384" href="../Connectives/#plfa_plfa-part1-Connectives-16384" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16386" href="../Connectives/#plfa_plfa-part1-Connectives-16386" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16388" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16393" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16395" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16396" href="../Connectives/#plfa_plfa-part1-Connectives-16396" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16398" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16400" href="../Connectives/#plfa_plfa-part1-Connectives-16384" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16402" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16404" href="../Connectives/#plfa_plfa-part1-Connectives-16386" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16405" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16407" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16409" href="../Connectives/#plfa_plfa-part1-Connectives-15282" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16416" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16421" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16426" href="../Connectives/#plfa_plfa-part1-Connectives-16396" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16428" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16430" href="../Connectives/#plfa_plfa-part1-Connectives-16396" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16432" href="../Connectives/#plfa_plfa-part1-Connectives-16375" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16436" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16437" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16442" href="../Connectives/#plfa_plfa-part1-Connectives-16442" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16443" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16445" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16447" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16452" href="../Connectives/#plfa_plfa-part1-Connectives-16375" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16456" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16457" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16462" href="../Connectives/#plfa_plfa-part1-Connectives-16462" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16463" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16465" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16467" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>更普遍地来说，我们亦可对于析取使用一个任意的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊎"></a><a id="plfa_plfa-part1-Connectives-16601" href="../Connectives/#plfa_plfa-part1-Connectives-16601" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16608" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16610" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16612" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16613" href="../Connectives/#plfa_plfa-part1-Connectives-16613" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16615" href="../Connectives/#plfa_plfa-part1-Connectives-16615" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16617" href="../Connectives/#plfa_plfa-part1-Connectives-16617" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-16619" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16621" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16624" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16626" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16627" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16629" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16631" href="../Connectives/#plfa_plfa-part1-Connectives-16613" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16633" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16635" href="../Connectives/#plfa_plfa-part1-Connectives-16615" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16637" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16639" href="../Connectives/#plfa_plfa-part1-Connectives-16617" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-16640" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16642" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16643" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16645" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16647" href="../Connectives/#plfa_plfa-part1-Connectives-16613" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16649" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16651" href="../Connectives/#plfa_plfa-part1-Connectives-16615" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16652" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16654" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Connectives-16658" href="../Connectives/#plfa_plfa-part1-Connectives-15282" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16665" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16666" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16668" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16670" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-16674" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16676" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16677" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16679" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16681" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-16685" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16687" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16689" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16691" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16693" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16695" href="../Connectives/#plfa_plfa-part1-Connectives-16601" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16702" href="../Connectives/#plfa_plfa-part1-Connectives-16702" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16704" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16705" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16710" href="../Connectives/#plfa_plfa-part1-Connectives-16710" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16711" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16713" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16720" href="../Connectives/#plfa_plfa-part1-Connectives-16601" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16727" href="../Connectives/#plfa_plfa-part1-Connectives-16727" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16729" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16730" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16735" href="../Connectives/#plfa_plfa-part1-Connectives-16735" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16736" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16738" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>inj₁ x</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项， <code>inj₂ y</code> 同理。</p><p>我们设置析取的优先级，使它与任何已经定义的运算符都结合的不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-17166" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-17173" class="Number">1</a> <a id="plfa_plfa-part1-Connectives-17175" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">_⊎_</a>
</pre><p>因此 <code>A × C ⊎ B × C</code> 解析为 <code>(A × C) ⊎ (B × C)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A ⊎ B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>和</strong>。 在集合论中它也被称作<strong>不交并（Disjoint Union）</strong>，在计算机科学中它对应<strong>变体记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A ⊎ B</code> 有 <code>m + n</code> 个不同的成员。这也是它被称为和的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型，如之前的定义。 那么，<code>Bool ⊎ Tri</code> 类型有如下的五个成员：</p><pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre><p>下面的函数枚举了所有类型为 <code>Bool ⊎ Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-count"></a><a id="plfa_plfa-part1-Connectives-18338" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18346" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-18348" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-18353" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-18355" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-18359" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-18361" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-18363" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18371" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18372" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18377" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Connectives-18381" class="Symbol">)</a>   <a id="plfa_plfa-part1-Connectives-18385" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18388" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-18390" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18398" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18399" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18404" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Connectives-18409" class="Symbol">)</a>  <a id="plfa_plfa-part1-Connectives-18412" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18415" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-18417" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18425" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18426" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18431" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a><a id="plfa_plfa-part1-Connectives-18433" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18439" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18442" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-18444" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18452" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18453" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18458" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a><a id="plfa_plfa-part1-Connectives-18460" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18466" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18469" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-18471" href="../Connectives/#plfa_plfa-part1-Connectives-18338" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18479" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18480" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18485" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a><a id="plfa_plfa-part1-Connectives-18487" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18493" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18496" class="Number">5</a>
</pre><p>类型上的和与数的和有相似的性质——它们满足交换律和结合律。 更确切地说，和在<strong>在同构意义下</strong>是交换和结合的。</p><h4 id="练习--comm-推荐">练习 <code>⊎-comm</code> （推荐）</h4><p>证明和类型在同构意义下满足交换律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-18841" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--assoc实践">练习 <code>⊎-assoc</code>（实践）</h4><p>证明和类型在同构意义下满足结合律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19007" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="假即是空类型">假即是空类型</h2><p>恒假 <code>⊥</code> 从不成立。我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19319" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊥"></a><a id="plfa_plfa-part1-Connectives-19324" href="../Connectives/#plfa_plfa-part1-Connectives-19324" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-19326" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-19328" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-19332" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-19340" class="Comment">-- 没有语句！</a>
</pre><p>没有 <code>⊥</code> 成立的证明。</p><p>与 <code>⊤</code> 相对偶，<code>⊥</code> 没有引入规则，但是有消去规则。因为恒假从不成立， 如果它一旦成立，我们就进入了矛盾之中。给定 <code>⊥</code> 成立的证明，我们可以得出任何结论！ 这是逻辑学的基本原理，又由中世纪的拉丁文词组 <em>ex falso</em> 为名。小孩子也由诸如 「如果猪有翅膀，那我就是示巴女王」的词组中知晓。我们如下将它形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-elim"></a><a id="plfa_plfa-part1-Connectives-20055" href="../Connectives/#plfa_plfa-part1-Connectives-20055" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20062" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20064" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20066" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20067" href="../Connectives/#plfa_plfa-part1-Connectives-20067" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-20069" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20071" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20074" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-20078" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20080" href="../Connectives/#plfa_plfa-part1-Connectives-19324" class="Datatype">⊥</a>
    <a id="plfa_plfa-part1-Connectives-20086" class="Comment">--</a>
  <a id="plfa_plfa-part1-Connectives-20091" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20093" href="../Connectives/#plfa_plfa-part1-Connectives-20067" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-20095" href="../Connectives/#plfa_plfa-part1-Connectives-20055" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20102" class="Symbol">()</a>
</pre><p>这是我们第一次使<strong>用荒谬模式（Absurd Pattern）</strong> <code>()</code>。在这里，因为 <code>⊥</code> 是一个没有成员的类型，我们用 <code>()</code> 模式来指明这里不可能匹配任何这个类型的值。</p><p><code>case-⊎</code> 的零元形式是 <code>⊥-elim</code>。类比的来说，它应该叫做 <code>case-⊥</code>， 但是我们在此使用标准库中使用的名字。</p><p><code>uniq-⊎</code> 的零元形式是 <code>uniq-⊥</code>，其断言了 <code>⊥-elim</code> 和任何取 <code>⊥</code> 的函数是等价的。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊥"></a><a id="plfa_plfa-part1-Connectives-20827" href="../Connectives/#plfa_plfa-part1-Connectives-20827" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20834" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20836" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20838" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20839" href="../Connectives/#plfa_plfa-part1-Connectives-20839" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-20841" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20843" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20846" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-20848" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20849" href="../Connectives/#plfa_plfa-part1-Connectives-20849" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20851" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20853" href="../Connectives/#plfa_plfa-part1-Connectives-19324" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-20855" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20857" href="../Connectives/#plfa_plfa-part1-Connectives-20839" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-20858" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20860" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20861" href="../Connectives/#plfa_plfa-part1-Connectives-20861" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20863" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20865" href="../Connectives/#plfa_plfa-part1-Connectives-19324" class="Datatype">⊥</a><a id="plfa_plfa-part1-Connectives-20866" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20868" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20870" href="../Connectives/#plfa_plfa-part1-Connectives-20055" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20877" href="../Connectives/#plfa_plfa-part1-Connectives-20861" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20879" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-20881" href="../Connectives/#plfa_plfa-part1-Connectives-20849" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20883" href="../Connectives/#plfa_plfa-part1-Connectives-20861" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-20885" href="../Connectives/#plfa_plfa-part1-Connectives-20827" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20892" href="../Connectives/#plfa_plfa-part1-Connectives-20892" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20894" class="Symbol">()</a>
</pre><p>使用荒谬模式断言了 <code>w</code> 没有任何可能的值，因此等式显然成立。</p><p>我们将 <code>⊥</code> 成为<strong>空（Empty）</strong>类型。实际上，<code>⊥</code> 类型没有成员。 例如，下面的函数枚举了所有 <code>⊥</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-count"></a><a id="plfa_plfa-part1-Connectives-21293" href="../Connectives/#plfa_plfa-part1-Connectives-21293" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21301" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-21303" href="../Connectives/#plfa_plfa-part1-Connectives-19324" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-21305" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-21307" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-21309" href="../Connectives/#plfa_plfa-part1-Connectives-21293" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21317" class="Symbol">()</a>
</pre><p>同样，荒谬模式告诉我们没有值可以来匹配类型 <code>⊥</code>。</p><p>对于数来说，0 是加法的幺元。对应地，空是和的幺元（<strong>在同构意义下</strong>）。</p><h4 id="练习--identityˡ-推荐">练习 <code>⊥-identityˡ</code> （推荐）</h4><p>证明空在同构意义下是和的左幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21784" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4><h4 id="练习--identityʳ实践">练习 <code>⊥-identityʳ</code>（实践）</h4><p>证明空在同构意义下是和的右幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21966" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="implication">蕴涵即是函数</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其蕴涵 <code>A → B</code> 在任何 <code>A</code> 成立的时候，<code>B</code> 也成立时成立。 我们用函数类型来形式化蕴涵，如本书中通篇出现的那样。</p><p><code>A → B</code> 成立的证据由下面的形式组成：</p><pre><code>λ (x : A) → N</code></pre><p>其中 <code>N</code> 是一个类型为 <code>B</code> 的项，其包括了一个类型为 <code>A</code> 的自由变量 <code>x</code>。 给定一个 <code>A → B</code> 成立的证明 <code>L</code>，和一个 <code>A</code> 成立的证明 <code>M</code>，那么 <code>L M</code> 是 <code>B</code> 成立的证明。 也就是说，<code>A → B</code> 成立的证明是一个函数，将 <code>A</code> 成立的证明转换成 <code>B</code> 成立的证明。</p><p>换句话说，如果知道 <code>A → B</code> 和 <code>A</code> 同时成立，那么我们可以推出 <code>B</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-elim"></a><a id="plfa_plfa-part1-Connectives-23149" href="../Connectives/#plfa_plfa-part1-Connectives-23149" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23156" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23158" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23160" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23161" href="../Connectives/#plfa_plfa-part1-Connectives-23161" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23163" href="../Connectives/#plfa_plfa-part1-Connectives-23163" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23165" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23167" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23170" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-23174" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23176" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23177" href="../Connectives/#plfa_plfa-part1-Connectives-23161" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23179" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23181" href="../Connectives/#plfa_plfa-part1-Connectives-23163" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23182" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-23186" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23188" href="../Connectives/#plfa_plfa-part1-Connectives-23161" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-23194" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Connectives-23204" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23206" href="../Connectives/#plfa_plfa-part1-Connectives-23163" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-23208" href="../Connectives/#plfa_plfa-part1-Connectives-23149" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23215" href="../Connectives/#plfa_plfa-part1-Connectives-23215" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23217" href="../Connectives/#plfa_plfa-part1-Connectives-23217" class="Bound">M</a> <a id="plfa_plfa-part1-Connectives-23219" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23221" href="../Connectives/#plfa_plfa-part1-Connectives-23215" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23223" href="../Connectives/#plfa_plfa-part1-Connectives-23217" class="Bound">M</a>
</pre><p>在中世纪，这条规则被叫做 <em>modus ponens</em>，它与函数应用相对应。</p><p>定义一个函数，不管是带名字的定义或是使用 Lambda 抽象，被称为<strong>引入</strong>一个函数， 使用一个函数被称为<strong>消去</strong>一个函数。</p><p>引入后接着消去，得到的还是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-→"></a><a id="plfa_plfa-part1-Connectives-23743" href="../Connectives/#plfa_plfa-part1-Connectives-23743" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23747" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23749" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23751" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23752" href="../Connectives/#plfa_plfa-part1-Connectives-23752" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23754" href="../Connectives/#plfa_plfa-part1-Connectives-23754" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23756" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23758" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23761" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-23763" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23764" href="../Connectives/#plfa_plfa-part1-Connectives-23764" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23766" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23768" href="../Connectives/#plfa_plfa-part1-Connectives-23752" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23770" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23772" href="../Connectives/#plfa_plfa-part1-Connectives-23754" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23773" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23775" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23777" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Connectives-23780" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23781" href="../Connectives/#plfa_plfa-part1-Connectives-23781" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-23783" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23785" href="../Connectives/#plfa_plfa-part1-Connectives-23752" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-23786" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23788" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23790" href="../Connectives/#plfa_plfa-part1-Connectives-23764" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23792" href="../Connectives/#plfa_plfa-part1-Connectives-23781" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-23793" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23795" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-23797" href="../Connectives/#plfa_plfa-part1-Connectives-23764" class="Bound">f</a>
<a id="plfa_plfa-part1-Connectives-23799" href="../Connectives/#plfa_plfa-part1-Connectives-23743" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23803" href="../Connectives/#plfa_plfa-part1-Connectives-23803" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23805" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23807" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>蕴涵比其他的运算符结合得都不紧密。因此 <code>A ⊎ B → B ⊎ A</code> 被解析为 <code>(A ⊎ B) → (B ⊎ A)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A → B</code> 称为从 <code>A</code> 到 <code>B</code> 的<strong>函数</strong>空间。 它有时也被称作以 <code>B</code> 为底，<code>A</code> 为次数的<strong>幂</strong>。如果类型 <code>A</code> 有 <code>m</code> 个不同的成员， 类型 <code>B</code> 有 <code>n</code> 个不同的成员，那么类型 <code>A → B</code> 有 <code>nᵐ</code> 个不同的成员。 这也是它被称为幂的原因之一。例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型， 如之前的定义。那么，<code>Bool → Tri</code> 类型有如下的九个成员（三的平方）：</p><pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre><p>下面的函数枚举了所有类型为 <code>Bool → Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-count"></a><a id="plfa_plfa-part1-Connectives-25194" href="../Connectives/#plfa_plfa-part1-Connectives-25194" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25202" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-25204" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-25205" href="../Connectives/#plfa_plfa-part1-Connectives-6537" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-25210" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25212" href="../Connectives/#plfa_plfa-part1-Connectives-6590" class="Datatype">Tri</a><a id="plfa_plfa-part1-Connectives-25215" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-25217" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25219" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-25221" href="../Connectives/#plfa_plfa-part1-Connectives-25194" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25229" href="../Connectives/#plfa_plfa-part1-Connectives-25229" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25231" class="Keyword">with</a> <a id="plfa_plfa-part1-Connectives-25236" href="../Connectives/#plfa_plfa-part1-Connectives-25229" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25238" href="../Connectives/#plfa_plfa-part1-Connectives-6556" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Connectives-25243" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25245" href="../Connectives/#plfa_plfa-part1-Connectives-25229" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25247" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Connectives-25253" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25266" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25268" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25275" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25277" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25285" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25289" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-25291" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25304" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25306" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25313" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25315" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25323" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25327" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-25329" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25342" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25344" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25351" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25353" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25361" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25365" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-25367" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25380" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25382" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25389" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25391" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25399" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25403" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-25405" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25418" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25420" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25427" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25429" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25437" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25441" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-25443" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25456" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25458" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25465" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25467" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25475" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25479" class="Number">6</a>
<a id="plfa_plfa-part1-Connectives-25481" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25494" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25496" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25503" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25505" href="../Connectives/#plfa_plfa-part1-Connectives-6608" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25513" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25517" class="Number">7</a>
<a id="plfa_plfa-part1-Connectives-25519" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25532" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25534" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25541" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25543" href="../Connectives/#plfa_plfa-part1-Connectives-6619" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25551" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25555" class="Number">8</a>
<a id="plfa_plfa-part1-Connectives-25557" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25570" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25572" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25579" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25581" href="../Connectives/#plfa_plfa-part1-Connectives-6630" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25589" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25593" class="Number">9</a>
</pre><p>类型上的幂与数的幂有相似的性质，很多数上成立的关系式也可以在类型上成立。</p><p>对应如下的定律：</p><pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre><p>我们有如下的同构：</p><pre><code>A → (B → C)  ≃  (A × B) → C</code></pre><p>两个类型可以被看作给定 <code>A</code> 成立的证据和 <code>B</code> 成立的证据，返回 <code>C</code> 成立的证据。 这个同构有时也被称作<strong>柯里化（Currying）</strong>。右逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-currying"></a><a id="plfa_plfa-part1-Connectives-26307" href="../Connectives/#plfa_plfa-part1-Connectives-26307" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26316" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26318" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-26320" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-26321" href="../Connectives/#plfa_plfa-part1-Connectives-26321" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26323" href="../Connectives/#plfa_plfa-part1-Connectives-26323" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26325" href="../Connectives/#plfa_plfa-part1-Connectives-26325" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-26327" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26329" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-26332" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-26334" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26336" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26337" href="../Connectives/#plfa_plfa-part1-Connectives-26321" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26339" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26341" href="../Connectives/#plfa_plfa-part1-Connectives-26323" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26343" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26345" href="../Connectives/#plfa_plfa-part1-Connectives-26325" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26346" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-26348" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-26350" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26351" href="../Connectives/#plfa_plfa-part1-Connectives-26321" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26353" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-26355" href="../Connectives/#plfa_plfa-part1-Connectives-26323" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26357" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26359" href="../Connectives/#plfa_plfa-part1-Connectives-26325" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26360" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-26362" href="../Connectives/#plfa_plfa-part1-Connectives-26307" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26371" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-26375" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-26386" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-26388" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-26396" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26399" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26402" href="../Connectives/#plfa_plfa-part1-Connectives-26402" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26404" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26406" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26409" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26411" href="../Connectives/#plfa_plfa-part1-Connectives-26411" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26413" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26415" href="../Connectives/#plfa_plfa-part1-Connectives-26415" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26417" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26419" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26421" href="../Connectives/#plfa_plfa-part1-Connectives-26402" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26423" href="../Connectives/#plfa_plfa-part1-Connectives-26411" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26425" href="../Connectives/#plfa_plfa-part1-Connectives-26415" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26427" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26434" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26436" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-26444" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26447" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26450" href="../Connectives/#plfa_plfa-part1-Connectives-26450" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26452" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26454" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26457" href="../Connectives/#plfa_plfa-part1-Connectives-26457" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26459" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26461" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26464" href="../Connectives/#plfa_plfa-part1-Connectives-26464" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26466" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26468" href="../Connectives/#plfa_plfa-part1-Connectives-26450" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26470" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26472" href="../Connectives/#plfa_plfa-part1-Connectives-26457" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26474" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26476" href="../Connectives/#plfa_plfa-part1-Connectives-26464" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26478" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26480" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Connectives-26488" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26490" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-26498" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26501" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26504" href="../Connectives/#plfa_plfa-part1-Connectives-26504" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26506" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26508" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26513" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-26519" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26521" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-26529" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26532" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26535" href="../Connectives/#plfa_plfa-part1-Connectives-26535" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26537" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26539" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-26554" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26557" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26559" href="../Connectives/#plfa_plfa-part1-Connectives-26559" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26561" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26563" href="../Connectives/#plfa_plfa-part1-Connectives-26563" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26565" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26567" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26569" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26574" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26581" class="Symbol">}</a>
</pre><p>柯里化告诉我们，如果一个函数有取一个数据对作为参数， 那么我们可以构造一个函数，取第一个参数，返回一个取第二个参数，返回最终结果的函数。 因此，举例来说，下面表示加法的形式：</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>和下面的一个带有一个数据对作为参数的函数是同构的：</p><pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre><p>Agda 对柯里化进行了优化，因此 <code>2 + 3</code> 是 <code>_+_ 2 3</code> 的简写。在一个对有序对进行优化的语言里， <code>2 +′ 3</code> 可能是 <code>_+′_ ⟨ 2 , 3 ⟩</code> 的简写。</p><p>对应如下的定律：</p><pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre><p>命题如果 <code>A</code> 成立或者 <code>B</code> 成立，那么 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>C</code> 成立以及 如果 <code>B</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-27853" href="../Connectives/#plfa_plfa-part1-Connectives-27853" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27865" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27867" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-27869" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-27870" href="../Connectives/#plfa_plfa-part1-Connectives-27870" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27872" href="../Connectives/#plfa_plfa-part1-Connectives-27872" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27874" href="../Connectives/#plfa_plfa-part1-Connectives-27874" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-27876" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27878" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-27881" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-27883" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27885" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27886" href="../Connectives/#plfa_plfa-part1-Connectives-27870" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27888" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-27890" href="../Connectives/#plfa_plfa-part1-Connectives-27872" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27892" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27894" href="../Connectives/#plfa_plfa-part1-Connectives-27874" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27895" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27897" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-27899" class="Symbol">((</a><a id="plfa_plfa-part1-Connectives-27901" href="../Connectives/#plfa_plfa-part1-Connectives-27870" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27903" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27905" href="../Connectives/#plfa_plfa-part1-Connectives-27874" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27906" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27908" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-27910" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27911" href="../Connectives/#plfa_plfa-part1-Connectives-27872" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27913" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27915" href="../Connectives/#plfa_plfa-part1-Connectives-27874" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27916" class="Symbol">))</a>
<a id="plfa_plfa-part1-Connectives-27919" href="../Connectives/#plfa_plfa-part1-Connectives-27853" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27931" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-27935" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-27946" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-27948" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-27956" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-27958" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-27961" href="../Connectives/#plfa_plfa-part1-Connectives-27961" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27963" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27965" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-27967" href="../Connectives/#plfa_plfa-part1-Connectives-27961" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27969" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-27971" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-27976" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-27978" href="../Connectives/#plfa_plfa-part1-Connectives-27961" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27980" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-27982" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-27987" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-27989" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-27995" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-27997" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28005" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28007" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28010" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28012" href="../Connectives/#plfa_plfa-part1-Connectives-28012" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28014" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28016" href="../Connectives/#plfa_plfa-part1-Connectives-28016" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28018" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28020" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28022" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28025" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28026" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28031" href="../Connectives/#plfa_plfa-part1-Connectives-28031" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28032" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28034" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28036" href="../Connectives/#plfa_plfa-part1-Connectives-28012" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28038" href="../Connectives/#plfa_plfa-part1-Connectives-28031" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28040" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28042" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28043" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28048" href="../Connectives/#plfa_plfa-part1-Connectives-28048" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28049" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28051" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28053" href="../Connectives/#plfa_plfa-part1-Connectives-28016" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28055" href="../Connectives/#plfa_plfa-part1-Connectives-28048" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-28057" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28059" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28065" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28067" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28075" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28077" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28080" href="../Connectives/#plfa_plfa-part1-Connectives-28080" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28082" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28084" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28099" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28102" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28103" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28108" href="../Connectives/#plfa_plfa-part1-Connectives-28108" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28109" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28111" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28118" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28120" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28121" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28126" href="../Connectives/#plfa_plfa-part1-Connectives-28126" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28127" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28129" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28131" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28136" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28138" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28144" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28146" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-28154" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28156" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28159" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28161" href="../Connectives/#plfa_plfa-part1-Connectives-28161" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28163" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28165" href="../Connectives/#plfa_plfa-part1-Connectives-28165" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28167" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28169" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28171" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28176" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28182" class="Symbol">}</a>
</pre><p>对应如下的定律：</p><pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre><p>命题如果 <code>A</code> 成立，那么 <code>B</code> 成立和 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>B</code> 成立以及 如果 <code>A</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性和积的 <code>η-×</code> 规则：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-×"></a><a id="plfa_plfa-part1-Connectives-28731" href="../Connectives/#plfa_plfa-part1-Connectives-28731" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28743" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28745" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-28747" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-28748" href="../Connectives/#plfa_plfa-part1-Connectives-28748" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28750" href="../Connectives/#plfa_plfa-part1-Connectives-28750" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28752" href="../Connectives/#plfa_plfa-part1-Connectives-28752" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-28754" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-28759" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28761" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28763" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28764" href="../Connectives/#plfa_plfa-part1-Connectives-28748" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28766" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28768" href="../Connectives/#plfa_plfa-part1-Connectives-28750" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28770" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28772" href="../Connectives/#plfa_plfa-part1-Connectives-28752" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28773" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28775" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-28777" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28778" href="../Connectives/#plfa_plfa-part1-Connectives-28748" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28780" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28782" href="../Connectives/#plfa_plfa-part1-Connectives-28750" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-28783" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28785" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28787" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28788" href="../Connectives/#plfa_plfa-part1-Connectives-28748" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28790" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28792" href="../Connectives/#plfa_plfa-part1-Connectives-28752" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28793" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-28795" href="../Connectives/#plfa_plfa-part1-Connectives-28731" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28807" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-28811" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-28822" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-28824" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-28832" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28834" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28837" href="../Connectives/#plfa_plfa-part1-Connectives-28837" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28839" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28841" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28843" href="../Connectives/#plfa_plfa-part1-Connectives-2100" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-28849" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28851" href="../Connectives/#plfa_plfa-part1-Connectives-28837" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28853" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28855" href="../Connectives/#plfa_plfa-part1-Connectives-2169" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-28861" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28863" href="../Connectives/#plfa_plfa-part1-Connectives-28837" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28865" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28867" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28873" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28875" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28883" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28885" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28888" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28890" href="../Connectives/#plfa_plfa-part1-Connectives-28890" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28892" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28894" href="../Connectives/#plfa_plfa-part1-Connectives-28894" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28896" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28898" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28900" class="Symbol">λ</a> <a id="plfa_plfa-part1-Connectives-28902" href="../Connectives/#plfa_plfa-part1-Connectives-28902" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28904" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28906" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28908" href="../Connectives/#plfa_plfa-part1-Connectives-28890" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28910" href="../Connectives/#plfa_plfa-part1-Connectives-28902" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28912" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28914" href="../Connectives/#plfa_plfa-part1-Connectives-28894" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28916" href="../Connectives/#plfa_plfa-part1-Connectives-28902" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28918" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28920" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28926" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28928" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28936" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28938" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28941" href="../Connectives/#plfa_plfa-part1-Connectives-28941" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28943" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28945" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28960" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28963" href="../Connectives/#plfa_plfa-part1-Connectives-28963" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28965" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28967" href="../Connectives/#plfa_plfa-part1-Connectives-4202" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-28971" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28972" href="../Connectives/#plfa_plfa-part1-Connectives-28941" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28974" href="../Connectives/#plfa_plfa-part1-Connectives-28963" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28975" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28977" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28979" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28985" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28987" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-28995" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28997" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29000" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29002" href="../Connectives/#plfa_plfa-part1-Connectives-29002" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-29004" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29006" href="../Connectives/#plfa_plfa-part1-Connectives-29006" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-29008" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29010" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29012" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-29017" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29023" class="Symbol">}</a>
</pre><h2 id="分配律">分配律</h2><p>在同构意义下，积对于和满足分配律。验证这条形式的代码和之前的证明相似：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-29250" href="../Connectives/#plfa_plfa-part1-Connectives-29250" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29262" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29264" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29266" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29267" href="../Connectives/#plfa_plfa-part1-Connectives-29267" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29269" href="../Connectives/#plfa_plfa-part1-Connectives-29269" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29271" href="../Connectives/#plfa_plfa-part1-Connectives-29271" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29273" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29275" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29278" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29280" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29282" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29283" href="../Connectives/#plfa_plfa-part1-Connectives-29267" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29285" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29287" href="../Connectives/#plfa_plfa-part1-Connectives-29269" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29288" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29290" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29292" href="../Connectives/#plfa_plfa-part1-Connectives-29271" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29294" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-29296" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29297" href="../Connectives/#plfa_plfa-part1-Connectives-29267" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29299" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29301" href="../Connectives/#plfa_plfa-part1-Connectives-29271" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29302" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29304" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29306" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29307" href="../Connectives/#plfa_plfa-part1-Connectives-29269" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29309" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29311" href="../Connectives/#plfa_plfa-part1-Connectives-29271" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29312" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-29314" href="../Connectives/#plfa_plfa-part1-Connectives-29250" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29326" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-29330" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-29341" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-29343" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5600" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-29351" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29353" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29356" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29358" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29363" href="../Connectives/#plfa_plfa-part1-Connectives-29363" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29365" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29367" href="../Connectives/#plfa_plfa-part1-Connectives-29367" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29369" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29371" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29373" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29374" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29379" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29381" href="../Connectives/#plfa_plfa-part1-Connectives-29363" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29383" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29385" href="../Connectives/#plfa_plfa-part1-Connectives-29367" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29387" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29388" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29407" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29409" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29411" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29416" href="../Connectives/#plfa_plfa-part1-Connectives-29416" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29418" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29420" href="../Connectives/#plfa_plfa-part1-Connectives-29420" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29422" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29424" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29426" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29427" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29432" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29434" href="../Connectives/#plfa_plfa-part1-Connectives-29416" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29436" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29438" href="../Connectives/#plfa_plfa-part1-Connectives-29420" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29440" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29441" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29460" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29466" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29468" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5617" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-29476" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29478" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29481" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29482" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29487" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29489" href="../Connectives/#plfa_plfa-part1-Connectives-29489" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29491" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29493" href="../Connectives/#plfa_plfa-part1-Connectives-29493" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29495" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29496" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29498" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29500" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29502" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29507" href="../Connectives/#plfa_plfa-part1-Connectives-29489" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29509" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29511" href="../Connectives/#plfa_plfa-part1-Connectives-29493" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29513" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29532" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29534" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29535" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29540" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29542" href="../Connectives/#plfa_plfa-part1-Connectives-29542" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29544" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29546" href="../Connectives/#plfa_plfa-part1-Connectives-29546" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29548" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29549" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29551" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29553" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29555" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29560" href="../Connectives/#plfa_plfa-part1-Connectives-29542" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29562" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29564" href="../Connectives/#plfa_plfa-part1-Connectives-29546" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29566" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29585" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29591" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29593" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5634" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-29601" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29603" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29606" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29608" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29613" href="../Connectives/#plfa_plfa-part1-Connectives-29613" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29615" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29617" href="../Connectives/#plfa_plfa-part1-Connectives-29617" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29619" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29621" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29623" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29645" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29647" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29649" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29654" href="../Connectives/#plfa_plfa-part1-Connectives-29654" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29656" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29658" href="../Connectives/#plfa_plfa-part1-Connectives-29658" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29660" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29662" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29664" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29686" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29692" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29694" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5676" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-29702" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29704" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29707" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29708" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29713" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29715" href="../Connectives/#plfa_plfa-part1-Connectives-29715" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29717" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29719" href="../Connectives/#plfa_plfa-part1-Connectives-29719" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29721" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29722" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29724" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29748" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29750" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29751" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29756" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29758" href="../Connectives/#plfa_plfa-part1-Connectives-29758" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29760" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29762" href="../Connectives/#plfa_plfa-part1-Connectives-29762" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29764" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29765" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29767" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29769" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29791" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29797" class="Symbol">}</a>
</pre><p>和对于积不满足分配律，但满足嵌入：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-distrib-×"></a><a id="plfa_plfa-part1-Connectives-29921" href="../Connectives/#plfa_plfa-part1-Connectives-29921" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-29933" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29935" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29937" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29938" href="../Connectives/#plfa_plfa-part1-Connectives-29938" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29940" href="../Connectives/#plfa_plfa-part1-Connectives-29940" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29942" href="../Connectives/#plfa_plfa-part1-Connectives-29942" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29944" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29946" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29949" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29951" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29953" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29954" href="../Connectives/#plfa_plfa-part1-Connectives-29938" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29956" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29958" href="../Connectives/#plfa_plfa-part1-Connectives-29940" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29959" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29961" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29963" href="../Connectives/#plfa_plfa-part1-Connectives-29942" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29965" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11699" class="Record Operator">≲</a> <a id="plfa_plfa-part1-Connectives-29967" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29968" href="../Connectives/#plfa_plfa-part1-Connectives-29938" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29970" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29972" href="../Connectives/#plfa_plfa-part1-Connectives-29942" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29973" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29975" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29977" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29978" href="../Connectives/#plfa_plfa-part1-Connectives-29940" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29980" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29982" href="../Connectives/#plfa_plfa-part1-Connectives-29942" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29983" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-29985" href="../Connectives/#plfa_plfa-part1-Connectives-29921" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-29997" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-30001" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-30012" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-30014" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11739" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-30022" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30024" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30027" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30028" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30033" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30035" href="../Connectives/#plfa_plfa-part1-Connectives-30035" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30037" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30039" href="../Connectives/#plfa_plfa-part1-Connectives-30039" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30041" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30042" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30044" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30046" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30048" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30053" href="../Connectives/#plfa_plfa-part1-Connectives-30035" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30055" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30057" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30062" href="../Connectives/#plfa_plfa-part1-Connectives-30039" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30064" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30083" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30085" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30086" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30091" href="../Connectives/#plfa_plfa-part1-Connectives-30091" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30092" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30102" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30104" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30106" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30111" href="../Connectives/#plfa_plfa-part1-Connectives-30091" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30113" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30115" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30120" href="../Connectives/#plfa_plfa-part1-Connectives-30091" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30122" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30141" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30147" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30149" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11759" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-30157" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30159" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30162" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30164" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30169" href="../Connectives/#plfa_plfa-part1-Connectives-30169" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30171" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30173" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30178" href="../Connectives/#plfa_plfa-part1-Connectives-30178" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30180" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30182" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30184" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30185" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30190" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30192" href="../Connectives/#plfa_plfa-part1-Connectives-30169" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30194" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30196" href="../Connectives/#plfa_plfa-part1-Connectives-30178" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30198" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30199" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30218" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30220" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30222" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30227" href="../Connectives/#plfa_plfa-part1-Connectives-30227" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30229" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30231" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30236" href="../Connectives/#plfa_plfa-part1-Connectives-30236" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30238" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30240" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30242" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30243" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30248" href="../Connectives/#plfa_plfa-part1-Connectives-30236" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30249" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30268" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30270" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30272" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30277" href="../Connectives/#plfa_plfa-part1-Connectives-30277" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30279" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30281" class="Symbol">_</a>      <a id="plfa_plfa-part1-Connectives-30288" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30290" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30292" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30293" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30298" href="../Connectives/#plfa_plfa-part1-Connectives-30277" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30299" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30318" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30324" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30326" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11779" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-30334" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30336" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30339" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30340" href="../Connectives/#plfa_plfa-part1-Connectives-14742" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30345" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30347" href="../Connectives/#plfa_plfa-part1-Connectives-30347" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30349" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30351" href="../Connectives/#plfa_plfa-part1-Connectives-30351" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30353" href="../Connectives/#plfa_plfa-part1-Connectives-1680" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30354" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30356" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30358" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30380" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30382" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30383" href="../Connectives/#plfa_plfa-part1-Connectives-14784" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30388" href="../Connectives/#plfa_plfa-part1-Connectives-30388" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30389" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30399" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30401" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30423" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30429" class="Symbol">}</a>
</pre><p>我们在定义 <code>from</code> 函数的时候可以有选择。给定的定义中，它将 <code>⟨ inj₂ z , inj₂ z′ ⟩</code> 转换为 <code>inj₂ z</code>，但我们也可以返回 <code>inj₂ z′</code> 作为嵌入证明的变种。我们在这里只能证明嵌入， 而不能证明同构，因为 <code>from</code> 函数必须丢弃 <code>z</code> 或者 <code>z′</code> 其中的一个。</p><p>在一般的逻辑学方法中，两条分配律都以等价的形式给出，每一边都蕴涵了另一边：</p><pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre><p>但当我们考虑提供上述蕴涵证明的函数时，第一条对应同构而第二条只能对应嵌入， 揭示了有些定理比另一个更加的「正确」。</p><h4 id="练习--weak--推荐">练习 <code>⊎-weak-×</code> （推荐）</h4><p>证明如下性质成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31624" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎-weak-×"></a><a id="plfa_plfa-part1-Connectives-31636" href="../Connectives/#plfa_plfa-part1-Connectives-31636" class="Postulate">⊎-weak-×</a> <a id="plfa_plfa-part1-Connectives-31645" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31647" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-31649" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-31650" href="../Connectives/#plfa_plfa-part1-Connectives-31650" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31652" href="../Connectives/#plfa_plfa-part1-Connectives-31652" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31654" href="../Connectives/#plfa_plfa-part1-Connectives-31654" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31656" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31658" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-31661" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-31663" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31665" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31666" href="../Connectives/#plfa_plfa-part1-Connectives-31650" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31668" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31670" href="../Connectives/#plfa_plfa-part1-Connectives-31652" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-31671" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-31673" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31675" href="../Connectives/#plfa_plfa-part1-Connectives-31654" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31677" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31679" href="../Connectives/#plfa_plfa-part1-Connectives-31650" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31681" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31683" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31684" href="../Connectives/#plfa_plfa-part1-Connectives-31652" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31686" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31688" href="../Connectives/#plfa_plfa-part1-Connectives-31654" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-31689" class="Symbol">)</a>
</pre><p>这被称为<strong>弱分配律（Weak Distributive Law）</strong>。给出相对应的分配律，并解释分配律与弱分配律的关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31910" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--implies-实践">练习 <code>⊎×-implies-×⊎</code>（实践）</h4><p>证明合取的析取蕴涵了析取的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32111" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎×-implies-×⊎"></a><a id="plfa_plfa-part1-Connectives-32123" href="../Connectives/#plfa_plfa-part1-Connectives-32123" class="Postulate">⊎×-implies-×⊎</a> <a id="plfa_plfa-part1-Connectives-32137" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32139" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-32141" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-32142" href="../Connectives/#plfa_plfa-part1-Connectives-32142" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32144" href="../Connectives/#plfa_plfa-part1-Connectives-32144" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32146" href="../Connectives/#plfa_plfa-part1-Connectives-32146" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32148" href="../Connectives/#plfa_plfa-part1-Connectives-32148" class="Bound">D</a> <a id="plfa_plfa-part1-Connectives-32150" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32152" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-32155" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-32157" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32159" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32160" href="../Connectives/#plfa_plfa-part1-Connectives-32142" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32162" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32164" href="../Connectives/#plfa_plfa-part1-Connectives-32144" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-32165" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32167" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32169" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32170" href="../Connectives/#plfa_plfa-part1-Connectives-32146" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32172" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32174" href="../Connectives/#plfa_plfa-part1-Connectives-32148" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32175" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32177" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32179" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32180" href="../Connectives/#plfa_plfa-part1-Connectives-32142" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32182" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32184" href="../Connectives/#plfa_plfa-part1-Connectives-32146" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-32185" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32187" href="../Connectives/#plfa_plfa-part1-Connectives-1649" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32189" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32190" href="../Connectives/#plfa_plfa-part1-Connectives-32144" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32192" href="../Connectives/#plfa_plfa-part1-Connectives-14711" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32194" href="../Connectives/#plfa_plfa-part1-Connectives-32148" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32195" class="Symbol">)</a>
</pre><p>反命题成立吗？如果成立，给出证明；如果不成立，给出反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32321" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32498" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32505" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Connectives-32518" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32524" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32525" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Connectives-32528" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32530" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#234" class="Field">proj₁</a><a id="plfa_plfa-part1-Connectives-32535" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32537" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#246" class="Field">proj₂</a><a id="plfa_plfa-part1-Connectives-32542" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32544" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32553" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32554" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Connectives-32558" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32561" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Connectives-32566" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32568" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32575" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Connectives-32585" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32591" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32592" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="plfa_plfa-part1-Connectives-32593" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Connectives-32597" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32599" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32606" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Connectives-32615" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32621" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32622" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Connectives-32625" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32627" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-32631" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32633" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-32637" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32639" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32648" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32649" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#920" class="Function Operator">[_,_]</a> <a id="plfa_plfa-part1-Connectives-32655" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32658" class="Function Operator">case-⊎</a><a id="plfa_plfa-part1-Connectives-32664" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32666" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32673" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Connectives-32684" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32690" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32691" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Connectives-32692" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32694" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Connectives-32700" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32702" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32709" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="plfa_plfa-part1-Connectives-32730" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32736" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32737" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Equivalence.html#1204" class="Function Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-32740" class="Symbol">)</a>
</pre><p>标准库中使用 <code>_,_</code> 构造数据对，而我们使用 <code>⟨_,_⟩</code>。前者在从数据对构造三元对或者更大的 元组时更加的方便，允许 <code>a , b , c</code> 作为 <code>(a, (b , c))</code> 的记法。但它与其他有用的记法相冲突， 比如说 <a href="../Lists/">Lists</a> 中的 <code>[_,_]</code> 记法表示两个元素的列表， 或者 <a href="../DeBruijn/">DeBruijn</a> 章节中的 <code>Γ , A</code> 来表示环境的扩展。 标准库中的 <code>_⇔_</code> 和我们的相似，但使用起来比较不便， 因为它可以根据任意的相等性定义进行参数化。</p><h2 id="unicode">Unicode</h2><p>本章节使用下列 Unicode：</p><pre><code>×  U+00D7  乘法符号 (\x)
⊎  U+228E  多重集并集 (\u+)
⊤  U+22A4  向下图钉 (\top)
⊥  U+22A5  向上图钉 (\bot)
η  U+03B7  希腊小写字母 ETA (\eta)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)</code></pre><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>此段内容由 Propositions as Types（命题即类型）改编而来， 作者：Philip Wadler，发表于 《ACM 通讯》，2015 年 9 月<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>