<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-oald/giFwKDrcy9DORpCxMSq2IAFjgwVUM5pRbyPtm60xZT/52VIm0b9qqbL2UcrxYzxM4cYrtRk02or57bQsA==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-3emtxUSJDVriAZnzOyZFTRu0beO+lk81E2cRDhzd62DQrlh2u4kR6+lz2dOUNZwPDvGwcqfFRrKJO2Zu0O4IJA==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Connectives</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Connectives: 合取、析取与蕴涵</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Connectives-110" class="Keyword">module</a> <a id="plfa_plfa-part1-Connectives-117" href="../Connectives/#" class="Module">plfa.part1.Connectives</a> <a id="plfa_plfa-part1-Connectives-140" class="Keyword">where</a>
</pre><p>本章节介绍基础的逻辑运算符。我们使用逻辑运算符与数据类型之间的对应关系， 即<strong>命题即类型（Propositions as Types）</strong>原理。</p><ul><li><strong>合取（Conjunction）</strong>即是<strong>积（Product）</strong></li><li><strong>析取（Disjunction）</strong>即是<strong>和（Sum）</strong></li><li><strong>真（True）</strong>即是<strong>单元类型（Unit Type）</strong></li><li><strong>假（False）</strong>即是<strong>空类型（Empty Type）</strong></li><li><strong>蕴涵（Implication）</strong>即是<strong>函数空间（Function Space）</strong></li></ul><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1070" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1077" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Connectives-1115" class="Symbol">as</a> <a id="plfa_plfa-part1-Connectives-1118" class="Module">Eq</a>
<a id="plfa_plfa-part1-Connectives-1121" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1126" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Connectives-1129" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1135" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1136" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Connectives-1139" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1141" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Connectives-1145" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1147" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1152" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Connectives-1167" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1172" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1179" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Connectives-1193" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1199" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1200" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Connectives-1201" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1203" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1208" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1215" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html" class="Module">Function.Base</a> <a id="plfa_plfa-part1-Connectives-1229" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1235" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1236" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Connectives-1239" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1241" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1246" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1253" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Connectives-1276" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1282" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1283" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Connectives-1286" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1288" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11704" class="Record Operator">_≲_</a><a id="plfa_plfa-part1-Connectives-1291" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1293" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Connectives-1307" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1309" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14965" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-1312" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1314" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1319" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10790" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre><h2 id="合取即是积">合取即是积</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其合取 <code>A × B</code> 成立当 <code>A</code> 成立和 <code>B</code> 成立。 我们用一个合适的数据类型将这样的概念形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1654" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_×_"></a><a id="plfa_plfa-part1-Connectives-1659" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">_×_</a> <a id="plfa_plfa-part1-Connectives-1663" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1664" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1666" href="../Connectives/#plfa_plfa-part1-Connectives-1666" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-1668" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1670" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-1673" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-1675" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1677" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-1681" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_×_.⟨_,_⟩"></a><a id="plfa_plfa-part1-Connectives-1690" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="plfa_plfa-part1-Connectives-1696" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-1704" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-1710" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1712" href="../Connectives/#plfa_plfa-part1-Connectives-1666" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-1720" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-1730" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1732" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1734" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-1736" href="../Connectives/#plfa_plfa-part1-Connectives-1666" class="Bound">B</a>
</pre><p><code>A × B</code> 成立的证明由 <code>⟨ M , N ⟩</code> 的形式表现，其中 <code>M</code> 是 <code>A</code> 成立的证明， <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A × B</code> 成立的证明，我们可以得出 <code>A</code> 成立和 <code>B</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-proj₁"></a><a id="plfa_plfa-part1-Connectives-2110" href="../Connectives/#plfa_plfa-part1-Connectives-2110" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2116" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2118" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2120" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2121" href="../Connectives/#plfa_plfa-part1-Connectives-2121" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2123" href="../Connectives/#plfa_plfa-part1-Connectives-2123" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2125" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2127" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2130" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2134" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2136" href="../Connectives/#plfa_plfa-part1-Connectives-2121" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2138" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2140" href="../Connectives/#plfa_plfa-part1-Connectives-2123" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2146" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2154" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2156" href="../Connectives/#plfa_plfa-part1-Connectives-2121" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-2158" href="../Connectives/#plfa_plfa-part1-Connectives-2110" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2164" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2166" href="../Connectives/#plfa_plfa-part1-Connectives-2166" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2168" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2170" href="../Connectives/#plfa_plfa-part1-Connectives-2170" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2172" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2174" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2176" href="../Connectives/#plfa_plfa-part1-Connectives-2166" class="Bound">x</a>

<a id="plfa_plfa-part1-Connectives-proj₂"></a><a id="plfa_plfa-part1-Connectives-2179" href="../Connectives/#plfa_plfa-part1-Connectives-2179" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2185" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2187" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2189" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2190" href="../Connectives/#plfa_plfa-part1-Connectives-2190" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2192" href="../Connectives/#plfa_plfa-part1-Connectives-2192" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2194" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2196" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2199" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2203" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2205" href="../Connectives/#plfa_plfa-part1-Connectives-2190" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2207" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2209" href="../Connectives/#plfa_plfa-part1-Connectives-2192" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2215" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2223" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2225" href="../Connectives/#plfa_plfa-part1-Connectives-2192" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-2227" href="../Connectives/#plfa_plfa-part1-Connectives-2179" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2233" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2235" href="../Connectives/#plfa_plfa-part1-Connectives-2235" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2237" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2239" href="../Connectives/#plfa_plfa-part1-Connectives-2239" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2241" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2243" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2245" href="../Connectives/#plfa_plfa-part1-Connectives-2239" class="Bound">y</a>
</pre><p>如果 <code>L</code> 是 <code>A × B</code> 成立的证据, 那么 <code>proj₁ L</code> 是 <code>A</code> 成立的证据， <code>proj₂ L</code> 是 <code>B</code> 成立的证据。</p><p>当 <code>⟨_,_⟩</code> 在等式右手边的项中出现的时候，我们将其称作<strong>构造子（Constructor）</strong>， 当它出现在等式左边时，我们将其称作<strong>解构子（Destructor）</strong>。我们亦可将 <code>proj₁</code> 和 <code>proj₂</code> 称作解构子，因为它们起到相似的效果。</p><p>其他的术语将 <code>⟨_,_⟩</code> 称作<strong>引入（Introduce）</strong>合取，将 <code>proj₁</code> 和 <code>proj₂</code> 称作<strong>消去（Eliminate）</strong>合取。 前者亦记作 <code>×-I</code>，后者 <code>×-E₁</code> 和 <code>×-E₂</code>。如果我们从上到下来阅读这些规则，引入和消去 正如其名字所说的那样：第一条<strong>引入</strong>一个运算符，所以运算符出现在结论中，而不是假设中； 第二条<strong>消去</strong>一个带有运算符的式子，而运算符出现在假设中，而不是结论中。引入规则描述了 运算符在什么情况下成立——即怎么样<strong>定义</strong>一个运算符。消去规则描述了运算符成立时，可以得出 什么样的结论——即怎么样<strong>使用</strong>一个运算符。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>在这样的情况下，先使用解构子，再使用构造子将结果重组，得到还是原来的积。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×"></a><a id="plfa_plfa-part1-Connectives-4212" href="../Connectives/#plfa_plfa-part1-Connectives-4212" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4216" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4218" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-4220" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-4221" href="../Connectives/#plfa_plfa-part1-Connectives-4221" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4223" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4225" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4227" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4230" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-4232" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4233" href="../Connectives/#plfa_plfa-part1-Connectives-4233" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4235" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4237" href="../Connectives/#plfa_plfa-part1-Connectives-4221" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4239" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-4241" href="../Connectives/#plfa_plfa-part1-Connectives-4223" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-4242" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4244" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-4246" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4248" href="../Connectives/#plfa_plfa-part1-Connectives-2110" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-4254" href="../Connectives/#plfa_plfa-part1-Connectives-4233" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4256" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4258" href="../Connectives/#plfa_plfa-part1-Connectives-2179" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-4264" href="../Connectives/#plfa_plfa-part1-Connectives-4233" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4266" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4268" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-4270" href="../Connectives/#plfa_plfa-part1-Connectives-4233" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-4272" href="../Connectives/#plfa_plfa-part1-Connectives-4212" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4276" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4278" href="../Connectives/#plfa_plfa-part1-Connectives-4278" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-4280" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4282" href="../Connectives/#plfa_plfa-part1-Connectives-4282" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-4284" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4286" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-4288" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>⟨ x , y ⟩</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项。</p><p>我们设置合取的优先级，使它与除了析取之外结合的都不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4678" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-4685" class="Number">2</a> <a id="plfa_plfa-part1-Connectives-4687" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">_×_</a>
</pre><p>因此，<code>m ≤ n × n ≤ p</code> 解析为 <code>(m ≤ n) × (n ≤ p)</code>。</p><p>Alternatively, we can declare conjunction as a record type:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4873" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-_×′_"></a><a id="plfa_plfa-part1-Connectives-4880" href="../Connectives/#plfa_plfa-part1-Connectives-4880" class="Record Operator">_×′_</a> <a id="plfa_plfa-part1-Connectives-4885" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4886" href="../Connectives/#plfa_plfa-part1-Connectives-4886" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4888" href="../Connectives/#plfa_plfa-part1-Connectives-4888" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4890" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4892" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4895" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4897" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4899" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-4903" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-4911" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-⟨_,_⟩′"></a><a id="plfa_plfa-part1-Connectives-4923" href="../Connectives/#plfa_plfa-part1-Connectives-4923" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="plfa_plfa-part1-Connectives-4932" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₁′"></a><a id="plfa_plfa-part1-Connectives-4942" href="../Connectives/#plfa_plfa-part1-Connectives-4942" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-4949" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4951" href="../Connectives/#plfa_plfa-part1-Connectives-4886" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₂′"></a><a id="plfa_plfa-part1-Connectives-4957" href="../Connectives/#plfa_plfa-part1-Connectives-4957" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-4964" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4966" href="../Connectives/#plfa_plfa-part1-Connectives-4888" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-4968" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-4973" href="../Connectives/#plfa_plfa-part1-Connectives-4880" class="Module Operator">_×′_</a>
</pre><p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p><p>The data type <code>_×_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×′"></a><a id="plfa_plfa-part1-Connectives-5530" href="../Connectives/#plfa_plfa-part1-Connectives-5530" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5535" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5537" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-5539" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-5540" href="../Connectives/#plfa_plfa-part1-Connectives-5540" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5542" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-5544" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5546" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-5549" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-5551" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-5552" href="../Connectives/#plfa_plfa-part1-Connectives-5552" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5554" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5556" href="../Connectives/#plfa_plfa-part1-Connectives-5540" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5558" href="../Connectives/#plfa_plfa-part1-Connectives-4880" class="Record Operator">×′</a> <a id="plfa_plfa-part1-Connectives-5561" href="../Connectives/#plfa_plfa-part1-Connectives-5542" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-5562" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-5564" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-5566" href="../Connectives/#plfa_plfa-part1-Connectives-4923" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-5568" href="../Connectives/#plfa_plfa-part1-Connectives-4942" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-5575" href="../Connectives/#plfa_plfa-part1-Connectives-5552" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5577" href="../Connectives/#plfa_plfa-part1-Connectives-4923" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-5579" href="../Connectives/#plfa_plfa-part1-Connectives-4957" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-5586" href="../Connectives/#plfa_plfa-part1-Connectives-5552" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5588" href="../Connectives/#plfa_plfa-part1-Connectives-4923" class="InductiveConstructor Operator">⟩′</a> <a id="plfa_plfa-part1-Connectives-5591" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-5593" href="../Connectives/#plfa_plfa-part1-Connectives-5552" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-5595" href="../Connectives/#plfa_plfa-part1-Connectives-5530" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5600" href="../Connectives/#plfa_plfa-part1-Connectives-5600" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5602" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-5604" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A × B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>积</strong>。 在集合论中它也被称作<strong>笛卡尔积（Cartesian Product）</strong>，在计算机科学中它对应<strong>记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A × B</code> 有 <code>m * n</code> 个不同的成员。这也是它被称为积的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-6542" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Bool"></a><a id="plfa_plfa-part1-Connectives-6547" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-6552" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6554" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6558" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Bool.true"></a><a id="plfa_plfa-part1-Connectives-6566" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-6572" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6574" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Connectives-Bool.false"></a><a id="plfa_plfa-part1-Connectives-6581" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-6587" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6589" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a>

<a id="plfa_plfa-part1-Connectives-6595" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Tri"></a><a id="plfa_plfa-part1-Connectives-6600" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-6604" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6606" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6610" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Tri.aa"></a><a id="plfa_plfa-part1-Connectives-6618" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-6621" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6623" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.bb"></a><a id="plfa_plfa-part1-Connectives-6629" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-6632" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6634" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.cc"></a><a id="plfa_plfa-part1-Connectives-6640" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-6643" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6645" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a>
</pre><p>那么，<code>Bool × Tri</code> 类型有如下的六个成员：</p><pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre><p>下面的函数枚举了所有类型为 <code>Bool × Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-count"></a><a id="plfa_plfa-part1-Connectives-6991" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-6999" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7001" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-7006" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-7008" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-7012" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-7014" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-7016" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7024" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7026" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7032" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7034" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7037" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7040" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7043" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-7045" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7053" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7055" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7061" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7063" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7066" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7069" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7072" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-7074" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7082" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7084" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7090" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7092" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7095" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7098" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7101" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-7103" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7111" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7113" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7119" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7121" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7124" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7127" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7130" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-7132" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7140" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7142" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7148" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7150" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7153" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7156" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7159" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-7161" href="../Connectives/#plfa_plfa-part1-Connectives-6991" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7169" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7171" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7177" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7179" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7182" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7185" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7188" class="Number">6</a>
</pre><p>类型上的积与数的积有相似的性质——它们满足交换律和结合律。 更确切地说，积在<strong>在同构意义下</strong>满足交换律和结合率。</p><p>对于交换律，<code>to</code> 函数将有序对交换，将 <code>⟨ x , y ⟩</code> 变为 <code>⟨ y , x ⟩</code>，<code>from</code> 函数亦是如此（忽略命名）。 在 <code>from∘to</code> 和 <code>to∘from</code> 中正确地实例化要匹配的模式是很重要的。 使用 <code>λ w → refl</code> 作为 <code>from∘to</code> 的定义是不可行的，<code>to∘from</code> 同理。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-comm"></a><a id="plfa_plfa-part1-Connectives-7977" href="../Connectives/#plfa_plfa-part1-Connectives-7977" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-7984" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7986" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-7988" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-7989" href="../Connectives/#plfa_plfa-part1-Connectives-7989" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-7991" href="../Connectives/#plfa_plfa-part1-Connectives-7991" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-7993" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7995" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-7998" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-8000" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8002" href="../Connectives/#plfa_plfa-part1-Connectives-7989" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-8004" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-8006" href="../Connectives/#plfa_plfa-part1-Connectives-7991" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-8008" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-8010" href="../Connectives/#plfa_plfa-part1-Connectives-7991" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-8012" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-8014" href="../Connectives/#plfa_plfa-part1-Connectives-7989" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-8016" href="../Connectives/#plfa_plfa-part1-Connectives-7977" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-8023" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-8027" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-8038" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-8040" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>       <a id="plfa_plfa-part1-Connectives-8049" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8052" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8055" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8057" href="../Connectives/#plfa_plfa-part1-Connectives-8057" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8059" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8061" href="../Connectives/#plfa_plfa-part1-Connectives-8061" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8063" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8065" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8067" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8069" href="../Connectives/#plfa_plfa-part1-Connectives-8061" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8071" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8073" href="../Connectives/#plfa_plfa-part1-Connectives-8057" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8075" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8077" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8083" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8085" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>     <a id="plfa_plfa-part1-Connectives-8094" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8097" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8100" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8102" href="../Connectives/#plfa_plfa-part1-Connectives-8102" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8104" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8106" href="../Connectives/#plfa_plfa-part1-Connectives-8106" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8108" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8110" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8112" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8114" href="../Connectives/#plfa_plfa-part1-Connectives-8106" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8116" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8118" href="../Connectives/#plfa_plfa-part1-Connectives-8102" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8120" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8122" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8128" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8130" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a>  <a id="plfa_plfa-part1-Connectives-8139" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8142" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8145" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8147" href="../Connectives/#plfa_plfa-part1-Connectives-8147" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8149" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8151" href="../Connectives/#plfa_plfa-part1-Connectives-8151" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8153" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8155" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8157" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8162" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8168" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8170" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a>  <a id="plfa_plfa-part1-Connectives-8179" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8182" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8185" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8187" href="../Connectives/#plfa_plfa-part1-Connectives-8187" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8189" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8191" href="../Connectives/#plfa_plfa-part1-Connectives-8191" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8193" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8195" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8197" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8202" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8208" class="Symbol">}</a>
</pre><p>满足<strong>交换律</strong>和<strong>在同构意义下满足交换律</strong>是不一样的。比较下列两个命题：</p><pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre><p>在第一个情况下，我们可能有 <code>m</code> 是 <code>2</code>、<code>n</code> 是 <code>3</code>，那么 <code>m * n</code> 和 <code>n * m</code> 都是 <code>6</code>。 在第二个情况下，我们可能有 <code>A</code> 是 <code>Bool</code> 和 <code>B</code> 是 <code>Tri</code>，但是 <code>Bool × Tri</code> 和 <code>Tri × Bool</code> <strong>不是</strong>一样的。但是存在一个两者之间的同构。例如：<code>⟨ true , aa ⟩</code> 是前者的成员， 其对应后者的成员 <code>⟨ aa , true ⟩</code>。</p><p>对于结合律来说，<code>to</code> 函数将两个有序对进行重组：将 <code>⟨ ⟨ x , y ⟩ , z ⟩</code> 转换为 <code>⟨ x , ⟨ y , z ⟩ ⟩</code>， <code>from</code> 函数则为其逆。同样，左逆和右逆的证明需要在一个合适的模式来匹配，从而可以直接化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-assoc"></a><a id="plfa_plfa-part1-Connectives-9474" href="../Connectives/#plfa_plfa-part1-Connectives-9474" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9482" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9484" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-9486" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-9487" href="../Connectives/#plfa_plfa-part1-Connectives-9487" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9489" href="../Connectives/#plfa_plfa-part1-Connectives-9489" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9491" href="../Connectives/#plfa_plfa-part1-Connectives-9491" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9493" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9495" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-9498" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-9500" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9502" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9503" href="../Connectives/#plfa_plfa-part1-Connectives-9487" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9505" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9507" href="../Connectives/#plfa_plfa-part1-Connectives-9489" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-9508" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-9510" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9512" href="../Connectives/#plfa_plfa-part1-Connectives-9491" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9514" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-9516" href="../Connectives/#plfa_plfa-part1-Connectives-9487" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9518" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9520" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9521" href="../Connectives/#plfa_plfa-part1-Connectives-9489" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9523" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9525" href="../Connectives/#plfa_plfa-part1-Connectives-9491" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-9526" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-9528" href="../Connectives/#plfa_plfa-part1-Connectives-9474" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9536" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-9540" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-9551" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-9553" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-9561" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9563" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9566" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9568" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9570" href="../Connectives/#plfa_plfa-part1-Connectives-9570" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9572" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9574" href="../Connectives/#plfa_plfa-part1-Connectives-9574" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9576" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9578" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9580" href="../Connectives/#plfa_plfa-part1-Connectives-9580" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9582" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9584" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9586" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9588" href="../Connectives/#plfa_plfa-part1-Connectives-9570" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9590" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9592" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9594" href="../Connectives/#plfa_plfa-part1-Connectives-9574" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9596" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9598" href="../Connectives/#plfa_plfa-part1-Connectives-9580" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9600" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9602" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9604" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9610" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9612" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-9620" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9622" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9625" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9627" href="../Connectives/#plfa_plfa-part1-Connectives-9627" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9629" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9631" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9633" href="../Connectives/#plfa_plfa-part1-Connectives-9633" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9635" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9637" href="../Connectives/#plfa_plfa-part1-Connectives-9637" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9639" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9641" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9643" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9645" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9647" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9649" href="../Connectives/#plfa_plfa-part1-Connectives-9627" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9651" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9653" href="../Connectives/#plfa_plfa-part1-Connectives-9633" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9655" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9657" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9659" href="../Connectives/#plfa_plfa-part1-Connectives-9637" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9661" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9663" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9669" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9671" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-9679" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9681" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9684" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9686" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9688" href="../Connectives/#plfa_plfa-part1-Connectives-9688" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9690" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9692" href="../Connectives/#plfa_plfa-part1-Connectives-9692" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9694" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9696" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9698" href="../Connectives/#plfa_plfa-part1-Connectives-9698" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9700" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9702" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9704" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9709" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9715" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9717" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-9725" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9727" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9730" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9732" href="../Connectives/#plfa_plfa-part1-Connectives-9732" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9734" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9736" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9738" href="../Connectives/#plfa_plfa-part1-Connectives-9738" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9740" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9742" href="../Connectives/#plfa_plfa-part1-Connectives-9742" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9744" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9746" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9748" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9750" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9755" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9761" class="Symbol">}</a>
</pre><p>满足<strong>结合律</strong>和<strong>在同构意义下满足结合律</strong>是不一样的。比较下列两个命题：</p><pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre><p>举个例子，<code>(ℕ × Bool) × Tri</code> 与 <code>ℕ × (Bool × Tri)</code> <strong>不同</strong>，但是两个类型之间 存在同构。例如 <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>，一个前者的成员，与 <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>， 一个后者的成员，相对应。</p><h4 id="练习-实践">练习 <code>⇔≃×</code>（实践）</h4><p>证明<a href="../Isomorphism/#iff">之前</a>定义的 <code>A ⇔ B</code> 与 <code>(A → B) × (B → A)</code> 同构。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10655" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="真即是单元类型">真即是单元类型</h2><p>恒真 <code>⊤</code> 恒成立。我们将这个概念用合适的数据类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10843" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊤"></a><a id="plfa_plfa-part1-Connectives-10848" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-10850" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-10852" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-10856" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-⊤.tt"></a><a id="plfa_plfa-part1-Connectives-10865" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-10868" class="Symbol">:</a>
    <a id="plfa_plfa-part1-Connectives-10874" class="Comment">--</a>
    <a id="plfa_plfa-part1-Connectives-10881" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a>
</pre><p><code>⊤</code> 成立的证明由 <code>tt</code> 的形式构成。</p><p>恒真有引入规则，但没有消去规则。给定一个 <code>⊤</code> 成立的证明，我们不能得出任何有趣的结论。 因为恒真恒成立，知道恒真成立不会给我们带来新的知识。</p><p><code>η-×</code> 的 零元形式是 <code>η-⊤</code>，其断言了任何 <code>⊤</code> 类型的值一定等于 <code>tt</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤"></a><a id="plfa_plfa-part1-Connectives-11425" href="../Connectives/#plfa_plfa-part1-Connectives-11425" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11429" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11431" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-11433" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-11434" href="../Connectives/#plfa_plfa-part1-Connectives-11434" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-11436" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11438" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-11439" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-11441" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-11443" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11446" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-11448" href="../Connectives/#plfa_plfa-part1-Connectives-11434" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-11450" href="../Connectives/#plfa_plfa-part1-Connectives-11425" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11454" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11457" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-11459" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。将 <code>w</code> 替换为 <code>tt</code> 让等式两边可以化简为相同的值。</p>Alternatively, we can declare truth as an empty record:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-11745" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-⊤′"></a><a id="plfa_plfa-part1-Connectives-11752" href="../Connectives/#plfa_plfa-part1-Connectives-11752" class="Record">⊤′</a> <a id="plfa_plfa-part1-Connectives-11755" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11757" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-11761" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-11769" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-tt′"></a><a id="plfa_plfa-part1-Connectives-11781" href="../Connectives/#plfa_plfa-part1-Connectives-11781" class="InductiveConstructor">tt′</a>
</pre><p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤′"></a><a id="plfa_plfa-part1-Connectives-12156" href="../Connectives/#plfa_plfa-part1-Connectives-12156" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12161" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12163" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-12165" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-12166" href="../Connectives/#plfa_plfa-part1-Connectives-12166" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12168" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12170" href="../Connectives/#plfa_plfa-part1-Connectives-11752" class="Record">⊤′</a><a id="plfa_plfa-part1-Connectives-12172" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-12174" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12176" href="../Connectives/#plfa_plfa-part1-Connectives-11781" class="InductiveConstructor">tt′</a> <a id="plfa_plfa-part1-Connectives-12180" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-12182" href="../Connectives/#plfa_plfa-part1-Connectives-12166" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-12184" href="../Connectives/#plfa_plfa-part1-Connectives-12156" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12189" href="../Connectives/#plfa_plfa-part1-Connectives-12189" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12191" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12193" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre>Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-truth′"></a><a id="plfa_plfa-part1-Connectives-12343" href="../Connectives/#plfa_plfa-part1-Connectives-12343" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12350" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12352" href="../Connectives/#plfa_plfa-part1-Connectives-11752" class="Record">⊤′</a>
<a id="plfa_plfa-part1-Connectives-12355" href="../Connectives/#plfa_plfa-part1-Connectives-12343" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12362" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12364" class="Symbol">_</a>
</pre><p>我们将 <code>⊤</code> 称为<strong>单元（Unit Type）</strong>类型。实际上，<code>⊤</code> 类型只有一个成员 <code>tt</code>。 例如，下面的函数枚举了所有 <code>⊤</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-count"></a><a id="plfa_plfa-part1-Connectives-12640" href="../Connectives/#plfa_plfa-part1-Connectives-12640" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12648" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12650" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-12652" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12654" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-12656" href="../Connectives/#plfa_plfa-part1-Connectives-12640" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12664" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-12667" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12669" class="Number">1</a>
</pre><p>对于数来说，1 是乘法的幺元。对应地，单元是积的幺元（<strong>在同构意义下</strong>）。对于左幺元来说， <code>to</code> 函数将 <code>⟨ tt , x ⟩</code> 转换成 <code>x</code>， <code>from</code> 函数则是其反函数。左逆的证明需要 匹配一个合适的模式来化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityˡ"></a><a id="plfa_plfa-part1-Connectives-13142" href="../Connectives/#plfa_plfa-part1-Connectives-13142" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13154" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13156" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-13158" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-13159" href="../Connectives/#plfa_plfa-part1-Connectives-13159" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13161" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13163" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-13166" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-13168" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13170" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-13172" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-13174" href="../Connectives/#plfa_plfa-part1-Connectives-13159" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13176" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-13178" href="../Connectives/#plfa_plfa-part1-Connectives-13159" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-13180" href="../Connectives/#plfa_plfa-part1-Connectives-13142" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13192" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-13196" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-13207" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-13209" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-13217" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13219" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13222" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13224" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13227" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13229" href="../Connectives/#plfa_plfa-part1-Connectives-13229" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13231" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13233" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13235" href="../Connectives/#plfa_plfa-part1-Connectives-13229" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13237" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13243" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13245" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-13253" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13255" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13258" href="../Connectives/#plfa_plfa-part1-Connectives-13258" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13260" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13262" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13264" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13267" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13269" href="../Connectives/#plfa_plfa-part1-Connectives-13258" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13271" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13273" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13279" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13281" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-13289" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13291" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13294" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13296" href="../Connectives/#plfa_plfa-part1-Connectives-10865" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13299" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13301" href="../Connectives/#plfa_plfa-part1-Connectives-13301" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13303" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13305" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13307" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13312" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13318" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13320" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-13328" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13330" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13333" href="../Connectives/#plfa_plfa-part1-Connectives-13333" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13335" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13337" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13342" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13348" class="Symbol">}</a>
</pre><p><strong>幺元</strong>和<strong>在同构意义下的幺元</strong>是不一样的。比较下列两个命题：</p><pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre><p>在第一种情况下，我们可能有 <code>m</code> 是 <code>2</code>，那么 <code>1 * m</code> 和 <code>m</code> 都为 <code>2</code>。 在第二种情况下，我们可能有 <code>A</code> 是 <code>Bool</code>，但是 <code>⊤ × Bool</code> 和 <code>Bool</code> 是不同的。 例如：<code>⟨ tt , true ⟩</code> 是前者的成员，其对应后者的成员 <code>true</code>。</p><p>右幺元可以由积的交换律得来：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityʳ"></a><a id="plfa_plfa-part1-Connectives-14168" href="../Connectives/#plfa_plfa-part1-Connectives-14168" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14180" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14182" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-14184" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14185" href="../Connectives/#plfa_plfa-part1-Connectives-14185" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14187" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14189" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14192" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14194" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14196" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14197" href="../Connectives/#plfa_plfa-part1-Connectives-14185" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14199" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14201" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14202" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14204" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-14206" href="../Connectives/#plfa_plfa-part1-Connectives-14185" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-14208" href="../Connectives/#plfa_plfa-part1-Connectives-14168" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14220" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14221" href="../Connectives/#plfa_plfa-part1-Connectives-14221" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14222" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14224" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-14228" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10866" class="Function Operator">≃-begin</a>
    <a id="plfa_plfa-part1-Connectives-14240" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14241" href="../Connectives/#plfa_plfa-part1-Connectives-14221" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14243" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14245" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14246" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14250" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10950" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14253" href="../Connectives/#plfa_plfa-part1-Connectives-7977" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-14260" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10950" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14266" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14267" href="../Connectives/#plfa_plfa-part1-Connectives-10848" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-14269" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14271" href="../Connectives/#plfa_plfa-part1-Connectives-14221" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14272" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14276" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10950" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14279" href="../Connectives/#plfa_plfa-part1-Connectives-13142" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-14291" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10950" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14297" href="../Connectives/#plfa_plfa-part1-Connectives-14221" class="Bound">A</a>
  <a id="plfa_plfa-part1-Connectives-14301" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11069" class="Function Operator">≃-∎</a>
</pre><p>我们在此使用了同构链，与等式链相似。</p><h2 id="析取即是和">析取即是和</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，析取 <code>A ⊎ B</code> 在 <code>A</code> 成立或者 <code>B</code> 成立时成立。 我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-14716" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_⊎_"></a><a id="plfa_plfa-part1-Connectives-14721" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">_⊎_</a> <a id="plfa_plfa-part1-Connectives-14725" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14726" href="../Connectives/#plfa_plfa-part1-Connectives-14726" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14728" href="../Connectives/#plfa_plfa-part1-Connectives-14728" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-14730" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14732" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14735" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14737" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14739" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-14743" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₁"></a><a id="plfa_plfa-part1-Connectives-14752" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-14757" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14765" href="../Connectives/#plfa_plfa-part1-Connectives-14726" class="Bound">A</a>
      <a id="plfa_plfa-part1-Connectives-14773" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14783" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14785" href="../Connectives/#plfa_plfa-part1-Connectives-14726" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14787" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14789" href="../Connectives/#plfa_plfa-part1-Connectives-14728" class="Bound">B</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₂"></a><a id="plfa_plfa-part1-Connectives-14794" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-14799" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14807" href="../Connectives/#plfa_plfa-part1-Connectives-14728" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-14815" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14825" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14827" href="../Connectives/#plfa_plfa-part1-Connectives-14726" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14829" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14831" href="../Connectives/#plfa_plfa-part1-Connectives-14728" class="Bound">B</a>
</pre><p><code>A ⊎ B</code> 成立的证明有两个形式： <code>inj₁ M</code>，其中 <code>M</code> 是 <code>A</code> 成立的证明，或者 <code>inj₂ N</code>，其中 <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A → C</code> 和 <code>B → C</code> 成立的证明，那么给定一个 <code>A ⊎ B</code> 的证明，我们可以得出 <code>C</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-case-⊎"></a><a id="plfa_plfa-part1-Connectives-15292" href="../Connectives/#plfa_plfa-part1-Connectives-15292" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15299" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15301" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-15303" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-15304" href="../Connectives/#plfa_plfa-part1-Connectives-15304" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15306" href="../Connectives/#plfa_plfa-part1-Connectives-15306" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15308" href="../Connectives/#plfa_plfa-part1-Connectives-15308" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-15310" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15312" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-15315" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-15319" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15321" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15322" href="../Connectives/#plfa_plfa-part1-Connectives-15304" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15324" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15326" href="../Connectives/#plfa_plfa-part1-Connectives-15308" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15327" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15331" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15333" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15334" href="../Connectives/#plfa_plfa-part1-Connectives-15306" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15336" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15338" href="../Connectives/#plfa_plfa-part1-Connectives-15308" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15339" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15343" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15345" href="../Connectives/#plfa_plfa-part1-Connectives-15304" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15347" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-15349" href="../Connectives/#plfa_plfa-part1-Connectives-15306" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-15355" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Connectives-15369" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15371" href="../Connectives/#plfa_plfa-part1-Connectives-15308" class="Bound">C</a>
<a id="plfa_plfa-part1-Connectives-15373" href="../Connectives/#plfa_plfa-part1-Connectives-15292" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15380" href="../Connectives/#plfa_plfa-part1-Connectives-15380" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15382" href="../Connectives/#plfa_plfa-part1-Connectives-15382" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15384" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15385" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-15390" href="../Connectives/#plfa_plfa-part1-Connectives-15390" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-15391" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15393" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15395" href="../Connectives/#plfa_plfa-part1-Connectives-15380" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15397" href="../Connectives/#plfa_plfa-part1-Connectives-15390" class="Bound">x</a>
<a id="plfa_plfa-part1-Connectives-15399" href="../Connectives/#plfa_plfa-part1-Connectives-15292" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15406" href="../Connectives/#plfa_plfa-part1-Connectives-15406" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15408" href="../Connectives/#plfa_plfa-part1-Connectives-15408" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15410" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15411" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-15416" href="../Connectives/#plfa_plfa-part1-Connectives-15416" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-15417" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15419" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15421" href="../Connectives/#plfa_plfa-part1-Connectives-15408" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15423" href="../Connectives/#plfa_plfa-part1-Connectives-15416" class="Bound">y</a>
</pre><p>对 <code>inj₁</code> 和 <code>inj₂</code> 进行模式匹配，是我们使用析取成立的证明的常见方法。</p><p>当 <code>inj₁</code> 和 <code>inj₂</code> 在等式右手边出现的时候，我们将其称作<strong>构造子</strong>， 当它出现在等式左边时，我们将其称作<strong>解构子</strong>。我们亦可将 <code>case-⊎</code> 称作解构子，因为它们起到相似的效果。其他术语将 <code>inj₁</code> 和 <code>inj₂</code> 称为<strong>引入</strong>析取， 将 <code>case-⊎</code> 称为<strong>消去</strong>析取。前者亦被称为 <code>⊎-I₁</code> 和 <code>⊎-I₂</code>，后者 <code>⊎-E</code>。</p><p>对每个构造子使用解构子得到的是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊎"></a><a id="plfa_plfa-part1-Connectives-16385" href="../Connectives/#plfa_plfa-part1-Connectives-16385" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16389" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16391" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16393" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16394" href="../Connectives/#plfa_plfa-part1-Connectives-16394" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16396" href="../Connectives/#plfa_plfa-part1-Connectives-16396" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16398" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16400" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16403" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16405" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16406" href="../Connectives/#plfa_plfa-part1-Connectives-16406" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16408" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16410" href="../Connectives/#plfa_plfa-part1-Connectives-16394" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16412" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16414" href="../Connectives/#plfa_plfa-part1-Connectives-16396" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16415" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16417" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16419" href="../Connectives/#plfa_plfa-part1-Connectives-15292" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16426" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16431" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16436" href="../Connectives/#plfa_plfa-part1-Connectives-16406" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16438" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16440" href="../Connectives/#plfa_plfa-part1-Connectives-16406" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16442" href="../Connectives/#plfa_plfa-part1-Connectives-16385" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16446" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16447" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16452" href="../Connectives/#plfa_plfa-part1-Connectives-16452" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16453" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16455" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16457" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16462" href="../Connectives/#plfa_plfa-part1-Connectives-16385" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16466" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16467" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16472" href="../Connectives/#plfa_plfa-part1-Connectives-16472" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16473" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16475" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16477" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>更普遍地来说，我们亦可对于析取使用一个任意的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊎"></a><a id="plfa_plfa-part1-Connectives-16611" href="../Connectives/#plfa_plfa-part1-Connectives-16611" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16618" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16620" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16622" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16623" href="../Connectives/#plfa_plfa-part1-Connectives-16623" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16625" href="../Connectives/#plfa_plfa-part1-Connectives-16625" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16627" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-16629" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16631" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16634" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16636" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16637" href="../Connectives/#plfa_plfa-part1-Connectives-16637" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16639" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16641" href="../Connectives/#plfa_plfa-part1-Connectives-16623" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16643" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16645" href="../Connectives/#plfa_plfa-part1-Connectives-16625" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16647" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16649" href="../Connectives/#plfa_plfa-part1-Connectives-16627" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-16650" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16652" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16653" href="../Connectives/#plfa_plfa-part1-Connectives-16653" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16655" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16657" href="../Connectives/#plfa_plfa-part1-Connectives-16623" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16659" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16661" href="../Connectives/#plfa_plfa-part1-Connectives-16625" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16662" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16664" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Connectives-16668" href="../Connectives/#plfa_plfa-part1-Connectives-15292" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16675" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16676" href="../Connectives/#plfa_plfa-part1-Connectives-16637" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16678" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16680" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-16684" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16686" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16687" href="../Connectives/#plfa_plfa-part1-Connectives-16637" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16689" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16691" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-16695" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16697" href="../Connectives/#plfa_plfa-part1-Connectives-16653" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16699" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16701" href="../Connectives/#plfa_plfa-part1-Connectives-16637" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16703" href="../Connectives/#plfa_plfa-part1-Connectives-16653" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16705" href="../Connectives/#plfa_plfa-part1-Connectives-16611" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16712" href="../Connectives/#plfa_plfa-part1-Connectives-16712" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16714" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16715" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16720" href="../Connectives/#plfa_plfa-part1-Connectives-16720" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16721" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16723" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16725" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16730" href="../Connectives/#plfa_plfa-part1-Connectives-16611" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16737" href="../Connectives/#plfa_plfa-part1-Connectives-16737" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16739" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16740" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16745" href="../Connectives/#plfa_plfa-part1-Connectives-16745" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16746" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16748" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16750" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>inj₁ x</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项， <code>inj₂ y</code> 同理。</p><p>我们设置析取的优先级，使它与任何已经定义的运算符都结合的不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-17176" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-17183" class="Number">1</a> <a id="plfa_plfa-part1-Connectives-17185" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">_⊎_</a>
</pre><p>因此 <code>A × C ⊎ B × C</code> 解析为 <code>(A × C) ⊎ (B × C)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A ⊎ B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>和</strong>。 在集合论中它也被称作<strong>不交并（Disjoint Union）</strong>，在计算机科学中它对应<strong>变体记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A ⊎ B</code> 有 <code>m + n</code> 个不同的成员。这也是它被称为和的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型，如之前的定义。 那么，<code>Bool ⊎ Tri</code> 类型有如下的五个成员：</p><pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre><p>下面的函数枚举了所有类型为 <code>Bool ⊎ Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-count"></a><a id="plfa_plfa-part1-Connectives-18348" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18356" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-18358" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-18363" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-18365" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-18369" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-18371" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-18373" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18381" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18382" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18387" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Connectives-18391" class="Symbol">)</a>   <a id="plfa_plfa-part1-Connectives-18395" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18398" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-18400" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18408" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18409" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18414" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Connectives-18419" class="Symbol">)</a>  <a id="plfa_plfa-part1-Connectives-18422" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18425" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-18427" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18435" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18436" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18441" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a><a id="plfa_plfa-part1-Connectives-18443" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18449" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18452" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-18454" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18462" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18463" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18468" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a><a id="plfa_plfa-part1-Connectives-18470" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18476" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18479" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-18481" href="../Connectives/#plfa_plfa-part1-Connectives-18348" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18489" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18490" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18495" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a><a id="plfa_plfa-part1-Connectives-18497" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18503" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18506" class="Number">5</a>
</pre><p>类型上的和与数的和有相似的性质——它们满足交换律和结合律。 更确切地说，和在<strong>在同构意义下</strong>是交换和结合的。</p><h4 id="练习--comm-推荐">练习 <code>⊎-comm</code> （推荐）</h4><p>证明和类型在同构意义下满足交换律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-18851" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--assoc实践">练习 <code>⊎-assoc</code>（实践）</h4><p>证明和类型在同构意义下满足结合律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19017" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="假即是空类型">假即是空类型</h2><p>恒假 <code>⊥</code> 从不成立。我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19329" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊥"></a><a id="plfa_plfa-part1-Connectives-19334" href="../Connectives/#plfa_plfa-part1-Connectives-19334" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-19336" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-19338" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-19342" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-19350" class="Comment">-- 没有语句！</a>
</pre><p>没有 <code>⊥</code> 成立的证明。</p><p>与 <code>⊤</code> 相对偶，<code>⊥</code> 没有引入规则，但是有消去规则。因为恒假从不成立， 如果它一旦成立，我们就进入了矛盾之中。给定 <code>⊥</code> 成立的证明，我们可以得出任何结论！ 这是逻辑学的基本原理，又由中世纪的拉丁文词组 <em>ex falso</em> 为名。小孩子也由诸如 「如果猪有翅膀，那我就是示巴女王」的词组中知晓。我们如下将它形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-elim"></a><a id="plfa_plfa-part1-Connectives-20065" href="../Connectives/#plfa_plfa-part1-Connectives-20065" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20072" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20074" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20076" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20077" href="../Connectives/#plfa_plfa-part1-Connectives-20077" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-20079" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20081" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20084" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-20088" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20090" href="../Connectives/#plfa_plfa-part1-Connectives-19334" class="Datatype">⊥</a>
    <a id="plfa_plfa-part1-Connectives-20096" class="Comment">--</a>
  <a id="plfa_plfa-part1-Connectives-20101" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20103" href="../Connectives/#plfa_plfa-part1-Connectives-20077" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-20105" href="../Connectives/#plfa_plfa-part1-Connectives-20065" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20112" class="Symbol">()</a>
</pre><p>这是我们第一次使<strong>用荒谬模式（Absurd Pattern）</strong> <code>()</code>。在这里，因为 <code>⊥</code> 是一个没有成员的类型，我们用 <code>()</code> 模式来指明这里不可能匹配任何这个类型的值。</p><p><code>case-⊎</code> 的零元形式是 <code>⊥-elim</code>。类比的来说，它应该叫做 <code>case-⊥</code>， 但是我们在此使用标准库中使用的名字。</p><p><code>uniq-⊎</code> 的零元形式是 <code>uniq-⊥</code>，其断言了 <code>⊥-elim</code> 和任何取 <code>⊥</code> 的函数是等价的。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊥"></a><a id="plfa_plfa-part1-Connectives-20837" href="../Connectives/#plfa_plfa-part1-Connectives-20837" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20844" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20846" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20848" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20849" href="../Connectives/#plfa_plfa-part1-Connectives-20849" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-20851" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20853" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20856" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-20858" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20859" href="../Connectives/#plfa_plfa-part1-Connectives-20859" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20861" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20863" href="../Connectives/#plfa_plfa-part1-Connectives-19334" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-20865" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20867" href="../Connectives/#plfa_plfa-part1-Connectives-20849" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-20868" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20870" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20871" href="../Connectives/#plfa_plfa-part1-Connectives-20871" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20873" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20875" href="../Connectives/#plfa_plfa-part1-Connectives-19334" class="Datatype">⊥</a><a id="plfa_plfa-part1-Connectives-20876" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20878" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20880" href="../Connectives/#plfa_plfa-part1-Connectives-20065" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20887" href="../Connectives/#plfa_plfa-part1-Connectives-20871" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20889" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-20891" href="../Connectives/#plfa_plfa-part1-Connectives-20859" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20893" href="../Connectives/#plfa_plfa-part1-Connectives-20871" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-20895" href="../Connectives/#plfa_plfa-part1-Connectives-20837" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20902" href="../Connectives/#plfa_plfa-part1-Connectives-20902" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20904" class="Symbol">()</a>
</pre><p>使用荒谬模式断言了 <code>w</code> 没有任何可能的值，因此等式显然成立。</p><p>我们将 <code>⊥</code> 成为<strong>空（Empty）</strong>类型。实际上，<code>⊥</code> 类型没有成员。 例如，下面的函数枚举了所有 <code>⊥</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-count"></a><a id="plfa_plfa-part1-Connectives-21303" href="../Connectives/#plfa_plfa-part1-Connectives-21303" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21311" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-21313" href="../Connectives/#plfa_plfa-part1-Connectives-19334" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-21315" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-21317" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-21319" href="../Connectives/#plfa_plfa-part1-Connectives-21303" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21327" class="Symbol">()</a>
</pre><p>同样，荒谬模式告诉我们没有值可以来匹配类型 <code>⊥</code>。</p><p>对于数来说，0 是加法的幺元。对应地，空是和的幺元（<strong>在同构意义下</strong>）。</p><h4 id="练习--identityˡ-推荐">练习 <code>⊥-identityˡ</code> （推荐）</h4><p>证明空在同构意义下是和的左幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21794" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4><h4 id="练习--identityʳ实践">练习 <code>⊥-identityʳ</code>（实践）</h4><p>证明空在同构意义下是和的右幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21976" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="implication">蕴涵即是函数</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其蕴涵 <code>A → B</code> 在任何 <code>A</code> 成立的时候，<code>B</code> 也成立时成立。 我们用函数类型来形式化蕴涵，如本书中通篇出现的那样。</p><p><code>A → B</code> 成立的证据由下面的形式组成：</p><pre><code>λ (x : A) → N</code></pre><p>其中 <code>N</code> 是一个类型为 <code>B</code> 的项，其包括了一个类型为 <code>A</code> 的自由变量 <code>x</code>。 给定一个 <code>A → B</code> 成立的证明 <code>L</code>，和一个 <code>A</code> 成立的证明 <code>M</code>，那么 <code>L M</code> 是 <code>B</code> 成立的证明。 也就是说，<code>A → B</code> 成立的证明是一个函数，将 <code>A</code> 成立的证明转换成 <code>B</code> 成立的证明。</p><p>换句话说，如果知道 <code>A → B</code> 和 <code>A</code> 同时成立，那么我们可以推出 <code>B</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-elim"></a><a id="plfa_plfa-part1-Connectives-23159" href="../Connectives/#plfa_plfa-part1-Connectives-23159" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23166" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23168" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23170" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23171" href="../Connectives/#plfa_plfa-part1-Connectives-23171" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23173" href="../Connectives/#plfa_plfa-part1-Connectives-23173" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23175" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23177" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23180" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-23184" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23186" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23187" href="../Connectives/#plfa_plfa-part1-Connectives-23171" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23189" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23191" href="../Connectives/#plfa_plfa-part1-Connectives-23173" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23192" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-23196" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23198" href="../Connectives/#plfa_plfa-part1-Connectives-23171" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-23204" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Connectives-23214" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23216" href="../Connectives/#plfa_plfa-part1-Connectives-23173" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-23218" href="../Connectives/#plfa_plfa-part1-Connectives-23159" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23225" href="../Connectives/#plfa_plfa-part1-Connectives-23225" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23227" href="../Connectives/#plfa_plfa-part1-Connectives-23227" class="Bound">M</a> <a id="plfa_plfa-part1-Connectives-23229" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23231" href="../Connectives/#plfa_plfa-part1-Connectives-23225" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23233" href="../Connectives/#plfa_plfa-part1-Connectives-23227" class="Bound">M</a>
</pre><p>在中世纪，这条规则被叫做 <em>modus ponens</em>，它与函数应用相对应。</p><p>定义一个函数，不管是带名字的定义或是使用 Lambda 抽象，被称为<strong>引入</strong>一个函数， 使用一个函数被称为<strong>消去</strong>一个函数。</p><p>引入后接着消去，得到的还是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-→"></a><a id="plfa_plfa-part1-Connectives-23753" href="../Connectives/#plfa_plfa-part1-Connectives-23753" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23757" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23759" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23761" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23762" href="../Connectives/#plfa_plfa-part1-Connectives-23762" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23764" href="../Connectives/#plfa_plfa-part1-Connectives-23764" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23766" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23768" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23771" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-23773" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23774" href="../Connectives/#plfa_plfa-part1-Connectives-23774" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23776" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23778" href="../Connectives/#plfa_plfa-part1-Connectives-23762" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23780" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23782" href="../Connectives/#plfa_plfa-part1-Connectives-23764" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23783" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23785" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23787" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Connectives-23790" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23791" href="../Connectives/#plfa_plfa-part1-Connectives-23791" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-23793" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23795" href="../Connectives/#plfa_plfa-part1-Connectives-23762" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-23796" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23798" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23800" href="../Connectives/#plfa_plfa-part1-Connectives-23774" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23802" href="../Connectives/#plfa_plfa-part1-Connectives-23791" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-23803" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23805" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-23807" href="../Connectives/#plfa_plfa-part1-Connectives-23774" class="Bound">f</a>
<a id="plfa_plfa-part1-Connectives-23809" href="../Connectives/#plfa_plfa-part1-Connectives-23753" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23813" href="../Connectives/#plfa_plfa-part1-Connectives-23813" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23815" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23817" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>蕴涵比其他的运算符结合得都不紧密。因此 <code>A ⊎ B → B ⊎ A</code> 被解析为 <code>(A ⊎ B) → (B ⊎ A)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A → B</code> 称为从 <code>A</code> 到 <code>B</code> 的<strong>函数</strong>空间。 它有时也被称作以 <code>B</code> 为底，<code>A</code> 为次数的<strong>幂</strong>。如果类型 <code>A</code> 有 <code>m</code> 个不同的成员， 类型 <code>B</code> 有 <code>n</code> 个不同的成员，那么类型 <code>A → B</code> 有 <code>nᵐ</code> 个不同的成员。 这也是它被称为幂的原因之一。例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型， 如之前的定义。那么，<code>Bool → Tri</code> 类型有如下的九个成员（三的平方）：</p><pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre><p>下面的函数枚举了所有类型为 <code>Bool → Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-count"></a><a id="plfa_plfa-part1-Connectives-25204" href="../Connectives/#plfa_plfa-part1-Connectives-25204" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25212" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-25214" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-25215" href="../Connectives/#plfa_plfa-part1-Connectives-6547" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-25220" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25222" href="../Connectives/#plfa_plfa-part1-Connectives-6600" class="Datatype">Tri</a><a id="plfa_plfa-part1-Connectives-25225" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-25227" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25229" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-25231" href="../Connectives/#plfa_plfa-part1-Connectives-25204" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25239" href="../Connectives/#plfa_plfa-part1-Connectives-25239" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25241" class="Keyword">with</a> <a id="plfa_plfa-part1-Connectives-25246" href="../Connectives/#plfa_plfa-part1-Connectives-25239" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25248" href="../Connectives/#plfa_plfa-part1-Connectives-6566" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Connectives-25253" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25255" href="../Connectives/#plfa_plfa-part1-Connectives-25239" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25257" href="../Connectives/#plfa_plfa-part1-Connectives-6581" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Connectives-25263" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25276" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25278" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25285" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25287" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25295" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25299" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-25301" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25314" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25316" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25323" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25325" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25333" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25337" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-25339" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25352" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25354" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25361" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25363" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25371" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25375" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-25377" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25390" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25392" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25399" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25401" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25409" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25413" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-25415" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25428" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25430" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25437" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25439" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25447" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25451" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-25453" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25466" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25468" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25475" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25477" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25485" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25489" class="Number">6</a>
<a id="plfa_plfa-part1-Connectives-25491" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25504" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25506" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25513" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25515" href="../Connectives/#plfa_plfa-part1-Connectives-6618" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25523" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25527" class="Number">7</a>
<a id="plfa_plfa-part1-Connectives-25529" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25542" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25544" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25551" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25553" href="../Connectives/#plfa_plfa-part1-Connectives-6629" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25561" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25565" class="Number">8</a>
<a id="plfa_plfa-part1-Connectives-25567" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25580" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25582" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25589" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25591" href="../Connectives/#plfa_plfa-part1-Connectives-6640" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25599" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25603" class="Number">9</a>
</pre><p>类型上的幂与数的幂有相似的性质，很多数上成立的关系式也可以在类型上成立。</p><p>对应如下的定律：</p><pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre><p>我们有如下的同构：</p><pre><code>A → (B → C)  ≃  (A × B) → C</code></pre><p>两个类型可以被看作给定 <code>A</code> 成立的证据和 <code>B</code> 成立的证据，返回 <code>C</code> 成立的证据。 这个同构有时也被称作<strong>柯里化（Currying）</strong>。右逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-currying"></a><a id="plfa_plfa-part1-Connectives-26317" href="../Connectives/#plfa_plfa-part1-Connectives-26317" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26326" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26328" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-26330" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-26331" href="../Connectives/#plfa_plfa-part1-Connectives-26331" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26333" href="../Connectives/#plfa_plfa-part1-Connectives-26333" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26335" href="../Connectives/#plfa_plfa-part1-Connectives-26335" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-26337" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26339" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-26342" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-26344" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26346" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26347" href="../Connectives/#plfa_plfa-part1-Connectives-26331" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26349" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26351" href="../Connectives/#plfa_plfa-part1-Connectives-26333" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26353" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26355" href="../Connectives/#plfa_plfa-part1-Connectives-26335" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26356" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-26358" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-26360" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26361" href="../Connectives/#plfa_plfa-part1-Connectives-26331" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26363" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-26365" href="../Connectives/#plfa_plfa-part1-Connectives-26333" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26367" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26369" href="../Connectives/#plfa_plfa-part1-Connectives-26335" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26370" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-26372" href="../Connectives/#plfa_plfa-part1-Connectives-26317" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26381" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-26385" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-26396" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-26398" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-26406" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26409" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26412" href="../Connectives/#plfa_plfa-part1-Connectives-26412" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26414" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26416" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26419" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26421" href="../Connectives/#plfa_plfa-part1-Connectives-26421" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26423" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26425" href="../Connectives/#plfa_plfa-part1-Connectives-26425" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26427" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26429" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26431" href="../Connectives/#plfa_plfa-part1-Connectives-26412" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26433" href="../Connectives/#plfa_plfa-part1-Connectives-26421" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26435" href="../Connectives/#plfa_plfa-part1-Connectives-26425" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26437" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26444" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26446" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-26454" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26457" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26460" href="../Connectives/#plfa_plfa-part1-Connectives-26460" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26462" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26464" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26467" href="../Connectives/#plfa_plfa-part1-Connectives-26467" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26469" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26471" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26474" href="../Connectives/#plfa_plfa-part1-Connectives-26474" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26476" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26478" href="../Connectives/#plfa_plfa-part1-Connectives-26460" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26480" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26482" href="../Connectives/#plfa_plfa-part1-Connectives-26467" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26484" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26486" href="../Connectives/#plfa_plfa-part1-Connectives-26474" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26488" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26490" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Connectives-26498" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26500" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-26508" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26511" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26514" href="../Connectives/#plfa_plfa-part1-Connectives-26514" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26516" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26518" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26523" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-26529" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26531" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-26539" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26542" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26545" href="../Connectives/#plfa_plfa-part1-Connectives-26545" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26547" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26549" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-26564" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26567" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26569" href="../Connectives/#plfa_plfa-part1-Connectives-26569" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26571" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26573" href="../Connectives/#plfa_plfa-part1-Connectives-26573" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26575" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26577" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26579" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26584" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26591" class="Symbol">}</a>
</pre><p>柯里化告诉我们，如果一个函数有取一个数据对作为参数， 那么我们可以构造一个函数，取第一个参数，返回一个取第二个参数，返回最终结果的函数。 因此，举例来说，下面表示加法的形式：</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>和下面的一个带有一个数据对作为参数的函数是同构的：</p><pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre><p>Agda 对柯里化进行了优化，因此 <code>2 + 3</code> 是 <code>_+_ 2 3</code> 的简写。在一个对有序对进行优化的语言里， <code>2 +′ 3</code> 可能是 <code>_+′_ ⟨ 2 , 3 ⟩</code> 的简写。</p><p>对应如下的定律：</p><pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre><p>命题如果 <code>A</code> 成立或者 <code>B</code> 成立，那么 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>C</code> 成立以及 如果 <code>B</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-27863" href="../Connectives/#plfa_plfa-part1-Connectives-27863" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27875" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27877" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-27879" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-27880" href="../Connectives/#plfa_plfa-part1-Connectives-27880" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27882" href="../Connectives/#plfa_plfa-part1-Connectives-27882" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27884" href="../Connectives/#plfa_plfa-part1-Connectives-27884" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-27886" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27888" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-27891" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-27893" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27895" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27896" href="../Connectives/#plfa_plfa-part1-Connectives-27880" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27898" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-27900" href="../Connectives/#plfa_plfa-part1-Connectives-27882" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27902" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27904" href="../Connectives/#plfa_plfa-part1-Connectives-27884" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27905" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27907" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-27909" class="Symbol">((</a><a id="plfa_plfa-part1-Connectives-27911" href="../Connectives/#plfa_plfa-part1-Connectives-27880" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27913" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27915" href="../Connectives/#plfa_plfa-part1-Connectives-27884" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27916" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27918" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-27920" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27921" href="../Connectives/#plfa_plfa-part1-Connectives-27882" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27923" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27925" href="../Connectives/#plfa_plfa-part1-Connectives-27884" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27926" class="Symbol">))</a>
<a id="plfa_plfa-part1-Connectives-27929" href="../Connectives/#plfa_plfa-part1-Connectives-27863" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27941" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-27945" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-27956" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-27958" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-27966" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-27968" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-27971" href="../Connectives/#plfa_plfa-part1-Connectives-27971" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27973" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27975" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-27977" href="../Connectives/#plfa_plfa-part1-Connectives-27971" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27979" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-27981" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-27986" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-27988" href="../Connectives/#plfa_plfa-part1-Connectives-27971" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27990" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-27992" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-27997" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-27999" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28005" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28007" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28015" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28017" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28020" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28022" href="../Connectives/#plfa_plfa-part1-Connectives-28022" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28024" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28026" href="../Connectives/#plfa_plfa-part1-Connectives-28026" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28028" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28030" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28032" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28035" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28036" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28041" href="../Connectives/#plfa_plfa-part1-Connectives-28041" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28042" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28044" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28046" href="../Connectives/#plfa_plfa-part1-Connectives-28022" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28048" href="../Connectives/#plfa_plfa-part1-Connectives-28041" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28050" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28052" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28053" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28058" href="../Connectives/#plfa_plfa-part1-Connectives-28058" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28059" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28061" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28063" href="../Connectives/#plfa_plfa-part1-Connectives-28026" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28065" href="../Connectives/#plfa_plfa-part1-Connectives-28058" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-28067" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28069" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28075" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28077" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28085" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28087" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28090" href="../Connectives/#plfa_plfa-part1-Connectives-28090" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28092" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28094" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28109" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28112" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28113" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28118" href="../Connectives/#plfa_plfa-part1-Connectives-28118" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28119" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28121" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28123" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28128" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28130" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28131" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28136" href="../Connectives/#plfa_plfa-part1-Connectives-28136" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28137" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28139" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28141" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28146" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28148" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28154" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28156" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-28164" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28166" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28169" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28171" href="../Connectives/#plfa_plfa-part1-Connectives-28171" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28173" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28175" href="../Connectives/#plfa_plfa-part1-Connectives-28175" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28177" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28179" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28181" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28186" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28192" class="Symbol">}</a>
</pre><p>对应如下的定律：</p><pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre><p>命题如果 <code>A</code> 成立，那么 <code>B</code> 成立和 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>B</code> 成立以及 如果 <code>A</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性和积的 <code>η-×</code> 规则：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-×"></a><a id="plfa_plfa-part1-Connectives-28741" href="../Connectives/#plfa_plfa-part1-Connectives-28741" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28753" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28755" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-28757" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-28758" href="../Connectives/#plfa_plfa-part1-Connectives-28758" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28760" href="../Connectives/#plfa_plfa-part1-Connectives-28760" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28762" href="../Connectives/#plfa_plfa-part1-Connectives-28762" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-28764" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28766" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-28769" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28771" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28773" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28774" href="../Connectives/#plfa_plfa-part1-Connectives-28758" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28776" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28778" href="../Connectives/#plfa_plfa-part1-Connectives-28760" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28780" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28782" href="../Connectives/#plfa_plfa-part1-Connectives-28762" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28783" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28785" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-28787" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28788" href="../Connectives/#plfa_plfa-part1-Connectives-28758" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28790" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28792" href="../Connectives/#plfa_plfa-part1-Connectives-28760" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-28793" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28795" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28797" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28798" href="../Connectives/#plfa_plfa-part1-Connectives-28758" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28800" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28802" href="../Connectives/#plfa_plfa-part1-Connectives-28762" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28803" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-28805" href="../Connectives/#plfa_plfa-part1-Connectives-28741" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28817" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-28821" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-28832" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-28834" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-28842" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28844" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28847" href="../Connectives/#plfa_plfa-part1-Connectives-28847" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28849" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28851" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28853" href="../Connectives/#plfa_plfa-part1-Connectives-2110" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-28859" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28861" href="../Connectives/#plfa_plfa-part1-Connectives-28847" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28863" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28865" href="../Connectives/#plfa_plfa-part1-Connectives-2179" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-28871" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28873" href="../Connectives/#plfa_plfa-part1-Connectives-28847" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28875" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28877" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28883" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28885" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28893" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28895" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28898" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28900" href="../Connectives/#plfa_plfa-part1-Connectives-28900" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28902" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28904" href="../Connectives/#plfa_plfa-part1-Connectives-28904" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28906" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28908" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28910" class="Symbol">λ</a> <a id="plfa_plfa-part1-Connectives-28912" href="../Connectives/#plfa_plfa-part1-Connectives-28912" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28914" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28916" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28918" href="../Connectives/#plfa_plfa-part1-Connectives-28900" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28920" href="../Connectives/#plfa_plfa-part1-Connectives-28912" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28922" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28924" href="../Connectives/#plfa_plfa-part1-Connectives-28904" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28926" href="../Connectives/#plfa_plfa-part1-Connectives-28912" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28928" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28930" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28936" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28938" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28946" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28948" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28951" href="../Connectives/#plfa_plfa-part1-Connectives-28951" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28953" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28955" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28970" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28973" href="../Connectives/#plfa_plfa-part1-Connectives-28973" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28975" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28977" href="../Connectives/#plfa_plfa-part1-Connectives-4212" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-28981" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28982" href="../Connectives/#plfa_plfa-part1-Connectives-28951" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28984" href="../Connectives/#plfa_plfa-part1-Connectives-28973" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28985" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28987" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28989" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28995" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28997" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-29005" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29007" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29010" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29012" href="../Connectives/#plfa_plfa-part1-Connectives-29012" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-29014" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29016" href="../Connectives/#plfa_plfa-part1-Connectives-29016" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-29018" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29020" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29022" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-29027" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29033" class="Symbol">}</a>
</pre><h2 id="分配律">分配律</h2><p>在同构意义下，积对于和满足分配律。验证这条形式的代码和之前的证明相似：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-29260" href="../Connectives/#plfa_plfa-part1-Connectives-29260" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29272" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29274" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29276" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29277" href="../Connectives/#plfa_plfa-part1-Connectives-29277" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29279" href="../Connectives/#plfa_plfa-part1-Connectives-29279" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29281" href="../Connectives/#plfa_plfa-part1-Connectives-29281" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29283" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29285" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29288" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29290" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29292" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29293" href="../Connectives/#plfa_plfa-part1-Connectives-29277" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29295" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29297" href="../Connectives/#plfa_plfa-part1-Connectives-29279" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29298" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29300" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29302" href="../Connectives/#plfa_plfa-part1-Connectives-29281" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29304" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-29306" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29307" href="../Connectives/#plfa_plfa-part1-Connectives-29277" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29309" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29311" href="../Connectives/#plfa_plfa-part1-Connectives-29281" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29312" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29314" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29316" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29317" href="../Connectives/#plfa_plfa-part1-Connectives-29279" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29319" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29321" href="../Connectives/#plfa_plfa-part1-Connectives-29281" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29322" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-29324" href="../Connectives/#plfa_plfa-part1-Connectives-29260" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29336" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-29340" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-29351" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-29353" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5605" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-29361" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29363" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29366" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29368" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29373" href="../Connectives/#plfa_plfa-part1-Connectives-29373" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29375" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29377" href="../Connectives/#plfa_plfa-part1-Connectives-29377" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29379" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29381" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29383" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29384" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29389" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29391" href="../Connectives/#plfa_plfa-part1-Connectives-29373" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29393" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29395" href="../Connectives/#plfa_plfa-part1-Connectives-29377" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29397" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29398" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29417" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29419" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29421" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29426" href="../Connectives/#plfa_plfa-part1-Connectives-29426" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29428" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29430" href="../Connectives/#plfa_plfa-part1-Connectives-29430" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29432" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29434" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29436" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29437" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29442" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29444" href="../Connectives/#plfa_plfa-part1-Connectives-29426" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29446" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29448" href="../Connectives/#plfa_plfa-part1-Connectives-29430" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29450" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29451" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29470" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29476" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29478" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5622" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-29486" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29488" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29491" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29492" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29497" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29499" href="../Connectives/#plfa_plfa-part1-Connectives-29499" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29501" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29503" href="../Connectives/#plfa_plfa-part1-Connectives-29503" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29505" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29506" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29508" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29510" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29512" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29517" href="../Connectives/#plfa_plfa-part1-Connectives-29499" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29519" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29521" href="../Connectives/#plfa_plfa-part1-Connectives-29503" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29523" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29542" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29544" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29545" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29550" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29552" href="../Connectives/#plfa_plfa-part1-Connectives-29552" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29554" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29556" href="../Connectives/#plfa_plfa-part1-Connectives-29556" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29558" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29559" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29561" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29563" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29565" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29570" href="../Connectives/#plfa_plfa-part1-Connectives-29552" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29572" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29574" href="../Connectives/#plfa_plfa-part1-Connectives-29556" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29576" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29595" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29601" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29603" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5639" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-29611" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29613" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29616" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29618" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29623" href="../Connectives/#plfa_plfa-part1-Connectives-29623" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29625" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29627" href="../Connectives/#plfa_plfa-part1-Connectives-29627" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29629" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29631" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29633" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29655" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29657" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29659" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29664" href="../Connectives/#plfa_plfa-part1-Connectives-29664" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29666" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29668" href="../Connectives/#plfa_plfa-part1-Connectives-29668" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29670" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29672" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29674" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29696" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29702" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29704" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5681" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-29712" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29714" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29717" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29718" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29723" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29725" href="../Connectives/#plfa_plfa-part1-Connectives-29725" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29727" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29729" href="../Connectives/#plfa_plfa-part1-Connectives-29729" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29731" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29732" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29734" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29736" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29758" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29760" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29761" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29766" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29768" href="../Connectives/#plfa_plfa-part1-Connectives-29768" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29770" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29772" href="../Connectives/#plfa_plfa-part1-Connectives-29772" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29774" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29775" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29777" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29779" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29801" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29807" class="Symbol">}</a>
</pre><p>和对于积不满足分配律，但满足嵌入：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-distrib-×"></a><a id="plfa_plfa-part1-Connectives-29931" href="../Connectives/#plfa_plfa-part1-Connectives-29931" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-29943" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29945" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29947" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29948" href="../Connectives/#plfa_plfa-part1-Connectives-29948" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29950" href="../Connectives/#plfa_plfa-part1-Connectives-29950" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29952" href="../Connectives/#plfa_plfa-part1-Connectives-29952" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29954" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29956" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29959" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29961" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29963" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29964" href="../Connectives/#plfa_plfa-part1-Connectives-29948" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29966" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29968" href="../Connectives/#plfa_plfa-part1-Connectives-29950" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29969" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29971" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29973" href="../Connectives/#plfa_plfa-part1-Connectives-29952" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29975" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11704" class="Record Operator">≲</a> <a id="plfa_plfa-part1-Connectives-29977" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29978" href="../Connectives/#plfa_plfa-part1-Connectives-29948" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29980" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29982" href="../Connectives/#plfa_plfa-part1-Connectives-29952" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29983" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29985" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29987" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29988" href="../Connectives/#plfa_plfa-part1-Connectives-29950" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29990" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29992" href="../Connectives/#plfa_plfa-part1-Connectives-29952" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29993" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-29995" href="../Connectives/#plfa_plfa-part1-Connectives-29931" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-30007" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-30011" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-30022" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-30024" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11744" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-30032" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30034" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30037" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30038" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30043" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30045" href="../Connectives/#plfa_plfa-part1-Connectives-30045" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30047" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30049" href="../Connectives/#plfa_plfa-part1-Connectives-30049" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30051" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30052" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30054" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30056" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30058" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30063" href="../Connectives/#plfa_plfa-part1-Connectives-30045" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30065" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30067" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30072" href="../Connectives/#plfa_plfa-part1-Connectives-30049" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30074" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30093" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30095" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30096" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30101" href="../Connectives/#plfa_plfa-part1-Connectives-30101" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30102" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30112" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30114" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30116" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30121" href="../Connectives/#plfa_plfa-part1-Connectives-30101" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30123" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30125" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30130" href="../Connectives/#plfa_plfa-part1-Connectives-30101" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30132" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30151" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30157" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30159" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11764" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-30167" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30169" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30172" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30174" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30179" href="../Connectives/#plfa_plfa-part1-Connectives-30179" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30181" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30183" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30188" href="../Connectives/#plfa_plfa-part1-Connectives-30188" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30190" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30192" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30194" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30195" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30200" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30202" href="../Connectives/#plfa_plfa-part1-Connectives-30179" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30204" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30206" href="../Connectives/#plfa_plfa-part1-Connectives-30188" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30208" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30209" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30228" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30230" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30232" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30237" href="../Connectives/#plfa_plfa-part1-Connectives-30237" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30239" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30241" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30246" href="../Connectives/#plfa_plfa-part1-Connectives-30246" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30248" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30250" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30252" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30253" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30258" href="../Connectives/#plfa_plfa-part1-Connectives-30246" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30259" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30278" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30280" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30282" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30287" href="../Connectives/#plfa_plfa-part1-Connectives-30287" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30289" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30291" class="Symbol">_</a>      <a id="plfa_plfa-part1-Connectives-30298" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30300" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30302" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30303" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30308" href="../Connectives/#plfa_plfa-part1-Connectives-30287" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30309" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30328" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30334" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30336" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11784" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-30344" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30346" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30349" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30350" href="../Connectives/#plfa_plfa-part1-Connectives-14752" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30355" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30357" href="../Connectives/#plfa_plfa-part1-Connectives-30357" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30359" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30361" href="../Connectives/#plfa_plfa-part1-Connectives-30361" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30363" href="../Connectives/#plfa_plfa-part1-Connectives-1690" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30364" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30366" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30368" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30390" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30392" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30393" href="../Connectives/#plfa_plfa-part1-Connectives-14794" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30398" href="../Connectives/#plfa_plfa-part1-Connectives-30398" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30399" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30409" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30411" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30433" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30439" class="Symbol">}</a>
</pre><p>我们在定义 <code>from</code> 函数的时候可以有选择。给定的定义中，它将 <code>⟨ inj₂ z , inj₂ z′ ⟩</code> 转换为 <code>inj₂ z</code>，但我们也可以返回 <code>inj₂ z′</code> 作为嵌入证明的变种。我们在这里只能证明嵌入， 而不能证明同构，因为 <code>from</code> 函数必须丢弃 <code>z</code> 或者 <code>z′</code> 其中的一个。</p><p>在一般的逻辑学方法中，两条分配律都以等价的形式给出，每一边都蕴涵了另一边：</p><pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre><p>但当我们考虑提供上述蕴涵证明的函数时，第一条对应同构而第二条只能对应嵌入， 揭示了有些定理比另一个更加的「正确」。</p><h4 id="练习--weak--推荐">练习 <code>⊎-weak-×</code> （推荐）</h4><p>证明如下性质成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31634" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎-weak-×"></a><a id="plfa_plfa-part1-Connectives-31646" href="../Connectives/#plfa_plfa-part1-Connectives-31646" class="Postulate">⊎-weak-×</a> <a id="plfa_plfa-part1-Connectives-31655" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31657" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-31659" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-31660" href="../Connectives/#plfa_plfa-part1-Connectives-31660" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31662" href="../Connectives/#plfa_plfa-part1-Connectives-31662" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31664" href="../Connectives/#plfa_plfa-part1-Connectives-31664" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31666" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31668" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-31671" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-31673" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31675" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31676" href="../Connectives/#plfa_plfa-part1-Connectives-31660" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31678" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31680" href="../Connectives/#plfa_plfa-part1-Connectives-31662" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-31681" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-31683" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31685" href="../Connectives/#plfa_plfa-part1-Connectives-31664" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31687" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31689" href="../Connectives/#plfa_plfa-part1-Connectives-31660" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31691" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31693" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31694" href="../Connectives/#plfa_plfa-part1-Connectives-31662" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31696" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31698" href="../Connectives/#plfa_plfa-part1-Connectives-31664" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-31699" class="Symbol">)</a>
</pre><p>这被称为<strong>弱分配律（Weak Distributive Law）</strong>。给出相对应的分配律，并解释分配律与弱分配律的关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31920" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--implies-实践">练习 <code>⊎×-implies-×⊎</code>（实践）</h4><p>证明合取的析取蕴涵了析取的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32121" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎×-implies-×⊎"></a><a id="plfa_plfa-part1-Connectives-32133" href="../Connectives/#plfa_plfa-part1-Connectives-32133" class="Postulate">⊎×-implies-×⊎</a> <a id="plfa_plfa-part1-Connectives-32147" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32149" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-32151" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-32152" href="../Connectives/#plfa_plfa-part1-Connectives-32152" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32154" href="../Connectives/#plfa_plfa-part1-Connectives-32154" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32156" href="../Connectives/#plfa_plfa-part1-Connectives-32156" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32158" href="../Connectives/#plfa_plfa-part1-Connectives-32158" class="Bound">D</a> <a id="plfa_plfa-part1-Connectives-32160" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32162" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-32165" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-32167" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32169" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32170" href="../Connectives/#plfa_plfa-part1-Connectives-32152" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32172" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32174" href="../Connectives/#plfa_plfa-part1-Connectives-32154" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-32175" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32177" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32179" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32180" href="../Connectives/#plfa_plfa-part1-Connectives-32156" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32182" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32184" href="../Connectives/#plfa_plfa-part1-Connectives-32158" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32185" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32187" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32189" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32190" href="../Connectives/#plfa_plfa-part1-Connectives-32152" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32192" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32194" href="../Connectives/#plfa_plfa-part1-Connectives-32156" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-32195" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32197" href="../Connectives/#plfa_plfa-part1-Connectives-1659" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32199" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32200" href="../Connectives/#plfa_plfa-part1-Connectives-32154" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32202" href="../Connectives/#plfa_plfa-part1-Connectives-14721" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32204" href="../Connectives/#plfa_plfa-part1-Connectives-32158" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32205" class="Symbol">)</a>
</pre><p>反命题成立吗？如果成立，给出证明；如果不成立，给出反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32331" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32508" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32515" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Connectives-32528" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32534" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32535" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Connectives-32538" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32540" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#636" class="Field">proj₁</a><a id="plfa_plfa-part1-Connectives-32545" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32547" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#650" class="Field">proj₂</a><a id="plfa_plfa-part1-Connectives-32552" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32554" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32563" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32564" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Connectives-32568" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32571" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Connectives-32576" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32578" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32585" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Connectives-32595" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32601" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32602" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="plfa_plfa-part1-Connectives-32603" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32605" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Connectives-32607" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32609" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32616" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Connectives-32625" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32631" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32632" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Connectives-32635" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32637" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-32641" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32643" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-32647" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32649" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32658" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32659" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#811" class="Function Operator">[_,_]</a> <a id="plfa_plfa-part1-Connectives-32665" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32668" class="Function Operator">case-⊎</a><a id="plfa_plfa-part1-Connectives-32674" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32676" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32683" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Connectives-32694" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32700" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32701" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a><a id="plfa_plfa-part1-Connectives-32702" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32704" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#1069" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Connectives-32710" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32712" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32719" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Bundles.html" class="Module">Function.Bundles</a> <a id="plfa_plfa-part1-Connectives-32736" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32742" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32743" href="https://agda.github.io/agda-stdlib/v2.2-dev/Function.Bundles.html#12400" class="Function Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-32746" class="Symbol">)</a>
</pre><p>标准库中使用 <code>_,_</code> 构造数据对，而我们使用 <code>⟨_,_⟩</code>。前者在从数据对构造三元对或者更大的 元组时更加的方便，允许 <code>a , b , c</code> 作为 <code>(a, (b , c))</code> 的记法。但它与其他有用的记法相冲突， 比如说 <a href="../Lists/">Lists</a> 中的 <code>[_,_]</code> 记法表示两个元素的列表， 或者 <a href="../DeBruijn/">DeBruijn</a> 章节中的 <code>Γ , A</code> 来表示环境的扩展。 标准库中的 <code>_⇔_</code> 和我们的相似，但使用起来比较不便， 因为它可以根据任意的相等性定义进行参数化。</p><h2 id="unicode">Unicode</h2><p>本章节使用下列 Unicode：</p><pre><code>×  U+00D7  乘法符号 (\x)
⊎  U+228E  多重集并集 (\u+)
⊤  U+22A4  向下图钉 (\top)
⊥  U+22A5  向上图钉 (\bot)
η  U+03B7  希腊小写字母 ETA (\eta)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)</code></pre><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>此段内容由 Propositions as Types（命题即类型）改编而来， 作者：Philip Wadler，发表于 《ACM 通讯》，2015 年 9 月<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>