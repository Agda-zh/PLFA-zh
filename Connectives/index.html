<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Connectives</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon" aria-hidden="true"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book" aria-hidden="true"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Connectives: 合取、析取与蕴涵</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Connectives-125" class="Keyword">module</a> <a id="plfa_plfa-part1-Connectives-132" href="../Connectives/#" class="Module">plfa.part1.Connectives</a> <a id="plfa_plfa-part1-Connectives-155" class="Keyword">where</a>
</pre><p>本章节介绍基础的逻辑运算符。我们使用逻辑运算符与数据类型之间的对应关系， 即<strong>命题即类型（Propositions as Types）</strong>原理。</p><ul><li><strong>合取（Conjunction）</strong>即是<strong>积（Product）</strong></li><li><strong>析取（Disjunction）</strong>即是<strong>和（Sum）</strong></li><li><strong>真（True）</strong>即是<strong>单元类型（Unit Type）</strong></li><li><strong>假（False）</strong>即是<strong>空类型（Empty Type）</strong></li><li><strong>蕴涵（Implication）</strong>即是<strong>函数空间（Function Space）</strong></li></ul><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1085" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1092" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Connectives-1130" class="Symbol">as</a> <a id="plfa_plfa-part1-Connectives-1133" class="Module">Eq</a>
<a id="plfa_plfa-part1-Connectives-1136" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1141" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Connectives-1144" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1150" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1151" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Connectives-1154" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1156" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Connectives-1160" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1162" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1167" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Connectives-1182" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1187" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1194" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Connectives-1203" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1209" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1210" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Connectives-1211" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1213" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1218" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1225" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Connectives-1234" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1240" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1241" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Connectives-1244" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1246" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1251" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-1258" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Connectives-1281" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-1287" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1288" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Connectives-1291" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1293" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11714" class="Record Operator">_≲_</a><a id="plfa_plfa-part1-Connectives-1296" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1298" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Connectives-1312" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-1314" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-1317" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-1319" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-1324" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10800" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre><h2 id="合取即是积">合取即是积</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其合取 <code>A × B</code> 成立当 <code>A</code> 成立和 <code>B</code> 成立。 我们用一个合适的数据类型将这样的概念形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-1659" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_×_"></a><a id="plfa_plfa-part1-Connectives-1664" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">_×_</a> <a id="plfa_plfa-part1-Connectives-1668" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-1669" href="../Connectives/#plfa_plfa-part1-Connectives-1669" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1671" href="../Connectives/#plfa_plfa-part1-Connectives-1671" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-1673" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1675" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-1678" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-1680" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-1682" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-1686" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_×_.⟨_,_⟩"></a><a id="plfa_plfa-part1-Connectives-1695" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="plfa_plfa-part1-Connectives-1701" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-1709" href="../Connectives/#plfa_plfa-part1-Connectives-1669" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-1715" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1717" href="../Connectives/#plfa_plfa-part1-Connectives-1671" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-1725" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-1735" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-1737" href="../Connectives/#plfa_plfa-part1-Connectives-1669" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-1739" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-1741" href="../Connectives/#plfa_plfa-part1-Connectives-1671" class="Bound">B</a>
</pre><p><code>A × B</code> 成立的证明由 <code>⟨ M , N ⟩</code> 的形式表现，其中 <code>M</code> 是 <code>A</code> 成立的证明， <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A × B</code> 成立的证明，我们可以得出 <code>A</code> 成立和 <code>B</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-proj₁"></a><a id="plfa_plfa-part1-Connectives-2115" href="../Connectives/#plfa_plfa-part1-Connectives-2115" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2121" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2123" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2125" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2126" href="../Connectives/#plfa_plfa-part1-Connectives-2126" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2128" href="../Connectives/#plfa_plfa-part1-Connectives-2128" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2130" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2132" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2135" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2139" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2141" href="../Connectives/#plfa_plfa-part1-Connectives-2126" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2143" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2145" href="../Connectives/#plfa_plfa-part1-Connectives-2128" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2151" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2159" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2161" href="../Connectives/#plfa_plfa-part1-Connectives-2126" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-2163" href="../Connectives/#plfa_plfa-part1-Connectives-2115" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-2169" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2171" href="../Connectives/#plfa_plfa-part1-Connectives-2171" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2173" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2175" href="../Connectives/#plfa_plfa-part1-Connectives-2175" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2177" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2179" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2181" href="../Connectives/#plfa_plfa-part1-Connectives-2171" class="Bound">x</a>

<a id="plfa_plfa-part1-Connectives-proj₂"></a><a id="plfa_plfa-part1-Connectives-2184" href="../Connectives/#plfa_plfa-part1-Connectives-2184" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2190" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2192" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-2194" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-2195" href="../Connectives/#plfa_plfa-part1-Connectives-2195" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2197" href="../Connectives/#plfa_plfa-part1-Connectives-2197" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-2199" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-2201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-2204" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-2208" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2210" href="../Connectives/#plfa_plfa-part1-Connectives-2195" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-2212" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-2214" href="../Connectives/#plfa_plfa-part1-Connectives-2197" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-2220" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Connectives-2228" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-2230" href="../Connectives/#plfa_plfa-part1-Connectives-2197" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-2232" href="../Connectives/#plfa_plfa-part1-Connectives-2184" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-2238" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-2240" href="../Connectives/#plfa_plfa-part1-Connectives-2240" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-2242" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-2244" href="../Connectives/#plfa_plfa-part1-Connectives-2244" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-2246" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-2248" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-2250" href="../Connectives/#plfa_plfa-part1-Connectives-2244" class="Bound">y</a>
</pre><p>如果 <code>L</code> 是 <code>A × B</code> 成立的证据, 那么 <code>proj₁ L</code> 是 <code>A</code> 成立的证据， <code>proj₂ L</code> 是 <code>B</code> 成立的证据。</p><p>当 <code>⟨_,_⟩</code> 在等式右手边的项中出现的时候，我们将其称作<strong>构造子（Constructor）</strong>， 当它出现在等式左边时，我们将其称作<strong>析构器（Destructor）</strong>。我们亦可将 <code>proj₁</code> 和 <code>proj₂</code> 称作析构器，因为它们起到相似的效果。</p><p>其他的术语将 <code>⟨_,_⟩</code> 称作<strong>引入（Introduce）</strong>合取，将 <code>proj₁</code> 和 <code>proj₂</code> 称作<strong>消去（Eliminate）</strong>合取。 前者亦记作 <code>×-I</code>，后者 <code>×-E₁</code> 和 <code>×-E₂</code>。如果我们从上到下来阅读这些规则，引入和消去 正如其名字所说的那样：第一条<strong>引入</strong>一个运算符，所以运算符出现在结论中，而不是假设中； 第二条<strong>消去</strong>一个带有运算符的式子，而运算符出现在假设中，而不是结论中。引入规则描述了 运算符在什么情况下成立——即怎么样<strong>定义</strong>一个运算符。消去规则描述了运算符成立时，可以得出 什么样的结论——即怎么样<strong>使用</strong>一个运算符。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>在这样的情况下，先使用析构器，再使用构造子将结果重组，得到还是原来的积。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×"></a><a id="plfa_plfa-part1-Connectives-4217" href="../Connectives/#plfa_plfa-part1-Connectives-4217" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4221" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4223" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-4225" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-4226" href="../Connectives/#plfa_plfa-part1-Connectives-4226" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4228" href="../Connectives/#plfa_plfa-part1-Connectives-4228" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4230" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4232" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4235" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-4237" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4238" href="../Connectives/#plfa_plfa-part1-Connectives-4238" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4240" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4242" href="../Connectives/#plfa_plfa-part1-Connectives-4226" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4244" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-4246" href="../Connectives/#plfa_plfa-part1-Connectives-4228" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-4247" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4249" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-4251" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4253" href="../Connectives/#plfa_plfa-part1-Connectives-2115" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-4259" href="../Connectives/#plfa_plfa-part1-Connectives-4238" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4261" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4263" href="../Connectives/#plfa_plfa-part1-Connectives-2184" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-4269" href="../Connectives/#plfa_plfa-part1-Connectives-4238" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-4271" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4273" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-4275" href="../Connectives/#plfa_plfa-part1-Connectives-4238" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-4277" href="../Connectives/#plfa_plfa-part1-Connectives-4217" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-4281" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-4283" href="../Connectives/#plfa_plfa-part1-Connectives-4283" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-4285" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-4287" href="../Connectives/#plfa_plfa-part1-Connectives-4287" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-4289" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-4291" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-4293" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>⟨ x , y ⟩</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项。</p><p>我们设置合取的优先级，使它与除了析取之外结合的都不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4683" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-4690" class="Number">2</a> <a id="plfa_plfa-part1-Connectives-4692" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">_×_</a>
</pre><p>因此，<code>m ≤ n × n ≤ p</code> 解析为 <code>(m ≤ n) × (n ≤ p)</code>。</p><p>Alternatively, we can declare conjunction as a record type:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-4878" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-_×′_"></a><a id="plfa_plfa-part1-Connectives-4885" href="../Connectives/#plfa_plfa-part1-Connectives-4885" class="Record Operator">_×′_</a> <a id="plfa_plfa-part1-Connectives-4890" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-4891" href="../Connectives/#plfa_plfa-part1-Connectives-4891" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-4893" href="../Connectives/#plfa_plfa-part1-Connectives-4893" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-4895" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4897" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-4900" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-4902" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4904" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-4908" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-4916" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-⟨_,_⟩′"></a><a id="plfa_plfa-part1-Connectives-4928" href="../Connectives/#plfa_plfa-part1-Connectives-4928" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="plfa_plfa-part1-Connectives-4937" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₁′"></a><a id="plfa_plfa-part1-Connectives-4947" href="../Connectives/#plfa_plfa-part1-Connectives-4947" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-4954" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4956" href="../Connectives/#plfa_plfa-part1-Connectives-4891" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-_×′_.proj₂′"></a><a id="plfa_plfa-part1-Connectives-4962" href="../Connectives/#plfa_plfa-part1-Connectives-4962" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-4969" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-4971" href="../Connectives/#plfa_plfa-part1-Connectives-4893" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-4973" class="Keyword">open</a> <a id="plfa_plfa-part1-Connectives-4978" href="../Connectives/#plfa_plfa-part1-Connectives-4885" class="Module Operator">_×′_</a>
</pre><p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p><p>The data type <code>_×_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-×′"></a><a id="plfa_plfa-part1-Connectives-5535" href="../Connectives/#plfa_plfa-part1-Connectives-5535" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5540" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5542" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-5544" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-5545" href="../Connectives/#plfa_plfa-part1-Connectives-5545" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5547" href="../Connectives/#plfa_plfa-part1-Connectives-5547" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-5549" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5551" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-5554" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-5556" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-5557" href="../Connectives/#plfa_plfa-part1-Connectives-5557" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5559" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-5561" href="../Connectives/#plfa_plfa-part1-Connectives-5545" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-5563" href="../Connectives/#plfa_plfa-part1-Connectives-4885" class="Record Operator">×′</a> <a id="plfa_plfa-part1-Connectives-5566" href="../Connectives/#plfa_plfa-part1-Connectives-5547" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-5567" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-5569" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-5571" href="../Connectives/#plfa_plfa-part1-Connectives-4928" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-5573" href="../Connectives/#plfa_plfa-part1-Connectives-4947" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Connectives-5580" href="../Connectives/#plfa_plfa-part1-Connectives-5557" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5582" href="../Connectives/#plfa_plfa-part1-Connectives-4928" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-5584" href="../Connectives/#plfa_plfa-part1-Connectives-4962" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Connectives-5591" href="../Connectives/#plfa_plfa-part1-Connectives-5557" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5593" href="../Connectives/#plfa_plfa-part1-Connectives-4928" class="InductiveConstructor Operator">⟩′</a> <a id="plfa_plfa-part1-Connectives-5596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-5598" href="../Connectives/#plfa_plfa-part1-Connectives-5557" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-5600" href="../Connectives/#plfa_plfa-part1-Connectives-5535" class="Function">η-×′</a> <a id="plfa_plfa-part1-Connectives-5605" href="../Connectives/#plfa_plfa-part1-Connectives-5605" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-5607" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-5609" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A × B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>积</strong>。 在集合论中它也被称作<strong>笛卡尔积（Cartesian Product）</strong>，在计算机科学中它对应<strong>记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A × B</code> 有 <code>m * n</code> 个不同的成员。这也是它被称为积的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-6547" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Bool"></a><a id="plfa_plfa-part1-Connectives-6552" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-6557" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6563" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Bool.true"></a><a id="plfa_plfa-part1-Connectives-6571" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-6577" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6579" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Connectives-Bool.false"></a><a id="plfa_plfa-part1-Connectives-6586" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-6592" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6594" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a>

<a id="plfa_plfa-part1-Connectives-6600" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-Tri"></a><a id="plfa_plfa-part1-Connectives-6605" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-6609" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-6615" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-Tri.aa"></a><a id="plfa_plfa-part1-Connectives-6623" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-6626" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6628" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.bb"></a><a id="plfa_plfa-part1-Connectives-6634" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-6637" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6639" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Connectives-Tri.cc"></a><a id="plfa_plfa-part1-Connectives-6645" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-6648" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-6650" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a>
</pre><p>那么，<code>Bool × Tri</code> 类型有如下的六个成员：</p><pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre><p>下面的函数枚举了所有类型为 <code>Bool × Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-count"></a><a id="plfa_plfa-part1-Connectives-6996" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7004" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7006" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-7011" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-7013" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-7017" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-7019" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-7021" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7029" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7031" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7037" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7039" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7042" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7045" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7048" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-7050" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7058" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7060" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7066" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7068" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7071" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7074" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7077" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-7079" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7087" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7089" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Connectives-7095" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7097" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7100" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7103" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7106" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-7108" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7116" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7118" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7124" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7126" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Connectives-7129" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7132" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7135" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-7137" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7145" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7147" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7153" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7155" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Connectives-7158" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7161" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7164" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-7166" href="../Connectives/#plfa_plfa-part1-Connectives-6996" class="Function">×-count</a> <a id="plfa_plfa-part1-Connectives-7174" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-7176" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Connectives-7182" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-7184" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Connectives-7187" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Connectives-7190" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-7193" class="Number">6</a>
</pre><p>类型上的积与数的积有相似的性质——它们满足交换律和结合律。 更确切地说，积在<strong>在同构意义下</strong>满足交换律和结合率。</p><p>对于交换律，<code>to</code> 函数将有序对交换，将 <code>⟨ x , y ⟩</code> 变为 <code>⟨ y , x ⟩</code>，<code>from</code> 函数亦是如此（忽略命名）。 在 <code>from∘to</code> 和 <code>to∘from</code> 中正确地实例化要匹配的模式是很重要的。 使用 <code>λ w → refl</code> 作为 <code>from∘to</code> 的定义是不可行的，<code>to∘from</code> 同理。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-comm"></a><a id="plfa_plfa-part1-Connectives-7982" href="../Connectives/#plfa_plfa-part1-Connectives-7982" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-7989" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-7991" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-7993" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-7994" href="../Connectives/#plfa_plfa-part1-Connectives-7994" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-7996" href="../Connectives/#plfa_plfa-part1-Connectives-7996" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-7998" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-8000" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-8003" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-8005" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8007" href="../Connectives/#plfa_plfa-part1-Connectives-7994" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-8009" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-8011" href="../Connectives/#plfa_plfa-part1-Connectives-7996" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-8013" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-8015" href="../Connectives/#plfa_plfa-part1-Connectives-7996" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-8017" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-8019" href="../Connectives/#plfa_plfa-part1-Connectives-7994" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-8021" href="../Connectives/#plfa_plfa-part1-Connectives-7982" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-8028" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-8032" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-8043" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-8045" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>       <a id="plfa_plfa-part1-Connectives-8054" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8057" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8060" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8062" href="../Connectives/#plfa_plfa-part1-Connectives-8062" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8064" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8066" href="../Connectives/#plfa_plfa-part1-Connectives-8066" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8068" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8070" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8072" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8074" href="../Connectives/#plfa_plfa-part1-Connectives-8066" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8076" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8078" href="../Connectives/#plfa_plfa-part1-Connectives-8062" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8080" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8082" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8088" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8090" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>     <a id="plfa_plfa-part1-Connectives-8099" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8102" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8105" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8107" href="../Connectives/#plfa_plfa-part1-Connectives-8107" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8109" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8111" href="../Connectives/#plfa_plfa-part1-Connectives-8111" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8113" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8115" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8117" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8119" href="../Connectives/#plfa_plfa-part1-Connectives-8111" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8121" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8123" href="../Connectives/#plfa_plfa-part1-Connectives-8107" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8125" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8127" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8133" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8135" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a>  <a id="plfa_plfa-part1-Connectives-8144" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8147" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8150" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8152" href="../Connectives/#plfa_plfa-part1-Connectives-8152" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8154" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8156" href="../Connectives/#plfa_plfa-part1-Connectives-8156" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8158" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8160" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8162" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8167" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8173" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-8175" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a>  <a id="plfa_plfa-part1-Connectives-8184" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-8187" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-8190" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-8192" href="../Connectives/#plfa_plfa-part1-Connectives-8192" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-8194" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-8196" href="../Connectives/#plfa_plfa-part1-Connectives-8196" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-8198" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-8200" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-8202" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-8207" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-8213" class="Symbol">}</a>
</pre><p>满足<strong>交换律</strong>和<strong>在同构意义下满足交换律</strong>是不一样的。比较下列两个命题：</p><pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre><p>在第一个情况下，我们可能有 <code>m</code> 是 <code>2</code>、<code>n</code> 是 <code>3</code>，那么 <code>m * n</code> 和 <code>n * m</code> 都是 <code>6</code>。 在第二个情况下，我们可能有 <code>A</code> 是 <code>Bool</code> 和 <code>B</code> 是 <code>Tri</code>，但是 <code>Bool × Tri</code> 和 <code>Tri × Bool</code> <strong>不是</strong>一样的。但是存在一个两者之间的同构。例如：<code>⟨ true , aa ⟩</code> 是前者的成员， 其对应后者的成员 <code>⟨ aa , true ⟩</code>。</p><p>对于结合律来说，<code>to</code> 函数将两个有序对进行重组：将 <code>⟨ ⟨ x , y ⟩ , z ⟩</code> 转换为 <code>⟨ x , ⟨ y , z ⟩ ⟩</code>， <code>from</code> 函数则为其逆。同样，左逆和右逆的证明需要在一个合适的模式来匹配，从而可以直接化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-assoc"></a><a id="plfa_plfa-part1-Connectives-9479" href="../Connectives/#plfa_plfa-part1-Connectives-9479" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9487" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9489" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-9491" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-9492" href="../Connectives/#plfa_plfa-part1-Connectives-9492" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9494" href="../Connectives/#plfa_plfa-part1-Connectives-9494" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9496" href="../Connectives/#plfa_plfa-part1-Connectives-9496" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9498" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-9500" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-9503" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-9505" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9507" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9508" href="../Connectives/#plfa_plfa-part1-Connectives-9492" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9510" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9512" href="../Connectives/#plfa_plfa-part1-Connectives-9494" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-9513" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-9515" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9517" href="../Connectives/#plfa_plfa-part1-Connectives-9496" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-9519" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-9521" href="../Connectives/#plfa_plfa-part1-Connectives-9492" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-9523" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9525" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-9526" href="../Connectives/#plfa_plfa-part1-Connectives-9494" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-9528" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-9530" href="../Connectives/#plfa_plfa-part1-Connectives-9496" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-9531" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-9533" href="../Connectives/#plfa_plfa-part1-Connectives-9479" class="Function">×-assoc</a> <a id="plfa_plfa-part1-Connectives-9541" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-9545" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-9556" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-9558" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-9566" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9568" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9571" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9573" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9575" href="../Connectives/#plfa_plfa-part1-Connectives-9575" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9577" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9579" href="../Connectives/#plfa_plfa-part1-Connectives-9579" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9581" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9583" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9585" href="../Connectives/#plfa_plfa-part1-Connectives-9585" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9587" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9589" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9591" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9593" href="../Connectives/#plfa_plfa-part1-Connectives-9575" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9595" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9597" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9599" href="../Connectives/#plfa_plfa-part1-Connectives-9579" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9601" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9603" href="../Connectives/#plfa_plfa-part1-Connectives-9585" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9605" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9607" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9609" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9615" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9617" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-9625" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9627" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9630" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9632" href="../Connectives/#plfa_plfa-part1-Connectives-9632" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9634" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9636" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9638" href="../Connectives/#plfa_plfa-part1-Connectives-9638" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9640" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9642" href="../Connectives/#plfa_plfa-part1-Connectives-9642" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9644" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9646" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9648" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9650" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9652" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9654" href="../Connectives/#plfa_plfa-part1-Connectives-9632" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9656" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9658" href="../Connectives/#plfa_plfa-part1-Connectives-9638" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9660" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9662" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9664" href="../Connectives/#plfa_plfa-part1-Connectives-9642" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9666" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9668" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9674" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9676" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-9684" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9686" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9689" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9691" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9693" href="../Connectives/#plfa_plfa-part1-Connectives-9693" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9695" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9697" href="../Connectives/#plfa_plfa-part1-Connectives-9697" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9699" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9701" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9703" href="../Connectives/#plfa_plfa-part1-Connectives-9703" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9705" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9707" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9709" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9714" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9720" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-9722" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-9730" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-9732" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-9735" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9737" href="../Connectives/#plfa_plfa-part1-Connectives-9737" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-9739" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9741" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-9743" href="../Connectives/#plfa_plfa-part1-Connectives-9743" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-9745" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-9747" href="../Connectives/#plfa_plfa-part1-Connectives-9747" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-9749" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9751" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-9753" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-9755" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-9760" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-9766" class="Symbol">}</a>
</pre><p>满足<strong>结合律</strong>和<strong>在同构意义下满足结合律</strong>是不一样的。比较下列两个命题：</p><pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre><p>举个例子，<code>(ℕ × Bool) × Tri</code> 与 <code>ℕ × (Bool × Tri)</code> <strong>不同</strong>，但是两个类型之间 存在同构。例如 <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>，一个前者的成员，与 <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>， 一个后者的成员，相对应。</p><h4 id="练习-实践">练习 <code>⇔≃×</code>（实践）</h4><p>证明<a href="../Isomorphism/#iff">之前</a>定义的 <code>A ⇔ B</code> 与 <code>(A → B) × (B → A)</code> 同构。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10660" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="真即是单元类型">真即是单元类型</h2><p>恒真 <code>⊤</code> 恒成立。我们将这个概念用合适的数据类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-10849" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊤"></a><a id="plfa_plfa-part1-Connectives-10854" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-10856" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-10858" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-10862" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-⊤.tt"></a><a id="plfa_plfa-part1-Connectives-10871" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-10874" class="Symbol">:</a>
    <a id="plfa_plfa-part1-Connectives-10880" class="Comment">--</a>
    <a id="plfa_plfa-part1-Connectives-10887" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a>
</pre><p><code>⊤</code> 成立的证明由 <code>tt</code> 的形式构成。</p><p>恒真有引入规则，但没有消去规则。给定一个 <code>⊤</code> 成立的证明，我们不能得出任何有趣的结论。 因为恒真恒成立，知道恒真成立不会给我们带来新的知识。</p><p><code>η-×</code> 的 零元形式是 <code>η-⊤</code>，其断言了任何 <code>⊤</code> 类型的值一定等于 <code>tt</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤"></a><a id="plfa_plfa-part1-Connectives-11431" href="../Connectives/#plfa_plfa-part1-Connectives-11431" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11435" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11437" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-11439" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-11440" href="../Connectives/#plfa_plfa-part1-Connectives-11440" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-11442" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11444" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-11445" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-11447" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-11449" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11452" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-11454" href="../Connectives/#plfa_plfa-part1-Connectives-11440" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-11456" href="../Connectives/#plfa_plfa-part1-Connectives-11431" class="Function">η-⊤</a> <a id="plfa_plfa-part1-Connectives-11460" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-11463" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-11465" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。将 <code>w</code> 替换为 <code>tt</code> 让等式两边可以化简为相同的值。</p>Alternatively, we can declare truth as an empty record:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-11751" class="Keyword">record</a> <a id="plfa_plfa-part1-Connectives-⊤′"></a><a id="plfa_plfa-part1-Connectives-11758" href="../Connectives/#plfa_plfa-part1-Connectives-11758" class="Record">⊤′</a> <a id="plfa_plfa-part1-Connectives-11761" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-11763" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-11767" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-11775" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Connectives-tt′"></a><a id="plfa_plfa-part1-Connectives-11787" href="../Connectives/#plfa_plfa-part1-Connectives-11787" class="InductiveConstructor">tt′</a>
</pre><p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊤′"></a><a id="plfa_plfa-part1-Connectives-12162" href="../Connectives/#plfa_plfa-part1-Connectives-12162" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12167" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12169" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-12171" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-12172" href="../Connectives/#plfa_plfa-part1-Connectives-12172" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12174" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12176" href="../Connectives/#plfa_plfa-part1-Connectives-11758" class="Record">⊤′</a><a id="plfa_plfa-part1-Connectives-12178" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-12180" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12182" href="../Connectives/#plfa_plfa-part1-Connectives-11787" class="InductiveConstructor">tt′</a> <a id="plfa_plfa-part1-Connectives-12186" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-12188" href="../Connectives/#plfa_plfa-part1-Connectives-12172" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-12190" href="../Connectives/#plfa_plfa-part1-Connectives-12162" class="Function">η-⊤′</a> <a id="plfa_plfa-part1-Connectives-12195" href="../Connectives/#plfa_plfa-part1-Connectives-12195" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-12197" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12199" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre>Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:<pre class="Agda"><a id="plfa_plfa-part1-Connectives-truth′"></a><a id="plfa_plfa-part1-Connectives-12349" href="../Connectives/#plfa_plfa-part1-Connectives-12349" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12356" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12358" href="../Connectives/#plfa_plfa-part1-Connectives-11758" class="Record">⊤′</a>
<a id="plfa_plfa-part1-Connectives-12361" href="../Connectives/#plfa_plfa-part1-Connectives-12349" class="Function">truth′</a> <a id="plfa_plfa-part1-Connectives-12368" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12370" class="Symbol">_</a>
</pre><p>我们将 <code>⊤</code> 称为<strong>单元（Unit Type）</strong>类型。实际上，<code>⊤</code> 类型只有一个成员 <code>tt</code>。 例如，下面的函数枚举了所有 <code>⊤</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-count"></a><a id="plfa_plfa-part1-Connectives-12646" href="../Connectives/#plfa_plfa-part1-Connectives-12646" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12654" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-12656" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-12658" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-12660" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-12662" href="../Connectives/#plfa_plfa-part1-Connectives-12646" class="Function">⊤-count</a> <a id="plfa_plfa-part1-Connectives-12670" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-12673" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-12675" class="Number">1</a>
</pre><p>对于数来说，1 是乘法的幺元。对应地，单元是积的幺元（<strong>在同构意义下</strong>）。对于左幺元来说， <code>to</code> 函数将 <code>⟨ tt , x ⟩</code> 转换成 <code>x</code>， <code>from</code> 函数则是其反函数。左逆的证明需要 匹配一个合适的模式来化简：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityˡ"></a><a id="plfa_plfa-part1-Connectives-13148" href="../Connectives/#plfa_plfa-part1-Connectives-13148" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13160" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13162" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-13164" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-13165" href="../Connectives/#plfa_plfa-part1-Connectives-13165" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13167" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-13169" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-13172" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-13174" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13176" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-13178" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-13180" href="../Connectives/#plfa_plfa-part1-Connectives-13165" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-13182" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-13184" href="../Connectives/#plfa_plfa-part1-Connectives-13165" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-13186" href="../Connectives/#plfa_plfa-part1-Connectives-13148" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-13198" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-13202" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-13213" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-13215" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-13223" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13225" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13228" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13230" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13233" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13235" href="../Connectives/#plfa_plfa-part1-Connectives-13235" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13237" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13239" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13241" href="../Connectives/#plfa_plfa-part1-Connectives-13235" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13243" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13249" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13251" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-13259" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13261" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13264" href="../Connectives/#plfa_plfa-part1-Connectives-13264" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13266" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13268" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13270" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13273" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13275" href="../Connectives/#plfa_plfa-part1-Connectives-13264" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13277" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13279" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13285" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13287" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-13295" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13297" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13300" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-13302" href="../Connectives/#plfa_plfa-part1-Connectives-10871" class="InductiveConstructor">tt</a> <a id="plfa_plfa-part1-Connectives-13305" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-13307" href="../Connectives/#plfa_plfa-part1-Connectives-13307" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13309" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-13311" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13313" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13318" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13324" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-13326" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-13334" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-13336" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-13339" href="../Connectives/#plfa_plfa-part1-Connectives-13339" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-13341" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-13343" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-13348" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-13354" class="Symbol">}</a>
</pre><p><strong>幺元</strong>和<strong>在同构意义下的幺元</strong>是不一样的。比较下列两个命题：</p><pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre><p>在第一种情况下，我们可能有 <code>m</code> 是 <code>2</code>，那么 <code>1 * m</code> 和 <code>m</code> 都为 <code>2</code>。 在第二种情况下，我们可能有 <code>A</code> 是 <code>Bool</code>，但是 <code>⊤ × Bool</code> 和 <code>Bool</code> 是不同的。 例如：<code>⟨ tt , true ⟩</code> 是前者的成员，其对应后者的成员 <code>true</code>。</p><p>右幺元可以由积的交换律得来：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊤-identityʳ"></a><a id="plfa_plfa-part1-Connectives-14174" href="../Connectives/#plfa_plfa-part1-Connectives-14174" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14186" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14188" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-14190" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14191" href="../Connectives/#plfa_plfa-part1-Connectives-14191" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14193" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14195" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14198" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14200" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14202" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14203" href="../Connectives/#plfa_plfa-part1-Connectives-14191" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14205" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14207" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14208" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14210" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-14212" href="../Connectives/#plfa_plfa-part1-Connectives-14191" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-14214" href="../Connectives/#plfa_plfa-part1-Connectives-14174" class="Function">⊤-identityʳ</a> <a id="plfa_plfa-part1-Connectives-14226" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-14227" href="../Connectives/#plfa_plfa-part1-Connectives-14227" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14228" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-14230" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-14234" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10876" class="Function Operator">≃-begin</a>
    <a id="plfa_plfa-part1-Connectives-14246" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14247" href="../Connectives/#plfa_plfa-part1-Connectives-14227" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14249" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14251" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a><a id="plfa_plfa-part1-Connectives-14252" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14256" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10960" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14259" href="../Connectives/#plfa_plfa-part1-Connectives-7982" class="Function">×-comm</a> <a id="plfa_plfa-part1-Connectives-14266" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10960" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14272" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14273" href="../Connectives/#plfa_plfa-part1-Connectives-10854" class="Datatype">⊤</a> <a id="plfa_plfa-part1-Connectives-14275" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-14277" href="../Connectives/#plfa_plfa-part1-Connectives-14227" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-14278" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-14282" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10960" class="Function Operator">≃⟨</a> <a id="plfa_plfa-part1-Connectives-14285" href="../Connectives/#plfa_plfa-part1-Connectives-13148" class="Function">⊤-identityˡ</a> <a id="plfa_plfa-part1-Connectives-14297" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-10960" class="Function Operator">⟩</a>
    <a id="plfa_plfa-part1-Connectives-14303" href="../Connectives/#plfa_plfa-part1-Connectives-14227" class="Bound">A</a>
  <a id="plfa_plfa-part1-Connectives-14307" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11079" class="Function Operator">≃-∎</a>
</pre><p>我们在此使用了同构链，与等式链相似。</p><h2 id="析取即是和">析取即是和</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，析取 <code>A ⊎ B</code> 在 <code>A</code> 成立或者 <code>B</code> 成立时成立。 我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-14722" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-_⊎_"></a><a id="plfa_plfa-part1-Connectives-14727" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">_⊎_</a> <a id="plfa_plfa-part1-Connectives-14731" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-14732" href="../Connectives/#plfa_plfa-part1-Connectives-14732" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14734" href="../Connectives/#plfa_plfa-part1-Connectives-14734" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-14736" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14738" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-14741" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-14743" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-14745" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-14749" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₁"></a><a id="plfa_plfa-part1-Connectives-14758" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-14763" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14771" href="../Connectives/#plfa_plfa-part1-Connectives-14732" class="Bound">A</a>
      <a id="plfa_plfa-part1-Connectives-14779" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14789" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14791" href="../Connectives/#plfa_plfa-part1-Connectives-14732" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14793" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14795" href="../Connectives/#plfa_plfa-part1-Connectives-14734" class="Bound">B</a>

  <a id="plfa_plfa-part1-Connectives-_⊎_.inj₂"></a><a id="plfa_plfa-part1-Connectives-14800" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-14805" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Connectives-14813" href="../Connectives/#plfa_plfa-part1-Connectives-14734" class="Bound">B</a>
      <a id="plfa_plfa-part1-Connectives-14821" class="Comment">-----</a>
    <a id="plfa_plfa-part1-Connectives-14831" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-14833" href="../Connectives/#plfa_plfa-part1-Connectives-14732" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-14835" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-14837" href="../Connectives/#plfa_plfa-part1-Connectives-14734" class="Bound">B</a>
</pre><p><code>A ⊎ B</code> 成立的证明有两个形式： <code>inj₁ M</code>，其中 <code>M</code> 是 <code>A</code> 成立的证明，或者 <code>inj₂ N</code>，其中 <code>N</code> 是 <code>B</code> 成立的证明。</p><p>给定 <code>A → C</code> 和 <code>B → C</code> 成立的证明，那么给定一个 <code>A ⊎ B</code> 的证明，我们可以得出 <code>C</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-case-⊎"></a><a id="plfa_plfa-part1-Connectives-15298" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15305" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15307" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-15309" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-15310" href="../Connectives/#plfa_plfa-part1-Connectives-15310" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15312" href="../Connectives/#plfa_plfa-part1-Connectives-15312" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15314" href="../Connectives/#plfa_plfa-part1-Connectives-15314" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-15316" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-15318" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-15321" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-15325" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15327" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15328" href="../Connectives/#plfa_plfa-part1-Connectives-15310" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15330" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15332" href="../Connectives/#plfa_plfa-part1-Connectives-15314" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15333" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15337" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15339" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15340" href="../Connectives/#plfa_plfa-part1-Connectives-15312" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-15342" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15344" href="../Connectives/#plfa_plfa-part1-Connectives-15314" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-15345" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-15349" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15351" href="../Connectives/#plfa_plfa-part1-Connectives-15310" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-15353" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-15355" href="../Connectives/#plfa_plfa-part1-Connectives-15312" class="Bound">B</a>
    <a id="plfa_plfa-part1-Connectives-15361" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Connectives-15375" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-15377" href="../Connectives/#plfa_plfa-part1-Connectives-15314" class="Bound">C</a>
<a id="plfa_plfa-part1-Connectives-15379" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15386" href="../Connectives/#plfa_plfa-part1-Connectives-15386" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15388" href="../Connectives/#plfa_plfa-part1-Connectives-15388" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15390" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15391" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-15396" href="../Connectives/#plfa_plfa-part1-Connectives-15396" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-15397" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15399" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15401" href="../Connectives/#plfa_plfa-part1-Connectives-15386" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15403" href="../Connectives/#plfa_plfa-part1-Connectives-15396" class="Bound">x</a>
<a id="plfa_plfa-part1-Connectives-15405" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-15412" href="../Connectives/#plfa_plfa-part1-Connectives-15412" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-15414" href="../Connectives/#plfa_plfa-part1-Connectives-15414" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15416" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-15417" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-15422" href="../Connectives/#plfa_plfa-part1-Connectives-15422" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-15423" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-15425" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-15427" href="../Connectives/#plfa_plfa-part1-Connectives-15414" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-15429" href="../Connectives/#plfa_plfa-part1-Connectives-15422" class="Bound">y</a>
</pre><p>对 <code>inj₁</code> 和 <code>inj₂</code> 进行模式匹配，是我们使用析取成立的证明的常见方法。</p><p>当 <code>inj₁</code> 和 <code>inj₂</code> 在等式右手边出现的时候，我们将其称作<strong>构造子</strong>， 当它出现在等式左边时，我们将其称作<strong>析构器</strong>。我们亦可将 <code>case-⊎</code> 称作析构器，因为它们起到相似的效果。其他术语将 <code>inj₁</code> 和 <code>inj₂</code> 称为<strong>引入</strong>析取， 将 <code>case-⊎</code> 称为<strong>消去</strong>析取。前者亦被称为 <code>⊎-I₁</code> 和 <code>⊎-I₂</code>，后者 <code>⊎-E</code>。</p><p>对每个构造子使用析构器得到的是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-⊎"></a><a id="plfa_plfa-part1-Connectives-16391" href="../Connectives/#plfa_plfa-part1-Connectives-16391" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16395" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16397" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16399" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16400" href="../Connectives/#plfa_plfa-part1-Connectives-16400" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16402" href="../Connectives/#plfa_plfa-part1-Connectives-16402" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16404" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16406" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16409" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16411" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16412" href="../Connectives/#plfa_plfa-part1-Connectives-16412" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16414" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16416" href="../Connectives/#plfa_plfa-part1-Connectives-16400" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16418" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16420" href="../Connectives/#plfa_plfa-part1-Connectives-16402" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16421" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16423" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16425" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16432" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16437" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16442" href="../Connectives/#plfa_plfa-part1-Connectives-16412" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16446" href="../Connectives/#plfa_plfa-part1-Connectives-16412" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16448" href="../Connectives/#plfa_plfa-part1-Connectives-16391" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16452" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16453" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16458" href="../Connectives/#plfa_plfa-part1-Connectives-16458" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16459" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16461" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16468" href="../Connectives/#plfa_plfa-part1-Connectives-16391" class="Function">η-⊎</a> <a id="plfa_plfa-part1-Connectives-16472" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16473" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16478" href="../Connectives/#plfa_plfa-part1-Connectives-16478" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16479" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16481" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16483" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>更普遍地来说，我们亦可对于析取使用一个任意的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊎"></a><a id="plfa_plfa-part1-Connectives-16617" href="../Connectives/#plfa_plfa-part1-Connectives-16617" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16624" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16626" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-16628" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-16629" href="../Connectives/#plfa_plfa-part1-Connectives-16629" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16631" href="../Connectives/#plfa_plfa-part1-Connectives-16631" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16633" href="../Connectives/#plfa_plfa-part1-Connectives-16633" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-16635" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-16640" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-16642" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16643" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16645" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16647" href="../Connectives/#plfa_plfa-part1-Connectives-16629" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16649" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16651" href="../Connectives/#plfa_plfa-part1-Connectives-16631" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-16653" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-16655" href="../Connectives/#plfa_plfa-part1-Connectives-16633" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-16656" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16658" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16659" href="../Connectives/#plfa_plfa-part1-Connectives-16659" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16661" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-16663" href="../Connectives/#plfa_plfa-part1-Connectives-16629" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-16665" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-16667" href="../Connectives/#plfa_plfa-part1-Connectives-16631" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-16668" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16670" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Connectives-16674" href="../Connectives/#plfa_plfa-part1-Connectives-15298" class="Function">case-⊎</a> <a id="plfa_plfa-part1-Connectives-16681" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16682" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16684" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16686" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-16690" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16692" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16693" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16695" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-16697" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-16701" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16703" href="../Connectives/#plfa_plfa-part1-Connectives-16659" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-16705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-16707" href="../Connectives/#plfa_plfa-part1-Connectives-16643" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16709" href="../Connectives/#plfa_plfa-part1-Connectives-16659" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-16711" href="../Connectives/#plfa_plfa-part1-Connectives-16617" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16718" href="../Connectives/#plfa_plfa-part1-Connectives-16718" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16720" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16721" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-16726" href="../Connectives/#plfa_plfa-part1-Connectives-16726" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-16727" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16729" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Connectives-16736" href="../Connectives/#plfa_plfa-part1-Connectives-16617" class="Function">uniq-⊎</a> <a id="plfa_plfa-part1-Connectives-16743" href="../Connectives/#plfa_plfa-part1-Connectives-16743" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-16745" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-16746" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-16751" href="../Connectives/#plfa_plfa-part1-Connectives-16751" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-16752" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-16754" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-16756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>左手边的模式匹配是必要的。用 <code>inj₁ x</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项， <code>inj₂ y</code> 同理。</p><p>我们设置析取的优先级，使它与任何已经定义的运算符都结合的不紧密：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-17182" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Connectives-17189" class="Number">1</a> <a id="plfa_plfa-part1-Connectives-17191" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">_⊎_</a>
</pre><p>因此 <code>A × C ⊎ B × C</code> 解析为 <code>(A × C) ⊎ (B × C)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A ⊎ B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>和</strong>。 在集合论中它也被称作<strong>不交并（Disjoint Union）</strong>，在计算机科学中它对应<strong>变体记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A ⊎ B</code> 有 <code>m + n</code> 个不同的成员。这也是它被称为和的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型，如之前的定义。 那么，<code>Bool ⊎ Tri</code> 类型有如下的五个成员：</p><pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre><p>下面的函数枚举了所有类型为 <code>Bool ⊎ Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-count"></a><a id="plfa_plfa-part1-Connectives-18354" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18362" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-18364" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-18369" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-18371" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Connectives-18375" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-18377" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-18379" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18387" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18388" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18393" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Connectives-18397" class="Symbol">)</a>   <a id="plfa_plfa-part1-Connectives-18401" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18404" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-18406" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18414" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18415" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-18420" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Connectives-18425" class="Symbol">)</a>  <a id="plfa_plfa-part1-Connectives-18428" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18431" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-18433" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18441" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18442" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18447" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a><a id="plfa_plfa-part1-Connectives-18449" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18455" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18458" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-18460" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18468" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18469" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18474" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a><a id="plfa_plfa-part1-Connectives-18476" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18482" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18485" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-18487" href="../Connectives/#plfa_plfa-part1-Connectives-18354" class="Function">⊎-count</a> <a id="plfa_plfa-part1-Connectives-18495" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-18496" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-18501" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a><a id="plfa_plfa-part1-Connectives-18503" class="Symbol">)</a>     <a id="plfa_plfa-part1-Connectives-18509" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-18512" class="Number">5</a>
</pre><p>类型上的和与数的和有相似的性质——它们满足交换律和结合律。 更确切地说，和在<strong>在同构意义下</strong>是交换和结合的。</p><h4 id="练习--comm-推荐">练习 <code>⊎-comm</code> （推荐）</h4><p>证明和类型在同构意义下满足交换律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-18857" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习--assoc实践">练习 <code>⊎-assoc</code>（实践）</h4><p>证明和类型在同构意义下满足结合律。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19024" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="假即是空类型">假即是空类型</h2><p>恒假 <code>⊥</code> 从不成立。我们将这个概念用合适的归纳类型来形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-19337" class="Keyword">data</a> <a id="plfa_plfa-part1-Connectives-⊥"></a><a id="plfa_plfa-part1-Connectives-19342" href="../Connectives/#plfa_plfa-part1-Connectives-19342" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-19344" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-19346" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Connectives-19350" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Connectives-19358" class="Comment">-- 没有语句！</a>
</pre><p>没有 <code>⊥</code> 成立的证明。</p><p>与 <code>⊤</code> 相对偶，<code>⊥</code> 没有引入规则，但是有消去规则。因为恒假从不成立， 如果它一旦成立，我们就进入了矛盾之中。给定 <code>⊥</code> 成立的证明，我们可以得出任何结论！ 这是逻辑学的基本原理，又由中世纪的拉丁文词组 <em>ex falso</em> 为名。小孩子也由诸如 「如果猪有翅膀，那我就是示巴女王」的词组中知晓。我们如下将它形式化：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-elim"></a><a id="plfa_plfa-part1-Connectives-20073" href="../Connectives/#plfa_plfa-part1-Connectives-20073" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20080" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20082" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20084" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20085" href="../Connectives/#plfa_plfa-part1-Connectives-20085" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-20087" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20089" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20092" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-20096" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20098" href="../Connectives/#plfa_plfa-part1-Connectives-19342" class="Datatype">⊥</a>
    <a id="plfa_plfa-part1-Connectives-20104" class="Comment">--</a>
  <a id="plfa_plfa-part1-Connectives-20109" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20111" href="../Connectives/#plfa_plfa-part1-Connectives-20085" class="Bound">A</a>
<a id="plfa_plfa-part1-Connectives-20113" href="../Connectives/#plfa_plfa-part1-Connectives-20073" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20120" class="Symbol">()</a>
</pre><p>这是我们第一次使<strong>用荒谬模式（Absurd Pattern）</strong> <code>()</code>。在这里，因为 <code>⊥</code> 是一个没有成员的类型，我们用 <code>()</code> 模式来指明这里不可能匹配任何这个类型的值。</p><p><code>case-⊎</code> 的零元形式是 <code>⊥-elim</code>。类比的来说，它应该叫做 <code>case-⊥</code>， 但是我们在此使用标准库中使用的名字。</p><p><code>uniq-⊎</code> 的零元形式是 <code>uniq-⊥</code>，其断言了 <code>⊥-elim</code> 和任何取 <code>⊥</code> 的函数是等价的。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-uniq-⊥"></a><a id="plfa_plfa-part1-Connectives-20845" href="../Connectives/#plfa_plfa-part1-Connectives-20845" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20852" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20854" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-20856" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-20857" href="../Connectives/#plfa_plfa-part1-Connectives-20857" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-20859" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20861" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-20864" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-20866" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20867" href="../Connectives/#plfa_plfa-part1-Connectives-20867" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20869" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20871" href="../Connectives/#plfa_plfa-part1-Connectives-19342" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-20873" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20875" href="../Connectives/#plfa_plfa-part1-Connectives-20857" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-20876" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20878" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-20879" href="../Connectives/#plfa_plfa-part1-Connectives-20879" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20881" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-20883" href="../Connectives/#plfa_plfa-part1-Connectives-19342" class="Datatype">⊥</a><a id="plfa_plfa-part1-Connectives-20884" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-20886" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-20888" href="../Connectives/#plfa_plfa-part1-Connectives-20073" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Connectives-20895" href="../Connectives/#plfa_plfa-part1-Connectives-20879" class="Bound">w</a> <a id="plfa_plfa-part1-Connectives-20897" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-20899" href="../Connectives/#plfa_plfa-part1-Connectives-20867" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20901" href="../Connectives/#plfa_plfa-part1-Connectives-20879" class="Bound">w</a>
<a id="plfa_plfa-part1-Connectives-20903" href="../Connectives/#plfa_plfa-part1-Connectives-20845" class="Function">uniq-⊥</a> <a id="plfa_plfa-part1-Connectives-20910" href="../Connectives/#plfa_plfa-part1-Connectives-20910" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-20912" class="Symbol">()</a>
</pre><p>使用荒谬模式断言了 <code>w</code> 没有任何可能的值，因此等式显然成立。</p><p>我们将 <code>⊥</code> 成为<strong>空（Empty）</strong>类型。实际上，<code>⊥</code> 类型没有成员。 例如，下面的函数枚举了所有 <code>⊥</code> 类型的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊥-count"></a><a id="plfa_plfa-part1-Connectives-21311" href="../Connectives/#plfa_plfa-part1-Connectives-21311" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21319" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-21321" href="../Connectives/#plfa_plfa-part1-Connectives-19342" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Connectives-21323" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-21325" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-21327" href="../Connectives/#plfa_plfa-part1-Connectives-21311" class="Function">⊥-count</a> <a id="plfa_plfa-part1-Connectives-21335" class="Symbol">()</a>
</pre><p>同样，荒谬模式告诉我们没有值可以来匹配类型 <code>⊥</code>。</p><p>对于数来说，0 是加法的幺元。对应地，空是和的幺元（<strong>在同构意义下</strong>）。</p><h4 id="练习--identityˡ-推荐">练习 <code>⊥-identityˡ</code> （推荐）</h4><p>证明空在同构意义下是和的左幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21802" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4><h4 id="练习--identityʳ实践">练习 <code>⊥-identityʳ</code>（实践）</h4><p>证明空在同构意义下是和的右幺元。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-21985" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="implication">蕴涵即是函数</h2><p>给定两个命题 <code>A</code> 和 <code>B</code>，其蕴涵 <code>A → B</code> 在任何 <code>A</code> 成立的时候，<code>B</code> 也成立时成立。 我们用函数类型来形式化蕴涵，如本书中通篇出现的那样。</p><p><code>A → B</code> 成立的证据由下面的形式组成：</p><pre><code>λ (x : A) → N</code></pre><p>其中 <code>N</code> 是一个类型为 <code>B</code> 的项，其包括了一个类型为 <code>A</code> 的自由变量 <code>x</code>。 给定一个 <code>A → B</code> 成立的证明 <code>L</code>，和一个 <code>A</code> 成立的证明 <code>M</code>，那么 <code>L M</code> 是 <code>B</code> 成立的证明。 也就是说，<code>A → B</code> 成立的证明是一个函数，将 <code>A</code> 成立的证明转换成 <code>B</code> 成立的证明。</p><p>换句话说，如果知道 <code>A → B</code> 和 <code>A</code> 同时成立，那么我们可以推出 <code>B</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-elim"></a><a id="plfa_plfa-part1-Connectives-23169" href="../Connectives/#plfa_plfa-part1-Connectives-23169" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23176" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23178" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23180" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23181" href="../Connectives/#plfa_plfa-part1-Connectives-23181" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23183" href="../Connectives/#plfa_plfa-part1-Connectives-23183" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23185" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23190" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Connectives-23194" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23196" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23197" href="../Connectives/#plfa_plfa-part1-Connectives-23181" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23199" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23201" href="../Connectives/#plfa_plfa-part1-Connectives-23183" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23202" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Connectives-23206" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23208" href="../Connectives/#plfa_plfa-part1-Connectives-23181" class="Bound">A</a>
    <a id="plfa_plfa-part1-Connectives-23214" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Connectives-23224" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23226" href="../Connectives/#plfa_plfa-part1-Connectives-23183" class="Bound">B</a>
<a id="plfa_plfa-part1-Connectives-23228" href="../Connectives/#plfa_plfa-part1-Connectives-23169" class="Function">→-elim</a> <a id="plfa_plfa-part1-Connectives-23235" href="../Connectives/#plfa_plfa-part1-Connectives-23235" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23237" href="../Connectives/#plfa_plfa-part1-Connectives-23237" class="Bound">M</a> <a id="plfa_plfa-part1-Connectives-23239" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23241" href="../Connectives/#plfa_plfa-part1-Connectives-23235" class="Bound">L</a> <a id="plfa_plfa-part1-Connectives-23243" href="../Connectives/#plfa_plfa-part1-Connectives-23237" class="Bound">M</a>
</pre><p>在中世纪，这条规则被叫做 <em>modus ponens</em>，它与函数应用相对应。</p><p>定义一个函数，不管是带名字的定义或是使用 Lambda 抽象，被称为<strong>引入</strong>一个函数， 使用一个函数被称为<strong>消去</strong>一个函数。</p><p>引入后接着消去，得到的还是原来的值：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-η-→"></a><a id="plfa_plfa-part1-Connectives-23763" href="../Connectives/#plfa_plfa-part1-Connectives-23763" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23767" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23769" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-23771" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-23772" href="../Connectives/#plfa_plfa-part1-Connectives-23772" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23774" href="../Connectives/#plfa_plfa-part1-Connectives-23774" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-23776" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23778" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-23781" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-23783" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23784" href="../Connectives/#plfa_plfa-part1-Connectives-23784" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23786" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23788" href="../Connectives/#plfa_plfa-part1-Connectives-23772" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-23790" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23792" href="../Connectives/#plfa_plfa-part1-Connectives-23774" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-23793" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23795" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23797" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Connectives-23800" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-23801" href="../Connectives/#plfa_plfa-part1-Connectives-23801" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-23803" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-23805" href="../Connectives/#plfa_plfa-part1-Connectives-23772" class="Bound">A</a><a id="plfa_plfa-part1-Connectives-23806" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23808" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-23810" href="../Connectives/#plfa_plfa-part1-Connectives-23784" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23812" href="../Connectives/#plfa_plfa-part1-Connectives-23801" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-23813" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-23815" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Connectives-23817" href="../Connectives/#plfa_plfa-part1-Connectives-23784" class="Bound">f</a>
<a id="plfa_plfa-part1-Connectives-23819" href="../Connectives/#plfa_plfa-part1-Connectives-23763" class="Function">η-→</a> <a id="plfa_plfa-part1-Connectives-23823" href="../Connectives/#plfa_plfa-part1-Connectives-23823" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-23825" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-23827" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>蕴涵比其他的运算符结合得都不紧密。因此 <code>A ⊎ B → B ⊎ A</code> 被解析为 <code>(A ⊎ B) → (B ⊎ A)</code>。</p><p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A → B</code> 称为从 <code>A</code> 到 <code>B</code> 的<strong>函数</strong>空间。 它有时也被称作以 <code>B</code> 为底，<code>A</code> 为次数的<strong>幂</strong>。如果类型 <code>A</code> 有 <code>m</code> 个不同的成员， 类型 <code>B</code> 有 <code>n</code> 个不同的成员，那么类型 <code>A → B</code> 有 <code>nᵐ</code> 个不同的成员。 这也是它被称为幂的原因之一。例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型， 如之前的定义。那么，<code>Bool → Tri</code> 类型有如下的九个成员（三的平方）：</p><pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre><p>下面的函数枚举了所有类型为 <code>Bool → Tri</code> 的参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-count"></a><a id="plfa_plfa-part1-Connectives-25214" href="../Connectives/#plfa_plfa-part1-Connectives-25214" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25222" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-25224" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-25225" href="../Connectives/#plfa_plfa-part1-Connectives-6552" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Connectives-25230" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25232" href="../Connectives/#plfa_plfa-part1-Connectives-6605" class="Datatype">Tri</a><a id="plfa_plfa-part1-Connectives-25235" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-25237" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-25239" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Connectives-25241" href="../Connectives/#plfa_plfa-part1-Connectives-25214" class="Function">→-count</a> <a id="plfa_plfa-part1-Connectives-25249" href="../Connectives/#plfa_plfa-part1-Connectives-25249" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25251" class="Keyword">with</a> <a id="plfa_plfa-part1-Connectives-25256" href="../Connectives/#plfa_plfa-part1-Connectives-25249" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25258" href="../Connectives/#plfa_plfa-part1-Connectives-6571" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Connectives-25263" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25265" href="../Connectives/#plfa_plfa-part1-Connectives-25249" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-25267" href="../Connectives/#plfa_plfa-part1-Connectives-6586" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Connectives-25273" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25286" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25288" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25295" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25297" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25305" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25309" class="Number">1</a>
<a id="plfa_plfa-part1-Connectives-25311" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25324" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25326" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25333" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25335" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25343" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25347" class="Number">2</a>
<a id="plfa_plfa-part1-Connectives-25349" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25362" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25364" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>     <a id="plfa_plfa-part1-Connectives-25371" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25373" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25381" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25385" class="Number">3</a>
<a id="plfa_plfa-part1-Connectives-25387" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25400" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25402" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25409" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25411" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25419" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25423" class="Number">4</a>
<a id="plfa_plfa-part1-Connectives-25425" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25438" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25440" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25447" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25449" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25457" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25461" class="Number">5</a>
<a id="plfa_plfa-part1-Connectives-25463" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25476" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25478" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>     <a id="plfa_plfa-part1-Connectives-25485" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25487" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25495" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25499" class="Number">6</a>
<a id="plfa_plfa-part1-Connectives-25501" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25514" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25516" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25523" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25525" href="../Connectives/#plfa_plfa-part1-Connectives-6623" class="InductiveConstructor">aa</a>      <a id="plfa_plfa-part1-Connectives-25533" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25537" class="Number">7</a>
<a id="plfa_plfa-part1-Connectives-25539" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25552" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25554" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25561" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25563" href="../Connectives/#plfa_plfa-part1-Connectives-6634" class="InductiveConstructor">bb</a>      <a id="plfa_plfa-part1-Connectives-25571" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25575" class="Number">8</a>
<a id="plfa_plfa-part1-Connectives-25577" class="Symbol">...</a>          <a id="plfa_plfa-part1-Connectives-25590" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25592" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>     <a id="plfa_plfa-part1-Connectives-25599" class="Symbol">|</a> <a id="plfa_plfa-part1-Connectives-25601" href="../Connectives/#plfa_plfa-part1-Connectives-6645" class="InductiveConstructor">cc</a>      <a id="plfa_plfa-part1-Connectives-25609" class="Symbol">=</a>   <a id="plfa_plfa-part1-Connectives-25613" class="Number">9</a>
</pre><p>类型上的幂与数的幂有相似的性质，很多数上成立的关系式也可以在类型上成立。</p><p>对应如下的定律：</p><pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre><p>我们有如下的同构：</p><pre><code>A → (B → C)  ≃  (A × B) → C</code></pre><p>两个类型可以被看作给定 <code>A</code> 成立的证据和 <code>B</code> 成立的证据，返回 <code>C</code> 成立的证据。 这个同构有时也被称作<strong>柯里化（Currying）</strong>。右逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-currying"></a><a id="plfa_plfa-part1-Connectives-26327" href="../Connectives/#plfa_plfa-part1-Connectives-26327" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26336" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26338" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-26340" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-26341" href="../Connectives/#plfa_plfa-part1-Connectives-26341" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26343" href="../Connectives/#plfa_plfa-part1-Connectives-26343" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26345" href="../Connectives/#plfa_plfa-part1-Connectives-26345" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-26347" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-26349" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-26352" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-26354" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26356" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26357" href="../Connectives/#plfa_plfa-part1-Connectives-26341" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26359" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26361" href="../Connectives/#plfa_plfa-part1-Connectives-26343" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26363" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26365" href="../Connectives/#plfa_plfa-part1-Connectives-26345" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26366" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-26368" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-26370" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-26371" href="../Connectives/#plfa_plfa-part1-Connectives-26341" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-26373" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-26375" href="../Connectives/#plfa_plfa-part1-Connectives-26343" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-26377" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26379" href="../Connectives/#plfa_plfa-part1-Connectives-26345" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-26380" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-26382" href="../Connectives/#plfa_plfa-part1-Connectives-26327" class="Function">currying</a> <a id="plfa_plfa-part1-Connectives-26391" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-26395" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-26406" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-26408" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-26416" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26419" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26422" href="../Connectives/#plfa_plfa-part1-Connectives-26422" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26424" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26426" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26429" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26431" href="../Connectives/#plfa_plfa-part1-Connectives-26431" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26433" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26435" href="../Connectives/#plfa_plfa-part1-Connectives-26435" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26437" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26439" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26441" href="../Connectives/#plfa_plfa-part1-Connectives-26422" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26443" href="../Connectives/#plfa_plfa-part1-Connectives-26431" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26445" href="../Connectives/#plfa_plfa-part1-Connectives-26435" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26447" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26454" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26456" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-26464" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26467" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26470" href="../Connectives/#plfa_plfa-part1-Connectives-26470" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26472" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26474" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26477" href="../Connectives/#plfa_plfa-part1-Connectives-26477" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26479" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26481" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26484" href="../Connectives/#plfa_plfa-part1-Connectives-26484" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26486" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26488" href="../Connectives/#plfa_plfa-part1-Connectives-26470" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26490" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26492" href="../Connectives/#plfa_plfa-part1-Connectives-26477" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26494" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26496" href="../Connectives/#plfa_plfa-part1-Connectives-26484" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26498" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26500" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Connectives-26508" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26510" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-26518" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26521" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26524" href="../Connectives/#plfa_plfa-part1-Connectives-26524" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-26526" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26528" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26533" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-26539" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-26541" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-26549" class="Symbol">=</a>  <a id="plfa_plfa-part1-Connectives-26552" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26555" href="../Connectives/#plfa_plfa-part1-Connectives-26555" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-26557" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26559" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-26574" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-26577" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-26579" href="../Connectives/#plfa_plfa-part1-Connectives-26579" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-26581" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-26583" href="../Connectives/#plfa_plfa-part1-Connectives-26583" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-26585" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-26587" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-26589" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-26594" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Connectives-26601" class="Symbol">}</a>
</pre><p>柯里化告诉我们，如果一个函数有取一个数据对作为参数， 那么我们可以构造一个函数，取第一个参数，返回一个取第二个参数，返回最终结果的函数。 因此，举例来说，下面表示加法的形式：</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>和下面的一个带有一个数据对作为参数的函数是同构的：</p><pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre><p>Agda 对柯里化进行了优化，因此 <code>2 + 3</code> 是 <code>_+_ 2 3</code> 的简写。在一个对有序对进行优化的语言里， <code>2 +′ 3</code> 可能是 <code>_+′_ ⟨ 2 , 3 ⟩</code> 的简写。</p><p>对应如下的定律：</p><pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre><p>命题如果 <code>A</code> 成立或者 <code>B</code> 成立，那么 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>C</code> 成立以及 如果 <code>B</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-27873" href="../Connectives/#plfa_plfa-part1-Connectives-27873" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27885" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27887" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-27889" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-27890" href="../Connectives/#plfa_plfa-part1-Connectives-27890" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27892" href="../Connectives/#plfa_plfa-part1-Connectives-27892" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27894" href="../Connectives/#plfa_plfa-part1-Connectives-27894" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-27896" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-27898" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-27901" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-27903" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27905" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27906" href="../Connectives/#plfa_plfa-part1-Connectives-27890" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27908" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-27910" href="../Connectives/#plfa_plfa-part1-Connectives-27892" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27912" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27914" href="../Connectives/#plfa_plfa-part1-Connectives-27894" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27915" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27917" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-27919" class="Symbol">((</a><a id="plfa_plfa-part1-Connectives-27921" href="../Connectives/#plfa_plfa-part1-Connectives-27890" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-27923" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27925" href="../Connectives/#plfa_plfa-part1-Connectives-27894" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27926" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-27928" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-27930" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-27931" href="../Connectives/#plfa_plfa-part1-Connectives-27892" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-27933" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27935" href="../Connectives/#plfa_plfa-part1-Connectives-27894" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-27936" class="Symbol">))</a>
<a id="plfa_plfa-part1-Connectives-27939" href="../Connectives/#plfa_plfa-part1-Connectives-27873" class="Function">→-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-27951" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-27955" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-27966" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-27968" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-27976" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-27978" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-27981" href="../Connectives/#plfa_plfa-part1-Connectives-27981" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27983" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-27985" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-27987" href="../Connectives/#plfa_plfa-part1-Connectives-27981" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-27989" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-27991" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-27996" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-27998" href="../Connectives/#plfa_plfa-part1-Connectives-27981" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28000" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28002" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28007" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28009" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28015" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28017" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28025" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28027" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28030" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28032" href="../Connectives/#plfa_plfa-part1-Connectives-28032" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28034" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28036" href="../Connectives/#plfa_plfa-part1-Connectives-28036" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28038" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28040" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28042" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28045" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28046" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28051" href="../Connectives/#plfa_plfa-part1-Connectives-28051" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28052" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28054" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28056" href="../Connectives/#plfa_plfa-part1-Connectives-28032" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28058" href="../Connectives/#plfa_plfa-part1-Connectives-28051" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28060" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28062" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28063" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28068" href="../Connectives/#plfa_plfa-part1-Connectives-28068" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28069" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28071" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28073" href="../Connectives/#plfa_plfa-part1-Connectives-28036" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28075" href="../Connectives/#plfa_plfa-part1-Connectives-28068" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-28077" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28079" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28085" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28087" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28095" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28097" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28100" href="../Connectives/#plfa_plfa-part1-Connectives-28100" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28102" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28104" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28119" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28122" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28123" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-28128" href="../Connectives/#plfa_plfa-part1-Connectives-28128" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28129" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28131" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28133" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28138" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28140" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28141" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-28146" href="../Connectives/#plfa_plfa-part1-Connectives-28146" class="Bound">y</a><a id="plfa_plfa-part1-Connectives-28147" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28149" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28151" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28156" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28158" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28164" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28166" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-28174" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28176" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28179" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28181" href="../Connectives/#plfa_plfa-part1-Connectives-28181" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28183" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28185" href="../Connectives/#plfa_plfa-part1-Connectives-28185" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28187" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28189" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28191" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-28196" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28202" class="Symbol">}</a>
</pre><p>对应如下的定律：</p><pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre><p>我们有如下的同构：</p><pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre><p>命题如果 <code>A</code> 成立，那么 <code>B</code> 成立和 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>B</code> 成立以及 如果 <code>A</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性和积的 <code>η-×</code> 规则：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-→-distrib-×"></a><a id="plfa_plfa-part1-Connectives-28751" href="../Connectives/#plfa_plfa-part1-Connectives-28751" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28763" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28765" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-28767" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-28768" href="../Connectives/#plfa_plfa-part1-Connectives-28768" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28770" href="../Connectives/#plfa_plfa-part1-Connectives-28770" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28772" href="../Connectives/#plfa_plfa-part1-Connectives-28772" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-28774" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-28776" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-28779" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28781" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28783" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28784" href="../Connectives/#plfa_plfa-part1-Connectives-28768" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28786" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28788" href="../Connectives/#plfa_plfa-part1-Connectives-28770" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-28790" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28792" href="../Connectives/#plfa_plfa-part1-Connectives-28772" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28793" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28795" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-28797" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28798" href="../Connectives/#plfa_plfa-part1-Connectives-28768" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28800" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28802" href="../Connectives/#plfa_plfa-part1-Connectives-28770" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-28803" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28805" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-28807" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28808" href="../Connectives/#plfa_plfa-part1-Connectives-28768" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-28810" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28812" href="../Connectives/#plfa_plfa-part1-Connectives-28772" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-28813" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-28815" href="../Connectives/#plfa_plfa-part1-Connectives-28751" class="Function">→-distrib-×</a> <a id="plfa_plfa-part1-Connectives-28827" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-28831" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-28842" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-28844" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-28852" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28854" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28857" href="../Connectives/#plfa_plfa-part1-Connectives-28857" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28859" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28861" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28863" href="../Connectives/#plfa_plfa-part1-Connectives-2115" class="Function">proj₁</a> <a id="plfa_plfa-part1-Connectives-28869" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28871" href="../Connectives/#plfa_plfa-part1-Connectives-28857" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28873" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28875" href="../Connectives/#plfa_plfa-part1-Connectives-2184" class="Function">proj₂</a> <a id="plfa_plfa-part1-Connectives-28881" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Connectives-28883" href="../Connectives/#plfa_plfa-part1-Connectives-28857" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28885" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28887" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28893" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28895" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-28903" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28905" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28908" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28910" href="../Connectives/#plfa_plfa-part1-Connectives-28910" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28912" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28914" href="../Connectives/#plfa_plfa-part1-Connectives-28914" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28916" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28918" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28920" class="Symbol">λ</a> <a id="plfa_plfa-part1-Connectives-28922" href="../Connectives/#plfa_plfa-part1-Connectives-28922" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28924" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28926" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-28928" href="../Connectives/#plfa_plfa-part1-Connectives-28910" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-28930" href="../Connectives/#plfa_plfa-part1-Connectives-28922" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28932" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-28934" href="../Connectives/#plfa_plfa-part1-Connectives-28914" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-28936" href="../Connectives/#plfa_plfa-part1-Connectives-28922" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28938" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-28940" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-28946" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-28948" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-28956" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-28958" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28961" href="../Connectives/#plfa_plfa-part1-Connectives-28961" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28963" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28965" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Connectives-28980" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-28983" href="../Connectives/#plfa_plfa-part1-Connectives-28983" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-28985" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-28987" href="../Connectives/#plfa_plfa-part1-Connectives-4217" class="Function">η-×</a> <a id="plfa_plfa-part1-Connectives-28991" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-28992" href="../Connectives/#plfa_plfa-part1-Connectives-28961" class="Bound">f</a> <a id="plfa_plfa-part1-Connectives-28994" href="../Connectives/#plfa_plfa-part1-Connectives-28983" class="Bound">x</a><a id="plfa_plfa-part1-Connectives-28995" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-28997" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-28999" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29005" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29007" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-29015" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29017" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29020" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29022" href="../Connectives/#plfa_plfa-part1-Connectives-29022" class="Bound">g</a> <a id="plfa_plfa-part1-Connectives-29024" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29026" href="../Connectives/#plfa_plfa-part1-Connectives-29026" class="Bound">h</a> <a id="plfa_plfa-part1-Connectives-29028" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29030" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29032" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Connectives-29037" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29043" class="Symbol">}</a>
</pre><h2 id="分配律">分配律</h2><p>在同构意义下，积对于和满足分配律。验证这条形式的代码和之前的证明相似：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-×-distrib-⊎"></a><a id="plfa_plfa-part1-Connectives-29270" href="../Connectives/#plfa_plfa-part1-Connectives-29270" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29282" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29284" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29286" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29287" href="../Connectives/#plfa_plfa-part1-Connectives-29287" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29289" href="../Connectives/#plfa_plfa-part1-Connectives-29289" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29291" href="../Connectives/#plfa_plfa-part1-Connectives-29291" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29293" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29295" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29298" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29300" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29302" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29303" href="../Connectives/#plfa_plfa-part1-Connectives-29287" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29305" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29307" href="../Connectives/#plfa_plfa-part1-Connectives-29289" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29308" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29310" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29312" href="../Connectives/#plfa_plfa-part1-Connectives-29291" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29314" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Connectives-29316" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29317" href="../Connectives/#plfa_plfa-part1-Connectives-29287" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29319" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29321" href="../Connectives/#plfa_plfa-part1-Connectives-29291" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29322" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29324" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29326" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29327" href="../Connectives/#plfa_plfa-part1-Connectives-29289" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29329" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29331" href="../Connectives/#plfa_plfa-part1-Connectives-29291" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29332" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-29334" href="../Connectives/#plfa_plfa-part1-Connectives-29270" class="Function">×-distrib-⊎</a> <a id="plfa_plfa-part1-Connectives-29346" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-29350" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-29361" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-29363" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5615" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-29371" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29373" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29376" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29378" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29383" href="../Connectives/#plfa_plfa-part1-Connectives-29383" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29385" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29387" href="../Connectives/#plfa_plfa-part1-Connectives-29387" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29389" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29391" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29393" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29394" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29399" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29401" href="../Connectives/#plfa_plfa-part1-Connectives-29383" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29403" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29405" href="../Connectives/#plfa_plfa-part1-Connectives-29387" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29407" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29408" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29427" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29429" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29431" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29436" href="../Connectives/#plfa_plfa-part1-Connectives-29436" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29438" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29440" href="../Connectives/#plfa_plfa-part1-Connectives-29440" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29442" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29444" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29446" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29447" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29452" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29454" href="../Connectives/#plfa_plfa-part1-Connectives-29436" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29456" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29458" href="../Connectives/#plfa_plfa-part1-Connectives-29440" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29460" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29461" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-29480" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29486" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29488" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5632" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-29496" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29498" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29501" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29502" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29507" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29509" href="../Connectives/#plfa_plfa-part1-Connectives-29509" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29511" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29513" href="../Connectives/#plfa_plfa-part1-Connectives-29513" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29515" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29516" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29518" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29520" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29522" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29527" href="../Connectives/#plfa_plfa-part1-Connectives-29509" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29529" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29531" href="../Connectives/#plfa_plfa-part1-Connectives-29513" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29533" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29552" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29554" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29555" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29560" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29562" href="../Connectives/#plfa_plfa-part1-Connectives-29562" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29564" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29566" href="../Connectives/#plfa_plfa-part1-Connectives-29566" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29568" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29569" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29571" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29573" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29575" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29580" href="../Connectives/#plfa_plfa-part1-Connectives-29562" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29582" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29584" href="../Connectives/#plfa_plfa-part1-Connectives-29566" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29586" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-29605" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29611" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29613" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5649" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-29621" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29623" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29626" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29628" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29633" href="../Connectives/#plfa_plfa-part1-Connectives-29633" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29635" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29637" href="../Connectives/#plfa_plfa-part1-Connectives-29637" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29639" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29641" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29643" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29665" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29667" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29669" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29674" href="../Connectives/#plfa_plfa-part1-Connectives-29674" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29676" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29678" href="../Connectives/#plfa_plfa-part1-Connectives-29678" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29680" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-29682" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29706" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29712" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29714" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5691" class="Field">to∘from</a> <a id="plfa_plfa-part1-Connectives-29722" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-29724" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-29727" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29728" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-29733" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29735" href="../Connectives/#plfa_plfa-part1-Connectives-29735" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-29737" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29739" href="../Connectives/#plfa_plfa-part1-Connectives-29739" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29741" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29742" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29744" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29746" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29768" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-29770" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29771" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-29776" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-29778" href="../Connectives/#plfa_plfa-part1-Connectives-29778" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-29780" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-29782" href="../Connectives/#plfa_plfa-part1-Connectives-29782" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-29784" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-29785" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29787" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29789" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-29811" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-29817" class="Symbol">}</a>
</pre><p>和对于积不满足分配律，但满足嵌入：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-⊎-distrib-×"></a><a id="plfa_plfa-part1-Connectives-29941" href="../Connectives/#plfa_plfa-part1-Connectives-29941" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-29953" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29955" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-29957" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-29958" href="../Connectives/#plfa_plfa-part1-Connectives-29958" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29960" href="../Connectives/#plfa_plfa-part1-Connectives-29960" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-29962" href="../Connectives/#plfa_plfa-part1-Connectives-29962" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29964" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-29966" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-29969" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-29971" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-29973" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29974" href="../Connectives/#plfa_plfa-part1-Connectives-29958" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29976" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29978" href="../Connectives/#plfa_plfa-part1-Connectives-29960" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-29979" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29981" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29983" href="../Connectives/#plfa_plfa-part1-Connectives-29962" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-29985" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11714" class="Record Operator">≲</a> <a id="plfa_plfa-part1-Connectives-29987" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29988" href="../Connectives/#plfa_plfa-part1-Connectives-29958" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-29990" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-29992" href="../Connectives/#plfa_plfa-part1-Connectives-29962" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-29993" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-29995" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-29997" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-29998" href="../Connectives/#plfa_plfa-part1-Connectives-29960" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-30000" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-30002" href="../Connectives/#plfa_plfa-part1-Connectives-29962" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-30003" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-30005" href="../Connectives/#plfa_plfa-part1-Connectives-29941" class="Function">⊎-distrib-×</a> <a id="plfa_plfa-part1-Connectives-30017" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Connectives-30021" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Connectives-30032" class="Symbol">{</a> <a id="plfa_plfa-part1-Connectives-30034" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11754" class="Field">to</a>      <a id="plfa_plfa-part1-Connectives-30042" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30044" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30047" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30048" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30053" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30055" href="../Connectives/#plfa_plfa-part1-Connectives-30055" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30057" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30059" href="../Connectives/#plfa_plfa-part1-Connectives-30059" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30061" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30062" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30064" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30066" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30068" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30073" href="../Connectives/#plfa_plfa-part1-Connectives-30055" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30075" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30077" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30082" href="../Connectives/#plfa_plfa-part1-Connectives-30059" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30084" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30103" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30105" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30106" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30111" href="../Connectives/#plfa_plfa-part1-Connectives-30111" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30112" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30122" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30124" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30126" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30131" href="../Connectives/#plfa_plfa-part1-Connectives-30111" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30133" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30135" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30140" href="../Connectives/#plfa_plfa-part1-Connectives-30111" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30142" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a>
                 <a id="plfa_plfa-part1-Connectives-30161" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30167" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30169" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11774" class="Field">from</a>    <a id="plfa_plfa-part1-Connectives-30177" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30179" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30182" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30184" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30189" href="../Connectives/#plfa_plfa-part1-Connectives-30189" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30191" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30193" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30198" href="../Connectives/#plfa_plfa-part1-Connectives-30198" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30200" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30202" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30204" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30205" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30210" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30212" href="../Connectives/#plfa_plfa-part1-Connectives-30189" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30214" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30216" href="../Connectives/#plfa_plfa-part1-Connectives-30198" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30218" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30219" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30238" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30240" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30242" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30247" href="../Connectives/#plfa_plfa-part1-Connectives-30247" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30249" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30251" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30256" href="../Connectives/#plfa_plfa-part1-Connectives-30256" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30258" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30260" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30262" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30263" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30268" href="../Connectives/#plfa_plfa-part1-Connectives-30256" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30269" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30288" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30290" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30292" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30297" href="../Connectives/#plfa_plfa-part1-Connectives-30297" class="Bound">z</a> <a id="plfa_plfa-part1-Connectives-30299" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30301" class="Symbol">_</a>      <a id="plfa_plfa-part1-Connectives-30308" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Connectives-30310" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30312" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30313" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30318" href="../Connectives/#plfa_plfa-part1-Connectives-30297" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30319" class="Symbol">)</a>
                 <a id="plfa_plfa-part1-Connectives-30338" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30344" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30346" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-11794" class="Field">from∘to</a> <a id="plfa_plfa-part1-Connectives-30354" class="Symbol">=</a> <a id="plfa_plfa-part1-Connectives-30356" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Connectives-30359" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30360" href="../Connectives/#plfa_plfa-part1-Connectives-14758" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Connectives-30365" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Connectives-30367" href="../Connectives/#plfa_plfa-part1-Connectives-30367" class="Bound">x</a> <a id="plfa_plfa-part1-Connectives-30369" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Connectives-30371" href="../Connectives/#plfa_plfa-part1-Connectives-30371" class="Bound">y</a> <a id="plfa_plfa-part1-Connectives-30373" href="../Connectives/#plfa_plfa-part1-Connectives-1695" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Connectives-30374" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-30376" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30378" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30400" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-30402" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-30403" href="../Connectives/#plfa_plfa-part1-Connectives-14800" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Connectives-30408" href="../Connectives/#plfa_plfa-part1-Connectives-30408" class="Bound">z</a><a id="plfa_plfa-part1-Connectives-30409" class="Symbol">)</a>         <a id="plfa_plfa-part1-Connectives-30419" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-30421" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
                 <a id="plfa_plfa-part1-Connectives-30443" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Connectives-30449" class="Symbol">}</a>
</pre><p>我们在定义 <code>from</code> 函数的时候可以有选择。给定的定义中，它将 <code>⟨ inj₂ z , inj₂ z′ ⟩</code> 转换为 <code>inj₂ z</code>，但我们也可以返回 <code>inj₂ z′</code> 作为嵌入证明的变种。我们在这里只能证明嵌入， 而不能证明同构，因为 <code>from</code> 函数必须丢弃 <code>z</code> 或者 <code>z′</code> 其中的一个。</p><p>在一般的逻辑学方法中，两条分配律都以等价的形式给出，每一边都蕴涵了另一边：</p><pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre><p>但当我们考虑提供上述蕴涵证明的函数时，第一条对应同构而第二条只能对应嵌入， 揭示了有些定理比另一个更加的「正确」。</p><h4 id="练习--weak--推荐">练习 <code>⊎-weak-×</code> （推荐）</h4><p>证明如下性质成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31644" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎-weak-×"></a><a id="plfa_plfa-part1-Connectives-31656" href="../Connectives/#plfa_plfa-part1-Connectives-31656" class="Postulate">⊎-weak-×</a> <a id="plfa_plfa-part1-Connectives-31665" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31667" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-31669" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-31670" href="../Connectives/#plfa_plfa-part1-Connectives-31670" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31672" href="../Connectives/#plfa_plfa-part1-Connectives-31672" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31674" href="../Connectives/#plfa_plfa-part1-Connectives-31674" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31676" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-31678" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-31681" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-31683" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31685" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31686" href="../Connectives/#plfa_plfa-part1-Connectives-31670" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31688" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31690" href="../Connectives/#plfa_plfa-part1-Connectives-31672" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-31691" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-31693" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31695" href="../Connectives/#plfa_plfa-part1-Connectives-31674" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-31697" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-31699" href="../Connectives/#plfa_plfa-part1-Connectives-31670" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-31701" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-31703" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-31704" href="../Connectives/#plfa_plfa-part1-Connectives-31672" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-31706" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-31708" href="../Connectives/#plfa_plfa-part1-Connectives-31674" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-31709" class="Symbol">)</a>
</pre><p>这被称为<strong>弱分配律（Weak Distributive Law）</strong>。给出相对应的分配律，并解释分配律与弱分配律的关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-31930" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习--implies-实践">练习 <code>⊎×-implies-×⊎</code>（实践）</h4><p>证明合取的析取蕴涵了析取的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32132" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Connectives-⊎×-implies-×⊎"></a><a id="plfa_plfa-part1-Connectives-32144" href="../Connectives/#plfa_plfa-part1-Connectives-32144" class="Postulate">⊎×-implies-×⊎</a> <a id="plfa_plfa-part1-Connectives-32158" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32160" class="Symbol">∀</a> <a id="plfa_plfa-part1-Connectives-32162" class="Symbol">{</a><a id="plfa_plfa-part1-Connectives-32163" href="../Connectives/#plfa_plfa-part1-Connectives-32163" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32165" href="../Connectives/#plfa_plfa-part1-Connectives-32165" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32167" href="../Connectives/#plfa_plfa-part1-Connectives-32167" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32169" href="../Connectives/#plfa_plfa-part1-Connectives-32169" class="Bound">D</a> <a id="plfa_plfa-part1-Connectives-32171" class="Symbol">:</a> <a id="plfa_plfa-part1-Connectives-32173" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Connectives-32176" class="Symbol">}</a> <a id="plfa_plfa-part1-Connectives-32178" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32180" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32181" href="../Connectives/#plfa_plfa-part1-Connectives-32163" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32183" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32185" href="../Connectives/#plfa_plfa-part1-Connectives-32165" class="Bound">B</a><a id="plfa_plfa-part1-Connectives-32186" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32188" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32190" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32191" href="../Connectives/#plfa_plfa-part1-Connectives-32167" class="Bound">C</a> <a id="plfa_plfa-part1-Connectives-32193" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32195" href="../Connectives/#plfa_plfa-part1-Connectives-32169" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32196" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32198" class="Symbol">→</a> <a id="plfa_plfa-part1-Connectives-32200" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32201" href="../Connectives/#plfa_plfa-part1-Connectives-32163" class="Bound">A</a> <a id="plfa_plfa-part1-Connectives-32203" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32205" href="../Connectives/#plfa_plfa-part1-Connectives-32167" class="Bound">C</a><a id="plfa_plfa-part1-Connectives-32206" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32208" href="../Connectives/#plfa_plfa-part1-Connectives-1664" class="Datatype Operator">×</a> <a id="plfa_plfa-part1-Connectives-32210" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32211" href="../Connectives/#plfa_plfa-part1-Connectives-32165" class="Bound">B</a> <a id="plfa_plfa-part1-Connectives-32213" href="../Connectives/#plfa_plfa-part1-Connectives-14727" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Connectives-32215" href="../Connectives/#plfa_plfa-part1-Connectives-32169" class="Bound">D</a><a id="plfa_plfa-part1-Connectives-32216" class="Symbol">)</a>
</pre><p>反命题成立吗？如果成立，给出证明；如果不成立，给出反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32342" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中可以找到与本章节中相似的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Connectives-32520" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32527" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Connectives-32540" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32546" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32547" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Connectives-32550" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32552" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#234" class="Field">proj₁</a><a id="plfa_plfa-part1-Connectives-32557" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#246" class="Field">proj₂</a><a id="plfa_plfa-part1-Connectives-32564" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32566" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32575" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32576" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Connectives-32580" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32583" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Connectives-32588" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32590" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32597" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Connectives-32607" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32613" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32614" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="plfa_plfa-part1-Connectives-32615" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32617" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Connectives-32619" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32621" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32628" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Connectives-32637" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32643" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32644" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Connectives-32647" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32649" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Connectives-32653" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32655" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Connectives-32659" class="Symbol">)</a> <a id="plfa_plfa-part1-Connectives-32661" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Connectives-32670" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32671" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#920" class="Function Operator">[_,_]</a> <a id="plfa_plfa-part1-Connectives-32677" class="Symbol">to</a> <a id="plfa_plfa-part1-Connectives-32680" class="Function Operator">case-⊎</a><a id="plfa_plfa-part1-Connectives-32686" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32688" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32695" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Connectives-32706" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32712" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32713" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Connectives-32714" class="Symbol">;</a> <a id="plfa_plfa-part1-Connectives-32716" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Connectives-32722" class="Symbol">)</a>
<a id="plfa_plfa-part1-Connectives-32724" class="Keyword">import</a> <a id="plfa_plfa-part1-Connectives-32731" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="plfa_plfa-part1-Connectives-32752" class="Keyword">using</a> <a id="plfa_plfa-part1-Connectives-32758" class="Symbol">(</a><a id="plfa_plfa-part1-Connectives-32759" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Equivalence.html#1204" class="Function Operator">_⇔_</a><a id="plfa_plfa-part1-Connectives-32762" class="Symbol">)</a>
</pre><p>标准库中使用 <code>_,_</code> 构造数据对，而我们使用 <code>⟨_,_⟩</code>。前者在从数据对构造三元对或者更大的 元组时更加的方便，允许 <code>a , b , c</code> 作为 <code>(a, (b , c))</code> 的记法。但它与其他有用的记法相冲突， 比如说 <a href="../Lists/">Lists</a> 中的 <code>[_,_]</code> 记法表示两个元素的列表， 或者 <a href="../DeBruijn/">DeBruijn</a> 章节中的 <code>Γ , A</code> 来表示环境的扩展。 标准库中的 <code>_⇔_</code> 和我们的相似，但使用起来比较不便， 因为它可以根据任意的相等性定义进行参数化。</p><h2 id="unicode">Unicode</h2><p>本章节使用下列 Unicode：</p><pre><code>×  U+00D7  乘法符号 (\x)
⊎  U+228E  多重集并集 (\u+)
⊤  U+22A4  向下图钉 (\top)
⊥  U+22A5  向上图钉 (\bot)
η  U+03B7  希腊小写字母 ETA (\eta)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)</code></pre><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>此段内容由 Propositions as Types（命题即类型）改编而来， 作者：Philip Wadler，发表于 《ACM 通讯》，2015 年 9 月<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Isomorphism/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Negation/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：95% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>