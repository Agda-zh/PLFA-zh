<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Induction: 归纳证明</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-116" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-123" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-144" class="Keyword">where</a>
</pre><blockquote><p>归纳会让你对无中生有感到内疚 ……但它却是文明中最伟大的思想之一。 —— Herbert Wilf</p></blockquote><p>现在我们定义了自然数及其运算，下一步是学习如何证明它们满足的性质。 顾名思义，<strong>归纳数据类型（Inductive Datatype）</strong>是通过<strong>归纳（Induction）</strong> 来证明的。</p><h2 id="导入">导入</h2><p>我们需要上一章中的相等性，加上自然数及其运算。我们还导入了一些新的运算： <code>cong</code>、<code>sym</code> 和 <code>_≡⟨_⟩_</code>，之后会解释它们：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-1009" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1016" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-1054" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-1057" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-1060" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1065" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-1068" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1075" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-1078" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1080" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-1084" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1086" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Induction-1090" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1092" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Induction-1095" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1097" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1102" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-1117" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1123" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1124" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-1130" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1132" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">_≡⟨⟩_</a><a id="plfa_plfa-part1-Induction-1137" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1139" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">step-≡</a><a id="plfa_plfa-part1-Induction-1145" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1147" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-1149" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1151" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1156" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1163" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-1172" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1178" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-1180" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-1186" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-1191" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-1196" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-1201" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1203" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-1206" class="Symbol">)</a>
</pre><p>(Importing <code>step-≡</code> defines <code>_≡⟨_⟩_</code>.)</p><h2 id="运算符的性质">运算符的性质</h2><p>运算符随处可见，而数学家们统一了一些最常见的性质的名称。</p><ul><li><p><strong>幺元（Identity）</strong>：对于所有的 <code>n</code>，若 <code>0 + n ≡ n</code>，则 <code>+</code> 有左幺元 <code>0</code>； 若 <code>n + 0 ≡ n</code>，则 <code>+</code> 有右幺元 <code>0</code>。同时为左幺元和右幺元的值称简称幺元。 幺元有时也称作<strong>单位元（Unit）</strong>。</p></li><li><p><strong>结合律（Associativity）</strong>：若括号的位置无关紧要，则称运算符 <code>+</code> 满足结合律， 即对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，有 <code>(m + n) + p ≡ m + (n + p)</code>。</p></li><li><p><strong>交换律（Commutativity）</strong>：若参数的顺序无关紧要，则称运算符 <code>+</code> 满足交换律， 即对于所有的 <code>m</code> 和 <code>n</code>，有 <code>m + n ≡ n + m</code>。</p></li><li><p><strong>分配律（Distributivity）</strong>：对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>m * (p + q) ≡ (m * p) + (m * q)</code>，则运算符 <code>*</code> 对运算符 <code>+</code> 满足左分配律； 对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>(m + n) * p ≡ (m * p) + (n * p)</code>，则满足右分配律。</p></li></ul><p>加法的幺元为 <code>0</code>，乘法的幺元为 <code>1</code>。加法和乘法都满足结合律和交换律， 乘法对加法满足分配律。</p><p>如果你在一个舞会上碰见了一位操作员，那么你可以跟他闲聊，问问他是否有单位元， 能不能结合或者交换。如果你碰见了两位操作员，那么可以问他们某一位是否在另一位上面分布。</p><p>【译注：作者的双关冷笑话，运算符（Operator）也有操作员的意思。】</p><p>正经来说，如果你在阅读技术论文时遇到了一个运算符，那么你可以考察它是否拥有幺元， 是否满足结合律或分配律，或者是否对另一个运算符满足分配律，这能为你提供一种视角。 细心的作者通常会指出它们是否满足这些性质，比如说指明一个新引入的运算符满足结合律 但不满足交换律。</p><h4 id="operators">练习 <code>operators</code>（实践）</h4><p>请给出另一对运算符，它们拥有一个幺元，满足结合律、交换律，且其中一个对另一个满足分配律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4202" class="Comment">-- 请将代码写在此处。</a>
</pre><p>请给出一个运算符的例子，它拥有幺元、满足结合律但不满足交换律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4378" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="结合律">结合律</h2><p>加法的一个性质是满足<strong>结合律</strong>，即括号的位置无关紧要：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的变量 <code>m</code>、<code>n</code> 和 <code>p</code> 的取值范围都是全体自然数。</p><p>我们可以为这三个变量选取特定的数值来验证此命题：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4866" href="../Induction/#plfa_plfa-part1-Induction-4866" class="Function">_</a> <a id="plfa_plfa-part1-Induction-4868" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-4870" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4871" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4873" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4875" class="Number">4</a><a id="plfa_plfa-part1-Induction-4876" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4878" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4880" class="Number">5</a> <a id="plfa_plfa-part1-Induction-4882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-4884" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4886" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4888" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4889" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4891" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4893" class="Number">5</a><a id="plfa_plfa-part1-Induction-4894" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-4896" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-4898" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-4902" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-4912" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4913" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4915" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4917" class="Number">4</a><a id="plfa_plfa-part1-Induction-4918" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4920" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4922" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4926" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4934" class="Number">7</a> <a id="plfa_plfa-part1-Induction-4936" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4938" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4942" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4950" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-4955" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4963" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4965" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4967" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-4971" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4979" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4981" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4983" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4984" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4986" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4988" class="Number">5</a><a id="plfa_plfa-part1-Induction-4989" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-4993" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在这里，我们将计算过程写成了等式链，每行一个式子。这样的等式链通常非常易读， 你可以从上到下，直到遇到最简形式（本例中为 <code>12</code>），也可以从下到上，直到回到同样的式子。</p><p>该测试揭示了结合律可能没有它初看起来那么显然。为什么 <code>7 + 5</code> 与 <code>3 + 9</code> 相同？ 我们可能需要收集更多证据，选择其它的数值来验证此命题。但由于自然数是无限的， 因此测试永远无法完成。那么我们还有其它可以确保结合律对于<strong>所有</strong>自然数都成立的方法吗？</p><p>当然有！我们可以用<strong>归纳证明（Proof by Induction）</strong> 来确保某个性质对于所有的自然数都成立。</p><h2 id="归纳证明">归纳证明</h2><p>回想自然数的定义，它由一个<strong>起始步骤</strong>「<code>zero</code> 是一个自然数」 和一个<strong>归纳步骤</strong>「若 <code>m</code> 是一个自然数，则 <code>suc m</code> 也是一个自然数」构成。</p><p>归纳证明遵循此定义的结构。要通过归纳证明自然数的某个性质，我们需要两个步骤。 其一是<strong>起始步骤</strong>，即需要证明此性质对 <code>zero</code> 成立。其二是<strong>归纳步骤</strong>， 即假设此性质对一个任意自然数 <code>m</code> 成立（我们称之为<strong>归纳假设（Induction Hypothesis）</strong>），然后证明该性质对 <code>suc m</code> 必定成立。</p><p>若将 <code>m</code> 的某种性质（Property）写作 <code>P m</code>，那么我们需要证明的就是以下两个推导规则：</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>先来分析一下这些规则。第一条规则是起始步骤，它需要我们证明性质 <code>P</code> 对 <code>zero</code> 成立。第二条规则是归纳步骤，它需要我们证明若归纳假设「<code>P</code> 对 <code>m</code> 成立」， 那么 <code>P</code> 也对 <code>suc m</code> 成立。</p><p>为什么可以这样做呢？它也可以用创世故事来讲解。起初，我们对性质一无所知：</p><pre><code>-- 起初，世上没有已知的性质。</code></pre><p>现在我们对所有已知的性质应用上述两条规则。起始步骤告诉我们 <code>P zero</code> 成立， 所以我们将它加入已知的性质集合中。归纳步骤告诉我们若「昨天的」<code>P m</code> 成立， 那么「今天的」<code>P (suc m)</code> 也成立。我们在今天之前并不知道任何性质， 因此归纳步骤在这里不适用：</p><pre><code>-- 第一天，我们知道了一个性质。
P zero</code></pre><p>然后我们重复此过程。在接下来的一天我们知道今天之前的所有性质， 以及任何通过此规则添加的性质。起始步骤告诉我们 <code>P zero</code> 成立，我们已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>P zero</code> 在昨天成立，那么 <code>P (suc zero)</code> 今天也成立。</p><pre><code>-- 第二天，我们知道了两个性质。
P zero
P (suc zero)</code></pre><p>我们再重复此过程。现在归纳步骤告诉我们由于 <code>P zero</code> 和 <code>P (suc zero)</code> 都成立， 因此 <code>P (suc zero)</code> 和 <code>P (suc (suc zero))</code> 也成立。我们已经知道第一个成立了， 但第二个是新引入的：</p><pre><code>-- 第三天，我们知道了三个性质。
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了四个性质。
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的性质成立。 每个自然数的性质都会在某一天出现。具体来说，性质 <code>P n</code> 会在第 <em>n+1</em> 天 首次出现。</p><h2 id="第一个证明结合律">第一个证明：结合律</h2><p>要证明结合律，我们需要将 <code>P m</code> 看做以下性质：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的 <code>n</code> 和 <code>p</code> 是任意自然数，因此若我们可以证明该等式对所有的 <code>m</code> 都成立，那么它也会对所有的 <code>n</code> 和 <code>p</code> 成立。其推理规则的对应实例如下：</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>如果我们可以证明这两条规则，那么加法结合律就可以用归纳法来证明。</p><p>以下为此性质的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-11118" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11126" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11128" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11130" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11131" href="../Induction/#plfa_plfa-part1-Induction-11131" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11133" href="../Induction/#plfa_plfa-part1-Induction-11133" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11135" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11137" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11139" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11140" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11142" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11144" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11145" href="../Induction/#plfa_plfa-part1-Induction-11131" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11147" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11149" href="../Induction/#plfa_plfa-part1-Induction-11133" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11150" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11152" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11154" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11156" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11158" href="../Induction/#plfa_plfa-part1-Induction-11131" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11160" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11162" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11163" href="../Induction/#plfa_plfa-part1-Induction-11133" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11165" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11167" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11168" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11170" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11178" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11183" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11185" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11187" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11191" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11201" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11202" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11207" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11209" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11210" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11212" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11214" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11218" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11226" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11228" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11230" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11234" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11242" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11247" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11249" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11250" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11252" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11254" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11255" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11259" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-11261" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11269" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11270" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11274" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a><a id="plfa_plfa-part1-Induction-11275" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11277" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11279" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11281" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11285" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11295" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11296" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11300" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11302" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11304" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11305" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11307" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11309" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11313" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11321" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11325" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11326" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11328" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11330" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11331" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11333" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11335" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11339" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11347" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11351" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11353" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11355" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11357" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11358" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11360" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11362" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11363" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11367" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11370" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11375" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11379" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11380" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11388" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11390" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11392" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11393" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11395" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11401" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11405" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11406" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11408" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11410" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11411" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11415" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11416" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11421" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11429" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11433" href="../Induction/#plfa_plfa-part1-Induction-11274" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11435" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11437" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11438" href="../Induction/#plfa_plfa-part1-Induction-11277" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11440" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11442" href="../Induction/#plfa_plfa-part1-Induction-11279" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11443" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11447" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们将此证明命名为 <code>+-assoc</code>。在 Agda 中，标识符可以由除空格和 <code>@.(){};_</code> 之外的任何字符序列构成。</p><p>我们来分析一下这段代码。其签名（Signature）描述了我们定义的标识符 <code>+-assoc</code> 为以下命题提供了证据（Evidence）：</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>倒 A 符号读作「对于所有（for all）」，而该命题断言对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，等式 <code>(m + n) + p ≡ m + (n + p)</code> 成立。该命题的证据是一个接受三个自然数的函数， 将它们绑定到 <code>m</code>、<code>n</code> 和 <code>p</code>，并返回该等式对应实例的证据。</p><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>用加法的起始步骤化简等式两边会得到：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。阅读此证明中起始步骤中的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们在中间遇到 <code>n + p</code> 。此步骤无需多言，化简即可。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>用加法的归纳步骤化简等式两边会得到：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此证明中归纳步骤的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们到达上面化简等式的地方。剩下的等式单化简还不行， 我们还需要为推理链使用一个附加的运算符 <code>_≡⟨_⟩_</code>， 并将等式的依据放在尖括号中。这里给出的依据是：</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>在这里，递归调用的 <code>+-assoc m n p</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。</p><p>若某个关系在应用了给定的函数后仍然保持不变，则称该关系满足<strong>合同性（Congruence）</strong>。 若 <code>e</code> 是 <code>x ≡ y</code> 的证据，那么对于任意函数 <code>f</code>，<code>cong f e</code> 就是 <code>f x ≡ f y</code> 的证据。</p><p>在这里并未假定归纳假设，而是通过递归调用我们定义的函数 <code>+-assoc m n p</code> 来证明。 对于加法，这是良基的（well-founded），因为更大数值的结合律可基于更小数值的结合律 来证明。在此步骤中，<code>assoc (suc m) n p</code> 是用 <code>assoc m n p</code> 证明的。 归纳证明和递归定义之间的这种对应是 Agda 中最吸引人的方面之一。</p><h2 id="归纳即递归">归纳即递归</h2><p>下面是归纳如何对应于递归的具体例子，它是在结合律的证明中，将 <code>m</code> 实例化为 <code>2</code> 时的计算过程。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-15659" href="../Induction/#plfa_plfa-part1-Induction-15659" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-15669" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15671" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15673" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15674" href="../Induction/#plfa_plfa-part1-Induction-15674" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15676" href="../Induction/#plfa_plfa-part1-Induction-15676" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15678" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15681" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15683" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15685" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15686" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15688" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15690" href="../Induction/#plfa_plfa-part1-Induction-15674" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15691" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15693" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15695" href="../Induction/#plfa_plfa-part1-Induction-15676" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15697" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15699" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15701" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15703" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15704" href="../Induction/#plfa_plfa-part1-Induction-15674" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15708" href="../Induction/#plfa_plfa-part1-Induction-15676" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15709" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15711" href="../Induction/#plfa_plfa-part1-Induction-15659" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-15721" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15723" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15725" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15729" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15739" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15740" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15742" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15744" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15745" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15747" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15749" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15753" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15761" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15765" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15766" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15768" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15770" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15771" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15773" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15775" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15779" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15787" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15791" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-15793" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15795" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15797" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15798" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15800" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15802" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15803" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15807" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-15810" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-15815" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15819" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15820" href="../Induction/#plfa_plfa-part1-Induction-15895" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15830" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15832" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15833" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15835" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-15841" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15845" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15846" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15848" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15850" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15851" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15853" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15855" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15856" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-15861" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15869" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15871" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15873" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15874" href="../Induction/#plfa_plfa-part1-Induction-15721" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15876" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15878" href="../Induction/#plfa_plfa-part1-Induction-15723" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15879" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15883" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
  <a id="plfa_plfa-part1-Induction-15887" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Induction-15895" href="../Induction/#plfa_plfa-part1-Induction-15895" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15905" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15907" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15909" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15910" href="../Induction/#plfa_plfa-part1-Induction-15910" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15912" href="../Induction/#plfa_plfa-part1-Induction-15912" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15914" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15916" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15917" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15919" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15921" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15922" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15926" href="../Induction/#plfa_plfa-part1-Induction-15910" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15927" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15929" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15931" href="../Induction/#plfa_plfa-part1-Induction-15912" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15933" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15935" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15937" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15939" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15940" href="../Induction/#plfa_plfa-part1-Induction-15910" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15942" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15944" href="../Induction/#plfa_plfa-part1-Induction-15912" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15945" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15949" href="../Induction/#plfa_plfa-part1-Induction-15895" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15959" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15961" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15963" class="Symbol">=</a>
    <a id="plfa_plfa-part1-Induction-15969" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
      <a id="plfa_plfa-part1-Induction-15981" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15982" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15984" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15986" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15987" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15989" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15991" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a>
    <a id="plfa_plfa-part1-Induction-15997" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16007" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16011" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16012" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16014" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16016" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16017" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16019" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16021" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a>
    <a id="plfa_plfa-part1-Induction-16027" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16037" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16041" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16043" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16045" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16047" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16048" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16050" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16052" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16053" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16059" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16062" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16067" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16071" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16072" href="../Induction/#plfa_plfa-part1-Induction-16159" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16082" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16084" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16085" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16087" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
      <a id="plfa_plfa-part1-Induction-16095" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16099" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16100" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16104" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16105" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16107" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16109" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16110" class="Symbol">))</a>
    <a id="plfa_plfa-part1-Induction-16117" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16127" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16129" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16131" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16132" href="../Induction/#plfa_plfa-part1-Induction-15959" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16134" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16136" href="../Induction/#plfa_plfa-part1-Induction-15961" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16137" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16143" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
    <a id="plfa_plfa-part1-Induction-16149" class="Keyword">where</a>
    <a id="plfa_plfa-part1-Induction-16159" href="../Induction/#plfa_plfa-part1-Induction-16159" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16169" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16171" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16173" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16174" href="../Induction/#plfa_plfa-part1-Induction-16174" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16176" href="../Induction/#plfa_plfa-part1-Induction-16176" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16178" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16180" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16181" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16183" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16185" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16186" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16190" href="../Induction/#plfa_plfa-part1-Induction-16174" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16191" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16195" href="../Induction/#plfa_plfa-part1-Induction-16176" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16197" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16199" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16203" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16204" href="../Induction/#plfa_plfa-part1-Induction-16174" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16206" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16208" href="../Induction/#plfa_plfa-part1-Induction-16176" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16209" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16215" href="../Induction/#plfa_plfa-part1-Induction-16159" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16225" href="../Induction/#plfa_plfa-part1-Induction-16225" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16227" href="../Induction/#plfa_plfa-part1-Induction-16227" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16229" class="Symbol">=</a>
      <a id="plfa_plfa-part1-Induction-16237" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
        <a id="plfa_plfa-part1-Induction-16251" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16252" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16254" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16256" href="../Induction/#plfa_plfa-part1-Induction-16225" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16257" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16259" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16261" href="../Induction/#plfa_plfa-part1-Induction-16227" class="Bound">p</a>
      <a id="plfa_plfa-part1-Induction-16269" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
        <a id="plfa_plfa-part1-Induction-16281" href="../Induction/#plfa_plfa-part1-Induction-16225" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16283" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16285" href="../Induction/#plfa_plfa-part1-Induction-16227" class="Bound">p</a>
      <a id="plfa_plfa-part1-Induction-16293" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
        <a id="plfa_plfa-part1-Induction-16305" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16307" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16309" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16310" href="../Induction/#plfa_plfa-part1-Induction-16225" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16312" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16314" href="../Induction/#plfa_plfa-part1-Induction-16227" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16315" class="Symbol">)</a>
      <a id="plfa_plfa-part1-Induction-16323" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h2 id="术语与记法">术语与记法</h2><p>在结合律的陈述中出现的符号 <code>∀</code> 表示它对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code> 都成立。 我们将 <code>∀</code> 称为<strong>全称量词（Universal Quantifier）</strong>，我们会在 <a href="../Quantifiers/">Quantifiers</a> 章节中进一步讨论。</p><p>全称量词的证据是一个函数。记法</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>和</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>是等价的。和 <code>ℕ → ℕ → ℕ</code> 这样的函数类型不同，上述函数中的变量 与每一个实参类型相关联，且其结果类型可能会涉及（或依赖于）这些变量， 因此它们叫做<strong>依赖函数（Dependent Function）</strong>。</p><h2 id="第二个证明交换律">第二个证明：交换律</h2><p>加法的另一个重要性质是满足<strong>交换律（Commutativity）</strong>，即运算数的顺序无关紧要：</p><pre><code>m + n ≡ n + m</code></pre><p>要证明它，我们需要先证明两条引理（Lemma）。</p><h3 id="第一条引理">第一条引理</h3><p>加法定义的起始步骤说明零是一个左幺元：</p><pre><code>zero + n ≡ n</code></pre><p>我们的第一条引理则说明零也是一个右幺元：</p><pre><code>m + zero ≡ m</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-18069" href="../Induction/#plfa_plfa-part1-Induction-18069" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18081" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18083" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18085" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18086" href="../Induction/#plfa_plfa-part1-Induction-18086" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18088" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18090" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18091" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18093" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18095" href="../Induction/#plfa_plfa-part1-Induction-18086" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18097" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18099" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18104" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18106" href="../Induction/#plfa_plfa-part1-Induction-18086" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-18108" href="../Induction/#plfa_plfa-part1-Induction-18069" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18120" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18125" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18129" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18139" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18144" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18146" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18153" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18161" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18168" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-18170" href="../Induction/#plfa_plfa-part1-Induction-18069" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18182" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18183" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18187" href="../Induction/#plfa_plfa-part1-Induction-18187" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18188" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18190" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18194" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18204" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18208" href="../Induction/#plfa_plfa-part1-Induction-18187" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18210" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18212" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18219" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18227" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18231" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18232" href="../Induction/#plfa_plfa-part1-Induction-18187" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18234" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18236" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-18240" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18244" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18247" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18252" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18256" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18257" href="../Induction/#plfa_plfa-part1-Induction-18069" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18269" href="../Induction/#plfa_plfa-part1-Induction-18187" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18270" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18272" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18278" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18282" href="../Induction/#plfa_plfa-part1-Induction-18187" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-18286" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-identityʳ</code> 提供了以下命题的证据：</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>该命题的证据是一个函数，它接受一个自然数，将其绑定到 <code>m</code>，然后返回 该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + zero ≡ zero</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m) + zero = suc m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + zero) = suc m</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + zero ≡ m</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此等式链，从上到下和从下到上读都会让我们到达上面化简等式的地方。 剩下的等式可由以下依据得出：</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>在这里，递归调用的 <code>+-identityʳ m</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第一条引理证毕。</p><h3 id="第二条引理">第二条引理</h3><p>加法定义的归纳步骤将第一个参数的 <code>suc</code> 推到了外面：</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>我们的第二条引理则对第二个参数的 <code>suc</code> 做同样的事情：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-20287" href="../Induction/#plfa_plfa-part1-Induction-20287" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20293" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20295" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-20297" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20298" href="../Induction/#plfa_plfa-part1-Induction-20298" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20300" href="../Induction/#plfa_plfa-part1-Induction-20300" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20302" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20304" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-20305" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20307" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-20309" href="../Induction/#plfa_plfa-part1-Induction-20298" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20311" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20313" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20317" href="../Induction/#plfa_plfa-part1-Induction-20300" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20319" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-20321" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20325" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20326" href="../Induction/#plfa_plfa-part1-Induction-20298" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20328" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20330" href="../Induction/#plfa_plfa-part1-Induction-20300" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20331" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-20333" href="../Induction/#plfa_plfa-part1-Induction-20287" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20339" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20344" href="../Induction/#plfa_plfa-part1-Induction-20344" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20346" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20350" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20360" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20365" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20367" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20371" href="../Induction/#plfa_plfa-part1-Induction-20344" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20375" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20383" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20387" href="../Induction/#plfa_plfa-part1-Induction-20344" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20391" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20399" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20403" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20404" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20409" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20411" href="../Induction/#plfa_plfa-part1-Induction-20344" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20412" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20416" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-20418" href="../Induction/#plfa_plfa-part1-Induction-20287" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20424" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20425" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20429" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a><a id="plfa_plfa-part1-Induction-20430" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20432" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20434" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20438" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20452" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20454" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20456" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20460" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20464" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20472" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20476" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20477" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20479" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20481" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20485" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20486" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20490" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-20493" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-20498" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20502" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20503" href="../Induction/#plfa_plfa-part1-Induction-20287" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20509" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20511" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20512" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20514" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-20520" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20524" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20525" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20529" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20530" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20532" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20534" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20535" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-20540" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20548" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20552" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20553" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20557" href="../Induction/#plfa_plfa-part1-Induction-20429" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20561" href="../Induction/#plfa_plfa-part1-Induction-20432" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20562" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20566" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-suc</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>从上到下或从下到上阅读等式链都会让我们在中间遇到化简后的等式。剩下的等式 可由以下依据得出：</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>在这里，递归调用的 <code>+-suc m n</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第二条引理证毕。</p><h3 id="命题">命题</h3><p>最后，以下是我们的命题的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-22337" href="../Induction/#plfa_plfa-part1-Induction-22337" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22344" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22346" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22348" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22349" href="../Induction/#plfa_plfa-part1-Induction-22349" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22351" href="../Induction/#plfa_plfa-part1-Induction-22351" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22353" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22355" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22356" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22358" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22360" href="../Induction/#plfa_plfa-part1-Induction-22349" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22362" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22364" href="../Induction/#plfa_plfa-part1-Induction-22351" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22366" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22368" href="../Induction/#plfa_plfa-part1-Induction-22351" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22372" href="../Induction/#plfa_plfa-part1-Induction-22349" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-22374" href="../Induction/#plfa_plfa-part1-Induction-22337" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22381" href="../Induction/#plfa_plfa-part1-Induction-22381" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22383" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22388" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22392" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22402" href="../Induction/#plfa_plfa-part1-Induction-22381" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22404" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22406" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-22413" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22416" href="../Induction/#plfa_plfa-part1-Induction-18069" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-22428" href="../Induction/#plfa_plfa-part1-Induction-22381" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22436" href="../Induction/#plfa_plfa-part1-Induction-22381" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22440" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22453" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22455" href="../Induction/#plfa_plfa-part1-Induction-22381" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22459" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-22461" href="../Induction/#plfa_plfa-part1-Induction-22337" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22468" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22470" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22471" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22475" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22476" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22478" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22482" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22492" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22494" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22496" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22500" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-22504" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22507" href="../Induction/#plfa_plfa-part1-Induction-20287" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-22513" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22515" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22517" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22527" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22528" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22530" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22532" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22533" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22537" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22540" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-22545" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22549" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22550" href="../Induction/#plfa_plfa-part1-Induction-22337" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22557" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22559" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22560" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22562" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22572" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22573" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22575" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22577" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22578" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22582" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22594" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22598" href="../Induction/#plfa_plfa-part1-Induction-22468" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22602" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行说明我们定义的标识符 <code>+-comm</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>n</code> 进行归纳来证明。（这次不是 <code>m</code>！）</p><p>对于起始步骤，我们必须证明：</p><pre><code>m + zero ≡ zero + m</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>m + zero ≡ m</code></pre><p>剩下的等式可由依据 <code>⟨ +-identityʳ m ⟩</code> 得出，它调用第一条引理。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>我们分两步来证明它。首先，我们有：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>它依据第二条引理 <code>⟨ +-suc m n ⟩</code> 得出。之后我们有：</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>它依据合同性和归纳假设 <code>⟨ cong suc (+-comm m n) ⟩</code> 得出。证毕。</p><p>Agda 要求标识符必须在使用前定义，因此我们必须在主命题之前列出引理， 如前例所示。在实践中，我们通常会先试着证明主命题，之后所需的等式会说明 需要证明哪些引理。</p><h2 id="sections">第一个推论：重排定理</h2><p>我们可以随意应用结合律来重排括号。例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-24744" href="../Induction/#plfa_plfa-part1-Induction-24744" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24756" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24758" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-24760" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24761" href="../Induction/#plfa_plfa-part1-Induction-24761" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24763" href="../Induction/#plfa_plfa-part1-Induction-24763" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24765" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24767" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24769" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24771" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-24772" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24774" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-24776" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24777" href="../Induction/#plfa_plfa-part1-Induction-24761" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24779" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24781" href="../Induction/#plfa_plfa-part1-Induction-24763" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24782" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24784" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24786" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24787" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24789" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24791" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24792" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24794" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-24796" href="../Induction/#plfa_plfa-part1-Induction-24761" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24798" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24800" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24801" href="../Induction/#plfa_plfa-part1-Induction-24763" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24803" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24805" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24806" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24808" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24810" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-24812" href="../Induction/#plfa_plfa-part1-Induction-24744" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24824" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24826" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24828" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24830" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24832" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-24836" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-24846" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24847" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24849" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24851" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24852" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24854" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24856" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24857" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24859" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24861" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24862" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-24866" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-24869" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-24873" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24874" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-24882" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24883" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24885" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24887" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24888" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24890" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24892" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24893" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24895" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-24901" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-24903" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24905" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24907" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24908" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24910" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24912" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24913" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24915" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24917" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-24921" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-24924" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-24929" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24930" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-24933" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24934" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24936" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24937" href="../Induction/#plfa_plfa-part1-Induction-11118" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-24945" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24947" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24949" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24950" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24952" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-24958" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24959" href="../Induction/#plfa_plfa-part1-Induction-24824" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24961" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24963" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24964" href="../Induction/#plfa_plfa-part1-Induction-24826" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24966" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24968" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24969" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-24972" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24974" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-24978" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>无需归纳法，我们只不过应用了两次结合律就完成了证明。其中有几点需要注意的地方。</p><p>第一，加法是左结合的，因此 <code>m + (n + p) + q</code> 表示 <code>(m + (n + p)) + q</code>。</p><p>第二，我们用 <code>sym</code> 来交换等式的两边。命题 <code>+-assoc (m + n) p q</code> 会将括号从左边移到右边：</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>要往另一个方向移动括号，我们要用 <code>sym (+-assoc m n p)</code>：</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>一般来说，若 <code>e</code> 提供了 <code>x ≡ y</code> 的证据，那么 <code>sym e</code> 就提供了 <code>y ≡ x</code> 的证据。</p><p>第三，Agda 支持 Richard Bird 引入的<strong>片段（Section）</strong>记法。我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(_+ y)</code>。因此，对于 <code>assoc m n p</code> 应用合同性 <code>cong (_+ q)</code> 会将等式：</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>转换成:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>类似地，我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(x +_ )</code>。 这同样适用于任何中缀运算符。</p><h2 id="创世最后一次">创世，最后一次</h2><p>我们回到结合律的证明上来，把归纳证明（或等价的递归定义）看做一个创世故事会有助于理解。 这次我们专注于判断结合律的断言：</p><pre><code> -- 起初，我们对结合律一无所知。</code></pre><p>现在，我们将规则应用到所有已知的判断上来。起始步骤告诉我们对于所有的自然数 <code>n</code> 和 <code>p</code> 来说，<code>(zero + n) + p ≡ zero + (n + p)</code>。归纳步骤告我我们若 <code>(m + n) + p ≡ m + (n + p)</code>（在昨天）成立，那么 <code>(suc m + n) + p ≡ suc m + (n + p)</code> （在今天）也成立。我们在今天之前并不知道任何关于结合律的判断， 因此此规则并未给出任何新的判断：</p><pre><code>-- 第一天，我们知道了关于 0 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>之后我们重复此过程，因此接下来一天我们知道今天以前的所有判断， 以及任何通过此规则添加的判断。起始步骤并未告诉我们新的东西， 而如今归归纳步骤添加了更多的判断：</p><pre><code>-- 第二天，我们知道了关于 0 和 1 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>我们再次重复此过程：</p><pre><code>-- 第三天，我们知道了关于 0、1 和 2 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了关于 0、1、2 和 3 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们会知道所有第一个数小于 <em>m</em> 的判断。</p><p>还有一种完全有限的方法来生成同样的等式，它的证明留作读者的练习。</p><h4 id="finite-plus-assoc">练习 <code>finite-+-assoc</code>（延伸）</h4><p>请参考<a href="../Naturals/#finite-creation">前文</a>写出前四天已知的加法结合律的创世故事。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-30627" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="用改写来证明结合律">用改写来证明结合律</h2><p>证明可不止一种方法。下面是第二种在 Agda 中证明加法结合律的方法，使用 <code>rewrite</code>（改写） 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-30930" href="../Induction/#plfa_plfa-part1-Induction-30930" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-30939" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-30941" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-30943" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30944" href="../Induction/#plfa_plfa-part1-Induction-30944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30946" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-30948" href="../Induction/#plfa_plfa-part1-Induction-30948" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-30950" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-30952" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-30953" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-30955" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-30957" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30958" href="../Induction/#plfa_plfa-part1-Induction-30944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30960" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30962" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Bound">n</a><a id="plfa_plfa-part1-Induction-30963" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-30965" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30967" href="../Induction/#plfa_plfa-part1-Induction-30948" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-30969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-30971" href="../Induction/#plfa_plfa-part1-Induction-30944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30973" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30975" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30976" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-30978" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30980" href="../Induction/#plfa_plfa-part1-Induction-30948" class="Bound">p</a><a id="plfa_plfa-part1-Induction-30981" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-30983" href="../Induction/#plfa_plfa-part1-Induction-30930" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-30992" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-31000" href="../Induction/#plfa_plfa-part1-Induction-31000" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31002" href="../Induction/#plfa_plfa-part1-Induction-31002" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-31029" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31032" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-31037" href="../Induction/#plfa_plfa-part1-Induction-30930" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31046" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-31051" href="../Induction/#plfa_plfa-part1-Induction-31051" class="Bound">m</a><a id="plfa_plfa-part1-Induction-31052" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31054" href="../Induction/#plfa_plfa-part1-Induction-31054" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31056" href="../Induction/#plfa_plfa-part1-Induction-31056" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31059" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-31067" href="../Induction/#plfa_plfa-part1-Induction-30930" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31076" href="../Induction/#plfa_plfa-part1-Induction-31051" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31078" href="../Induction/#plfa_plfa-part1-Induction-31054" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31080" href="../Induction/#plfa_plfa-part1-Induction-31056" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31083" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31086" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。一个项等于其自身的证明写作 <code>refl</code>（自反性）。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>其证明同样由 <code>refl</code> 给出。改写不仅可以省去等式链还可以避免调用 <code>cong</code>.</p><h2 id="使用改写证明交换律">使用改写证明交换律</h2><p>下面是加法交换律的第二个证明，使用 <code>rewrite</code> 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-32456" href="../Induction/#plfa_plfa-part1-Induction-32456" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32468" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32470" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32472" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32473" href="../Induction/#plfa_plfa-part1-Induction-32473" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32475" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32478" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32480" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32482" href="../Induction/#plfa_plfa-part1-Induction-32473" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32484" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32486" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32491" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32493" href="../Induction/#plfa_plfa-part1-Induction-32473" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-32495" href="../Induction/#plfa_plfa-part1-Induction-32456" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32507" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32512" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32514" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32519" href="../Induction/#plfa_plfa-part1-Induction-32456" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32531" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32532" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32536" href="../Induction/#plfa_plfa-part1-Induction-32536" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32537" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32539" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32547" href="../Induction/#plfa_plfa-part1-Induction-32456" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32559" href="../Induction/#plfa_plfa-part1-Induction-32536" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32561" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-32569" href="../Induction/#plfa_plfa-part1-Induction-32569" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32576" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32578" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32580" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32581" href="../Induction/#plfa_plfa-part1-Induction-32581" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32583" href="../Induction/#plfa_plfa-part1-Induction-32583" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32585" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32587" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32588" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32590" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32592" href="../Induction/#plfa_plfa-part1-Induction-32581" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32600" href="../Induction/#plfa_plfa-part1-Induction-32583" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32602" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32604" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32608" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32609" href="../Induction/#plfa_plfa-part1-Induction-32581" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32613" href="../Induction/#plfa_plfa-part1-Induction-32583" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32614" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-32616" href="../Induction/#plfa_plfa-part1-Induction-32569" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32623" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32628" href="../Induction/#plfa_plfa-part1-Induction-32628" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32630" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32632" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32637" href="../Induction/#plfa_plfa-part1-Induction-32569" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32644" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32645" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32649" href="../Induction/#plfa_plfa-part1-Induction-32649" class="Bound">m</a><a id="plfa_plfa-part1-Induction-32650" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32652" href="../Induction/#plfa_plfa-part1-Induction-32652" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32654" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32662" href="../Induction/#plfa_plfa-part1-Induction-32569" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32669" href="../Induction/#plfa_plfa-part1-Induction-32649" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32671" href="../Induction/#plfa_plfa-part1-Induction-32652" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32673" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32675" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-32681" href="../Induction/#plfa_plfa-part1-Induction-32681" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32689" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32691" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32693" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32694" href="../Induction/#plfa_plfa-part1-Induction-32694" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32696" href="../Induction/#plfa_plfa-part1-Induction-32696" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32698" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32700" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32701" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32703" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32705" href="../Induction/#plfa_plfa-part1-Induction-32694" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32707" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32709" href="../Induction/#plfa_plfa-part1-Induction-32696" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32711" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32713" href="../Induction/#plfa_plfa-part1-Induction-32696" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32717" href="../Induction/#plfa_plfa-part1-Induction-32694" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-32719" href="../Induction/#plfa_plfa-part1-Induction-32681" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32727" href="../Induction/#plfa_plfa-part1-Induction-32727" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32729" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32734" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32742" href="../Induction/#plfa_plfa-part1-Induction-32456" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32754" href="../Induction/#plfa_plfa-part1-Induction-32727" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32756" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32758" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32763" href="../Induction/#plfa_plfa-part1-Induction-32681" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32771" href="../Induction/#plfa_plfa-part1-Induction-32771" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32773" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32774" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32778" href="../Induction/#plfa_plfa-part1-Induction-32778" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32779" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32781" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32789" href="../Induction/#plfa_plfa-part1-Induction-32569" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32796" href="../Induction/#plfa_plfa-part1-Induction-32771" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32798" href="../Induction/#plfa_plfa-part1-Induction-32778" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32800" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-32802" href="../Induction/#plfa_plfa-part1-Induction-32681" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32810" href="../Induction/#plfa_plfa-part1-Induction-32771" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32812" href="../Induction/#plfa_plfa-part1-Induction-32778" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32814" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32816" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>在最后一行中，用两个等式进行改写被表示为用一条竖线分隔两个相关等式的证明。 左边的改写会在右边之前被执行。</p><h2 id="交互式构造证明">交互式构造证明</h2><p>看看如何在 Emacs 中用 Agda 的交互式特性来构造另一种结合律的证明会很有启发性。 我们从输入以下内容开始：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>其中的问号表示你想要 Agda 帮你填充的代码。如果你按下 <code>C-c C-l</code> （先按 Ctrl-c 再按 Ctrl-l），那么问号会被替换为：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>空的大括号叫做<strong>洞（Hole）</strong>，0 是用来指代此洞的编号。洞可能会以绿色高亮显示。 Emacs 还会在屏幕下方创建一个新的窗口并显示文本：</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>这表示 0 号洞需要以所提示的判断的证明来填充。</p><p>我们希望对 <code>m</code> 进行归纳来证明此命题。将光标移动到洞中并按下 <code>C-c C-c</code>。它会给出提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>按下 <code>m</code> 会拆分该变量，并更新此代码：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>现在有两个洞了，下方的窗口会告诉你每个洞中需要证明的内容：</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>进入 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>它表示在化简之后，0 号洞的目标如上所示，所示类型的变量 <code>p</code> 和 <code>n</code> 可在证明中使用。 给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充。按下 <code>C-c C-l</code> 会将剩下的洞重新编号为 0：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>进入新的 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>同样，它会给出化简后的目标和可用的变量。在此步骤中，我们需要根据归纳假设进行改写， 于是我们来编辑这些文本：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>进入剩下的洞中并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充并完成证明：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">练习：<code>+-swap</code>（推荐）</h4><p>请证明对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>成立。无需归纳证明，只需应用前面满足结合律和交换律的结果即可。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37337" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-distrib-plus">练习 <code>*-distrib-+</code>（推荐）</h4><p>请证明乘法对加法满足分配律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37678" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-assoc">练习 <code>*-assoc</code>（推荐）</h4><p>请证明乘法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37981" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-comm">练习 <code>*-comm</code>（实践）</h4><p>请证明乘法满足交换律，即对于所有的自然数 <code>m</code> 和 <code>n</code>，</p><pre><code>m * n ≡ n * m</code></pre><p>成立。和加法交换律一样，你需要陈述并证明配套的引理。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38368" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="zero-monus">练习 <code>0∸n≡0</code>（实践）</h4><p>请证明对于所有的自然数 <code>n</code>，</p><pre><code>zero ∸ n ≡ zero</code></pre><p>成立。你的证明需要归纳法吗？</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38625" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="monus-plus-assoc">练习 <code>∸-+-assoc</code>（实践）</h4><p>请证明饱和减法与加法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38949" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-延伸">练习 <code>+*^</code> （延伸）</h4><p>证明下列三条定律</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>对于所有 <code>m</code>、<code>n</code> 和 <code>p</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39306" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-laws">练习 <code>Bin-laws</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a> 中定义的一种表示自然数的比特串数据类型 <code>Bin</code> 以及要求你定义的函数：</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>考虑以下定律，其中 <code>n</code> 表示自然数，<code>b</code> 表示比特串：</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>对于每一条定律：若它成立，请证明；若不成立，请给出一个反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40018" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>本章中类似的定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40195" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-40202" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-40222" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-40228" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-40229" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-40236" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40238" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-40249" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40251" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#12854" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-40256" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40258" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-40264" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章中使用了以下 Unicode：</p><pre><code>∀  U+2200  对于所有 (\forall, \all)
ʳ  U+02B3  修饰符小写字母 r (\^r)
′  U+2032  撇号 (\&#39;)
″  U+2033  双撇号 (\&#39;)
‴  U+2034  三撇号 (\&#39;)
⁗  U+2057  四撇号 (\&#39;)</code></pre><p>与 <code>\r</code> 类似，命令 <code>\^r</code> 列出了多种上标右箭头的变体，以及上标的字母 <code>r</code>。 命令 <code>\&#39;</code> 列出了一些撇号（<code>′ ″ ‴ ⁗</code>）。</p></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Oling Cat</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>