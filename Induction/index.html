<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-oald/giFwKDrcy9DORpCxMSq2IAFjgwVUM5pRbyPtm60xZT/52VIm0b9qqbL2UcrxYzxM4cYrtRk02or57bQsA==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-3emtxUSJDVriAZnzOyZFTRu0beO+lk81E2cRDhzd62DQrlh2u4kR6+lz2dOUNZwPDvGwcqfFRrKJO2Zu0O4IJA==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Induction: 归纳证明</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-100" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-107" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-128" class="Keyword">where</a>
</pre><blockquote><p>归纳会让你对无中生有感到内疚 ……但它却是文明中最伟大的思想之一。 —— Herbert Wilf</p></blockquote><p>现在我们定义了自然数及其运算，下一步是学习如何证明它们满足的性质。 顾名思义，<strong>归纳数据类型（Inductive Datatype）</strong>是通过<strong>归纳（Induction）</strong> 来证明的。</p><h2 id="导入">导入</h2><p>我们需要上一章中的相等性，加上自然数及其运算。我们还导入了一些新的运算： <code>cong</code>、<code>sym</code>、<code>_≡⟨⟩_</code> 和 <code>_≡⟨_⟩_</code>，之后会解释它们：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-1009" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1016" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-1054" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-1057" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-1060" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1065" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-1068" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1075" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-1078" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1080" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-1084" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1086" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="plfa_plfa-part1-Induction-1090" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1092" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="plfa_plfa-part1-Induction-1095" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1097" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1102" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-1117" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1123" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1124" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-1130" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1132" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">step-≡-∣</a><a id="plfa_plfa-part1-Induction-1140" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1142" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">step-≡-⟩</a><a id="plfa_plfa-part1-Induction-1150" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1152" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-1154" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1156" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1161" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1168" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-1177" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1183" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1184" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-1185" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1187" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-1191" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1193" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-1196" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1198" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-1201" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1203" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-1206" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1208" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#4462" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-1211" class="Symbol">;</a><a id="plfa_plfa-part1-Induction-1212" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html#6567" class="Function Operator">_^_</a><a id="plfa_plfa-part1-Induction-1215" class="Symbol">)</a>
</pre><p>（导入 <code>step-≡-∣</code> 定义了 <code>_≡⟨⟩_</code>，导入 <code>step-≡-⟩</code> 定义了 <code>_≡⟨_⟩_</code>。）</p><h2 id="运算符的性质">运算符的性质</h2><p>运算符随处可见，而数学家们统一了一些最常见的性质的名称。</p><ul><li><p><strong>幺元（Identity）</strong>：对于所有的 <code>n</code>，若 <code>0 + n ≡ n</code>，则 <code>+</code> 有左幺元 <code>0</code>； 若 <code>n + 0 ≡ n</code>，则 <code>+</code> 有右幺元 <code>0</code>。同时为左幺元和右幺元的值称简称幺元。 幺元有时也称作<strong>单位元（Unit）</strong>。</p></li><li><p><strong>结合律（Associativity）</strong>：若括号的位置无关紧要，则称运算符 <code>+</code> 满足结合律， 即对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，有 <code>(m + n) + p ≡ m + (n + p)</code>。</p></li><li><p><strong>交换律（Commutativity）</strong>：若参数的顺序无关紧要，则称运算符 <code>+</code> 满足交换律， 即对于所有的 <code>m</code> 和 <code>n</code>，有 <code>m + n ≡ n + m</code>。</p></li><li><p><strong>分配律（Distributivity）</strong>：对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>m * (p + q) ≡ (m * p) + (m * q)</code>，则运算符 <code>*</code> 对运算符 <code>+</code> 满足左分配律； 对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>(m + n) * p ≡ (m * p) + (n * p)</code>，则满足右分配律。</p></li></ul><p>加法的幺元为 <code>0</code>，乘法的幺元为 <code>1</code>。加法和乘法都满足结合律和交换律， 乘法对加法满足分配律。</p><p>如果你在一个舞会上碰见了一位操作员，那么你可以跟他闲聊，问问他是否有单位元， 能不能结合或者交换。如果你碰见了两位操作员，那么可以问他们某一位是否在另一位上面分布。</p><p>【译注：作者的双关冷笑话，运算符（Operator）也有操作员的意思。】</p><p>正经来说，如果你在阅读技术论文时遇到了一个运算符，那么你可以考察它是否拥有幺元， 是否满足结合律或分配律，或者是否对另一个运算符满足分配律，这能为你提供一种视角。 细心的作者通常会指出它们是否满足这些性质，比如说指明一个新引入的运算符满足结合律 但不满足交换律。</p><h4 id="operators">练习 <code>operators</code>（实践）</h4><p>请给出另一对运算符，它们拥有一个幺元，满足结合律、交换律，且其中一个对另一个满足分配律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4321" class="Comment">-- 请将代码写在此处</a>
</pre><p>请给出一个运算符的例子，它拥有幺元、满足结合律但不满足交换律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4496" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="结合律">结合律</h2><p>加法的一个性质是满足<strong>结合律</strong>，即括号的位置无关紧要：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的变量 <code>m</code>、<code>n</code> 和 <code>p</code> 的取值范围都是全体自然数。</p><p>我们可以为这三个变量选取特定的数值来验证此命题：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4983" href="../Induction/#plfa_plfa-part1-Induction-4983" class="Function">_</a> <a id="plfa_plfa-part1-Induction-4985" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-4987" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4988" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4990" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4992" class="Number">4</a><a id="plfa_plfa-part1-Induction-4993" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4995" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4997" class="Number">5</a> <a id="plfa_plfa-part1-Induction-4999" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-5001" class="Number">3</a> <a id="plfa_plfa-part1-Induction-5003" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5005" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-5006" class="Number">4</a> <a id="plfa_plfa-part1-Induction-5008" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5010" class="Number">5</a><a id="plfa_plfa-part1-Induction-5011" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-5013" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-5015" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-5019" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-5029" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-5030" class="Number">3</a> <a id="plfa_plfa-part1-Induction-5032" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5034" class="Number">4</a><a id="plfa_plfa-part1-Induction-5035" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-5037" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5039" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-5043" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-5051" class="Number">7</a> <a id="plfa_plfa-part1-Induction-5053" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5055" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-5059" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-5067" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-5072" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-5080" class="Number">3</a> <a id="plfa_plfa-part1-Induction-5082" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5084" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-5088" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-5096" class="Number">3</a> <a id="plfa_plfa-part1-Induction-5098" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5100" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-5101" class="Number">4</a> <a id="plfa_plfa-part1-Induction-5103" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-5105" class="Number">5</a><a id="plfa_plfa-part1-Induction-5106" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-5110" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>在这里，我们将计算过程写成了等式链，每行一个式子。这样的等式链通常非常易读， 你可以从上到下，直到遇到最简形式（本例中为 <code>12</code>），也可以从下到上，直到回到同样的式子。</p><p>该测试揭示了结合律可能没有它初看起来那么显然。为什么 <code>7 + 5</code> 与 <code>3 + 9</code> 相同？ 我们可能需要收集更多证据，选择其它的数值来验证此命题。但由于自然数是无限的， 因此测试永远无法完成。那么我们还有其它可以确保结合律对于<strong>所有</strong>自然数都成立的方法吗？</p><p>当然有！我们可以用<strong>归纳证明（Proof by Induction）</strong> 来确保某个性质对于所有的自然数都成立。</p><h2 id="归纳证明">归纳证明</h2><p>回想自然数的定义，它由一个<strong>起始步骤</strong>「<code>zero</code> 是一个自然数」 和一个<strong>归纳步骤</strong>「若 <code>m</code> 是一个自然数，则 <code>suc m</code> 也是一个自然数」构成。</p><p>归纳证明遵循此定义的结构。要通过归纳证明自然数的某个性质，我们需要两个步骤。 其一是<strong>起始步骤</strong>，即需要证明此性质对 <code>zero</code> 成立。其二是<strong>归纳步骤</strong>， 即假设此性质对一个任意自然数 <code>m</code> 成立（我们称之为<strong>归纳假设（Induction Hypothesis）</strong>），然后证明该性质对 <code>suc m</code> 必定成立。</p><p>若将 <code>m</code> 的某种性质（Property）写作 <code>P m</code>，那么我们需要证明的就是以下两个推导规则：</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>先来分析一下这些规则。第一条规则是起始步骤，它需要我们证明性质 <code>P</code> 对 <code>zero</code> 成立。第二条规则是归纳步骤，它需要我们证明若归纳假设「<code>P</code> 对 <code>m</code> 成立」， 那么 <code>P</code> 也对 <code>suc m</code> 成立。</p><p>为什么可以这样做呢？它也可以用创世故事来讲解。起初，我们对性质一无所知：</p><pre><code>-- 起初，世上没有已知的性质。</code></pre><p>现在我们对所有已知的性质应用上述两条规则。起始步骤告诉我们 <code>P zero</code> 成立， 所以我们将它加入已知的性质集合中。归纳步骤告诉我们若「昨天的」<code>P m</code> 成立， 那么「今天的」<code>P (suc m)</code> 也成立。我们在今天之前并不知道任何性质， 因此归纳步骤在这里不适用：</p><pre><code>-- 第一天，我们知道了一个性质。
P zero</code></pre><p>然后我们重复此过程。在接下来的一天我们知道今天之前的所有性质， 以及任何通过此规则添加的性质。起始步骤告诉我们 <code>P zero</code> 成立，我们已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>P zero</code> 在昨天成立，那么 <code>P (suc zero)</code> 今天也成立。</p><pre><code>-- 第二天，我们知道了两个性质。
P zero
P (suc zero)</code></pre><p>我们再重复此过程。现在归纳步骤告诉我们由于 <code>P zero</code> 和 <code>P (suc zero)</code> 都成立， 因此 <code>P (suc zero)</code> 和 <code>P (suc (suc zero))</code> 也成立。我们已经知道第一个成立了， 但第二个是新引入的：</p><pre><code>-- 第三天，我们知道了三个性质。
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了四个性质。
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的性质成立。 每个自然数的性质都会在某一天出现。具体来说，性质 <code>P n</code> 会在第 <em>n+1</em> 天 首次出现。</p><h2 id="第一个证明结合律">第一个证明：结合律</h2><p>要证明结合律，我们需要将 <code>P m</code> 看做以下性质：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的 <code>n</code> 和 <code>p</code> 是任意自然数，因此若我们可以证明该等式对所有的 <code>m</code> 都成立，那么它也会对所有的 <code>n</code> 和 <code>p</code> 成立。其推理规则的对应实例如下：</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>如果我们可以证明这两条规则，那么加法结合律就可以用归纳法来证明。</p><p>以下为此性质的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-11235" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11243" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11245" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11247" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11248" href="../Induction/#plfa_plfa-part1-Induction-11248" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11250" href="../Induction/#plfa_plfa-part1-Induction-11250" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11252" href="../Induction/#plfa_plfa-part1-Induction-11252" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11254" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11256" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11257" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11259" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11261" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11262" href="../Induction/#plfa_plfa-part1-Induction-11248" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11264" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11266" href="../Induction/#plfa_plfa-part1-Induction-11250" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11267" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11269" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11271" href="../Induction/#plfa_plfa-part1-Induction-11252" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11273" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11275" href="../Induction/#plfa_plfa-part1-Induction-11248" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11277" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11279" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11280" href="../Induction/#plfa_plfa-part1-Induction-11250" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11282" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11284" href="../Induction/#plfa_plfa-part1-Induction-11252" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11285" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11287" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11295" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11300" href="../Induction/#plfa_plfa-part1-Induction-11300" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11302" href="../Induction/#plfa_plfa-part1-Induction-11302" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11304" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11308" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11318" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11319" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11324" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11326" href="../Induction/#plfa_plfa-part1-Induction-11300" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11327" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11329" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11331" href="../Induction/#plfa_plfa-part1-Induction-11302" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11335" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11343" href="../Induction/#plfa_plfa-part1-Induction-11300" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11345" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11347" href="../Induction/#plfa_plfa-part1-Induction-11302" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11351" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11359" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11364" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11366" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11367" href="../Induction/#plfa_plfa-part1-Induction-11300" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11369" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11371" href="../Induction/#plfa_plfa-part1-Induction-11302" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11372" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11376" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-11378" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11386" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11387" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11391" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a><a id="plfa_plfa-part1-Induction-11392" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11394" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11396" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11398" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11402" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11412" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11413" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11417" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11419" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11421" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11422" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11424" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11426" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11430" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11438" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11442" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11443" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11445" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11447" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11448" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11450" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11452" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11456" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11464" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11468" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11470" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11472" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11474" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11475" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11477" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11479" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11480" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11484" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11487" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11492" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11496" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11497" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11505" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11507" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11509" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11510" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11512" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11518" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11522" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11523" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11525" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11527" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11528" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11530" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11532" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11533" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11538" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11546" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11550" href="../Induction/#plfa_plfa-part1-Induction-11391" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11552" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11554" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11555" href="../Induction/#plfa_plfa-part1-Induction-11394" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11557" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11559" href="../Induction/#plfa_plfa-part1-Induction-11396" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11560" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11564" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>我们将此证明命名为 <code>+-assoc</code>。在 Agda 中，标识符可以由除空格和 <code>@.(){};_</code> 之外的任何字符序列构成。</p><p>我们来分析一下这段代码。其签名（Signature）描述了我们定义的标识符 <code>+-assoc</code> 为以下命题提供了证据（Evidence）：</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>倒 A 符号读作「对于所有（for all）」，而该命题断言对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，等式 <code>(m + n) + p ≡ m + (n + p)</code> 成立。该命题的证据是一个接受三个自然数的函数， 将它们绑定到 <code>m</code>、<code>n</code> 和 <code>p</code>，并返回该等式对应实例的证据。</p><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>用加法的起始步骤化简等式两边会得到：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。阅读此证明中起始步骤中的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们在中间遇到 <code>n + p</code> 。此步骤无需多言，化简即可。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>用加法的归纳步骤化简等式两边会得到：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此证明中归纳步骤的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们到达上面化简等式的地方。剩下的等式单化简还不行， 我们还需要为推理链使用一个附加的运算符 <code>_≡⟨_⟩_</code>， 并将等式的依据放在尖括号中。这里给出的依据是：</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>在这里，递归调用的 <code>+-assoc m n p</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。</p><p>若某个关系在应用了给定的函数后仍然保持不变，则称该关系满足<strong>合同性（Congruence）</strong>。 若 <code>e</code> 是 <code>x ≡ y</code> 的证据，那么对于任意函数 <code>f</code>，<code>cong f e</code> 就是 <code>f x ≡ f y</code> 的证据。</p><p>在这里并未假定归纳假设，而是通过递归调用我们定义的函数 <code>+-assoc m n p</code> 来证明。 对于加法，这是良基的（well-founded），因为更大数值的结合律可基于更小数值的结合律 来证明。在此步骤中，<code>assoc (suc m) n p</code> 是用 <code>assoc m n p</code> 证明的。 归纳证明和递归定义之间的这种对应是 Agda 中最吸引人的方面之一。</p><h2 id="归纳即递归">归纳即递归</h2><p>下面是归纳如何对应于递归的具体例子，它是在结合律的证明中，将 <code>m</code> 实例化为 <code>2</code> 时的计算过程。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-0"></a><a id="plfa_plfa-part1-Induction-15776" href="../Induction/#plfa_plfa-part1-Induction-15776" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15786" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15788" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15790" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15791" href="../Induction/#plfa_plfa-part1-Induction-15791" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15793" href="../Induction/#plfa_plfa-part1-Induction-15793" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15795" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15797" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15798" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15800" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15802" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15803" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15805" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15807" href="../Induction/#plfa_plfa-part1-Induction-15791" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15808" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15810" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15812" href="../Induction/#plfa_plfa-part1-Induction-15793" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15814" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15816" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15818" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15820" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15821" href="../Induction/#plfa_plfa-part1-Induction-15791" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15823" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15825" href="../Induction/#plfa_plfa-part1-Induction-15793" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15826" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15828" href="../Induction/#plfa_plfa-part1-Induction-15776" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15838" href="../Induction/#plfa_plfa-part1-Induction-15838" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15840" href="../Induction/#plfa_plfa-part1-Induction-15840" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15842" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15846" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15856" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15857" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15859" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15861" href="../Induction/#plfa_plfa-part1-Induction-15838" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15862" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15864" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15866" href="../Induction/#plfa_plfa-part1-Induction-15840" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15870" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15878" href="../Induction/#plfa_plfa-part1-Induction-15838" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15880" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15882" href="../Induction/#plfa_plfa-part1-Induction-15840" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15886" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15894" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15896" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15898" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15899" href="../Induction/#plfa_plfa-part1-Induction-15838" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15901" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15903" href="../Induction/#plfa_plfa-part1-Induction-15840" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15904" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15908" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-1"></a><a id="plfa_plfa-part1-Induction-15911" href="../Induction/#plfa_plfa-part1-Induction-15911" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15921" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15923" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15925" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15926" href="../Induction/#plfa_plfa-part1-Induction-15926" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15928" href="../Induction/#plfa_plfa-part1-Induction-15928" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15930" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15932" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15933" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15935" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15937" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15938" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15940" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15942" href="../Induction/#plfa_plfa-part1-Induction-15926" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15943" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15945" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15947" href="../Induction/#plfa_plfa-part1-Induction-15928" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15949" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15951" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15953" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15955" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15956" href="../Induction/#plfa_plfa-part1-Induction-15926" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15958" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15960" href="../Induction/#plfa_plfa-part1-Induction-15928" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15961" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15963" href="../Induction/#plfa_plfa-part1-Induction-15911" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15973" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15975" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15977" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15981" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15991" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15992" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15994" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15996" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15997" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15999" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16001" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16005" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16013" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16017" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16018" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16020" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16022" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16023" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16025" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16027" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16031" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16039" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16043" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16045" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16047" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16049" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16050" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16052" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16054" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16055" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16059" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16062" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16067" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16071" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16072" href="../Induction/#plfa_plfa-part1-Induction-15776" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16082" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16084" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16085" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16087" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16093" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16097" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16098" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16100" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16102" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16103" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16105" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16107" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16108" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-16113" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16121" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16123" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16125" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16126" href="../Induction/#plfa_plfa-part1-Induction-15973" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16128" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16130" href="../Induction/#plfa_plfa-part1-Induction-15975" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16131" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16135" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-16138" href="../Induction/#plfa_plfa-part1-Induction-16138" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16148" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16150" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16152" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16153" href="../Induction/#plfa_plfa-part1-Induction-16153" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16155" href="../Induction/#plfa_plfa-part1-Induction-16155" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16157" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16159" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16160" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16162" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16164" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16165" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16167" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16169" href="../Induction/#plfa_plfa-part1-Induction-16153" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16170" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16172" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16174" href="../Induction/#plfa_plfa-part1-Induction-16155" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16176" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16178" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16180" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16182" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16183" href="../Induction/#plfa_plfa-part1-Induction-16153" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16185" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16187" href="../Induction/#plfa_plfa-part1-Induction-16155" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16188" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-16190" href="../Induction/#plfa_plfa-part1-Induction-16138" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16200" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16202" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16204" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-16208" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-16218" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16219" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16221" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16223" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16224" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16226" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16228" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16232" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16240" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16244" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16245" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16247" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16249" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16250" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16252" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16254" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16258" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16266" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16270" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16272" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16274" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16276" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16277" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16279" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16281" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16282" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16286" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16289" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16294" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16298" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16299" href="../Induction/#plfa_plfa-part1-Induction-15911" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-16309" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16311" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16312" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16314" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16320" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16324" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16325" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16327" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16329" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16330" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16332" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16334" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16335" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-16340" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16348" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16350" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16352" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16353" href="../Induction/#plfa_plfa-part1-Induction-16200" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16355" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16357" href="../Induction/#plfa_plfa-part1-Induction-16202" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16358" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16362" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><h2 id="术语与记法">术语与记法</h2><p>在结合律的陈述中出现的符号 <code>∀</code> 表示它对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code> 都成立。 我们将 <code>∀</code> 称为<strong>全称量词（Universal Quantifier）</strong>，我们会在 <a href="../Quantifiers/">Quantifiers</a> 章节中进一步讨论。</p><p>全称量词的证据是一个函数。函数签名</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>和</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>是等价的。和 <code>ℕ → ℕ → ℕ</code> 这样的函数类型不同，上述函数中的变量 与每一个实参类型相关联，且其结果类型可能会涉及（或依赖于）这些变量， 因此它们叫做<strong>依赖函数（Dependent Function）</strong>。</p><p>Ordinary functions are a special case of dependent functions. For instance, the signatures</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m n : ℕ) → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m : ℕ) → ∀ (n : ℕ) → ℕ</code></pre><p>are all equivalent.</p><h2 id="第二个证明交换律">第二个证明：交换律</h2><p>加法的另一个重要性质是满足<strong>交换律（Commutativity）</strong>，即运算数的顺序无关紧要：</p><pre><code>m + n ≡ n + m</code></pre><p>要证明它，我们需要先证明两条引理（Lemma）。</p><h3 id="第一条引理">第一条引理</h3><p>加法定义的起始步骤说明零是一个左幺元：</p><pre><code>zero + n ≡ n</code></pre><p>我们的第一条引理则说明零也是一个右幺元：</p><pre><code>m + zero ≡ m</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-18320" href="../Induction/#plfa_plfa-part1-Induction-18320" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18332" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18334" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18336" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18337" href="../Induction/#plfa_plfa-part1-Induction-18337" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18339" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18341" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18342" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18344" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18346" href="../Induction/#plfa_plfa-part1-Induction-18337" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18348" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18350" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18355" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18357" href="../Induction/#plfa_plfa-part1-Induction-18337" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-18359" href="../Induction/#plfa_plfa-part1-Induction-18320" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18371" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18376" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18380" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18390" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18395" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18397" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18404" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18412" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18419" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-18421" href="../Induction/#plfa_plfa-part1-Induction-18320" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18433" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18434" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18438" href="../Induction/#plfa_plfa-part1-Induction-18438" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18439" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18441" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18445" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18455" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18459" href="../Induction/#plfa_plfa-part1-Induction-18438" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18461" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18463" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18470" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18478" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18482" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18483" href="../Induction/#plfa_plfa-part1-Induction-18438" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18485" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18487" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-18491" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18495" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18498" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18503" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18507" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18508" href="../Induction/#plfa_plfa-part1-Induction-18320" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18520" href="../Induction/#plfa_plfa-part1-Induction-18438" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18521" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18523" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18529" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18533" href="../Induction/#plfa_plfa-part1-Induction-18438" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-18537" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-identityʳ</code> 提供了以下命题的证据：</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>该命题的证据是一个函数，它接受一个自然数，将其绑定到 <code>m</code>，然后返回 该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + zero ≡ zero</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m) + zero = suc m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + zero) = suc m</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + zero ≡ m</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此等式链，从上到下和从下到上读都会让我们到达上面化简等式的地方。 剩下的等式可由以下依据得出：</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>在这里，递归调用的 <code>+-identityʳ m</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第一条引理证毕。</p><h3 id="第二条引理">第二条引理</h3><p>加法定义的归纳步骤将第一个参数的 <code>suc</code> 推到了外面：</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>我们的第二条引理则对第二个参数的 <code>suc</code> 做同样的事情：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-20538" href="../Induction/#plfa_plfa-part1-Induction-20538" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20544" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20546" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-20548" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20549" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20551" href="../Induction/#plfa_plfa-part1-Induction-20551" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20553" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20555" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-20556" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20558" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-20560" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20562" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20564" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20568" href="../Induction/#plfa_plfa-part1-Induction-20551" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20570" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-20572" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20576" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20577" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20579" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20581" href="../Induction/#plfa_plfa-part1-Induction-20551" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20582" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-20584" href="../Induction/#plfa_plfa-part1-Induction-20538" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20590" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20595" href="../Induction/#plfa_plfa-part1-Induction-20595" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20597" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20601" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20611" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20616" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20618" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20622" href="../Induction/#plfa_plfa-part1-Induction-20595" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20626" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20634" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20638" href="../Induction/#plfa_plfa-part1-Induction-20595" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20642" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20650" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20654" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20655" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20660" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20662" href="../Induction/#plfa_plfa-part1-Induction-20595" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20663" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20667" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-20669" href="../Induction/#plfa_plfa-part1-Induction-20538" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20675" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20676" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20680" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a><a id="plfa_plfa-part1-Induction-20681" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20683" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20685" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20689" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20699" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20703" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20705" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20707" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20711" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20715" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20723" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20727" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20728" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20730" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20732" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20736" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20737" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20741" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-20744" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-20749" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20753" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20754" href="../Induction/#plfa_plfa-part1-Induction-20538" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20760" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20762" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20763" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20765" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-20771" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20775" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20776" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20780" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20781" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20783" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20785" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20786" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-20791" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20799" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20803" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20804" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20808" href="../Induction/#plfa_plfa-part1-Induction-20680" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20810" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20812" href="../Induction/#plfa_plfa-part1-Induction-20683" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20813" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20817" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-suc</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>从上到下或从下到上阅读等式链都会让我们在中间遇到化简后的等式。剩下的等式 可由以下依据得出：</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>在这里，递归调用的 <code>+-suc m n</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第二条引理证毕。</p><h3 id="命题">命题</h3><p>最后，以下是我们的命题的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-22588" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22595" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22597" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22599" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22600" href="../Induction/#plfa_plfa-part1-Induction-22600" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22602" href="../Induction/#plfa_plfa-part1-Induction-22602" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22604" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22606" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22607" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22609" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22611" href="../Induction/#plfa_plfa-part1-Induction-22600" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22613" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22615" href="../Induction/#plfa_plfa-part1-Induction-22602" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22617" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22619" href="../Induction/#plfa_plfa-part1-Induction-22602" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22621" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22623" href="../Induction/#plfa_plfa-part1-Induction-22600" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-22625" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22632" href="../Induction/#plfa_plfa-part1-Induction-22632" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22634" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22639" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22643" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22653" href="../Induction/#plfa_plfa-part1-Induction-22632" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22655" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22657" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-22664" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22667" href="../Induction/#plfa_plfa-part1-Induction-18320" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-22679" href="../Induction/#plfa_plfa-part1-Induction-22632" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22681" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22687" href="../Induction/#plfa_plfa-part1-Induction-22632" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22691" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22699" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22704" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22706" href="../Induction/#plfa_plfa-part1-Induction-22632" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22710" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-22712" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22719" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22721" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22722" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22726" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22727" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22729" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22733" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22743" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22745" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22747" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22751" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-22755" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22758" href="../Induction/#plfa_plfa-part1-Induction-20538" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-22764" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22766" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22768" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22774" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22778" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22779" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22781" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22783" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22784" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22788" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22791" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-22796" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22800" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22801" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22808" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22810" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22811" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22813" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22819" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22823" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22824" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22826" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22828" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22829" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22833" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22841" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22845" href="../Induction/#plfa_plfa-part1-Induction-22726" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22847" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22849" href="../Induction/#plfa_plfa-part1-Induction-22719" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22853" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>第一行说明我们定义的标识符 <code>+-comm</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>n</code> 进行归纳来证明。（这次不是 <code>m</code>！）</p><p>对于起始步骤，我们必须证明：</p><pre><code>m + zero ≡ zero + m</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>m + zero ≡ m</code></pre><p>剩下的等式可由依据 <code>⟨ +-identityʳ m ⟩</code> 得出，它调用第一条引理。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>我们分两步来证明它。首先，我们有：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>它依据第二条引理 <code>⟨ +-suc m n ⟩</code> 得出。之后我们有：</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>它依据合同性和归纳假设 <code>⟨ cong suc (+-comm m n) ⟩</code> 得出。证毕。</p><p>Agda 要求标识符必须在使用前定义，因此我们必须在主命题之前列出引理， 如前例所示。在实践中，我们通常会先试着证明主命题，之后所需的等式会说明 需要证明哪些引理。</p><h2 id="sections">第一个推论：重排定理</h2><p>我们可以随意应用结合律来重排括号。例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-24995" href="../Induction/#plfa_plfa-part1-Induction-24995" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-25007" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-25009" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-25011" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25012" href="../Induction/#plfa_plfa-part1-Induction-25012" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25014" href="../Induction/#plfa_plfa-part1-Induction-25014" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25016" href="../Induction/#plfa_plfa-part1-Induction-25016" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25018" href="../Induction/#plfa_plfa-part1-Induction-25018" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-25020" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-25022" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-25023" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25025" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-25027" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25028" href="../Induction/#plfa_plfa-part1-Induction-25012" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25030" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25032" href="../Induction/#plfa_plfa-part1-Induction-25014" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25033" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25035" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25037" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25038" href="../Induction/#plfa_plfa-part1-Induction-25016" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25040" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25042" href="../Induction/#plfa_plfa-part1-Induction-25018" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25043" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25045" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-25047" href="../Induction/#plfa_plfa-part1-Induction-25012" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25049" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25051" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25052" href="../Induction/#plfa_plfa-part1-Induction-25014" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25054" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25056" href="../Induction/#plfa_plfa-part1-Induction-25016" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25057" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25059" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25061" href="../Induction/#plfa_plfa-part1-Induction-25018" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-25063" href="../Induction/#plfa_plfa-part1-Induction-24995" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-25075" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25077" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25079" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25081" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-25083" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-25087" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-25097" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25098" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25100" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25102" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25103" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25105" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25107" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25108" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25110" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25112" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25113" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-25117" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-25120" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-25124" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25125" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25133" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25134" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25136" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25138" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25139" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25141" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25143" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25144" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25146" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25152" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-25154" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25156" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25158" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25159" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25161" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25163" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25164" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25166" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25168" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25172" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-25175" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-25180" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25181" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-25184" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25185" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25187" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25188" href="../Induction/#plfa_plfa-part1-Induction-11235" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25196" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25198" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25200" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25201" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25203" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25209" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25210" href="../Induction/#plfa_plfa-part1-Induction-25075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25212" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25214" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25215" href="../Induction/#plfa_plfa-part1-Induction-25077" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25217" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25219" href="../Induction/#plfa_plfa-part1-Induction-25079" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25220" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-25223" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25225" href="../Induction/#plfa_plfa-part1-Induction-25081" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25229" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>无需归纳法，我们只不过应用了两次结合律就完成了证明。其中有几点需要注意的地方。</p><p>第一，加法是左结合的，因此 <code>m + (n + p) + q</code> 表示 <code>(m + (n + p)) + q</code>。</p><p>第二，我们用 <code>sym</code> 来交换等式的两边。命题 <code>+-assoc (m + n) p q</code> 会将括号从左边移到右边：</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>要往另一个方向移动括号，我们要用 <code>sym (+-assoc (m + n) p q)</code>：</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>一般来说，若 <code>e</code> 提供了 <code>x ≡ y</code> 的证据，那么 <code>sym e</code> 就提供了 <code>y ≡ x</code> 的证据。</p><p>第三，Agda 支持 Richard Bird 引入的<strong>片段（Section）</strong>记法。我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(_+ y)</code>。因此，对于 <code>assoc m n p</code> 应用合同性 <code>cong (_+ q)</code> 会将等式：</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>转换成:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>类似地，我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(x +_ )</code>。 这同样适用于任何中缀运算符。</p><h2 id="创世最后一次">创世，最后一次</h2><p>我们回到结合律的证明上来，把归纳证明（或等价的递归定义）看做一个创世故事会有助于理解。 这次我们专注于判断结合律的断言：</p><pre><code> -- 起初，我们对结合律一无所知。</code></pre><p>现在，我们将规则应用到所有已知的判断上来。起始步骤告诉我们对于所有的自然数 <code>n</code> 和 <code>p</code> 来说，<code>(zero + n) + p ≡ zero + (n + p)</code>。归纳步骤告我我们若 <code>(m + n) + p ≡ m + (n + p)</code>（在昨天）成立，那么 <code>(suc m + n) + p ≡ suc m + (n + p)</code> （在今天）也成立。我们在今天之前并不知道任何关于结合律的判断， 因此此规则并未给出任何新的判断：</p><pre><code>-- 第一天，我们知道了关于 0 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>之后我们重复此过程，因此接下来一天我们知道今天以前的所有判断， 以及任何通过此规则添加的判断。起始步骤并未告诉我们新的东西， 而如今归归纳步骤添加了更多的判断：</p><pre><code>-- 第二天，我们知道了关于 0 和 1 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>我们再次重复此过程：</p><pre><code>-- 第三天，我们知道了关于 0、1 和 2 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了关于 0、1、2 和 3 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们会知道所有第一个数小于 <em>m</em> 的判断。</p><p>还有一种完全有限的方法来生成同样的等式，它的证明留作读者的练习。</p><h4 id="finite-plus-assoc">练习 <code>finite-+-assoc</code>（延伸）</h4><p>请参考<a href="../Naturals/#finite-creation">前文</a>写出前四天已知的加法结合律的创世故事。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-30890" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="用改写来证明结合律">用改写来证明结合律</h2><p>证明可不止一种方法。下面是第二种在 Agda 中证明加法结合律的方法，使用 <code>rewrite</code>（改写） 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-31192" href="../Induction/#plfa_plfa-part1-Induction-31192" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31201" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31203" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-31205" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31206" href="../Induction/#plfa_plfa-part1-Induction-31206" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31208" href="../Induction/#plfa_plfa-part1-Induction-31208" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31210" href="../Induction/#plfa_plfa-part1-Induction-31210" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31212" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31214" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-31215" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31217" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-31219" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31220" href="../Induction/#plfa_plfa-part1-Induction-31206" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31222" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31224" href="../Induction/#plfa_plfa-part1-Induction-31208" class="Bound">n</a><a id="plfa_plfa-part1-Induction-31225" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31227" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31229" href="../Induction/#plfa_plfa-part1-Induction-31210" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31231" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-31233" href="../Induction/#plfa_plfa-part1-Induction-31206" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31235" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31237" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31238" href="../Induction/#plfa_plfa-part1-Induction-31208" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31240" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31242" href="../Induction/#plfa_plfa-part1-Induction-31210" class="Bound">p</a><a id="plfa_plfa-part1-Induction-31243" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-31245" href="../Induction/#plfa_plfa-part1-Induction-31192" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31254" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-31262" href="../Induction/#plfa_plfa-part1-Induction-31262" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31264" href="../Induction/#plfa_plfa-part1-Induction-31264" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-31291" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31294" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-31299" href="../Induction/#plfa_plfa-part1-Induction-31192" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31308" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31309" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-31313" href="../Induction/#plfa_plfa-part1-Induction-31313" class="Bound">m</a><a id="plfa_plfa-part1-Induction-31314" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31316" href="../Induction/#plfa_plfa-part1-Induction-31316" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31318" href="../Induction/#plfa_plfa-part1-Induction-31318" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31321" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-31329" href="../Induction/#plfa_plfa-part1-Induction-31192" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31338" href="../Induction/#plfa_plfa-part1-Induction-31313" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31340" href="../Induction/#plfa_plfa-part1-Induction-31316" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31342" href="../Induction/#plfa_plfa-part1-Induction-31318" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31345" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31348" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。一个项等于其自身的证明写作 <code>refl</code>（自反性）。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>其证明同样由 <code>refl</code> 给出。改写不仅可以省去等式链还可以避免调用 <code>cong</code>.</p><h2 id="使用改写证明交换律">使用改写证明交换律</h2><p>下面是加法交换律的第二个证明，使用 <code>rewrite</code> 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-32718" href="../Induction/#plfa_plfa-part1-Induction-32718" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32730" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32732" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32734" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32735" href="../Induction/#plfa_plfa-part1-Induction-32735" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32737" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32739" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32740" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32742" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32744" href="../Induction/#plfa_plfa-part1-Induction-32735" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32746" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32748" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32753" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32755" href="../Induction/#plfa_plfa-part1-Induction-32735" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-32757" href="../Induction/#plfa_plfa-part1-Induction-32718" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32769" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32774" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32776" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32781" href="../Induction/#plfa_plfa-part1-Induction-32718" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32793" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32794" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32798" href="../Induction/#plfa_plfa-part1-Induction-32798" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32799" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32801" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32809" href="../Induction/#plfa_plfa-part1-Induction-32718" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32821" href="../Induction/#plfa_plfa-part1-Induction-32798" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32823" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32825" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-32831" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32838" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32840" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32842" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32843" href="../Induction/#plfa_plfa-part1-Induction-32843" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32845" href="../Induction/#plfa_plfa-part1-Induction-32845" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32847" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32849" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32850" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32852" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32854" href="../Induction/#plfa_plfa-part1-Induction-32843" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32856" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32858" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32862" href="../Induction/#plfa_plfa-part1-Induction-32845" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32864" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32866" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32870" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32871" href="../Induction/#plfa_plfa-part1-Induction-32843" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32873" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32875" href="../Induction/#plfa_plfa-part1-Induction-32845" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32876" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-32878" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32885" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32890" href="../Induction/#plfa_plfa-part1-Induction-32890" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32892" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32894" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32899" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32906" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32907" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32911" href="../Induction/#plfa_plfa-part1-Induction-32911" class="Bound">m</a><a id="plfa_plfa-part1-Induction-32912" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32914" href="../Induction/#plfa_plfa-part1-Induction-32914" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32916" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32924" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32931" href="../Induction/#plfa_plfa-part1-Induction-32911" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32933" href="../Induction/#plfa_plfa-part1-Induction-32914" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32935" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32937" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-32943" href="../Induction/#plfa_plfa-part1-Induction-32943" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32951" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32953" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32955" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32956" href="../Induction/#plfa_plfa-part1-Induction-32956" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32958" href="../Induction/#plfa_plfa-part1-Induction-32958" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32960" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32962" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32963" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32965" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32967" href="../Induction/#plfa_plfa-part1-Induction-32956" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32969" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32971" href="../Induction/#plfa_plfa-part1-Induction-32958" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32973" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32975" href="../Induction/#plfa_plfa-part1-Induction-32958" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32977" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32979" href="../Induction/#plfa_plfa-part1-Induction-32956" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-32981" href="../Induction/#plfa_plfa-part1-Induction-32943" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32989" href="../Induction/#plfa_plfa-part1-Induction-32989" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32991" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32996" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-33004" href="../Induction/#plfa_plfa-part1-Induction-32718" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-33016" href="../Induction/#plfa_plfa-part1-Induction-32989" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-33018" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-33020" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-33025" href="../Induction/#plfa_plfa-part1-Induction-32943" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-33033" href="../Induction/#plfa_plfa-part1-Induction-33033" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-33035" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-33036" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-33040" href="../Induction/#plfa_plfa-part1-Induction-33040" class="Bound">n</a><a id="plfa_plfa-part1-Induction-33041" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-33043" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-33051" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-33058" href="../Induction/#plfa_plfa-part1-Induction-33033" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-33060" href="../Induction/#plfa_plfa-part1-Induction-33040" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-33062" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-33064" href="../Induction/#plfa_plfa-part1-Induction-32943" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-33072" href="../Induction/#plfa_plfa-part1-Induction-33033" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-33074" href="../Induction/#plfa_plfa-part1-Induction-33040" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-33076" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-33078" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>在最后一行中，用两个等式进行改写被表示为用一条竖线分隔两个相关等式的证明。 左边的改写会在右边之前被执行。</p><h2 id="交互式构造证明">交互式构造证明</h2><p>看看如何在 Emacs 中用 Agda 的交互式特性来构造另一种结合律的证明会很有启发性。 我们从输入以下内容开始：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>其中的问号表示你想要 Agda 帮你填充的代码。如果你按下 <code>C-c C-l</code> （先按 Ctrl-c 再按 Ctrl-l），那么问号会被替换为：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>空的大括号叫做<strong>洞（Hole）</strong>，0 是用来指代此洞的编号。洞可能会以绿色高亮显示。 Emacs 还会在屏幕下方创建一个新的窗口并显示文本：</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>这表示 0 号洞需要以所提示的判断的证明来填充。</p><p>我们希望对 <code>m</code> 进行归纳来证明此命题。将光标移动到洞中并按下 <code>C-c C-c</code>。它会给出提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>按下 <code>m</code> 会拆分该变量，并更新此代码：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>现在有两个洞了，下方的窗口会告诉你每个洞中需要证明的内容：</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>进入 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>它表示在化简之后，0 号洞的目标如上所示，所示类型的变量 <code>p</code> 和 <code>n</code> 可在证明中使用。 给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充。按下 <code>C-c C-l</code> 会将剩下的洞重新编号为 0：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>进入新的 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>同样，它会给出化简后的目标和可用的变量。在此步骤中，我们需要根据归纳假设进行改写， 于是我们来编辑这些文本：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>进入剩下的洞中并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充并完成证明：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">练习：<code>+-swap</code>（推荐）</h4><p>请证明对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>成立。无需归纳证明，只需应用前面满足结合律和交换律的结果即可。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37599" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-distrib-plus">练习 <code>*-distrib-+</code>（推荐）</h4><p>请证明乘法对加法满足分配律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37939" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-assoc">练习 <code>*-assoc</code>（推荐）</h4><p>请证明乘法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38241" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-comm">练习 <code>*-comm</code>（实践）</h4><p>请证明乘法满足交换律，即对于所有的自然数 <code>m</code> 和 <code>n</code>，</p><pre><code>m * n ≡ n * m</code></pre><p>成立。和加法交换律一样，你需要陈述并证明配套的引理。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38627" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="zero-monus">练习 <code>0∸n≡0</code>（实践）</h4><p>请证明对于所有的自然数 <code>n</code>，</p><pre><code>zero ∸ n ≡ zero</code></pre><p>成立。你的证明需要归纳法吗？</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38883" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="monus-plus-assoc">练习 <code>∸-+-assoc</code>（实践）</h4><p>请证明饱和减法与加法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39206" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-延伸">练习 <code>+*^</code> （延伸）</h4><p>证明下列三条定律</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>对于所有 <code>m</code>、<code>n</code> 和 <code>p</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39562" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="Bin-laws">练习 <code>Bin-laws</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a> 中定义的一种表示自然数的比特串数据类型 <code>Bin</code> 以及要求你定义的函数：</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>考虑以下定律，其中 <code>n</code> 表示自然数，<code>b</code> 表示比特串：</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>对于每一条定律：若它成立，请证明；若不成立，请给出一个反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40273" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>本章中类似的定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40449" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-40456" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-40476" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-40482" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-40483" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15309" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-40490" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40492" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15465" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-40503" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40505" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15101" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-40510" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40512" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#15642" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-40518" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章中使用了以下 Unicode：</p><pre><code>∀  U+2200  对于所有 (\forall, \all)
ʳ  U+02B3  修饰符小写字母 r (\^r)
′  U+2032  撇号 (\&#39;)
″  U+2033  双撇号 (\&#39;)
‴  U+2034  三撇号 (\&#39;)
⁗  U+2057  四撇号 (\&#39;)</code></pre><p>与 <code>\r</code> 类似，命令 <code>\^r</code> 列出了多种上标右箭头的变体，以及上标的字母 <code>r</code>。 命令 <code>\&#39;</code> 列出了一些撇号（<code>′ ″ ‴ ⁗</code>）。</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Oling Cat<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>