<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon" aria-hidden="true"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book" aria-hidden="true"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Induction: 归纳证明</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-116" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-123" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-144" class="Keyword">where</a>
</pre><blockquote><p>归纳会让你对无中生有感到内疚 ……但它却是文明中最伟大的思想之一。 —— Herbert Wilf</p></blockquote><p>现在我们定义了自然数及其运算，下一步是学习如何证明它们满足的性质。 顾名思义，<strong>归纳数据类型（Inductive Datatype）</strong>是通过<strong>归纳（Induction）</strong> 来证明的。</p><h2 id="导入">导入</h2><p>我们需要上一章中的相等性，加上自然数及其运算。我们还导入了一些新的运算： <code>cong</code>、<code>sym</code> 和 <code>_≡⟨_⟩_</code>，之后会解释它们：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-1009" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1016" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-1054" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-1057" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-1060" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1065" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-1068" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1075" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-1078" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1080" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-1084" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1086" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Induction-1090" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1092" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Induction-1095" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1097" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1102" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-1117" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1123" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1124" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-1130" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1132" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">_≡⟨⟩_</a><a id="plfa_plfa-part1-Induction-1137" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1139" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">step-≡</a><a id="plfa_plfa-part1-Induction-1145" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1147" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-1149" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1151" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1156" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1163" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-1172" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1178" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-1180" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-1186" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-1191" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-1196" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-1201" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1203" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-1206" class="Symbol">;</a><a id="plfa_plfa-part1-Induction-1207" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#3471" class="Function Operator">_^_</a><a id="plfa_plfa-part1-Induction-1210" class="Symbol">)</a>
</pre><p>(Importing <code>step-≡</code> defines <code>_≡⟨_⟩_</code>.)</p><h2 id="运算符的性质">运算符的性质</h2><p>运算符随处可见，而数学家们统一了一些最常见的性质的名称。</p><ul><li><p><strong>幺元（Identity）</strong>：对于所有的 <code>n</code>，若 <code>0 + n ≡ n</code>，则 <code>+</code> 有左幺元 <code>0</code>； 若 <code>n + 0 ≡ n</code>，则 <code>+</code> 有右幺元 <code>0</code>。同时为左幺元和右幺元的值称简称幺元。 幺元有时也称作<strong>单位元（Unit）</strong>。</p></li><li><p><strong>结合律（Associativity）</strong>：若括号的位置无关紧要，则称运算符 <code>+</code> 满足结合律， 即对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，有 <code>(m + n) + p ≡ m + (n + p)</code>。</p></li><li><p><strong>交换律（Commutativity）</strong>：若参数的顺序无关紧要，则称运算符 <code>+</code> 满足交换律， 即对于所有的 <code>m</code> 和 <code>n</code>，有 <code>m + n ≡ n + m</code>。</p></li><li><p><strong>分配律（Distributivity）</strong>：对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>m * (p + q) ≡ (m * p) + (m * q)</code>，则运算符 <code>*</code> 对运算符 <code>+</code> 满足左分配律； 对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>(m + n) * p ≡ (m * p) + (n * p)</code>，则满足右分配律。</p></li></ul><p>加法的幺元为 <code>0</code>，乘法的幺元为 <code>1</code>。加法和乘法都满足结合律和交换律， 乘法对加法满足分配律。</p><p>如果你在一个舞会上碰见了一位操作员，那么你可以跟他闲聊，问问他是否有单位元， 能不能结合或者交换。如果你碰见了两位操作员，那么可以问他们某一位是否在另一位上面分布。</p><p>【译注：作者的双关冷笑话，运算符（Operator）也有操作员的意思。】</p><p>正经来说，如果你在阅读技术论文时遇到了一个运算符，那么你可以考察它是否拥有幺元， 是否满足结合律或分配律，或者是否对另一个运算符满足分配律，这能为你提供一种视角。 细心的作者通常会指出它们是否满足这些性质，比如说指明一个新引入的运算符满足结合律 但不满足交换律。</p><h4 id="operators">练习 <code>operators</code>（实践）</h4><p>请给出另一对运算符，它们拥有一个幺元，满足结合律、交换律，且其中一个对另一个满足分配律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4206" class="Comment">-- 请将代码写在此处。</a>
</pre><p>请给出一个运算符的例子，它拥有幺元、满足结合律但不满足交换律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4382" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="结合律">结合律</h2><p>加法的一个性质是满足<strong>结合律</strong>，即括号的位置无关紧要：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的变量 <code>m</code>、<code>n</code> 和 <code>p</code> 的取值范围都是全体自然数。</p><p>我们可以为这三个变量选取特定的数值来验证此命题：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4870" href="../Induction/#plfa_plfa-part1-Induction-4870" class="Function">_</a> <a id="plfa_plfa-part1-Induction-4872" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-4874" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4875" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4879" class="Number">4</a><a id="plfa_plfa-part1-Induction-4880" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4884" class="Number">5</a> <a id="plfa_plfa-part1-Induction-4886" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-4888" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4890" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4892" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4893" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4895" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4897" class="Number">5</a><a id="plfa_plfa-part1-Induction-4898" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-4900" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-4902" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-4906" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-4916" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4917" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4919" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4921" class="Number">4</a><a id="plfa_plfa-part1-Induction-4922" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4926" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4930" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4938" class="Number">7</a> <a id="plfa_plfa-part1-Induction-4940" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4942" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4946" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4954" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-4959" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4967" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4971" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-4975" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4983" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4985" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4987" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4988" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4990" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4992" class="Number">5</a><a id="plfa_plfa-part1-Induction-4993" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-4997" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在这里，我们将计算过程写成了等式链，每行一个式子。这样的等式链通常非常易读， 你可以从上到下，直到遇到最简形式（本例中为 <code>12</code>），也可以从下到上，直到回到同样的式子。</p><p>该测试揭示了结合律可能没有它初看起来那么显然。为什么 <code>7 + 5</code> 与 <code>3 + 9</code> 相同？ 我们可能需要收集更多证据，选择其它的数值来验证此命题。但由于自然数是无限的， 因此测试永远无法完成。那么我们还有其它可以确保结合律对于<strong>所有</strong>自然数都成立的方法吗？</p><p>当然有！我们可以用<strong>归纳证明（Proof by Induction）</strong> 来确保某个性质对于所有的自然数都成立。</p><h2 id="归纳证明">归纳证明</h2><p>回想自然数的定义，它由一个<strong>起始步骤</strong>「<code>zero</code> 是一个自然数」 和一个<strong>归纳步骤</strong>「若 <code>m</code> 是一个自然数，则 <code>suc m</code> 也是一个自然数」构成。</p><p>归纳证明遵循此定义的结构。要通过归纳证明自然数的某个性质，我们需要两个步骤。 其一是<strong>起始步骤</strong>，即需要证明此性质对 <code>zero</code> 成立。其二是<strong>归纳步骤</strong>， 即假设此性质对一个任意自然数 <code>m</code> 成立（我们称之为<strong>归纳假设（Induction Hypothesis）</strong>），然后证明该性质对 <code>suc m</code> 必定成立。</p><p>若将 <code>m</code> 的某种性质（Property）写作 <code>P m</code>，那么我们需要证明的就是以下两个推导规则：</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>先来分析一下这些规则。第一条规则是起始步骤，它需要我们证明性质 <code>P</code> 对 <code>zero</code> 成立。第二条规则是归纳步骤，它需要我们证明若归纳假设「<code>P</code> 对 <code>m</code> 成立」， 那么 <code>P</code> 也对 <code>suc m</code> 成立。</p><p>为什么可以这样做呢？它也可以用创世故事来讲解。起初，我们对性质一无所知：</p><pre><code>-- 起初，世上没有已知的性质。</code></pre><p>现在我们对所有已知的性质应用上述两条规则。起始步骤告诉我们 <code>P zero</code> 成立， 所以我们将它加入已知的性质集合中。归纳步骤告诉我们若「昨天的」<code>P m</code> 成立， 那么「今天的」<code>P (suc m)</code> 也成立。我们在今天之前并不知道任何性质， 因此归纳步骤在这里不适用：</p><pre><code>-- 第一天，我们知道了一个性质。
P zero</code></pre><p>然后我们重复此过程。在接下来的一天我们知道今天之前的所有性质， 以及任何通过此规则添加的性质。起始步骤告诉我们 <code>P zero</code> 成立，我们已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>P zero</code> 在昨天成立，那么 <code>P (suc zero)</code> 今天也成立。</p><pre><code>-- 第二天，我们知道了两个性质。
P zero
P (suc zero)</code></pre><p>我们再重复此过程。现在归纳步骤告诉我们由于 <code>P zero</code> 和 <code>P (suc zero)</code> 都成立， 因此 <code>P (suc zero)</code> 和 <code>P (suc (suc zero))</code> 也成立。我们已经知道第一个成立了， 但第二个是新引入的：</p><pre><code>-- 第三天，我们知道了三个性质。
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了四个性质。
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的性质成立。 每个自然数的性质都会在某一天出现。具体来说，性质 <code>P n</code> 会在第 <em>n+1</em> 天 首次出现。</p><h2 id="第一个证明结合律">第一个证明：结合律</h2><p>要证明结合律，我们需要将 <code>P m</code> 看做以下性质：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的 <code>n</code> 和 <code>p</code> 是任意自然数，因此若我们可以证明该等式对所有的 <code>m</code> 都成立，那么它也会对所有的 <code>n</code> 和 <code>p</code> 成立。其推理规则的对应实例如下：</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>如果我们可以证明这两条规则，那么加法结合律就可以用归纳法来证明。</p><p>以下为此性质的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-11122" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11130" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11132" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11134" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11135" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11137" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11139" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11141" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11144" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11146" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11148" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11149" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11151" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11153" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11154" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11156" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11158" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11160" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11162" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11166" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11167" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11169" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11171" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11172" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11174" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11187" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11189" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11191" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11195" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11205" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11206" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11211" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11213" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11214" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11216" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11218" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11222" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11230" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11232" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11234" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11238" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11246" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11251" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11253" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11254" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11256" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11258" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11259" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11263" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-11265" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11273" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11274" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11278" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a><a id="plfa_plfa-part1-Induction-11279" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11281" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11283" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11285" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11289" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11299" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11300" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11304" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11306" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11308" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11309" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11311" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11313" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11317" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11325" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11329" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11330" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11334" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11335" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11339" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11343" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11355" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11357" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11359" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11361" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11362" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11364" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11366" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11367" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11371" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11374" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11379" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11383" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11384" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11392" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11394" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11396" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11397" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11399" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11405" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11409" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11410" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11412" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11414" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11415" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11417" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11419" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11420" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11425" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11433" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11437" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11439" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11441" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11442" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11446" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11447" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11451" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们将此证明命名为 <code>+-assoc</code>。在 Agda 中，标识符可以由除空格和 <code>@.(){};_</code> 之外的任何字符序列构成。</p><p>我们来分析一下这段代码。其签名（Signature）描述了我们定义的标识符 <code>+-assoc</code> 为以下命题提供了证据（Evidence）：</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>倒 A 符号读作「对于所有（for all）」，而该命题断言对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，等式 <code>(m + n) + p ≡ m + (n + p)</code> 成立。该命题的证据是一个接受三个自然数的函数， 将它们绑定到 <code>m</code>、<code>n</code> 和 <code>p</code>，并返回该等式对应实例的证据。</p><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>用加法的起始步骤化简等式两边会得到：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。阅读此证明中起始步骤中的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们在中间遇到 <code>n + p</code> 。此步骤无需多言，化简即可。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>用加法的归纳步骤化简等式两边会得到：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此证明中归纳步骤的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们到达上面化简等式的地方。剩下的等式单化简还不行， 我们还需要为推理链使用一个附加的运算符 <code>_≡⟨_⟩_</code>， 并将等式的依据放在尖括号中。这里给出的依据是：</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>在这里，递归调用的 <code>+-assoc m n p</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。</p><p>若某个关系在应用了给定的函数后仍然保持不变，则称该关系满足<strong>合同性（Congruence）</strong>。 若 <code>e</code> 是 <code>x ≡ y</code> 的证据，那么对于任意函数 <code>f</code>，<code>cong f e</code> 就是 <code>f x ≡ f y</code> 的证据。</p><p>在这里并未假定归纳假设，而是通过递归调用我们定义的函数 <code>+-assoc m n p</code> 来证明。 对于加法，这是良基的（well-founded），因为更大数值的结合律可基于更小数值的结合律 来证明。在此步骤中，<code>assoc (suc m) n p</code> 是用 <code>assoc m n p</code> 证明的。 归纳证明和递归定义之间的这种对应是 Agda 中最吸引人的方面之一。</p><h2 id="归纳即递归">归纳即递归</h2><p>下面是归纳如何对应于递归的具体例子，它是在结合律的证明中，将 <code>m</code> 实例化为 <code>2</code> 时的计算过程。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-0"></a><a id="plfa_plfa-part1-Induction-15663" href="../Induction/#plfa_plfa-part1-Induction-15663" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15673" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15675" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15677" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15678" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15680" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15682" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15685" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15687" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15689" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15690" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15692" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15694" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15695" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15697" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15699" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15701" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15703" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15707" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15708" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15712" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15713" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15715" href="../Induction/#plfa_plfa-part1-Induction-15663" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15725" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15727" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15729" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15733" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15743" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15744" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15746" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15748" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15749" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15751" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15753" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15757" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15765" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15767" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15769" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15773" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15781" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15783" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15785" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15786" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15788" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15790" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15791" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15795" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-1"></a><a id="plfa_plfa-part1-Induction-15798" href="../Induction/#plfa_plfa-part1-Induction-15798" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15808" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15810" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15812" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15813" href="../Induction/#plfa_plfa-part1-Induction-15813" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15815" href="../Induction/#plfa_plfa-part1-Induction-15815" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15817" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15819" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15820" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15822" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15824" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15825" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15827" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15829" href="../Induction/#plfa_plfa-part1-Induction-15813" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15830" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15832" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15834" href="../Induction/#plfa_plfa-part1-Induction-15815" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15836" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15838" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15840" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15842" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15843" href="../Induction/#plfa_plfa-part1-Induction-15813" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15845" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15847" href="../Induction/#plfa_plfa-part1-Induction-15815" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15848" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15850" href="../Induction/#plfa_plfa-part1-Induction-15798" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15860" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15862" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15864" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15868" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15878" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15879" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15881" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15883" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15884" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15886" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15888" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15892" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15900" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15904" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15905" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15907" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15909" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15910" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15912" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15914" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15918" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15926" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15930" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-15932" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15934" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15936" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15937" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15939" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15941" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15942" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15946" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-15949" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-15954" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15958" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15959" href="../Induction/#plfa_plfa-part1-Induction-15663" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15969" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15971" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15972" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15974" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-15980" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15984" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15985" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15987" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15989" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15990" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15992" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15994" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15995" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-16000" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16008" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16010" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16012" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16013" href="../Induction/#plfa_plfa-part1-Induction-15860" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16015" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16017" href="../Induction/#plfa_plfa-part1-Induction-15862" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16018" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16022" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-16025" href="../Induction/#plfa_plfa-part1-Induction-16025" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16035" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16037" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16039" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16040" href="../Induction/#plfa_plfa-part1-Induction-16040" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16042" href="../Induction/#plfa_plfa-part1-Induction-16042" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16044" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16046" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16047" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16049" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16051" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16052" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16054" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16056" href="../Induction/#plfa_plfa-part1-Induction-16040" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16057" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16059" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16061" href="../Induction/#plfa_plfa-part1-Induction-16042" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16063" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16065" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16067" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16069" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16070" href="../Induction/#plfa_plfa-part1-Induction-16040" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16072" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16074" href="../Induction/#plfa_plfa-part1-Induction-16042" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16075" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-16077" href="../Induction/#plfa_plfa-part1-Induction-16025" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16087" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16089" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16091" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-16095" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-16105" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16106" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16108" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16110" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16111" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16115" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16119" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16127" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16131" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16132" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16134" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16136" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16137" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16139" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16141" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16145" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16153" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16157" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16159" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16161" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16163" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16164" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16166" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16168" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16169" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16173" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16176" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16181" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16185" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16186" href="../Induction/#plfa_plfa-part1-Induction-15798" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-16196" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16198" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16199" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16201" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16207" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16211" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16212" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16214" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16216" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16217" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16219" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16221" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16222" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-16227" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16235" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16239" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16240" href="../Induction/#plfa_plfa-part1-Induction-16087" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16242" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16244" href="../Induction/#plfa_plfa-part1-Induction-16089" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16245" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16249" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h2 id="术语与记法">术语与记法</h2><p>在结合律的陈述中出现的符号 <code>∀</code> 表示它对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code> 都成立。 我们将 <code>∀</code> 称为<strong>全称量词（Universal Quantifier）</strong>，我们会在 <a href="../Quantifiers/">Quantifiers</a> 章节中进一步讨论。</p><p>全称量词的证据是一个函数。函数签名</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>和</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>是等价的。和 <code>ℕ → ℕ → ℕ</code> 这样的函数类型不同，上述函数中的变量 与每一个实参类型相关联，且其结果类型可能会涉及（或依赖于）这些变量， 因此它们叫做<strong>依赖函数（Dependent Function）</strong>。</p><p>Ordinary functions are a special case of dependent functions. For instance, the signatures</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m n : ℕ) → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m : ℕ) → ∀ (n : ℕ) → ℕ</code></pre><p>are all equivalent.</p><h2 id="第二个证明交换律">第二个证明：交换律</h2><p>加法的另一个重要性质是满足<strong>交换律（Commutativity）</strong>，即运算数的顺序无关紧要：</p><pre><code>m + n ≡ n + m</code></pre><p>要证明它，我们需要先证明两条引理（Lemma）。</p><h3 id="第一条引理">第一条引理</h3><p>加法定义的起始步骤说明零是一个左幺元：</p><pre><code>zero + n ≡ n</code></pre><p>我们的第一条引理则说明零也是一个右幺元：</p><pre><code>m + zero ≡ m</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-18207" href="../Induction/#plfa_plfa-part1-Induction-18207" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18219" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18221" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18223" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18224" href="../Induction/#plfa_plfa-part1-Induction-18224" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18226" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18228" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18229" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18231" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18233" href="../Induction/#plfa_plfa-part1-Induction-18224" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18235" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18242" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18244" href="../Induction/#plfa_plfa-part1-Induction-18224" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-18246" href="../Induction/#plfa_plfa-part1-Induction-18207" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18258" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18263" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18267" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18277" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18282" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18284" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18291" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18299" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18306" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-18308" href="../Induction/#plfa_plfa-part1-Induction-18207" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18320" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18321" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18325" href="../Induction/#plfa_plfa-part1-Induction-18325" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18326" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18328" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18332" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18342" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18346" href="../Induction/#plfa_plfa-part1-Induction-18325" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18348" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18350" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18357" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18365" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18369" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18370" href="../Induction/#plfa_plfa-part1-Induction-18325" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18372" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-18378" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18382" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18385" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18394" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18395" href="../Induction/#plfa_plfa-part1-Induction-18207" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18407" href="../Induction/#plfa_plfa-part1-Induction-18325" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18408" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18410" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18416" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18420" href="../Induction/#plfa_plfa-part1-Induction-18325" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-18424" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-identityʳ</code> 提供了以下命题的证据：</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>该命题的证据是一个函数，它接受一个自然数，将其绑定到 <code>m</code>，然后返回 该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + zero ≡ zero</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m) + zero = suc m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + zero) = suc m</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + zero ≡ m</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此等式链，从上到下和从下到上读都会让我们到达上面化简等式的地方。 剩下的等式可由以下依据得出：</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>在这里，递归调用的 <code>+-identityʳ m</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第一条引理证毕。</p><h3 id="第二条引理">第二条引理</h3><p>加法定义的归纳步骤将第一个参数的 <code>suc</code> 推到了外面：</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>我们的第二条引理则对第二个参数的 <code>suc</code> 做同样的事情：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-20425" href="../Induction/#plfa_plfa-part1-Induction-20425" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20431" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20433" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-20435" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20436" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20438" href="../Induction/#plfa_plfa-part1-Induction-20438" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20440" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20442" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-20443" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20445" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-20447" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20449" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20451" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20455" href="../Induction/#plfa_plfa-part1-Induction-20438" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20457" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-20459" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20463" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20464" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20466" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20468" href="../Induction/#plfa_plfa-part1-Induction-20438" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20469" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-20471" href="../Induction/#plfa_plfa-part1-Induction-20425" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20482" href="../Induction/#plfa_plfa-part1-Induction-20482" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20484" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20488" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20498" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20503" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20505" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20509" href="../Induction/#plfa_plfa-part1-Induction-20482" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20513" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20521" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20525" href="../Induction/#plfa_plfa-part1-Induction-20482" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20529" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20537" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20541" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20542" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20547" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20549" href="../Induction/#plfa_plfa-part1-Induction-20482" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20550" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20554" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-20556" href="../Induction/#plfa_plfa-part1-Induction-20425" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20562" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20567" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a><a id="plfa_plfa-part1-Induction-20568" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20570" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20572" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20576" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20586" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20590" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20592" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20598" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20602" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20614" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20615" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20617" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20619" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20623" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20624" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20628" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-20631" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-20636" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20640" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20641" href="../Induction/#plfa_plfa-part1-Induction-20425" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20647" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20649" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20650" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20652" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-20658" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20662" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20667" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20668" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20670" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20672" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20673" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-20678" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20686" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20690" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20691" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20695" href="../Induction/#plfa_plfa-part1-Induction-20567" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20697" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20699" href="../Induction/#plfa_plfa-part1-Induction-20570" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20700" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20704" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-suc</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>从上到下或从下到上阅读等式链都会让我们在中间遇到化简后的等式。剩下的等式 可由以下依据得出：</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>在这里，递归调用的 <code>+-suc m n</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第二条引理证毕。</p><h3 id="命题">命题</h3><p>最后，以下是我们的命题的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-22475" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22482" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22484" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22486" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22487" href="../Induction/#plfa_plfa-part1-Induction-22487" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22489" href="../Induction/#plfa_plfa-part1-Induction-22489" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22491" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22494" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22496" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22498" href="../Induction/#plfa_plfa-part1-Induction-22487" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22500" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22502" href="../Induction/#plfa_plfa-part1-Induction-22489" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22504" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22506" href="../Induction/#plfa_plfa-part1-Induction-22489" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22508" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22510" href="../Induction/#plfa_plfa-part1-Induction-22487" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-22512" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22519" href="../Induction/#plfa_plfa-part1-Induction-22519" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22521" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22526" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22530" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22540" href="../Induction/#plfa_plfa-part1-Induction-22519" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22542" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22544" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-22551" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22554" href="../Induction/#plfa_plfa-part1-Induction-18207" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-22566" href="../Induction/#plfa_plfa-part1-Induction-22519" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22568" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22574" href="../Induction/#plfa_plfa-part1-Induction-22519" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22578" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22586" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22591" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22593" href="../Induction/#plfa_plfa-part1-Induction-22519" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22597" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-22599" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22606" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22608" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22609" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22613" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22614" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22616" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22620" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22630" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22632" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22634" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22638" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-22642" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22645" href="../Induction/#plfa_plfa-part1-Induction-20425" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-22651" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22653" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22655" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22661" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22665" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22666" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22670" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22671" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22675" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22678" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-22683" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22687" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22688" href="../Induction/#plfa_plfa-part1-Induction-22475" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22695" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22697" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22698" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22700" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22710" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22711" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22713" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22715" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22716" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22720" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22728" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22732" href="../Induction/#plfa_plfa-part1-Induction-22613" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22734" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22736" href="../Induction/#plfa_plfa-part1-Induction-22606" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22740" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行说明我们定义的标识符 <code>+-comm</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>n</code> 进行归纳来证明。（这次不是 <code>m</code>！）</p><p>对于起始步骤，我们必须证明：</p><pre><code>m + zero ≡ zero + m</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>m + zero ≡ m</code></pre><p>剩下的等式可由依据 <code>⟨ +-identityʳ m ⟩</code> 得出，它调用第一条引理。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>我们分两步来证明它。首先，我们有：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>它依据第二条引理 <code>⟨ +-suc m n ⟩</code> 得出。之后我们有：</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>它依据合同性和归纳假设 <code>⟨ cong suc (+-comm m n) ⟩</code> 得出。证毕。</p><p>Agda 要求标识符必须在使用前定义，因此我们必须在主命题之前列出引理， 如前例所示。在实践中，我们通常会先试着证明主命题，之后所需的等式会说明 需要证明哪些引理。</p><h2 id="sections">第一个推论：重排定理</h2><p>我们可以随意应用结合律来重排括号。例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-24882" href="../Induction/#plfa_plfa-part1-Induction-24882" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24894" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24896" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-24898" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24899" href="../Induction/#plfa_plfa-part1-Induction-24899" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24901" href="../Induction/#plfa_plfa-part1-Induction-24901" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24903" href="../Induction/#plfa_plfa-part1-Induction-24903" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24905" href="../Induction/#plfa_plfa-part1-Induction-24905" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24907" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24909" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-24910" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24912" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-24914" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24915" href="../Induction/#plfa_plfa-part1-Induction-24899" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24917" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24919" href="../Induction/#plfa_plfa-part1-Induction-24901" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24920" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24922" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24924" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24925" href="../Induction/#plfa_plfa-part1-Induction-24903" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24927" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24929" href="../Induction/#plfa_plfa-part1-Induction-24905" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24930" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24932" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-24934" href="../Induction/#plfa_plfa-part1-Induction-24899" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24936" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24938" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24939" href="../Induction/#plfa_plfa-part1-Induction-24901" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24941" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24943" href="../Induction/#plfa_plfa-part1-Induction-24903" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24944" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24946" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24948" href="../Induction/#plfa_plfa-part1-Induction-24905" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-24950" href="../Induction/#plfa_plfa-part1-Induction-24882" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24962" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24964" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24966" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24968" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24970" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-24974" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-24984" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24985" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24987" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24989" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24990" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24992" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24994" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24995" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24997" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24999" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25000" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-25004" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-25007" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-25011" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25012" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25020" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25021" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25023" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25025" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25026" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25028" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25030" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25031" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25033" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25039" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-25041" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25043" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25045" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25046" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25048" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25050" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25051" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25053" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25055" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25059" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-25062" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-25067" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25068" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-25071" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25072" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25075" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25083" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25085" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25087" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25088" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25090" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25096" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25097" href="../Induction/#plfa_plfa-part1-Induction-24962" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25099" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25101" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25102" href="../Induction/#plfa_plfa-part1-Induction-24964" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25104" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25106" href="../Induction/#plfa_plfa-part1-Induction-24966" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25107" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-25110" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25112" href="../Induction/#plfa_plfa-part1-Induction-24968" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25116" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>无需归纳法，我们只不过应用了两次结合律就完成了证明。其中有几点需要注意的地方。</p><p>第一，加法是左结合的，因此 <code>m + (n + p) + q</code> 表示 <code>(m + (n + p)) + q</code>。</p><p>第二，我们用 <code>sym</code> 来交换等式的两边。命题 <code>+-assoc (m + n) p q</code> 会将括号从左边移到右边：</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>要往另一个方向移动括号，我们要用 <code>sym (+-assoc (m + n) p q)</code>：</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>一般来说，若 <code>e</code> 提供了 <code>x ≡ y</code> 的证据，那么 <code>sym e</code> 就提供了 <code>y ≡ x</code> 的证据。</p><p>第三，Agda 支持 Richard Bird 引入的<strong>片段（Section）</strong>记法。我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(_+ y)</code>。因此，对于 <code>assoc m n p</code> 应用合同性 <code>cong (_+ q)</code> 会将等式：</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>转换成:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>类似地，我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(x +_ )</code>。 这同样适用于任何中缀运算符。</p><h2 id="创世最后一次">创世，最后一次</h2><p>我们回到结合律的证明上来，把归纳证明（或等价的递归定义）看做一个创世故事会有助于理解。 这次我们专注于判断结合律的断言：</p><pre><code> -- 起初，我们对结合律一无所知。</code></pre><p>现在，我们将规则应用到所有已知的判断上来。起始步骤告诉我们对于所有的自然数 <code>n</code> 和 <code>p</code> 来说，<code>(zero + n) + p ≡ zero + (n + p)</code>。归纳步骤告我我们若 <code>(m + n) + p ≡ m + (n + p)</code>（在昨天）成立，那么 <code>(suc m + n) + p ≡ suc m + (n + p)</code> （在今天）也成立。我们在今天之前并不知道任何关于结合律的判断， 因此此规则并未给出任何新的判断：</p><pre><code>-- 第一天，我们知道了关于 0 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>之后我们重复此过程，因此接下来一天我们知道今天以前的所有判断， 以及任何通过此规则添加的判断。起始步骤并未告诉我们新的东西， 而如今归归纳步骤添加了更多的判断：</p><pre><code>-- 第二天，我们知道了关于 0 和 1 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>我们再次重复此过程：</p><pre><code>-- 第三天，我们知道了关于 0、1 和 2 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了关于 0、1、2 和 3 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们会知道所有第一个数小于 <em>m</em> 的判断。</p><p>还有一种完全有限的方法来生成同样的等式，它的证明留作读者的练习。</p><h4 id="finite-plus-assoc">练习 <code>finite-+-assoc</code>（延伸）</h4><p>请参考<a href="../Naturals/#finite-creation">前文</a>写出前四天已知的加法结合律的创世故事。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-30777" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="用改写来证明结合律">用改写来证明结合律</h2><p>证明可不止一种方法。下面是第二种在 Agda 中证明加法结合律的方法，使用 <code>rewrite</code>（改写） 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-31080" href="../Induction/#plfa_plfa-part1-Induction-31080" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31089" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31091" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-31093" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31094" href="../Induction/#plfa_plfa-part1-Induction-31094" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31096" href="../Induction/#plfa_plfa-part1-Induction-31096" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31098" href="../Induction/#plfa_plfa-part1-Induction-31098" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31100" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-31103" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31105" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-31107" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31108" href="../Induction/#plfa_plfa-part1-Induction-31094" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31110" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31112" href="../Induction/#plfa_plfa-part1-Induction-31096" class="Bound">n</a><a id="plfa_plfa-part1-Induction-31113" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31115" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31117" href="../Induction/#plfa_plfa-part1-Induction-31098" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-31121" href="../Induction/#plfa_plfa-part1-Induction-31094" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31123" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31125" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31126" href="../Induction/#plfa_plfa-part1-Induction-31096" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31128" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31130" href="../Induction/#plfa_plfa-part1-Induction-31098" class="Bound">p</a><a id="plfa_plfa-part1-Induction-31131" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-31133" href="../Induction/#plfa_plfa-part1-Induction-31080" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31142" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-31150" href="../Induction/#plfa_plfa-part1-Induction-31150" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31152" href="../Induction/#plfa_plfa-part1-Induction-31152" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-31179" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-31187" href="../Induction/#plfa_plfa-part1-Induction-31080" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31196" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31197" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-31201" href="../Induction/#plfa_plfa-part1-Induction-31201" class="Bound">m</a><a id="plfa_plfa-part1-Induction-31202" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31204" href="../Induction/#plfa_plfa-part1-Induction-31204" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31206" href="../Induction/#plfa_plfa-part1-Induction-31206" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31209" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-31217" href="../Induction/#plfa_plfa-part1-Induction-31080" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31226" href="../Induction/#plfa_plfa-part1-Induction-31201" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31228" href="../Induction/#plfa_plfa-part1-Induction-31204" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31230" href="../Induction/#plfa_plfa-part1-Induction-31206" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31233" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31236" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。一个项等于其自身的证明写作 <code>refl</code>（自反性）。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>其证明同样由 <code>refl</code> 给出。改写不仅可以省去等式链还可以避免调用 <code>cong</code>.</p><h2 id="使用改写证明交换律">使用改写证明交换律</h2><p>下面是加法交换律的第二个证明，使用 <code>rewrite</code> 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-32606" href="../Induction/#plfa_plfa-part1-Induction-32606" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32618" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32620" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32622" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32623" href="../Induction/#plfa_plfa-part1-Induction-32623" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32625" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32627" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32628" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32630" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32632" href="../Induction/#plfa_plfa-part1-Induction-32623" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32634" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32636" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32641" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32643" href="../Induction/#plfa_plfa-part1-Induction-32623" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-32645" href="../Induction/#plfa_plfa-part1-Induction-32606" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32657" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32662" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32664" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32669" href="../Induction/#plfa_plfa-part1-Induction-32606" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32681" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32682" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32686" href="../Induction/#plfa_plfa-part1-Induction-32686" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32687" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32689" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32697" href="../Induction/#plfa_plfa-part1-Induction-32606" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32709" href="../Induction/#plfa_plfa-part1-Induction-32686" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32711" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32713" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-32719" href="../Induction/#plfa_plfa-part1-Induction-32719" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32726" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32728" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32730" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32731" href="../Induction/#plfa_plfa-part1-Induction-32731" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32733" href="../Induction/#plfa_plfa-part1-Induction-32733" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32735" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32737" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32738" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32740" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32742" href="../Induction/#plfa_plfa-part1-Induction-32731" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32744" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32746" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32750" href="../Induction/#plfa_plfa-part1-Induction-32733" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32752" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32754" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32758" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32759" href="../Induction/#plfa_plfa-part1-Induction-32731" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32761" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32763" href="../Induction/#plfa_plfa-part1-Induction-32733" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32764" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-32766" href="../Induction/#plfa_plfa-part1-Induction-32719" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32773" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32778" href="../Induction/#plfa_plfa-part1-Induction-32778" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32780" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32787" href="../Induction/#plfa_plfa-part1-Induction-32719" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32794" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32795" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32799" href="../Induction/#plfa_plfa-part1-Induction-32799" class="Bound">m</a><a id="plfa_plfa-part1-Induction-32800" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32802" href="../Induction/#plfa_plfa-part1-Induction-32802" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32804" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32812" href="../Induction/#plfa_plfa-part1-Induction-32719" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32819" href="../Induction/#plfa_plfa-part1-Induction-32799" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32821" href="../Induction/#plfa_plfa-part1-Induction-32802" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32823" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32825" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-32831" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32839" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32841" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32843" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32844" href="../Induction/#plfa_plfa-part1-Induction-32844" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32846" href="../Induction/#plfa_plfa-part1-Induction-32846" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32848" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32850" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32851" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32853" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32855" href="../Induction/#plfa_plfa-part1-Induction-32844" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32857" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32859" href="../Induction/#plfa_plfa-part1-Induction-32846" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32861" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32863" href="../Induction/#plfa_plfa-part1-Induction-32846" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32865" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32867" href="../Induction/#plfa_plfa-part1-Induction-32844" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-32869" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32877" href="../Induction/#plfa_plfa-part1-Induction-32877" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32879" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32884" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32892" href="../Induction/#plfa_plfa-part1-Induction-32606" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32904" href="../Induction/#plfa_plfa-part1-Induction-32877" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32906" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32908" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32913" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32921" href="../Induction/#plfa_plfa-part1-Induction-32921" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32923" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32928" href="../Induction/#plfa_plfa-part1-Induction-32928" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32929" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32931" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32939" href="../Induction/#plfa_plfa-part1-Induction-32719" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32946" href="../Induction/#plfa_plfa-part1-Induction-32921" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32948" href="../Induction/#plfa_plfa-part1-Induction-32928" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32950" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-32952" href="../Induction/#plfa_plfa-part1-Induction-32831" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32960" href="../Induction/#plfa_plfa-part1-Induction-32921" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32962" href="../Induction/#plfa_plfa-part1-Induction-32928" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32964" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32966" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>在最后一行中，用两个等式进行改写被表示为用一条竖线分隔两个相关等式的证明。 左边的改写会在右边之前被执行。</p><h2 id="交互式构造证明">交互式构造证明</h2><p>看看如何在 Emacs 中用 Agda 的交互式特性来构造另一种结合律的证明会很有启发性。 我们从输入以下内容开始：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>其中的问号表示你想要 Agda 帮你填充的代码。如果你按下 <code>C-c C-l</code> （先按 Ctrl-c 再按 Ctrl-l），那么问号会被替换为：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>空的大括号叫做<strong>洞（Hole）</strong>，0 是用来指代此洞的编号。洞可能会以绿色高亮显示。 Emacs 还会在屏幕下方创建一个新的窗口并显示文本：</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>这表示 0 号洞需要以所提示的判断的证明来填充。</p><p>我们希望对 <code>m</code> 进行归纳来证明此命题。将光标移动到洞中并按下 <code>C-c C-c</code>。它会给出提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>按下 <code>m</code> 会拆分该变量，并更新此代码：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>现在有两个洞了，下方的窗口会告诉你每个洞中需要证明的内容：</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>进入 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>它表示在化简之后，0 号洞的目标如上所示，所示类型的变量 <code>p</code> 和 <code>n</code> 可在证明中使用。 给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充。按下 <code>C-c C-l</code> 会将剩下的洞重新编号为 0：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>进入新的 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>同样，它会给出化简后的目标和可用的变量。在此步骤中，我们需要根据归纳假设进行改写， 于是我们来编辑这些文本：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>进入剩下的洞中并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充并完成证明：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">练习：<code>+-swap</code>（推荐）</h4><p>请证明对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>成立。无需归纳证明，只需应用前面满足结合律和交换律的结果即可。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37487" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-distrib-plus">练习 <code>*-distrib-+</code>（推荐）</h4><p>请证明乘法对加法满足分配律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37828" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-assoc">练习 <code>*-assoc</code>（推荐）</h4><p>请证明乘法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38131" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-comm">练习 <code>*-comm</code>（实践）</h4><p>请证明乘法满足交换律，即对于所有的自然数 <code>m</code> 和 <code>n</code>，</p><pre><code>m * n ≡ n * m</code></pre><p>成立。和加法交换律一样，你需要陈述并证明配套的引理。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38518" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="zero-monus">练习 <code>0∸n≡0</code>（实践）</h4><p>请证明对于所有的自然数 <code>n</code>，</p><pre><code>zero ∸ n ≡ zero</code></pre><p>成立。你的证明需要归纳法吗？</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38775" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="monus-plus-assoc">练习 <code>∸-+-assoc</code>（实践）</h4><p>请证明饱和减法与加法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39099" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-延伸">练习 <code>+*^</code> （延伸）</h4><p>证明下列三条定律</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>对于所有 <code>m</code>、<code>n</code> 和 <code>p</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39456" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-laws">练习 <code>Bin-laws</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a> 中定义的一种表示自然数的比特串数据类型 <code>Bin</code> 以及要求你定义的函数：</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>考虑以下定律，其中 <code>n</code> 表示自然数，<code>b</code> 表示比特串：</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>对于每一条定律：若它成立，请证明；若不成立，请给出一个反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40168" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>本章中类似的定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40345" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-40352" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-40372" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-40378" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-40379" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-40386" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40388" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-40399" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40401" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#12854" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-40406" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40408" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-40414" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章中使用了以下 Unicode：</p><pre><code>∀  U+2200  对于所有 (\forall, \all)
ʳ  U+02B3  修饰符小写字母 r (\^r)
′  U+2032  撇号 (\&#39;)
″  U+2033  双撇号 (\&#39;)
‴  U+2034  三撇号 (\&#39;)
⁗  U+2057  四撇号 (\&#39;)</code></pre><p>与 <code>\r</code> 类似，命令 <code>\^r</code> 列出了多种上标右箭头的变体，以及上标的字母 <code>r</code>。 命令 <code>\&#39;</code> 列出了一些撇号（<code>′ ″ ‴ ⁗</code>）。</p></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Oling Cat</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>