<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Induction: 归纳证明</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-116" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-123" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-144" class="Keyword">where</a>
</pre><blockquote><p>归纳会让你对无中生有感到内疚 ……但它却是文明中最伟大的思想之一。 —— Herbert Wilf</p></blockquote><p>现在我们定义了自然数及其运算，下一步是学习如何证明它们满足的性质。 顾名思义，<strong>归纳数据类型（Inductive Datatype）</strong>是通过<strong>归纳（Induction）</strong> 来证明的。</p><h2 id="导入">导入</h2><p>我们需要上一章中的相等性，加上自然数及其运算。我们还导入了一些新的运算： <code>cong</code>、<code>sym</code> 和 <code>_≡⟨_⟩_</code>，之后会解释它们：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-1009" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1016" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-1054" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-1057" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-1060" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1065" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-1068" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1075" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-1078" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1080" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-1084" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1086" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Induction-1090" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1092" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Induction-1095" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1097" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1102" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-1117" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1123" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1124" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-1130" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1132" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">_≡⟨⟩_</a><a id="plfa_plfa-part1-Induction-1137" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1139" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">step-≡</a><a id="plfa_plfa-part1-Induction-1145" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1147" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-1149" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1151" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1156" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1163" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-1172" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1178" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-1180" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-1186" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-1191" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-1196" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-1201" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1203" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-1206" class="Symbol">;</a><a id="plfa_plfa-part1-Induction-1207" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#3471" class="Function Operator">_^_</a><a id="plfa_plfa-part1-Induction-1210" class="Symbol">)</a>
</pre><p>(Importing <code>step-≡</code> defines <code>_≡⟨_⟩_</code>.)</p><h2 id="运算符的性质">运算符的性质</h2><p>运算符随处可见，而数学家们统一了一些最常见的性质的名称。</p><ul><li><p><strong>幺元（Identity）</strong>：对于所有的 <code>n</code>，若 <code>0 + n ≡ n</code>，则 <code>+</code> 有左幺元 <code>0</code>； 若 <code>n + 0 ≡ n</code>，则 <code>+</code> 有右幺元 <code>0</code>。同时为左幺元和右幺元的值称简称幺元。 幺元有时也称作<strong>单位元（Unit）</strong>。</p></li><li><p><strong>结合律（Associativity）</strong>：若括号的位置无关紧要，则称运算符 <code>+</code> 满足结合律， 即对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，有 <code>(m + n) + p ≡ m + (n + p)</code>。</p></li><li><p><strong>交换律（Commutativity）</strong>：若参数的顺序无关紧要，则称运算符 <code>+</code> 满足交换律， 即对于所有的 <code>m</code> 和 <code>n</code>，有 <code>m + n ≡ n + m</code>。</p></li><li><p><strong>分配律（Distributivity）</strong>：对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>m * (p + q) ≡ (m * p) + (m * q)</code>，则运算符 <code>*</code> 对运算符 <code>+</code> 满足左分配律； 对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>(m + n) * p ≡ (m * p) + (n * p)</code>，则满足右分配律。</p></li></ul><p>加法的幺元为 <code>0</code>，乘法的幺元为 <code>1</code>。加法和乘法都满足结合律和交换律， 乘法对加法满足分配律。</p><p>如果你在一个舞会上碰见了一位操作员，那么你可以跟他闲聊，问问他是否有单位元， 能不能结合或者交换。如果你碰见了两位操作员，那么可以问他们某一位是否在另一位上面分布。</p><p>【译注：作者的双关冷笑话，运算符（Operator）也有操作员的意思。】</p><p>正经来说，如果你在阅读技术论文时遇到了一个运算符，那么你可以考察它是否拥有幺元， 是否满足结合律或分配律，或者是否对另一个运算符满足分配律，这能为你提供一种视角。 细心的作者通常会指出它们是否满足这些性质，比如说指明一个新引入的运算符满足结合律 但不满足交换律。</p><h4 id="operators">练习 <code>operators</code>（实践）</h4><p>请给出另一对运算符，它们拥有一个幺元，满足结合律、交换律，且其中一个对另一个满足分配律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4206" class="Comment">-- 请将代码写在此处。</a>
</pre><p>请给出一个运算符的例子，它拥有幺元、满足结合律但不满足交换律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4382" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="结合律">结合律</h2><p>加法的一个性质是满足<strong>结合律</strong>，即括号的位置无关紧要：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的变量 <code>m</code>、<code>n</code> 和 <code>p</code> 的取值范围都是全体自然数。</p><p>我们可以为这三个变量选取特定的数值来验证此命题：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4870" href="../Induction/#plfa_plfa-part1-Induction-4870" class="Function">_</a> <a id="plfa_plfa-part1-Induction-4872" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-4874" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4875" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4879" class="Number">4</a><a id="plfa_plfa-part1-Induction-4880" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4884" class="Number">5</a> <a id="plfa_plfa-part1-Induction-4886" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-4888" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4890" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4892" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4893" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4895" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4897" class="Number">5</a><a id="plfa_plfa-part1-Induction-4898" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-4900" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-4902" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-4906" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-4916" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4917" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4919" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4921" class="Number">4</a><a id="plfa_plfa-part1-Induction-4922" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4926" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4930" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4938" class="Number">7</a> <a id="plfa_plfa-part1-Induction-4940" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4942" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4946" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4954" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-4959" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4967" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4971" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-4975" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4983" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4985" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4987" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4988" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4990" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4992" class="Number">5</a><a id="plfa_plfa-part1-Induction-4993" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-4997" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在这里，我们将计算过程写成了等式链，每行一个式子。这样的等式链通常非常易读， 你可以从上到下，直到遇到最简形式（本例中为 <code>12</code>），也可以从下到上，直到回到同样的式子。</p><p>该测试揭示了结合律可能没有它初看起来那么显然。为什么 <code>7 + 5</code> 与 <code>3 + 9</code> 相同？ 我们可能需要收集更多证据，选择其它的数值来验证此命题。但由于自然数是无限的， 因此测试永远无法完成。那么我们还有其它可以确保结合律对于<strong>所有</strong>自然数都成立的方法吗？</p><p>当然有！我们可以用<strong>归纳证明（Proof by Induction）</strong> 来确保某个性质对于所有的自然数都成立。</p><h2 id="归纳证明">归纳证明</h2><p>回想自然数的定义，它由一个<strong>起始步骤</strong>「<code>zero</code> 是一个自然数」 和一个<strong>归纳步骤</strong>「若 <code>m</code> 是一个自然数，则 <code>suc m</code> 也是一个自然数」构成。</p><p>归纳证明遵循此定义的结构。要通过归纳证明自然数的某个性质，我们需要两个步骤。 其一是<strong>起始步骤</strong>，即需要证明此性质对 <code>zero</code> 成立。其二是<strong>归纳步骤</strong>， 即假设此性质对一个任意自然数 <code>m</code> 成立（我们称之为<strong>归纳假设（Induction Hypothesis）</strong>），然后证明该性质对 <code>suc m</code> 必定成立。</p><p>若将 <code>m</code> 的某种性质（Property）写作 <code>P m</code>，那么我们需要证明的就是以下两个推导规则：</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>先来分析一下这些规则。第一条规则是起始步骤，它需要我们证明性质 <code>P</code> 对 <code>zero</code> 成立。第二条规则是归纳步骤，它需要我们证明若归纳假设「<code>P</code> 对 <code>m</code> 成立」， 那么 <code>P</code> 也对 <code>suc m</code> 成立。</p><p>为什么可以这样做呢？它也可以用创世故事来讲解。起初，我们对性质一无所知：</p><pre><code>-- 起初，世上没有已知的性质。</code></pre><p>现在我们对所有已知的性质应用上述两条规则。起始步骤告诉我们 <code>P zero</code> 成立， 所以我们将它加入已知的性质集合中。归纳步骤告诉我们若「昨天的」<code>P m</code> 成立， 那么「今天的」<code>P (suc m)</code> 也成立。我们在今天之前并不知道任何性质， 因此归纳步骤在这里不适用：</p><pre><code>-- 第一天，我们知道了一个性质。
P zero</code></pre><p>然后我们重复此过程。在接下来的一天我们知道今天之前的所有性质， 以及任何通过此规则添加的性质。起始步骤告诉我们 <code>P zero</code> 成立，我们已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>P zero</code> 在昨天成立，那么 <code>P (suc zero)</code> 今天也成立。</p><pre><code>-- 第二天，我们知道了两个性质。
P zero
P (suc zero)</code></pre><p>我们再重复此过程。现在归纳步骤告诉我们由于 <code>P zero</code> 和 <code>P (suc zero)</code> 都成立， 因此 <code>P (suc zero)</code> 和 <code>P (suc (suc zero))</code> 也成立。我们已经知道第一个成立了， 但第二个是新引入的：</p><pre><code>-- 第三天，我们知道了三个性质。
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了四个性质。
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的性质成立。 每个自然数的性质都会在某一天出现。具体来说，性质 <code>P n</code> 会在第 <em>n+1</em> 天 首次出现。</p><h2 id="第一个证明结合律">第一个证明：结合律</h2><p>要证明结合律，我们需要将 <code>P m</code> 看做以下性质：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的 <code>n</code> 和 <code>p</code> 是任意自然数，因此若我们可以证明该等式对所有的 <code>m</code> 都成立，那么它也会对所有的 <code>n</code> 和 <code>p</code> 成立。其推理规则的对应实例如下：</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>如果我们可以证明这两条规则，那么加法结合律就可以用归纳法来证明。</p><p>以下为此性质的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-11122" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11130" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11132" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11134" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11135" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11137" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11139" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11141" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11144" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11146" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11148" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11149" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11151" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11153" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11154" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11156" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11158" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11160" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11162" href="../Induction/#plfa_plfa-part1-Induction-11135" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11166" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11167" href="../Induction/#plfa_plfa-part1-Induction-11137" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11169" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11171" href="../Induction/#plfa_plfa-part1-Induction-11139" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11172" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11174" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11187" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11189" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11191" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11195" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11205" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11206" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11211" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11213" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11214" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11216" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11218" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11222" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11230" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11232" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11234" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11238" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11246" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11251" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11253" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11254" href="../Induction/#plfa_plfa-part1-Induction-11187" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11256" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11258" href="../Induction/#plfa_plfa-part1-Induction-11189" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11259" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11263" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-11265" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11273" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11274" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11278" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a><a id="plfa_plfa-part1-Induction-11279" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11281" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11283" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11285" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11289" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11299" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11300" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11304" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11306" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11308" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11309" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11311" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11313" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11317" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11325" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11329" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11330" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11334" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11335" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11339" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11343" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11355" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11357" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11359" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11361" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11362" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11364" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11366" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11367" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11371" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11374" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11379" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11383" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11384" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11392" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11394" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11396" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11397" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11399" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11405" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11409" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11410" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11412" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11414" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11415" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11417" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11419" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11420" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11425" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11433" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11437" href="../Induction/#plfa_plfa-part1-Induction-11278" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11439" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11441" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11442" href="../Induction/#plfa_plfa-part1-Induction-11281" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11446" href="../Induction/#plfa_plfa-part1-Induction-11283" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11447" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11451" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们将此证明命名为 <code>+-assoc</code>。在 Agda 中，标识符可以由除空格和 <code>@.(){};_</code> 之外的任何字符序列构成。</p><p>我们来分析一下这段代码。其签名（Signature）描述了我们定义的标识符 <code>+-assoc</code> 为以下命题提供了证据（Evidence）：</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>倒 A 符号读作「对于所有（for all）」，而该命题断言对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，等式 <code>(m + n) + p ≡ m + (n + p)</code> 成立。该命题的证据是一个接受三个自然数的函数， 将它们绑定到 <code>m</code>、<code>n</code> 和 <code>p</code>，并返回该等式对应实例的证据。</p><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>用加法的起始步骤化简等式两边会得到：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。阅读此证明中起始步骤中的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们在中间遇到 <code>n + p</code> 。此步骤无需多言，化简即可。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>用加法的归纳步骤化简等式两边会得到：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此证明中归纳步骤的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们到达上面化简等式的地方。剩下的等式单化简还不行， 我们还需要为推理链使用一个附加的运算符 <code>_≡⟨_⟩_</code>， 并将等式的依据放在尖括号中。这里给出的依据是：</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>在这里，递归调用的 <code>+-assoc m n p</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。</p><p>若某个关系在应用了给定的函数后仍然保持不变，则称该关系满足<strong>合同性（Congruence）</strong>。 若 <code>e</code> 是 <code>x ≡ y</code> 的证据，那么对于任意函数 <code>f</code>，<code>cong f e</code> 就是 <code>f x ≡ f y</code> 的证据。</p><p>在这里并未假定归纳假设，而是通过递归调用我们定义的函数 <code>+-assoc m n p</code> 来证明。 对于加法，这是良基的（well-founded），因为更大数值的结合律可基于更小数值的结合律 来证明。在此步骤中，<code>assoc (suc m) n p</code> 是用 <code>assoc m n p</code> 证明的。 归纳证明和递归定义之间的这种对应是 Agda 中最吸引人的方面之一。</p><h2 id="归纳即递归">归纳即递归</h2><p>下面是归纳如何对应于递归的具体例子，它是在结合律的证明中，将 <code>m</code> 实例化为 <code>2</code> 时的计算过程。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-15663" href="../Induction/#plfa_plfa-part1-Induction-15663" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-15673" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15675" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15677" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15678" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15680" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15682" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15685" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15687" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15689" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15690" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15692" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15694" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15695" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15697" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15699" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15701" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15703" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15707" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15708" href="../Induction/#plfa_plfa-part1-Induction-15678" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15712" href="../Induction/#plfa_plfa-part1-Induction-15680" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15713" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15715" href="../Induction/#plfa_plfa-part1-Induction-15663" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-15725" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15727" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15729" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15733" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15743" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15744" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15746" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15748" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15749" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15751" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15753" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15757" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15765" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15769" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15770" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15772" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15774" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15775" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15777" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15779" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15783" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15791" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15795" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-15797" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15799" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15801" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15802" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15804" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15806" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15807" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15811" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-15814" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-15819" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15823" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15824" href="../Induction/#plfa_plfa-part1-Induction-15899" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15834" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15836" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15837" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15839" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-15845" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15849" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15850" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15852" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15854" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15855" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15857" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15859" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15860" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-15865" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15873" class="Number">2</a> <a id="plfa_plfa-part1-Induction-15875" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15877" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15878" href="../Induction/#plfa_plfa-part1-Induction-15725" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15880" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15882" href="../Induction/#plfa_plfa-part1-Induction-15727" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15883" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15887" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
  <a id="plfa_plfa-part1-Induction-15891" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Induction-15899" href="../Induction/#plfa_plfa-part1-Induction-15899" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15909" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15911" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15913" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15914" href="../Induction/#plfa_plfa-part1-Induction-15914" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15916" href="../Induction/#plfa_plfa-part1-Induction-15916" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15918" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15920" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15921" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15923" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15925" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15926" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15928" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15930" href="../Induction/#plfa_plfa-part1-Induction-15914" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15931" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15933" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15935" href="../Induction/#plfa_plfa-part1-Induction-15916" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15937" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15939" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15941" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15943" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15944" href="../Induction/#plfa_plfa-part1-Induction-15914" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15946" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15948" href="../Induction/#plfa_plfa-part1-Induction-15916" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15949" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15953" href="../Induction/#plfa_plfa-part1-Induction-15899" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15963" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15965" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15967" class="Symbol">=</a>
    <a id="plfa_plfa-part1-Induction-15973" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
      <a id="plfa_plfa-part1-Induction-15985" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15986" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15988" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15990" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15991" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15993" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15995" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a>
    <a id="plfa_plfa-part1-Induction-16001" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16011" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16015" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16016" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16018" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16020" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16021" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16023" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16025" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a>
    <a id="plfa_plfa-part1-Induction-16031" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16041" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16045" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16047" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16049" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16051" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16052" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16054" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16056" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16057" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16063" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16066" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16071" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16075" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16076" href="../Induction/#plfa_plfa-part1-Induction-16163" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16086" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16088" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16089" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16091" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
      <a id="plfa_plfa-part1-Induction-16099" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16103" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16104" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16106" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16108" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16109" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16111" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16113" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16114" class="Symbol">))</a>
    <a id="plfa_plfa-part1-Induction-16121" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="plfa_plfa-part1-Induction-16131" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16133" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16135" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16136" href="../Induction/#plfa_plfa-part1-Induction-15963" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16138" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16140" href="../Induction/#plfa_plfa-part1-Induction-15965" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16141" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16147" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
    <a id="plfa_plfa-part1-Induction-16153" class="Keyword">where</a>
    <a id="plfa_plfa-part1-Induction-16163" href="../Induction/#plfa_plfa-part1-Induction-16163" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16173" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16175" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16177" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16178" href="../Induction/#plfa_plfa-part1-Induction-16178" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16180" href="../Induction/#plfa_plfa-part1-Induction-16180" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16182" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16184" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16185" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16187" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16189" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16190" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16192" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16194" href="../Induction/#plfa_plfa-part1-Induction-16178" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16195" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16197" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16199" href="../Induction/#plfa_plfa-part1-Induction-16180" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16203" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16205" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16207" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16208" href="../Induction/#plfa_plfa-part1-Induction-16178" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16210" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16212" href="../Induction/#plfa_plfa-part1-Induction-16180" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16213" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Induction-16219" href="../Induction/#plfa_plfa-part1-Induction-16163" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-16229" href="../Induction/#plfa_plfa-part1-Induction-16229" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16231" href="../Induction/#plfa_plfa-part1-Induction-16231" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16233" class="Symbol">=</a>
      <a id="plfa_plfa-part1-Induction-16241" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
        <a id="plfa_plfa-part1-Induction-16255" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16256" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16258" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16260" href="../Induction/#plfa_plfa-part1-Induction-16229" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16261" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16263" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16265" href="../Induction/#plfa_plfa-part1-Induction-16231" class="Bound">p</a>
      <a id="plfa_plfa-part1-Induction-16273" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
        <a id="plfa_plfa-part1-Induction-16285" href="../Induction/#plfa_plfa-part1-Induction-16229" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16287" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16289" href="../Induction/#plfa_plfa-part1-Induction-16231" class="Bound">p</a>
      <a id="plfa_plfa-part1-Induction-16297" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
        <a id="plfa_plfa-part1-Induction-16309" class="Number">0</a> <a id="plfa_plfa-part1-Induction-16311" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16313" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16314" href="../Induction/#plfa_plfa-part1-Induction-16229" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16318" href="../Induction/#plfa_plfa-part1-Induction-16231" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16319" class="Symbol">)</a>
      <a id="plfa_plfa-part1-Induction-16327" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h2 id="术语与记法">术语与记法</h2><p>在结合律的陈述中出现的符号 <code>∀</code> 表示它对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code> 都成立。 我们将 <code>∀</code> 称为<strong>全称量词（Universal Quantifier）</strong>，我们会在 <a href="../Quantifiers/">Quantifiers</a> 章节中进一步讨论。</p><p>全称量词的证据是一个函数。记法</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>和</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>是等价的。和 <code>ℕ → ℕ → ℕ</code> 这样的函数类型不同，上述函数中的变量 与每一个实参类型相关联，且其结果类型可能会涉及（或依赖于）这些变量， 因此它们叫做<strong>依赖函数（Dependent Function）</strong>。</p><h2 id="第二个证明交换律">第二个证明：交换律</h2><p>加法的另一个重要性质是满足<strong>交换律（Commutativity）</strong>，即运算数的顺序无关紧要：</p><pre><code>m + n ≡ n + m</code></pre><p>要证明它，我们需要先证明两条引理（Lemma）。</p><h3 id="第一条引理">第一条引理</h3><p>加法定义的起始步骤说明零是一个左幺元：</p><pre><code>zero + n ≡ n</code></pre><p>我们的第一条引理则说明零也是一个右幺元：</p><pre><code>m + zero ≡ m</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-18073" href="../Induction/#plfa_plfa-part1-Induction-18073" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18085" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18087" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18089" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18090" href="../Induction/#plfa_plfa-part1-Induction-18090" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18092" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18094" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18095" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18097" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18099" href="../Induction/#plfa_plfa-part1-Induction-18090" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18101" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18103" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18108" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18110" href="../Induction/#plfa_plfa-part1-Induction-18090" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-18112" href="../Induction/#plfa_plfa-part1-Induction-18073" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18124" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18129" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18133" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18150" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18157" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18165" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18172" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-18174" href="../Induction/#plfa_plfa-part1-Induction-18073" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18186" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18191" href="../Induction/#plfa_plfa-part1-Induction-18191" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18192" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18194" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18198" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18208" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18212" href="../Induction/#plfa_plfa-part1-Induction-18191" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18214" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18216" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18223" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18231" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18235" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18236" href="../Induction/#plfa_plfa-part1-Induction-18191" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18238" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18240" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-18244" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18248" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18251" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18256" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18260" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18261" href="../Induction/#plfa_plfa-part1-Induction-18073" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18273" href="../Induction/#plfa_plfa-part1-Induction-18191" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18274" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18276" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18282" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18286" href="../Induction/#plfa_plfa-part1-Induction-18191" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-18290" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-identityʳ</code> 提供了以下命题的证据：</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>该命题的证据是一个函数，它接受一个自然数，将其绑定到 <code>m</code>，然后返回 该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + zero ≡ zero</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m) + zero = suc m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + zero) = suc m</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + zero ≡ m</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此等式链，从上到下和从下到上读都会让我们到达上面化简等式的地方。 剩下的等式可由以下依据得出：</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>在这里，递归调用的 <code>+-identityʳ m</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第一条引理证毕。</p><h3 id="第二条引理">第二条引理</h3><p>加法定义的归纳步骤将第一个参数的 <code>suc</code> 推到了外面：</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>我们的第二条引理则对第二个参数的 <code>suc</code> 做同样的事情：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-20291" href="../Induction/#plfa_plfa-part1-Induction-20291" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20297" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20299" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-20301" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20302" href="../Induction/#plfa_plfa-part1-Induction-20302" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20304" href="../Induction/#plfa_plfa-part1-Induction-20304" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20306" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20308" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-20309" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20311" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-20313" href="../Induction/#plfa_plfa-part1-Induction-20302" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20315" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20317" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20321" href="../Induction/#plfa_plfa-part1-Induction-20304" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20323" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-20325" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20329" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20330" href="../Induction/#plfa_plfa-part1-Induction-20302" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20334" href="../Induction/#plfa_plfa-part1-Induction-20304" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20335" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-20337" href="../Induction/#plfa_plfa-part1-Induction-20291" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20343" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20348" href="../Induction/#plfa_plfa-part1-Induction-20348" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20350" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20354" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20364" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20369" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20371" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20375" href="../Induction/#plfa_plfa-part1-Induction-20348" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20379" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20387" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20391" href="../Induction/#plfa_plfa-part1-Induction-20348" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20395" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20403" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20407" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20408" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20415" href="../Induction/#plfa_plfa-part1-Induction-20348" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20416" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20420" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-20422" href="../Induction/#plfa_plfa-part1-Induction-20291" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20428" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20429" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20433" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a><a id="plfa_plfa-part1-Induction-20434" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20436" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20438" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20442" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20452" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20456" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20458" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20460" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20464" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20468" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20476" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20480" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20481" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20483" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20485" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20489" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20490" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20494" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-20497" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-20502" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20506" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20507" href="../Induction/#plfa_plfa-part1-Induction-20291" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20513" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20515" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20516" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20518" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-20524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20528" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20533" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20534" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20536" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20538" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20539" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-20544" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20552" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20556" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20557" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20561" href="../Induction/#plfa_plfa-part1-Induction-20433" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20563" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20565" href="../Induction/#plfa_plfa-part1-Induction-20436" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20566" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20570" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-suc</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>从上到下或从下到上阅读等式链都会让我们在中间遇到化简后的等式。剩下的等式 可由以下依据得出：</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>在这里，递归调用的 <code>+-suc m n</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第二条引理证毕。</p><h3 id="命题">命题</h3><p>最后，以下是我们的命题的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-22341" href="../Induction/#plfa_plfa-part1-Induction-22341" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22348" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22350" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22352" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22353" href="../Induction/#plfa_plfa-part1-Induction-22353" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22355" href="../Induction/#plfa_plfa-part1-Induction-22355" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22357" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22359" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22360" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22362" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22364" href="../Induction/#plfa_plfa-part1-Induction-22353" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22366" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22368" href="../Induction/#plfa_plfa-part1-Induction-22355" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22372" href="../Induction/#plfa_plfa-part1-Induction-22355" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22376" href="../Induction/#plfa_plfa-part1-Induction-22353" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-22378" href="../Induction/#plfa_plfa-part1-Induction-22341" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22385" href="../Induction/#plfa_plfa-part1-Induction-22385" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22387" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22392" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22396" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22406" href="../Induction/#plfa_plfa-part1-Induction-22385" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22408" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22410" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-22417" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22420" href="../Induction/#plfa_plfa-part1-Induction-18073" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-22432" href="../Induction/#plfa_plfa-part1-Induction-22385" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22434" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22440" href="../Induction/#plfa_plfa-part1-Induction-22385" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22444" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22452" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22457" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22459" href="../Induction/#plfa_plfa-part1-Induction-22385" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22463" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-22465" href="../Induction/#plfa_plfa-part1-Induction-22341" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22472" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22474" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22475" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22479" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22480" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22482" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22486" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22496" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22498" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22500" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22504" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-22508" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22511" href="../Induction/#plfa_plfa-part1-Induction-20291" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-22517" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22519" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22521" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22527" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22531" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22532" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22534" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22536" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22537" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22541" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22544" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-22549" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22553" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22554" href="../Induction/#plfa_plfa-part1-Induction-22341" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22561" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22563" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22564" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22566" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22572" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22576" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22577" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22579" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22581" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22582" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22586" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22598" href="../Induction/#plfa_plfa-part1-Induction-22479" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22600" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22602" href="../Induction/#plfa_plfa-part1-Induction-22472" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22606" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行说明我们定义的标识符 <code>+-comm</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>n</code> 进行归纳来证明。（这次不是 <code>m</code>！）</p><p>对于起始步骤，我们必须证明：</p><pre><code>m + zero ≡ zero + m</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>m + zero ≡ m</code></pre><p>剩下的等式可由依据 <code>⟨ +-identityʳ m ⟩</code> 得出，它调用第一条引理。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>我们分两步来证明它。首先，我们有：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>它依据第二条引理 <code>⟨ +-suc m n ⟩</code> 得出。之后我们有：</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>它依据合同性和归纳假设 <code>⟨ cong suc (+-comm m n) ⟩</code> 得出。证毕。</p><p>Agda 要求标识符必须在使用前定义，因此我们必须在主命题之前列出引理， 如前例所示。在实践中，我们通常会先试着证明主命题，之后所需的等式会说明 需要证明哪些引理。</p><h2 id="sections">第一个推论：重排定理</h2><p>我们可以随意应用结合律来重排括号。例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-24748" href="../Induction/#plfa_plfa-part1-Induction-24748" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24760" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24762" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-24764" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24765" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24767" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24769" href="../Induction/#plfa_plfa-part1-Induction-24769" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24771" href="../Induction/#plfa_plfa-part1-Induction-24771" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24773" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24775" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-24776" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24778" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-24780" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24781" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24783" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24785" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24786" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24788" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24790" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24791" href="../Induction/#plfa_plfa-part1-Induction-24769" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24793" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24795" href="../Induction/#plfa_plfa-part1-Induction-24771" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24796" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24798" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-24800" href="../Induction/#plfa_plfa-part1-Induction-24765" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24802" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24804" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24805" href="../Induction/#plfa_plfa-part1-Induction-24767" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24807" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24809" href="../Induction/#plfa_plfa-part1-Induction-24769" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24810" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24812" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24814" href="../Induction/#plfa_plfa-part1-Induction-24771" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-24816" href="../Induction/#plfa_plfa-part1-Induction-24748" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24828" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24830" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24832" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24834" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24836" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-24840" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-24850" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24851" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24853" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24855" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24856" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24858" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24860" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24861" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24863" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24865" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24866" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-24870" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-24873" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-24877" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24878" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-24886" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24887" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24891" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24892" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24894" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24896" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24897" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24899" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-24905" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-24907" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24909" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24911" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24912" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24914" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24916" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24917" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24919" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24921" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-24925" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-24928" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-24933" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24934" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-24937" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24938" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24940" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24941" href="../Induction/#plfa_plfa-part1-Induction-11122" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-24949" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24951" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24953" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24954" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24956" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-24962" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24963" href="../Induction/#plfa_plfa-part1-Induction-24828" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24965" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24967" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24968" href="../Induction/#plfa_plfa-part1-Induction-24830" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24970" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24972" href="../Induction/#plfa_plfa-part1-Induction-24832" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24973" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-24976" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24978" href="../Induction/#plfa_plfa-part1-Induction-24834" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-24982" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>无需归纳法，我们只不过应用了两次结合律就完成了证明。其中有几点需要注意的地方。</p><p>第一，加法是左结合的，因此 <code>m + (n + p) + q</code> 表示 <code>(m + (n + p)) + q</code>。</p><p>第二，我们用 <code>sym</code> 来交换等式的两边。命题 <code>+-assoc (m + n) p q</code> 会将括号从左边移到右边：</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>要往另一个方向移动括号，我们要用 <code>sym (+-assoc (m + n) p q)</code>：</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>一般来说，若 <code>e</code> 提供了 <code>x ≡ y</code> 的证据，那么 <code>sym e</code> 就提供了 <code>y ≡ x</code> 的证据。</p><p>第三，Agda 支持 Richard Bird 引入的<strong>片段（Section）</strong>记法。我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(_+ y)</code>。因此，对于 <code>assoc m n p</code> 应用合同性 <code>cong (_+ q)</code> 会将等式：</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>转换成:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>类似地，我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(x +_ )</code>。 这同样适用于任何中缀运算符。</p><h2 id="创世最后一次">创世，最后一次</h2><p>我们回到结合律的证明上来，把归纳证明（或等价的递归定义）看做一个创世故事会有助于理解。 这次我们专注于判断结合律的断言：</p><pre><code> -- 起初，我们对结合律一无所知。</code></pre><p>现在，我们将规则应用到所有已知的判断上来。起始步骤告诉我们对于所有的自然数 <code>n</code> 和 <code>p</code> 来说，<code>(zero + n) + p ≡ zero + (n + p)</code>。归纳步骤告我我们若 <code>(m + n) + p ≡ m + (n + p)</code>（在昨天）成立，那么 <code>(suc m + n) + p ≡ suc m + (n + p)</code> （在今天）也成立。我们在今天之前并不知道任何关于结合律的判断， 因此此规则并未给出任何新的判断：</p><pre><code>-- 第一天，我们知道了关于 0 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>之后我们重复此过程，因此接下来一天我们知道今天以前的所有判断， 以及任何通过此规则添加的判断。起始步骤并未告诉我们新的东西， 而如今归归纳步骤添加了更多的判断：</p><pre><code>-- 第二天，我们知道了关于 0 和 1 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>我们再次重复此过程：</p><pre><code>-- 第三天，我们知道了关于 0、1 和 2 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了关于 0、1、2 和 3 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们会知道所有第一个数小于 <em>m</em> 的判断。</p><p>还有一种完全有限的方法来生成同样的等式，它的证明留作读者的练习。</p><h4 id="finite-plus-assoc">练习 <code>finite-+-assoc</code>（延伸）</h4><p>请参考<a href="../Naturals/#finite-creation">前文</a>写出前四天已知的加法结合律的创世故事。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-30643" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="用改写来证明结合律">用改写来证明结合律</h2><p>证明可不止一种方法。下面是第二种在 Agda 中证明加法结合律的方法，使用 <code>rewrite</code>（改写） 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-30946" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-30955" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-30957" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-30959" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30960" href="../Induction/#plfa_plfa-part1-Induction-30960" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30962" href="../Induction/#plfa_plfa-part1-Induction-30962" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-30964" href="../Induction/#plfa_plfa-part1-Induction-30964" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-30966" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-30968" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-30969" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-30971" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-30973" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30974" href="../Induction/#plfa_plfa-part1-Induction-30960" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30976" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30978" href="../Induction/#plfa_plfa-part1-Induction-30962" class="Bound">n</a><a id="plfa_plfa-part1-Induction-30979" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-30981" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30983" href="../Induction/#plfa_plfa-part1-Induction-30964" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-30985" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-30987" href="../Induction/#plfa_plfa-part1-Induction-30960" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-30989" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30991" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-30992" href="../Induction/#plfa_plfa-part1-Induction-30962" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-30994" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-30996" href="../Induction/#plfa_plfa-part1-Induction-30964" class="Bound">p</a><a id="plfa_plfa-part1-Induction-30997" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-30999" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31008" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-31016" href="../Induction/#plfa_plfa-part1-Induction-31016" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31018" href="../Induction/#plfa_plfa-part1-Induction-31018" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-31045" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31048" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-31053" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31062" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31063" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-31067" href="../Induction/#plfa_plfa-part1-Induction-31067" class="Bound">m</a><a id="plfa_plfa-part1-Induction-31068" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31070" href="../Induction/#plfa_plfa-part1-Induction-31070" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31072" href="../Induction/#plfa_plfa-part1-Induction-31072" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31075" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-31083" href="../Induction/#plfa_plfa-part1-Induction-30946" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31092" href="../Induction/#plfa_plfa-part1-Induction-31067" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31094" href="../Induction/#plfa_plfa-part1-Induction-31070" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31096" href="../Induction/#plfa_plfa-part1-Induction-31072" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31099" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。一个项等于其自身的证明写作 <code>refl</code>（自反性）。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>其证明同样由 <code>refl</code> 给出。改写不仅可以省去等式链还可以避免调用 <code>cong</code>.</p><h2 id="使用改写证明交换律">使用改写证明交换律</h2><p>下面是加法交换律的第二个证明，使用 <code>rewrite</code> 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-32472" href="../Induction/#plfa_plfa-part1-Induction-32472" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32484" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32486" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32488" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32489" href="../Induction/#plfa_plfa-part1-Induction-32489" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32491" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32494" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32496" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32498" href="../Induction/#plfa_plfa-part1-Induction-32489" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32500" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32502" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32507" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32509" href="../Induction/#plfa_plfa-part1-Induction-32489" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-32511" href="../Induction/#plfa_plfa-part1-Induction-32472" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32528" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32530" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32535" href="../Induction/#plfa_plfa-part1-Induction-32472" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32547" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32548" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32552" href="../Induction/#plfa_plfa-part1-Induction-32552" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32553" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32555" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32563" href="../Induction/#plfa_plfa-part1-Induction-32472" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32575" href="../Induction/#plfa_plfa-part1-Induction-32552" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32577" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32579" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-32585" href="../Induction/#plfa_plfa-part1-Induction-32585" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32592" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32594" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32596" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32597" href="../Induction/#plfa_plfa-part1-Induction-32597" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32599" href="../Induction/#plfa_plfa-part1-Induction-32599" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32601" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32603" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32604" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32606" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32608" href="../Induction/#plfa_plfa-part1-Induction-32597" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32612" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32616" href="../Induction/#plfa_plfa-part1-Induction-32599" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32618" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32620" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32624" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32625" href="../Induction/#plfa_plfa-part1-Induction-32597" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32627" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32629" href="../Induction/#plfa_plfa-part1-Induction-32599" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32630" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-32632" href="../Induction/#plfa_plfa-part1-Induction-32585" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32644" href="../Induction/#plfa_plfa-part1-Induction-32644" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32646" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32648" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32653" href="../Induction/#plfa_plfa-part1-Induction-32585" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32660" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32661" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32665" href="../Induction/#plfa_plfa-part1-Induction-32665" class="Bound">m</a><a id="plfa_plfa-part1-Induction-32666" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32668" href="../Induction/#plfa_plfa-part1-Induction-32668" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32670" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32678" href="../Induction/#plfa_plfa-part1-Induction-32585" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32685" href="../Induction/#plfa_plfa-part1-Induction-32665" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32687" href="../Induction/#plfa_plfa-part1-Induction-32668" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32689" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32691" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-32697" href="../Induction/#plfa_plfa-part1-Induction-32697" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32705" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32707" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32709" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32710" href="../Induction/#plfa_plfa-part1-Induction-32710" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32712" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32714" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32716" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32717" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32719" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32721" href="../Induction/#plfa_plfa-part1-Induction-32710" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32723" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32725" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32727" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32729" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32733" href="../Induction/#plfa_plfa-part1-Induction-32710" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-32735" href="../Induction/#plfa_plfa-part1-Induction-32697" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32743" href="../Induction/#plfa_plfa-part1-Induction-32743" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32745" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32750" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32758" href="../Induction/#plfa_plfa-part1-Induction-32472" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32770" href="../Induction/#plfa_plfa-part1-Induction-32743" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32772" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32774" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32779" href="../Induction/#plfa_plfa-part1-Induction-32697" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32787" href="../Induction/#plfa_plfa-part1-Induction-32787" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32789" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32790" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32794" href="../Induction/#plfa_plfa-part1-Induction-32794" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32795" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32797" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32805" href="../Induction/#plfa_plfa-part1-Induction-32585" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32812" href="../Induction/#plfa_plfa-part1-Induction-32787" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32814" href="../Induction/#plfa_plfa-part1-Induction-32794" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32816" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-32818" href="../Induction/#plfa_plfa-part1-Induction-32697" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32826" href="../Induction/#plfa_plfa-part1-Induction-32787" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32828" href="../Induction/#plfa_plfa-part1-Induction-32794" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32830" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32832" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>在最后一行中，用两个等式进行改写被表示为用一条竖线分隔两个相关等式的证明。 左边的改写会在右边之前被执行。</p><h2 id="交互式构造证明">交互式构造证明</h2><p>看看如何在 Emacs 中用 Agda 的交互式特性来构造另一种结合律的证明会很有启发性。 我们从输入以下内容开始：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>其中的问号表示你想要 Agda 帮你填充的代码。如果你按下 <code>C-c C-l</code> （先按 Ctrl-c 再按 Ctrl-l），那么问号会被替换为：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>空的大括号叫做<strong>洞（Hole）</strong>，0 是用来指代此洞的编号。洞可能会以绿色高亮显示。 Emacs 还会在屏幕下方创建一个新的窗口并显示文本：</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>这表示 0 号洞需要以所提示的判断的证明来填充。</p><p>我们希望对 <code>m</code> 进行归纳来证明此命题。将光标移动到洞中并按下 <code>C-c C-c</code>。它会给出提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>按下 <code>m</code> 会拆分该变量，并更新此代码：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>现在有两个洞了，下方的窗口会告诉你每个洞中需要证明的内容：</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>进入 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>它表示在化简之后，0 号洞的目标如上所示，所示类型的变量 <code>p</code> 和 <code>n</code> 可在证明中使用。 给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充。按下 <code>C-c C-l</code> 会将剩下的洞重新编号为 0：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>进入新的 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>同样，它会给出化简后的目标和可用的变量。在此步骤中，我们需要根据归纳假设进行改写， 于是我们来编辑这些文本：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>进入剩下的洞中并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充并完成证明：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">练习：<code>+-swap</code>（推荐）</h4><p>请证明对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>成立。无需归纳证明，只需应用前面满足结合律和交换律的结果即可。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37353" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-distrib-plus">练习 <code>*-distrib-+</code>（推荐）</h4><p>请证明乘法对加法满足分配律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37694" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-assoc">练习 <code>*-assoc</code>（推荐）</h4><p>请证明乘法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37997" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="times-comm">练习 <code>*-comm</code>（实践）</h4><p>请证明乘法满足交换律，即对于所有的自然数 <code>m</code> 和 <code>n</code>，</p><pre><code>m * n ≡ n * m</code></pre><p>成立。和加法交换律一样，你需要陈述并证明配套的引理。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38384" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="zero-monus">练习 <code>0∸n≡0</code>（实践）</h4><p>请证明对于所有的自然数 <code>n</code>，</p><pre><code>zero ∸ n ≡ zero</code></pre><p>成立。你的证明需要归纳法吗？</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38641" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="monus-plus-assoc">练习 <code>∸-+-assoc</code>（实践）</h4><p>请证明饱和减法与加法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38965" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-延伸">练习 <code>+*^</code> （延伸）</h4><p>证明下列三条定律</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>对于所有 <code>m</code>、<code>n</code> 和 <code>p</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39322" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-laws">练习 <code>Bin-laws</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a> 中定义的一种表示自然数的比特串数据类型 <code>Bin</code> 以及要求你定义的函数：</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>考虑以下定律，其中 <code>n</code> 表示自然数，<code>b</code> 表示比特串：</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>对于每一条定律：若它成立，请证明；若不成立，请给出一个反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40034" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>本章中类似的定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40211" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-40218" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-40238" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-40244" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-40245" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-40252" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40254" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-40265" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40267" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#12854" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-40272" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40274" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-40280" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章中使用了以下 Unicode：</p><pre><code>∀  U+2200  对于所有 (\forall, \all)
ʳ  U+02B3  修饰符小写字母 r (\^r)
′  U+2032  撇号 (\&#39;)
″  U+2033  双撇号 (\&#39;)
‴  U+2034  三撇号 (\&#39;)
⁗  U+2057  四撇号 (\&#39;)</code></pre><p>与 <code>\r</code> 类似，命令 <code>\^r</code> 列出了多种上标右箭头的变体，以及上标的字母 <code>r</code>。 命令 <code>\&#39;</code> 列出了一些撇号（<code>′ ″ ‴ ⁗</code>）。</p></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Oling Cat</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>