<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Induction: 归纳证明</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-100" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-107" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-128" class="Keyword">where</a>
</pre><blockquote><p>归纳会让你对无中生有感到内疚 ……但它却是文明中最伟大的思想之一。 —— Herbert Wilf</p></blockquote><p>现在我们定义了自然数及其运算，下一步是学习如何证明它们满足的性质。 顾名思义，<strong>归纳数据类型（Inductive Datatype）</strong>是通过<strong>归纳（Induction）</strong> 来证明的。</p><h2 id="导入">导入</h2><p>我们需要上一章中的相等性，加上自然数及其运算。我们还导入了一些新的运算： <code>cong</code>、<code>sym</code> 和 <code>_≡⟨_⟩_</code>，之后会解释它们：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-993" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1000" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-1038" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-1041" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-1044" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1049" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-1052" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1058" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1059" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-1062" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1064" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-1068" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1070" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Induction-1074" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1076" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Induction-1079" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1081" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1086" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-1101" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1107" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1108" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-1114" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1116" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">_≡⟨⟩_</a><a id="plfa_plfa-part1-Induction-1121" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1123" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">step-≡</a><a id="plfa_plfa-part1-Induction-1129" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1131" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-1133" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-1135" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-1140" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-1147" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-1156" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-1162" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-1163" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-1164" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1166" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-1170" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1172" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-1175" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1177" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-1180" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1182" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-1185" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-1187" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-1190" class="Symbol">;</a><a id="plfa_plfa-part1-Induction-1191" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#3471" class="Function Operator">_^_</a><a id="plfa_plfa-part1-Induction-1194" class="Symbol">)</a>
</pre><p>(Importing <code>step-≡</code> defines <code>_≡⟨_⟩_</code>.)</p><h2 id="运算符的性质">运算符的性质</h2><p>运算符随处可见，而数学家们统一了一些最常见的性质的名称。</p><ul><li><p><strong>幺元（Identity）</strong>：对于所有的 <code>n</code>，若 <code>0 + n ≡ n</code>，则 <code>+</code> 有左幺元 <code>0</code>； 若 <code>n + 0 ≡ n</code>，则 <code>+</code> 有右幺元 <code>0</code>。同时为左幺元和右幺元的值称简称幺元。 幺元有时也称作<strong>单位元（Unit）</strong>。</p></li><li><p><strong>结合律（Associativity）</strong>：若括号的位置无关紧要，则称运算符 <code>+</code> 满足结合律， 即对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，有 <code>(m + n) + p ≡ m + (n + p)</code>。</p></li><li><p><strong>交换律（Commutativity）</strong>：若参数的顺序无关紧要，则称运算符 <code>+</code> 满足交换律， 即对于所有的 <code>m</code> 和 <code>n</code>，有 <code>m + n ≡ n + m</code>。</p></li><li><p><strong>分配律（Distributivity）</strong>：对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>m * (p + q) ≡ (m * p) + (m * q)</code>，则运算符 <code>*</code> 对运算符 <code>+</code> 满足左分配律； 对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code>，若 <code>(m + n) * p ≡ (m * p) + (n * p)</code>，则满足右分配律。</p></li></ul><p>加法的幺元为 <code>0</code>，乘法的幺元为 <code>1</code>。加法和乘法都满足结合律和交换律， 乘法对加法满足分配律。</p><p>如果你在一个舞会上碰见了一位操作员，那么你可以跟他闲聊，问问他是否有单位元， 能不能结合或者交换。如果你碰见了两位操作员，那么可以问他们某一位是否在另一位上面分布。</p><p>【译注：作者的双关冷笑话，运算符（Operator）也有操作员的意思。】</p><p>正经来说，如果你在阅读技术论文时遇到了一个运算符，那么你可以考察它是否拥有幺元， 是否满足结合律或分配律，或者是否对另一个运算符满足分配律，这能为你提供一种视角。 细心的作者通常会指出它们是否满足这些性质，比如说指明一个新引入的运算符满足结合律 但不满足交换律。</p><h4 id="operators">练习 <code>operators</code>（实践）</h4><p>请给出另一对运算符，它们拥有一个幺元，满足结合律、交换律，且其中一个对另一个满足分配律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4190" class="Comment">-- 请将代码写在此处</a>
</pre><p>请给出一个运算符的例子，它拥有幺元、满足结合律但不满足交换律。 （你不必证明这些性质）</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4365" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="结合律">结合律</h2><p>加法的一个性质是满足<strong>结合律</strong>，即括号的位置无关紧要：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的变量 <code>m</code>、<code>n</code> 和 <code>p</code> 的取值范围都是全体自然数。</p><p>我们可以为这三个变量选取特定的数值来验证此命题：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-4852" href="../Induction/#plfa_plfa-part1-Induction-4852" class="Function">_</a> <a id="plfa_plfa-part1-Induction-4854" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-4856" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4857" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4859" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4861" class="Number">4</a><a id="plfa_plfa-part1-Induction-4862" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4864" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4866" class="Number">5</a> <a id="plfa_plfa-part1-Induction-4868" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-4870" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4872" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4874" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4875" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4879" class="Number">5</a><a id="plfa_plfa-part1-Induction-4880" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-4882" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-4884" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-4888" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-4898" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4899" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4901" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4903" class="Number">4</a><a id="plfa_plfa-part1-Induction-4904" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-4906" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4908" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4912" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4920" class="Number">7</a> <a id="plfa_plfa-part1-Induction-4922" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4924" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-4928" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4936" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-4941" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4949" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4951" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4953" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-4957" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-4965" class="Number">3</a> <a id="plfa_plfa-part1-Induction-4967" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4969" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-4970" class="Number">4</a> <a id="plfa_plfa-part1-Induction-4972" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-4974" class="Number">5</a><a id="plfa_plfa-part1-Induction-4975" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-4979" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在这里，我们将计算过程写成了等式链，每行一个式子。这样的等式链通常非常易读， 你可以从上到下，直到遇到最简形式（本例中为 <code>12</code>），也可以从下到上，直到回到同样的式子。</p><p>该测试揭示了结合律可能没有它初看起来那么显然。为什么 <code>7 + 5</code> 与 <code>3 + 9</code> 相同？ 我们可能需要收集更多证据，选择其它的数值来验证此命题。但由于自然数是无限的， 因此测试永远无法完成。那么我们还有其它可以确保结合律对于<strong>所有</strong>自然数都成立的方法吗？</p><p>当然有！我们可以用<strong>归纳证明（Proof by Induction）</strong> 来确保某个性质对于所有的自然数都成立。</p><h2 id="归纳证明">归纳证明</h2><p>回想自然数的定义，它由一个<strong>起始步骤</strong>「<code>zero</code> 是一个自然数」 和一个<strong>归纳步骤</strong>「若 <code>m</code> 是一个自然数，则 <code>suc m</code> 也是一个自然数」构成。</p><p>归纳证明遵循此定义的结构。要通过归纳证明自然数的某个性质，我们需要两个步骤。 其一是<strong>起始步骤</strong>，即需要证明此性质对 <code>zero</code> 成立。其二是<strong>归纳步骤</strong>， 即假设此性质对一个任意自然数 <code>m</code> 成立（我们称之为<strong>归纳假设（Induction Hypothesis）</strong>），然后证明该性质对 <code>suc m</code> 必定成立。</p><p>若将 <code>m</code> 的某种性质（Property）写作 <code>P m</code>，那么我们需要证明的就是以下两个推导规则：</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>先来分析一下这些规则。第一条规则是起始步骤，它需要我们证明性质 <code>P</code> 对 <code>zero</code> 成立。第二条规则是归纳步骤，它需要我们证明若归纳假设「<code>P</code> 对 <code>m</code> 成立」， 那么 <code>P</code> 也对 <code>suc m</code> 成立。</p><p>为什么可以这样做呢？它也可以用创世故事来讲解。起初，我们对性质一无所知：</p><pre><code>-- 起初，世上没有已知的性质。</code></pre><p>现在我们对所有已知的性质应用上述两条规则。起始步骤告诉我们 <code>P zero</code> 成立， 所以我们将它加入已知的性质集合中。归纳步骤告诉我们若「昨天的」<code>P m</code> 成立， 那么「今天的」<code>P (suc m)</code> 也成立。我们在今天之前并不知道任何性质， 因此归纳步骤在这里不适用：</p><pre><code>-- 第一天，我们知道了一个性质。
P zero</code></pre><p>然后我们重复此过程。在接下来的一天我们知道今天之前的所有性质， 以及任何通过此规则添加的性质。起始步骤告诉我们 <code>P zero</code> 成立，我们已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>P zero</code> 在昨天成立，那么 <code>P (suc zero)</code> 今天也成立。</p><pre><code>-- 第二天，我们知道了两个性质。
P zero
P (suc zero)</code></pre><p>我们再重复此过程。现在归纳步骤告诉我们由于 <code>P zero</code> 和 <code>P (suc zero)</code> 都成立， 因此 <code>P (suc zero)</code> 和 <code>P (suc (suc zero))</code> 也成立。我们已经知道第一个成立了， 但第二个是新引入的：</p><pre><code>-- 第三天，我们知道了三个性质。
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了四个性质。
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的性质成立。 每个自然数的性质都会在某一天出现。具体来说，性质 <code>P n</code> 会在第 <em>n+1</em> 天 首次出现。</p><h2 id="第一个证明结合律">第一个证明：结合律</h2><p>要证明结合律，我们需要将 <code>P m</code> 看做以下性质：</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>这里的 <code>n</code> 和 <code>p</code> 是任意自然数，因此若我们可以证明该等式对所有的 <code>m</code> 都成立，那么它也会对所有的 <code>n</code> 和 <code>p</code> 成立。其推理规则的对应实例如下：</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>如果我们可以证明这两条规则，那么加法结合律就可以用归纳法来证明。</p><p>以下为此性质的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-11104" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11112" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11114" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11116" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11117" href="../Induction/#plfa_plfa-part1-Induction-11117" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11119" href="../Induction/#plfa_plfa-part1-Induction-11119" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11121" href="../Induction/#plfa_plfa-part1-Induction-11121" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11123" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11125" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11126" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11128" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11130" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11131" href="../Induction/#plfa_plfa-part1-Induction-11117" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11133" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11135" href="../Induction/#plfa_plfa-part1-Induction-11119" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11136" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11138" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11140" href="../Induction/#plfa_plfa-part1-Induction-11121" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11142" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11144" href="../Induction/#plfa_plfa-part1-Induction-11117" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11146" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11148" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11149" href="../Induction/#plfa_plfa-part1-Induction-11119" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11151" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11153" href="../Induction/#plfa_plfa-part1-Induction-11121" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11154" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11156" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11164" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11169" href="../Induction/#plfa_plfa-part1-Induction-11169" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11171" href="../Induction/#plfa_plfa-part1-Induction-11171" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11173" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11177" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11187" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11188" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11193" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11195" href="../Induction/#plfa_plfa-part1-Induction-11169" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11196" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11200" href="../Induction/#plfa_plfa-part1-Induction-11171" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11204" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11212" href="../Induction/#plfa_plfa-part1-Induction-11169" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11214" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11216" href="../Induction/#plfa_plfa-part1-Induction-11171" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11220" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11228" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-11233" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11235" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11236" href="../Induction/#plfa_plfa-part1-Induction-11169" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11238" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11240" href="../Induction/#plfa_plfa-part1-Induction-11171" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11241" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11245" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-11247" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11255" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11256" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11260" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a><a id="plfa_plfa-part1-Induction-11261" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11263" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11265" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11267" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11271" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11281" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11282" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11286" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11288" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11290" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11291" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11293" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11295" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11299" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11307" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11311" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11312" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11314" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11316" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11317" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11319" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11321" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11325" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11333" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11337" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11339" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11341" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11343" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11344" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11346" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11348" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11349" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11353" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11356" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11361" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11365" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11366" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-11374" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11376" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11378" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11379" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11381" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11387" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11391" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11392" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11396" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11397" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11399" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11401" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11402" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11407" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11415" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11419" href="../Induction/#plfa_plfa-part1-Induction-11260" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-11421" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11423" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11424" href="../Induction/#plfa_plfa-part1-Induction-11263" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11426" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11428" href="../Induction/#plfa_plfa-part1-Induction-11265" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11429" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11433" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们将此证明命名为 <code>+-assoc</code>。在 Agda 中，标识符可以由除空格和 <code>@.(){};_</code> 之外的任何字符序列构成。</p><p>我们来分析一下这段代码。其签名（Signature）描述了我们定义的标识符 <code>+-assoc</code> 为以下命题提供了证据（Evidence）：</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>倒 A 符号读作「对于所有（for all）」，而该命题断言对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，等式 <code>(m + n) + p ≡ m + (n + p)</code> 成立。该命题的证据是一个接受三个自然数的函数， 将它们绑定到 <code>m</code>、<code>n</code> 和 <code>p</code>，并返回该等式对应实例的证据。</p><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>用加法的起始步骤化简等式两边会得到：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。阅读此证明中起始步骤中的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们在中间遇到 <code>n + p</code> 。此步骤无需多言，化简即可。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>用加法的归纳步骤化简等式两边会得到：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此证明中归纳步骤的等式链，其最初和最末的式子分别匹配待证等式的两边， 从上到下或从下到上读都会让我们到达上面化简等式的地方。剩下的等式单化简还不行， 我们还需要为推理链使用一个附加的运算符 <code>_≡⟨_⟩_</code>， 并将等式的依据放在尖括号中。这里给出的依据是：</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>在这里，递归调用的 <code>+-assoc m n p</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。</p><p>若某个关系在应用了给定的函数后仍然保持不变，则称该关系满足<strong>合同性（Congruence）</strong>。 若 <code>e</code> 是 <code>x ≡ y</code> 的证据，那么对于任意函数 <code>f</code>，<code>cong f e</code> 就是 <code>f x ≡ f y</code> 的证据。</p><p>在这里并未假定归纳假设，而是通过递归调用我们定义的函数 <code>+-assoc m n p</code> 来证明。 对于加法，这是良基的（well-founded），因为更大数值的结合律可基于更小数值的结合律 来证明。在此步骤中，<code>assoc (suc m) n p</code> 是用 <code>assoc m n p</code> 证明的。 归纳证明和递归定义之间的这种对应是 Agda 中最吸引人的方面之一。</p><h2 id="归纳即递归">归纳即递归</h2><p>下面是归纳如何对应于递归的具体例子，它是在结合律的证明中，将 <code>m</code> 实例化为 <code>2</code> 时的计算过程。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-0"></a><a id="plfa_plfa-part1-Induction-15645" href="../Induction/#plfa_plfa-part1-Induction-15645" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15655" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15657" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15659" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15660" href="../Induction/#plfa_plfa-part1-Induction-15660" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15662" href="../Induction/#plfa_plfa-part1-Induction-15662" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15664" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15666" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15667" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15669" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15671" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15672" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15674" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15676" href="../Induction/#plfa_plfa-part1-Induction-15660" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15677" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15679" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15681" href="../Induction/#plfa_plfa-part1-Induction-15662" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15683" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15685" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15687" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15689" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15690" href="../Induction/#plfa_plfa-part1-Induction-15660" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15692" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15694" href="../Induction/#plfa_plfa-part1-Induction-15662" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15695" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15697" href="../Induction/#plfa_plfa-part1-Induction-15645" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15707" href="../Induction/#plfa_plfa-part1-Induction-15707" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15709" href="../Induction/#plfa_plfa-part1-Induction-15709" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15711" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15715" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15725" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15726" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15728" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15730" href="../Induction/#plfa_plfa-part1-Induction-15707" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15731" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15733" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15735" href="../Induction/#plfa_plfa-part1-Induction-15709" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15739" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15747" href="../Induction/#plfa_plfa-part1-Induction-15707" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15749" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15751" href="../Induction/#plfa_plfa-part1-Induction-15709" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15755" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15763" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15765" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15767" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15768" href="../Induction/#plfa_plfa-part1-Induction-15707" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15770" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15772" href="../Induction/#plfa_plfa-part1-Induction-15709" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15773" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15777" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-1"></a><a id="plfa_plfa-part1-Induction-15780" href="../Induction/#plfa_plfa-part1-Induction-15780" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15790" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15792" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-15794" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15795" href="../Induction/#plfa_plfa-part1-Induction-15795" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15797" href="../Induction/#plfa_plfa-part1-Induction-15797" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15799" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-15801" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-15802" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15804" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-15806" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15807" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15809" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15811" href="../Induction/#plfa_plfa-part1-Induction-15795" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15812" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15814" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15816" href="../Induction/#plfa_plfa-part1-Induction-15797" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15818" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-15820" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15822" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15824" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15825" href="../Induction/#plfa_plfa-part1-Induction-15795" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15827" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15829" href="../Induction/#plfa_plfa-part1-Induction-15797" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15830" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-15832" href="../Induction/#plfa_plfa-part1-Induction-15780" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-15842" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15844" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-15846" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-15850" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-15860" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15861" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15863" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15865" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15866" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15868" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15870" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15874" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15886" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15887" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15891" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15892" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15894" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15896" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-15900" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15908" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15912" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-15914" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15916" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15918" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15919" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15921" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15923" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15924" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15928" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-15931" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-15936" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15940" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15941" href="../Induction/#plfa_plfa-part1-Induction-15645" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-15951" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15953" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15954" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15956" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-15962" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15966" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15967" class="Number">0</a> <a id="plfa_plfa-part1-Induction-15969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15971" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15972" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15974" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15976" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a><a id="plfa_plfa-part1-Induction-15977" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-15982" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15990" class="Number">1</a> <a id="plfa_plfa-part1-Induction-15992" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15994" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15995" href="../Induction/#plfa_plfa-part1-Induction-15842" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-15997" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15999" href="../Induction/#plfa_plfa-part1-Induction-15844" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16000" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16004" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-16007" href="../Induction/#plfa_plfa-part1-Induction-16007" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16017" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16019" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16021" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16022" href="../Induction/#plfa_plfa-part1-Induction-16022" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16024" href="../Induction/#plfa_plfa-part1-Induction-16024" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16026" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16028" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16029" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16031" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16033" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16034" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16036" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16038" href="../Induction/#plfa_plfa-part1-Induction-16022" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16039" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16041" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16043" href="../Induction/#plfa_plfa-part1-Induction-16024" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16045" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16047" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16049" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16051" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16052" href="../Induction/#plfa_plfa-part1-Induction-16022" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16054" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16056" href="../Induction/#plfa_plfa-part1-Induction-16024" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16057" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-16059" href="../Induction/#plfa_plfa-part1-Induction-16007" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-16069" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16071" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-16073" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-16077" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-16087" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16088" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16090" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16092" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16093" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16095" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16097" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16101" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16109" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16113" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16114" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16116" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16118" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16119" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16121" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16123" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-16127" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16135" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16139" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-16141" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16145" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16146" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16150" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16151" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16155" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16158" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16163" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16167" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16168" href="../Induction/#plfa_plfa-part1-Induction-15780" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-16178" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16180" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16181" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16183" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16189" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16193" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16194" class="Number">1</a> <a id="plfa_plfa-part1-Induction-16196" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16198" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16199" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16201" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16203" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16204" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-16209" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16217" class="Number">2</a> <a id="plfa_plfa-part1-Induction-16219" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16221" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16222" href="../Induction/#plfa_plfa-part1-Induction-16069" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16224" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16226" href="../Induction/#plfa_plfa-part1-Induction-16071" class="Bound">p</a><a id="plfa_plfa-part1-Induction-16227" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16231" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h2 id="术语与记法">术语与记法</h2><p>在结合律的陈述中出现的符号 <code>∀</code> 表示它对于所有的 <code>m</code>、<code>n</code> 和 <code>p</code> 都成立。 我们将 <code>∀</code> 称为<strong>全称量词（Universal Quantifier）</strong>，我们会在 <a href="../Quantifiers/">Quantifiers</a> 章节中进一步讨论。</p><p>全称量词的证据是一个函数。函数签名</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>和</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>是等价的。和 <code>ℕ → ℕ → ℕ</code> 这样的函数类型不同，上述函数中的变量 与每一个实参类型相关联，且其结果类型可能会涉及（或依赖于）这些变量， 因此它们叫做<strong>依赖函数（Dependent Function）</strong>。</p><p>Ordinary functions are a special case of dependent functions. For instance, the signatures</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m n : ℕ) → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m : ℕ) → ∀ (n : ℕ) → ℕ</code></pre><p>are all equivalent.</p><h2 id="第二个证明交换律">第二个证明：交换律</h2><p>加法的另一个重要性质是满足<strong>交换律（Commutativity）</strong>，即运算数的顺序无关紧要：</p><pre><code>m + n ≡ n + m</code></pre><p>要证明它，我们需要先证明两条引理（Lemma）。</p><h3 id="第一条引理">第一条引理</h3><p>加法定义的起始步骤说明零是一个左幺元：</p><pre><code>zero + n ≡ n</code></pre><p>我们的第一条引理则说明零也是一个右幺元：</p><pre><code>m + zero ≡ m</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-18189" href="../Induction/#plfa_plfa-part1-Induction-18189" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18201" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18203" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18205" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18206" href="../Induction/#plfa_plfa-part1-Induction-18206" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18208" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18210" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18211" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18213" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18215" href="../Induction/#plfa_plfa-part1-Induction-18206" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18219" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18224" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18226" href="../Induction/#plfa_plfa-part1-Induction-18206" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-18228" href="../Induction/#plfa_plfa-part1-Induction-18189" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18240" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18245" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18249" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18259" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-18264" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18266" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18273" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18281" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18288" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-18290" href="../Induction/#plfa_plfa-part1-Induction-18189" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18302" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18303" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18307" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18308" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18310" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18314" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18324" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18328" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18330" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-18339" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-18347" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18351" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18352" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18356" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-18360" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18364" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18367" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18372" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18376" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18377" href="../Induction/#plfa_plfa-part1-Induction-18189" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-18389" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">m</a><a id="plfa_plfa-part1-Induction-18390" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18392" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18398" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-18402" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-18406" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-identityʳ</code> 提供了以下命题的证据：</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>该命题的证据是一个函数，它接受一个自然数，将其绑定到 <code>m</code>，然后返回 该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + zero ≡ zero</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m) + zero = suc m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + zero) = suc m</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + zero ≡ m</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>阅读此等式链，从上到下和从下到上读都会让我们到达上面化简等式的地方。 剩下的等式可由以下依据得出：</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>在这里，递归调用的 <code>+-identityʳ m</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第一条引理证毕。</p><h3 id="第二条引理">第二条引理</h3><p>加法定义的归纳步骤将第一个参数的 <code>suc</code> 推到了外面：</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>我们的第二条引理则对第二个参数的 <code>suc</code> 做同样的事情：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>下面是该引理的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-20407" href="../Induction/#plfa_plfa-part1-Induction-20407" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20413" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20415" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-20417" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20418" href="../Induction/#plfa_plfa-part1-Induction-20418" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20420" href="../Induction/#plfa_plfa-part1-Induction-20420" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20422" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-20424" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-20425" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20427" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-20429" href="../Induction/#plfa_plfa-part1-Induction-20418" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20431" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20433" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20437" href="../Induction/#plfa_plfa-part1-Induction-20420" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20439" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-20441" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20445" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20446" href="../Induction/#plfa_plfa-part1-Induction-20418" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20450" href="../Induction/#plfa_plfa-part1-Induction-20420" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20451" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-20453" href="../Induction/#plfa_plfa-part1-Induction-20407" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20459" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20464" href="../Induction/#plfa_plfa-part1-Induction-20464" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20466" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20470" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20480" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20485" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20487" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20491" href="../Induction/#plfa_plfa-part1-Induction-20464" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20495" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20503" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20507" href="../Induction/#plfa_plfa-part1-Induction-20464" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20511" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20519" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20523" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-20529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20531" href="../Induction/#plfa_plfa-part1-Induction-20464" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20532" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20536" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-20538" href="../Induction/#plfa_plfa-part1-Induction-20407" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20544" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20545" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20549" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a><a id="plfa_plfa-part1-Induction-20550" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20552" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-20554" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-20558" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-20568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20572" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20574" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20576" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20580" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-20584" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20592" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20596" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20597" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20599" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20601" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20605" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20606" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20610" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-20613" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-20618" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20622" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20623" href="../Induction/#plfa_plfa-part1-Induction-20407" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-20629" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20631" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20632" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-20634" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-20640" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20644" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20645" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20649" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20650" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20652" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20654" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20655" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-20660" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-20668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20672" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-20673" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-20677" href="../Induction/#plfa_plfa-part1-Induction-20549" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-20679" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-20681" href="../Induction/#plfa_plfa-part1-Induction-20552" class="Bound">n</a><a id="plfa_plfa-part1-Induction-20682" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-20686" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>其签名说明我们定义的标识符 <code>+-suc</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>m</code> 进行归纳来证明。</p><p>对于起始步骤，我们必须证明：</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>根据加法的起始步骤化简，这很显然。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>反之，它也可以通过在归纳假设</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>两边之前加上 <code>suc</code> 得到。</p><p>从上到下或从下到上阅读等式链都会让我们在中间遇到化简后的等式。剩下的等式 可由以下依据得出：</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>在这里，递归调用的 <code>+-suc m n</code> 拥有归纳假设的类型，而 <code>cong suc</code> 会在等式两边的前面加上 <code>suc</code> 以得到需要的等式。第二条引理证毕。</p><h3 id="命题">命题</h3><p>最后，以下是我们的命题的陈述和证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-22457" href="../Induction/#plfa_plfa-part1-Induction-22457" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22464" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22466" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22468" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22469" href="../Induction/#plfa_plfa-part1-Induction-22469" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22471" href="../Induction/#plfa_plfa-part1-Induction-22471" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22473" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22475" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22476" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22478" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22480" href="../Induction/#plfa_plfa-part1-Induction-22469" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22482" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22484" href="../Induction/#plfa_plfa-part1-Induction-22471" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22486" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22488" href="../Induction/#plfa_plfa-part1-Induction-22471" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22490" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22492" href="../Induction/#plfa_plfa-part1-Induction-22469" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-22494" href="../Induction/#plfa_plfa-part1-Induction-22457" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22501" href="../Induction/#plfa_plfa-part1-Induction-22501" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22503" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22508" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22512" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22522" href="../Induction/#plfa_plfa-part1-Induction-22501" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22526" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-22533" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22536" href="../Induction/#plfa_plfa-part1-Induction-18189" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-22548" href="../Induction/#plfa_plfa-part1-Induction-22501" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22550" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22556" href="../Induction/#plfa_plfa-part1-Induction-22501" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22560" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22568" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-22573" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22575" href="../Induction/#plfa_plfa-part1-Induction-22501" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22579" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-22581" href="../Induction/#plfa_plfa-part1-Induction-22457" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22588" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22590" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22591" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22595" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22596" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22598" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-22602" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-22612" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22614" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22616" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22620" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-22624" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22627" href="../Induction/#plfa_plfa-part1-Induction-20407" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-22633" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22635" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22637" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22643" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22647" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22648" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22650" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22652" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22653" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22657" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-22660" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-22665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22669" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22670" href="../Induction/#plfa_plfa-part1-Induction-22457" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-22677" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22679" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22680" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22682" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-22688" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22692" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22693" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22695" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22697" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22698" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-22702" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-22710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22714" href="../Induction/#plfa_plfa-part1-Induction-22595" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22716" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22718" href="../Induction/#plfa_plfa-part1-Induction-22588" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-22722" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行说明我们定义的标识符 <code>+-comm</code> 提供了以下命题的证据：</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>该命题的证据是一个函数，它接受两个自然数，将二者分别绑定到 <code>m</code> 和 <code>n</code>， 并返回该等式对应实例的证据。它通过对 <code>n</code> 进行归纳来证明。（这次不是 <code>m</code>！）</p><p>对于起始步骤，我们必须证明：</p><pre><code>m + zero ≡ zero + m</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>m + zero ≡ m</code></pre><p>剩下的等式可由依据 <code>⟨ +-identityʳ m ⟩</code> 得出，它调用第一条引理。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>我们分两步来证明它。首先，我们有：</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>它依据第二条引理 <code>⟨ +-suc m n ⟩</code> 得出。之后我们有：</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>它依据合同性和归纳假设 <code>⟨ cong suc (+-comm m n) ⟩</code> 得出。证毕。</p><p>Agda 要求标识符必须在使用前定义，因此我们必须在主命题之前列出引理， 如前例所示。在实践中，我们通常会先试着证明主命题，之后所需的等式会说明 需要证明哪些引理。</p><h2 id="sections">第一个推论：重排定理</h2><p>我们可以随意应用结合律来重排括号。例如：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-24864" href="../Induction/#plfa_plfa-part1-Induction-24864" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24876" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24878" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-24880" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24881" href="../Induction/#plfa_plfa-part1-Induction-24881" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24883" href="../Induction/#plfa_plfa-part1-Induction-24883" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24885" href="../Induction/#plfa_plfa-part1-Induction-24885" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24887" href="../Induction/#plfa_plfa-part1-Induction-24887" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24889" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-24891" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-24892" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24894" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-24896" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24897" href="../Induction/#plfa_plfa-part1-Induction-24881" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24899" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24901" href="../Induction/#plfa_plfa-part1-Induction-24883" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24902" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24904" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24906" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24907" href="../Induction/#plfa_plfa-part1-Induction-24885" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24909" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24911" href="../Induction/#plfa_plfa-part1-Induction-24887" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24912" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24914" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-24916" href="../Induction/#plfa_plfa-part1-Induction-24881" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24918" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24920" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24921" href="../Induction/#plfa_plfa-part1-Induction-24883" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24923" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24925" href="../Induction/#plfa_plfa-part1-Induction-24885" class="Bound">p</a><a id="plfa_plfa-part1-Induction-24926" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24928" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24930" href="../Induction/#plfa_plfa-part1-Induction-24887" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-24932" href="../Induction/#plfa_plfa-part1-Induction-24864" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-24944" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24946" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-24948" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24950" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-24952" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-24956" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-24966" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24967" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-24969" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24971" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a><a id="plfa_plfa-part1-Induction-24972" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-24974" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24976" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24977" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-24979" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-24981" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a><a id="plfa_plfa-part1-Induction-24982" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-24986" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-24989" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-24993" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-24994" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25002" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25003" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25005" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25007" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25008" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25010" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-25012" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25013" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25015" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25021" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-25023" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25025" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25027" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a><a id="plfa_plfa-part1-Induction-25028" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25030" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25032" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25033" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25035" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25037" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25041" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-25044" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-25049" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25050" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-25053" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a><a id="plfa_plfa-part1-Induction-25054" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25056" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25057" href="../Induction/#plfa_plfa-part1-Induction-11104" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-25065" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25067" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25069" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25070" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-25072" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-25078" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25079" href="../Induction/#plfa_plfa-part1-Induction-24944" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-25081" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25083" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-25084" href="../Induction/#plfa_plfa-part1-Induction-24946" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-25086" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25088" href="../Induction/#plfa_plfa-part1-Induction-24948" class="Bound">p</a><a id="plfa_plfa-part1-Induction-25089" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-25092" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-25094" href="../Induction/#plfa_plfa-part1-Induction-24950" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-25098" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>无需归纳法，我们只不过应用了两次结合律就完成了证明。其中有几点需要注意的地方。</p><p>第一，加法是左结合的，因此 <code>m + (n + p) + q</code> 表示 <code>(m + (n + p)) + q</code>。</p><p>第二，我们用 <code>sym</code> 来交换等式的两边。命题 <code>+-assoc (m + n) p q</code> 会将括号从左边移到右边：</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>要往另一个方向移动括号，我们要用 <code>sym (+-assoc (m + n) p q)</code>：</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>一般来说，若 <code>e</code> 提供了 <code>x ≡ y</code> 的证据，那么 <code>sym e</code> 就提供了 <code>y ≡ x</code> 的证据。</p><p>第三，Agda 支持 Richard Bird 引入的<strong>片段（Section）</strong>记法。我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(_+ y)</code>。因此，对于 <code>assoc m n p</code> 应用合同性 <code>cong (_+ q)</code> 会将等式：</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>转换成:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>类似地，我们将应用到 <code>x</code> 并返回 <code>x + y</code> 的函数写作 <code>(x +_ )</code>。 这同样适用于任何中缀运算符。</p><h2 id="创世最后一次">创世，最后一次</h2><p>我们回到结合律的证明上来，把归纳证明（或等价的递归定义）看做一个创世故事会有助于理解。 这次我们专注于判断结合律的断言：</p><pre><code> -- 起初，我们对结合律一无所知。</code></pre><p>现在，我们将规则应用到所有已知的判断上来。起始步骤告诉我们对于所有的自然数 <code>n</code> 和 <code>p</code> 来说，<code>(zero + n) + p ≡ zero + (n + p)</code>。归纳步骤告我我们若 <code>(m + n) + p ≡ m + (n + p)</code>（在昨天）成立，那么 <code>(suc m + n) + p ≡ suc m + (n + p)</code> （在今天）也成立。我们在今天之前并不知道任何关于结合律的判断， 因此此规则并未给出任何新的判断：</p><pre><code>-- 第一天，我们知道了关于 0 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>之后我们重复此过程，因此接下来一天我们知道今天以前的所有判断， 以及任何通过此规则添加的判断。起始步骤并未告诉我们新的东西， 而如今归归纳步骤添加了更多的判断：</p><pre><code>-- 第二天，我们知道了关于 0 和 1 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>我们再次重复此过程：</p><pre><code>-- 第三天，我们知道了关于 0、1 和 2 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了关于 0、1、2 和 3 的结合律。
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们会知道所有第一个数小于 <em>m</em> 的判断。</p><p>还有一种完全有限的方法来生成同样的等式，它的证明留作读者的练习。</p><h4 id="finite-plus-assoc">练习 <code>finite-+-assoc</code>（延伸）</h4><p>请参考<a href="../Naturals/#finite-creation">前文</a>写出前四天已知的加法结合律的创世故事。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-30759" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="用改写来证明结合律">用改写来证明结合律</h2><p>证明可不止一种方法。下面是第二种在 Agda 中证明加法结合律的方法，使用 <code>rewrite</code>（改写） 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-31061" href="../Induction/#plfa_plfa-part1-Induction-31061" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31070" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31072" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-31074" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31075" href="../Induction/#plfa_plfa-part1-Induction-31075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31077" href="../Induction/#plfa_plfa-part1-Induction-31077" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31079" href="../Induction/#plfa_plfa-part1-Induction-31079" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31081" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-31083" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-31084" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31086" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-31088" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31089" href="../Induction/#plfa_plfa-part1-Induction-31075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31091" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31093" href="../Induction/#plfa_plfa-part1-Induction-31077" class="Bound">n</a><a id="plfa_plfa-part1-Induction-31094" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31096" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31098" href="../Induction/#plfa_plfa-part1-Induction-31079" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-31100" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-31102" href="../Induction/#plfa_plfa-part1-Induction-31075" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31104" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31106" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31107" href="../Induction/#plfa_plfa-part1-Induction-31077" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31109" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-31111" href="../Induction/#plfa_plfa-part1-Induction-31079" class="Bound">p</a><a id="plfa_plfa-part1-Induction-31112" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-31114" href="../Induction/#plfa_plfa-part1-Induction-31061" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31123" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-31131" href="../Induction/#plfa_plfa-part1-Induction-31131" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31133" href="../Induction/#plfa_plfa-part1-Induction-31133" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-31160" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31163" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-31168" href="../Induction/#plfa_plfa-part1-Induction-31061" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31177" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-31178" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-31182" href="../Induction/#plfa_plfa-part1-Induction-31182" class="Bound">m</a><a id="plfa_plfa-part1-Induction-31183" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-31185" href="../Induction/#plfa_plfa-part1-Induction-31185" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31187" href="../Induction/#plfa_plfa-part1-Induction-31187" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31190" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-31198" href="../Induction/#plfa_plfa-part1-Induction-31061" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-31207" href="../Induction/#plfa_plfa-part1-Induction-31182" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-31209" href="../Induction/#plfa_plfa-part1-Induction-31185" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-31211" href="../Induction/#plfa_plfa-part1-Induction-31187" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-31214" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-31217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>对于起始步骤，我们必须证明：</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>根据加法的起始步骤化简等式两边可得：</p><pre><code>n + p ≡ n + p</code></pre><p>此式平凡成立。一个项等于其自身的证明写作 <code>refl</code>（自反性）。</p><p>对于归纳步骤，我们必须证明：</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>根据加法的归纳步骤化简等式两边可得：</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>其证明同样由 <code>refl</code> 给出。改写不仅可以省去等式链还可以避免调用 <code>cong</code>.</p><h2 id="使用改写证明交换律">使用改写证明交换律</h2><p>下面是加法交换律的第二个证明，使用 <code>rewrite</code> 而非等式链：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-32587" href="../Induction/#plfa_plfa-part1-Induction-32587" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32599" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32601" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32603" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32604" href="../Induction/#plfa_plfa-part1-Induction-32604" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32606" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32608" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32609" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32611" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32613" href="../Induction/#plfa_plfa-part1-Induction-32604" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32615" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32617" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32622" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32624" href="../Induction/#plfa_plfa-part1-Induction-32604" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-32626" href="../Induction/#plfa_plfa-part1-Induction-32587" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32638" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32643" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32645" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32650" href="../Induction/#plfa_plfa-part1-Induction-32587" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32662" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32667" href="../Induction/#plfa_plfa-part1-Induction-32667" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32668" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32670" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32678" href="../Induction/#plfa_plfa-part1-Induction-32587" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32690" href="../Induction/#plfa_plfa-part1-Induction-32667" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32692" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-32700" href="../Induction/#plfa_plfa-part1-Induction-32700" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32707" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32709" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32711" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32712" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32714" href="../Induction/#plfa_plfa-part1-Induction-32714" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32716" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32718" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32719" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32721" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32723" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32727" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32731" href="../Induction/#plfa_plfa-part1-Induction-32714" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32733" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32735" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32739" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32740" href="../Induction/#plfa_plfa-part1-Induction-32712" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32742" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32744" href="../Induction/#plfa_plfa-part1-Induction-32714" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32745" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-32747" href="../Induction/#plfa_plfa-part1-Induction-32700" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32754" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32759" href="../Induction/#plfa_plfa-part1-Induction-32759" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32761" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32763" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32768" href="../Induction/#plfa_plfa-part1-Induction-32700" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32775" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32776" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32780" href="../Induction/#plfa_plfa-part1-Induction-32780" class="Bound">m</a><a id="plfa_plfa-part1-Induction-32781" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32783" href="../Induction/#plfa_plfa-part1-Induction-32783" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32785" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32793" href="../Induction/#plfa_plfa-part1-Induction-32700" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32800" href="../Induction/#plfa_plfa-part1-Induction-32780" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32802" href="../Induction/#plfa_plfa-part1-Induction-32783" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32804" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32806" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-32812" href="../Induction/#plfa_plfa-part1-Induction-32812" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32820" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32822" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-32824" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32825" href="../Induction/#plfa_plfa-part1-Induction-32825" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32827" href="../Induction/#plfa_plfa-part1-Induction-32827" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32829" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-32831" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-32832" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32834" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-32836" href="../Induction/#plfa_plfa-part1-Induction-32825" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32838" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32840" href="../Induction/#plfa_plfa-part1-Induction-32827" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32842" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-32844" href="../Induction/#plfa_plfa-part1-Induction-32827" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32846" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-32848" href="../Induction/#plfa_plfa-part1-Induction-32825" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-32850" href="../Induction/#plfa_plfa-part1-Induction-32812" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32858" href="../Induction/#plfa_plfa-part1-Induction-32858" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32860" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-32865" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32873" href="../Induction/#plfa_plfa-part1-Induction-32587" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-32885" href="../Induction/#plfa_plfa-part1-Induction-32858" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32887" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-32894" href="../Induction/#plfa_plfa-part1-Induction-32812" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32902" href="../Induction/#plfa_plfa-part1-Induction-32902" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32904" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-32905" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-32909" href="../Induction/#plfa_plfa-part1-Induction-32909" class="Bound">n</a><a id="plfa_plfa-part1-Induction-32910" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-32912" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-32920" href="../Induction/#plfa_plfa-part1-Induction-32700" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-32927" href="../Induction/#plfa_plfa-part1-Induction-32902" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32929" href="../Induction/#plfa_plfa-part1-Induction-32909" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32931" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-32933" href="../Induction/#plfa_plfa-part1-Induction-32812" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-32941" href="../Induction/#plfa_plfa-part1-Induction-32902" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-32943" href="../Induction/#plfa_plfa-part1-Induction-32909" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-32945" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-32947" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>在最后一行中，用两个等式进行改写被表示为用一条竖线分隔两个相关等式的证明。 左边的改写会在右边之前被执行。</p><h2 id="交互式构造证明">交互式构造证明</h2><p>看看如何在 Emacs 中用 Agda 的交互式特性来构造另一种结合律的证明会很有启发性。 我们从输入以下内容开始：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>其中的问号表示你想要 Agda 帮你填充的代码。如果你按下 <code>C-c C-l</code> （先按 Ctrl-c 再按 Ctrl-l），那么问号会被替换为：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>空的大括号叫做<strong>洞（Hole）</strong>，0 是用来指代此洞的编号。洞可能会以绿色高亮显示。 Emacs 还会在屏幕下方创建一个新的窗口并显示文本：</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>这表示 0 号洞需要以所提示的判断的证明来填充。</p><p>我们希望对 <code>m</code> 进行归纳来证明此命题。将光标移动到洞中并按下 <code>C-c C-c</code>。它会给出提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>按下 <code>m</code> 会拆分该变量，并更新此代码：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>现在有两个洞了，下方的窗口会告诉你每个洞中需要证明的内容：</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>进入 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>它表示在化简之后，0 号洞的目标如上所示，所示类型的变量 <code>p</code> 和 <code>n</code> 可在证明中使用。 给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充。按下 <code>C-c C-l</code> 会将剩下的洞重新编号为 0：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>进入新的 0 号洞并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>同样，它会给出化简后的目标和可用的变量。在此步骤中，我们需要根据归纳假设进行改写， 于是我们来编辑这些文本：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>进入剩下的洞中并按下 <code>C-c C-,</code> 会显示以下文本：</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>给定目标的证明很平凡，只需进入该目标并按下 <code>C-c C-r</code> 即可填充并完成证明：</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">练习：<code>+-swap</code>（推荐）</h4><p>请证明对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>成立。无需归纳证明，只需应用前面满足结合律和交换律的结果即可。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37468" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-distrib-plus">练习 <code>*-distrib-+</code>（推荐）</h4><p>请证明乘法对加法满足分配律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-37808" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-assoc">练习 <code>*-assoc</code>（推荐）</h4><p>请证明乘法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38110" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="times-comm">练习 <code>*-comm</code>（实践）</h4><p>请证明乘法满足交换律，即对于所有的自然数 <code>m</code> 和 <code>n</code>，</p><pre><code>m * n ≡ n * m</code></pre><p>成立。和加法交换律一样，你需要陈述并证明配套的引理。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38496" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="zero-monus">练习 <code>0∸n≡0</code>（实践）</h4><p>请证明对于所有的自然数 <code>n</code>，</p><pre><code>zero ∸ n ≡ zero</code></pre><p>成立。你的证明需要归纳法吗？</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-38752" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="monus-plus-assoc">练习 <code>∸-+-assoc</code>（实践）</h4><p>请证明饱和减法与加法满足结合律，即对于所有的自然数 <code>m</code>、<code>n</code> 和 <code>p</code>，</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39075" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-延伸">练习 <code>+*^</code> （延伸）</h4><p>证明下列三条定律</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>对于所有 <code>m</code>、<code>n</code> 和 <code>p</code> 成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-39431" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="Bin-laws">练习 <code>Bin-laws</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a> 中定义的一种表示自然数的比特串数据类型 <code>Bin</code> 以及要求你定义的函数：</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>考虑以下定律，其中 <code>n</code> 表示自然数，<code>b</code> 表示比特串：</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>对于每一条定律：若它成立，请证明；若不成立，请给出一个反例。</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40142" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>本章中类似的定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-40318" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-40325" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-40345" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-40351" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-40352" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-40359" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40361" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-40372" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40374" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#12854" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-40379" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-40381" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-40387" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章中使用了以下 Unicode：</p><pre><code>∀  U+2200  对于所有 (\forall, \all)
ʳ  U+02B3  修饰符小写字母 r (\^r)
′  U+2032  撇号 (\&#39;)
″  U+2033  双撇号 (\&#39;)
‴  U+2034  三撇号 (\&#39;)
⁗  U+2057  四撇号 (\&#39;)</code></pre><p>与 <code>\r</code> 类似，命令 <code>\^r</code> 列出了多种上标右箭头的变体，以及上标的字母 <code>r</code>。 命令 <code>\&#39;</code> 列出了一些撇号（<code>′ ″ ‴ ⁗</code>）。</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Induction.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Oling Cat<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>