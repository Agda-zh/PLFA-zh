<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-dJLJysMdqXtVegSgJLzVykvHbDNrQjmEoKen2rU7YiGMbNpIJIZA1D6HLml44nUJyUGPQ1vkYmT4t5PXKVuBxw==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-/ARdgOQa4vn2XAt4Y1F6NSxFACJwwEuz9pC9NZJHfA6M70ZLUlDoqqeh1kAoVZXgqSw2W4T4J1xuBba725O5/A==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Style guide for PLFA</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/web/StyleGuide.md">源文件</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Style guide for PLFA</h1></header><div class="post-content"><p>This is based on <a href="https://github.com/agda/agda-stdlib/blob/master/notes/style-guide.md">the style guide for the Agda standard library</a>. Like it, this is very much a work-in-progress and is not exhaustive.</p><h2 id="file-structure">File structure</h2><h4 id="module-imports">Module imports</h4><ul><li><p>All module imports should be placed at the top of the file immediately after the module declaration.</p></li><li><p>If the module takes parameters that require imports from other files then those imports only may be placed above the module declaration.</p></li><li><p>If it is important that certain names only come into scope later in the file then the module should still be imported at the top of the file but it can be given a shorter name using <code>as</code> and then opened later on in the file when needed, e.g.</p><div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> Data<span class="ot">.</span>List<span class="ot">.</span>Relation<span class="ot">.</span>Binary<span class="ot">.</span>Equality<span class="ot">.</span>Setoid as SetoidEquality</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> SetoidEquality S</span></code></pre></div></li><li><p>The list of module imports should be in alphabetical order.</p></li><li><p>When using only a few items from a module, the items should be enumerated in the import with <code>using</code> in order to make dependencies clearer.</p></li></ul><h4 id="indentation">Indentation</h4><ul><li><p>The contents of a top-level module should have zero indentation.</p></li><li><p>Every subsequent nested scope should then be indented by an additional two spaces.</p></li><li><p><code>where</code> blocks should be indented by two spaces and their contents should be aligned with the <code>where</code>.</p></li><li><p>If the type of a term does not fit on one line then the subsequent lines of the type should all be indented by two spaces, e.g.</p><div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>map-cong₂ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>f g <span class="ot">:</span> A <span class="ot">→</span> B<span class="ot">}</span> <span class="ot">{</span>xs<span class="ot">}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">→</span> All <span class="ot">(λ</span> x <span class="ot">→</span> f x ≡ g x<span class="ot">)</span> xs <span class="ot">→</span> map f xs ≡ map g xs</span></code></pre></div></li><li><p>As can be seen in the example above, function arrows at line breaks should always go at the beginning of the next line rather than the end of the line.</p></li></ul><h4 id="module-parameters">Module parameters</h4><ul><li><p>Module parameters should be put on a single line if they fit.</p></li><li><p>If they don’t fit on a single line, then they should be spread out over multiple lines, each indented by two spaces. If they can be grouped logically by line then it is fine to do so, otherwise a line each is probably clearest.</p></li><li><p>The <code>where</code> should go on it’s own line at the end.</p></li><li><p>For example:</p><div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>Reasoning<span class="ot">.</span>Base<span class="ot">.</span>Single</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>∼<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(</span>refl <span class="ot">:</span> Reflexive <span class="ot">_</span>∼<span class="ot">_)</span> <span class="ot">(</span>trans <span class="ot">:</span> Transitive <span class="ot">_</span>∼<span class="ot">_)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span></code></pre></div></li></ul><h4 id="reasoning-layout">Reasoning layout</h4><ul><li><p>The <code>begin</code> clause should go on a new line.</p></li><li><p>Every subsequent combinator <code>_≡⟨_⟩_</code> should go on its own line, with the intermediate terms on their own line, indented by two spaces.</p></li><li><p>The relation sign (e.g. <code>≡</code>) for each line should be aligned if possible.</p></li><li><p>For example:</p><div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>+-comm <span class="ot">:</span> Commutative <span class="ot">_</span>+<span class="ot">_</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>+-comm zero    n <span class="ot">=</span> sym <span class="ot">(</span>+-identityʳ n<span class="ot">)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>+-comm <span class="ot">(</span>suc m<span class="ot">)</span> n <span class="ot">=</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    suc m + n</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  ≡⟨⟩</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    suc <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  ≡⟨ cong suc <span class="ot">(</span>+-comm m n<span class="ot">)</span> ⟩</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    suc <span class="ot">(</span>n + m<span class="ot">)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  ≡⟨ sym <span class="ot">(</span>+-suc n m<span class="ot">)</span> ⟩</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    n + suc m</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  ∎</span></code></pre></div></li><li><p>When multiple reasoning frameworks need to be used in the same file, the <code>open</code> statement should always come in a where clause local to the definition. This way users can easily see which reasoning toolkit is being used. For instance:</p><div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>foo m n p <span class="ot">=</span> begin</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(...)</span> ∎</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> <span class="kw">open</span> ≤-Reasoning</span></code></pre></div></li></ul><h4 id="record-layout">Record layout</h4><ul><li><p>The <code>record</code> declaration should go on the same line as the rest of the proof.</p></li><li><p>The next line with the first record item should start with a single <code>{</code>.</p></li><li><p>Every subsequent item of the record should go on its own line starting with a <code>;</code>.</p></li><li><p>The final line should end with <code>}</code> on its own.</p></li><li><p>For example:</p><div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>≤-isPreorder <span class="ot">:</span> IsPreorder <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">_</span>≤<span class="ot">_</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>≤-isPreorder <span class="ot">=</span> <span class="kw">record</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{</span> isEquivalence <span class="ot">=</span> isEquivalence</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">;</span> reflexive     <span class="ot">=</span> ≤-reflexive</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">;</span> trans         <span class="ot">=</span> ≤-trans</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">}</span></span></code></pre></div></li></ul><h4 id="where-blocks"><code>where</code> blocks</h4><ul><li><p><code>where</code> blocks are preferred rather than the <code>let</code> construction.</p></li><li><p>The <code>where</code> should be placed on the line below the main proof, indented by two spaces.</p></li><li><p>If the contents of the block is non-trivial then types should be provided alongside the terms, and all terms should be on lines after the <code>where</code>, e.g.</p><div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>statement <span class="ot">:</span> Statement</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>statement <span class="ot">=</span> proof</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      proof <span class="ot">:</span> Proof</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      proof <span class="ot">=</span> some-very-long-proof</span></code></pre></div></li><li><p>If the contents of the block is trivial or is an <code>open</code> statement then it can provided on the same line as the <code>where</code> and a type can be omitted, e.g.</p><div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>statement <span class="ot">:</span> Statement</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>statement <span class="ot">=</span> proof</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> proof <span class="ot">=</span> x</span></code></pre></div></li></ul><h4 id="other">Other</h4><ul><li><p>Non-trivial proofs in <code>private</code> blocks are generally discouraged. If its non-trivial then the chances are someone will want to reuse it as some point!</p></li><li><p>The <code>with</code> syntax is preferred over the use of <code>case</code> from the <code>Function</code> module.</p></li></ul><h2 id="types">Types</h2><h4 id="implicit-and-explicit-arguments">Implicit and explicit arguments</h4><ul><li><p>Functions arguments should be implicit if they can “almost always” be inferred. If there are common cases where they cannot be inferred then they should be left explicit.</p></li><li><p>If there are lots of implicit arguments that are common to a collection of proofs they should be extracted by using an anonymous module.</p></li><li><p>Implicit of type <code>Level</code> and <code>Set</code> can be generalised using <code>variable</code>. At the moment the policy is <em>not</em> to generalise over any other types in order to minimise the amount of information that users have to keep in their head concurrently.</p></li></ul><h2 id="naming-conventions">Naming conventions</h2><ul><li><p>Names should be descriptive - i.e. given the name of a proof and the module it lives in then users should be able to make a reasonable guess at what it contains.</p></li><li><p>Terms from other modules should only be renamed to avoid name clashes, otherwise all names should be used as defined.</p></li><li><p>Datatype names should be capitalised and function names should be lowercase.</p></li></ul><h4 id="variables">Variables</h4><ul><li><p>Natural variables are named <code>m</code>, <code>n</code>, <code>o</code>, … (default <code>n</code>)</p></li><li><p>Integer variables are named <code>i</code>, <code>j</code>, <code>k</code>, … (default <code>i</code>)</p></li><li><p>Rational variables are named <code>p</code>, <code>q</code>, <code>r</code>, … (default <code>p</code>)</p></li><li><p>When naming proofs, the variables should occur in order, e.g. <code>m≤n+m</code> rather than <code>n≤m+n</code>.</p></li><li><p>Collections of elements are usually indicated by appending an <code>s</code> (e.g. if you are naming your variables <code>x</code> and <code>y</code> then lists should be named <code>xs</code> and <code>ys</code>).</p></li></ul><h4 id="preconditions-and-postconditions">Preconditions and postconditions</h4><ul><li><p>Preconditions should only be included in names of results if “important” (mostly judgement call).</p></li><li><p>Preconditions of results should be prepended to a description of the result by using the symbol <code>⇒</code> in names (e.g. <code>asym⇒antisym</code>)</p></li><li><p>Preconditions and postconditions should be combined using the symbols <code>∨</code> and <code>∧</code> (e.g. <code>m*n≡0⇒m≡0∨n≡0</code>)</p></li><li><p>Try to avoid the need for bracketing but if necessary use square brackets (e.g. <code>[m∸n]⊓[n∸m]≡0</code>)</p></li></ul><h4 id="operators-and-relations">Operators and relations</h4><ul><li><p>Operators and relations should be defined using mixfix notation where applicable (e.g. <code>_+_</code>, <code>_&lt;_</code>)</p></li><li><p>Common properties such as those in rings/orders/equivalences etc. have defined abbreviations (e.g. commutativity is shortened to <code>comm</code>). <code>Data.Nat.Properties</code> is a good place to look for examples.</p></li><li><p>Properties should be by prefixed by the relevant operator/relation (e.g. commutativity of <code>_+_</code> is named <code>+-comm</code>)</p></li><li><p>If the relevant unicode characters are available, negated forms of relations should be used over the <code>¬</code> symbol (e.g. <code>m+n≮n</code> should be used instead of <code>¬m+n&lt;n</code>).</p></li></ul><h4 id="functions-and-relations-over-specific-datatypes">Functions and relations over specific datatypes</h4><ul><li><p>When defining a new relation over a datatype (e.g. <code>Data.List.Relation.Binary.Pointwise</code>) it is often common to define how to introduce and eliminate that relation over various simple functions (e.g. <code>map</code>) over that datatype:</p><div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>map⁺ <span class="ot">:</span> Pointwise <span class="ot">(λ</span> a b <span class="ot">→</span> R <span class="ot">(</span>f a<span class="ot">)</span> <span class="ot">(</span>g b<span class="ot">))</span> as bs <span class="ot">→</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>               Pointwise R <span class="ot">(</span>map f as<span class="ot">)</span> <span class="ot">(</span>map g bs<span class="ot">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>map⁻ <span class="ot">:</span> Pointwise R <span class="ot">(</span>map f as<span class="ot">)</span> <span class="ot">(</span>map g bs<span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>               Pointwise <span class="ot">(λ</span> a b <span class="ot">→</span> R <span class="ot">(</span>f a<span class="ot">)</span> <span class="ot">(</span>g b<span class="ot">))</span> as bs</span></code></pre></div><p>Such elimination and introduction proofs are called the name of the function superscripted with either a <code>+</code> or <code>-</code> accordingly.</p></li></ul></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/web/StyleGuide.md">源文件</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer><script src="../assets/js/ruby-tags.js" integrity="sha512-ohLx3ydhHH5A2SRALHSSKZ1WRfgHk35NR9ef+bnxc1XgZCXDRYG5oNYdx2STnACcshdWXXnPjb5doJLM6Zhaew==" id="script-ruby-tags"></script></body></html>