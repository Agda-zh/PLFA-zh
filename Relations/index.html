<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Relations</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Relations: 关系的归纳定义</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Relations-105" class="Keyword">module</a> <a id="plfa_plfa-part1-Relations-112" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Relations-133" class="Keyword">where</a>
</pre><p>在定义了加法和乘法等运算以后，下一步我们来定义<strong>关系（Relation）</strong>，比如说<strong>小于等于</strong>。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Relations-382" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-389" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Relations-427" class="Symbol">as</a> <a id="plfa_plfa-part1-Relations-430" class="Module">Eq</a>
<a id="plfa_plfa-part1-Relations-433" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-438" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Relations-441" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-447" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Relations-451" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-453" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Relations-457" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-459" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Relations-463" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-465" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-470" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-477" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-486" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-492" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-494" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-496" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-500" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-502" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Relations-505" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-507" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Relations-510" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-512" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-517" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-524" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-544" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-550" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-551" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Relations-557" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-559" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Relations-570" class="Symbol">)</a>
</pre><h2 id="定义关系">定义关系</h2><p>小于等于这个关系有无穷个实例，如下所示：</p><pre><code>0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...</code></pre><p>但是，我们仍然可以用几行有限的定义来表示所有的实例，如下文所示的一对推理规则：</p><pre><code>z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n</code></pre><p>以及其 Agda 定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-1359" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_≤_"></a><a id="plfa_plfa-part1-Relations-1364" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Relations-1368" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1372" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1376" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1378" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-1382" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_≤_.z≤n"></a><a id="plfa_plfa-part1-Relations-1391" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-1395" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1397" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1399" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1400" href="../Relations/#plfa_plfa-part1-Relations-1400" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1402" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1404" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1405" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-1413" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Relations-1426" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1428" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-1433" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1435" href="../Relations/#plfa_plfa-part1-Relations-1400" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_≤_.s≤s"></a><a id="plfa_plfa-part1-Relations-1440" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-1444" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1446" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1448" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1449" href="../Relations/#plfa_plfa-part1-Relations-1449" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1451" href="../Relations/#plfa_plfa-part1-Relations-1451" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1453" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1455" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1456" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-1462" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1464" href="../Relations/#plfa_plfa-part1-Relations-1449" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1466" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1468" href="../Relations/#plfa_plfa-part1-Relations-1451" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-1476" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-1494" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1496" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1500" href="../Relations/#plfa_plfa-part1-Relations-1449" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1502" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1504" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1508" href="../Relations/#plfa_plfa-part1-Relations-1451" class="Bound">n</a>
</pre><p>在这里，<code>z≤n</code> 和 <code>s≤s</code>（无空格）是构造子的名称，<code>zero ≤ n</code>、<code>m ≤ n</code> 和 <code>suc m ≤ suc n</code> （带空格）是类型。在这里我们第一次用到了 <strong>索引数据类型（Indexed datatype）</strong>。我们使用 <code>m</code> 和 <code>n</code> 这两个自然数来索引 <code>m ≤ n</code> 这个类型。在 Agda 里，由两个及以上短横线开始的行是注释行， 我们巧妙利用这一语法特性，用上述形式来表示相应的推理规则。 在后文中，我们还会继续使用这一形式。</p><p>这两条定义告诉我们相同的两件事：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，命题 <code>zero ≤ n</code> 成立。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果命题 <code>m ≤ n</code> 成立， 那么命题 <code>suc m ≤ suc n</code> 成立。</li></ul><p>实际上，他们分别给我们更多的信息：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，构造子 <code>z≤n</code> 提供了 <code>zero ≤ n</code> 成立的证明。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，构造子 <code>s≤s</code> 将 <code>m ≤ n</code> 成立的证明 转化为 <code>suc m ≤ suc n</code> 成立的证明。</li></ul><p>例如，我们在这里以推理规则的形式写出 <code>2 ≤ 4</code> 的证明：</p><pre><code>  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4</code></pre><p>下面是对应的 Agda 证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-3402" href="../Relations/#plfa_plfa-part1-Relations-3402" class="Function">_</a> <a id="plfa_plfa-part1-Relations-3404" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-3406" class="Number">2</a> <a id="plfa_plfa-part1-Relations-3408" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-3410" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-3412" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-3414" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-3416" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3420" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-3421" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3425" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-3428" class="Symbol">)</a>
</pre><h2 id="隐式参数">隐式参数</h2><p>这是我们第一次使用隐式参数。定义不等式时，构造子的定义中使用了 <code>∀</code>， 就像我们在下面的命题中使用 <code>∀</code> 一样：</p><pre><code>+-comm : ∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>但是我们这里的定义使用了花括号 <code>{ }</code>，而不是小括号 <code>( )</code>。 这意味着参数是<strong>隐式的（Implicit）</strong>，不需要额外声明。实际上，Agda 的类型检查器 会<strong>推导（Infer）</strong>出它们。因此，我们在 <code>m + n ≡ n + m</code> 的证明中需要写出 <code>+-comm m n</code>， 在 <code>zero ≤ n</code> 的证明中可以省略 <code>n</code>。同理，如果 <code>m≤n</code> 是 <code>m ≤ n</code>的证明， 那么我们写出 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 的证明，无需声明 <code>m</code> 和 <code>n</code>。</p><p>如果有希望的话，我们也可以在大括号里显式声明隐式参数。例如，下面是 <code>2 ≤ 4</code> 的 Agda 证明，包括了显式声明了的隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4840" href="../Relations/#plfa_plfa-part1-Relations-4840" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4842" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4844" class="Number">2</a> <a id="plfa_plfa-part1-Relations-4846" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-4848" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-4850" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-4852" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-4854" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4858" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4859" class="Number">1</a><a id="plfa_plfa-part1-Relations-4860" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4862" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4863" class="Number">3</a><a id="plfa_plfa-part1-Relations-4864" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4866" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4867" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4871" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4872" class="Number">0</a><a id="plfa_plfa-part1-Relations-4873" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4875" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4876" class="Number">2</a><a id="plfa_plfa-part1-Relations-4877" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4879" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4880" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-4884" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4885" class="Number">2</a><a id="plfa_plfa-part1-Relations-4886" class="Symbol">}))</a>
</pre><p>也可以额外加上参数的名字：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4978" href="../Relations/#plfa_plfa-part1-Relations-4978" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4980" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4982" class="Number">2</a> <a id="plfa_plfa-part1-Relations-4984" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-4986" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-4988" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-4990" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-4992" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4996" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4997" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-4999" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5001" class="Number">1</a><a id="plfa_plfa-part1-Relations-5002" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5004" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5005" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5007" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5009" class="Number">3</a><a id="plfa_plfa-part1-Relations-5010" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5012" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5013" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5017" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5018" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5020" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5022" class="Number">0</a><a id="plfa_plfa-part1-Relations-5023" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5025" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5026" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5028" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5030" class="Number">2</a><a id="plfa_plfa-part1-Relations-5031" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5033" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5034" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-5038" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5039" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5041" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5043" class="Number">2</a><a id="plfa_plfa-part1-Relations-5044" class="Symbol">}))</a>
</pre><p>在后者的形式中，也可以选择只声明一部分隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-5174" href="../Relations/#plfa_plfa-part1-Relations-5174" class="Function">_</a> <a id="plfa_plfa-part1-Relations-5176" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5178" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5180" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5182" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5184" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5186" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5188" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5192" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5193" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5195" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5197" class="Number">3</a><a id="plfa_plfa-part1-Relations-5198" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5200" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5201" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5205" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5206" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5208" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5210" class="Number">2</a><a id="plfa_plfa-part1-Relations-5211" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5213" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-5216" class="Symbol">)</a>
</pre><p>但是不可以改变隐式参数的顺序，即便加上了名字。</p><p>我们可以写出 <code>_</code> 来让 Agda 用相同的推导方式试着推导一个<strong>显式</strong>的项。 例如，我们可以为命题 <code>+-identityʳ</code> 定义一个带有隐式参数的变体：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-identityʳ′"></a><a id="plfa_plfa-part1-Relations-5616" href="../Relations/#plfa_plfa-part1-Relations-5616" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5629" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5631" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-5633" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5634" href="../Relations/#plfa_plfa-part1-Relations-5634" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5636" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5638" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-5639" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5641" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-5643" href="../Relations/#plfa_plfa-part1-Relations-5634" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5645" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-5647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-5652" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-5654" href="../Relations/#plfa_plfa-part1-Relations-5634" class="Bound">m</a>
<a id="plfa_plfa-part1-Relations-5656" href="../Relations/#plfa_plfa-part1-Relations-5616" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5669" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5671" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Relations-5683" class="Symbol">_</a>
</pre><p>我们用 <code>_</code> 来让 Agda 从语境中推导<strong>显式参数</strong>的值。只有 <code>m</code> 这一个值能够给出正确的证明，因此 Agda 愉快地填入了它。 如果 Agda 推导值失败，那么它会报一个错误。</p><h2 id="优先级">优先级</h2><p>我们如下定义比较的优先级：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-6146" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-6152" class="Number">4</a> <a id="plfa_plfa-part1-Relations-6154" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">_≤_</a>
</pre><p>我们将 <code>_≤_</code> 的优先级设置为 4，所以它不如优先级为 6 的 <code>_+_</code> 结合得紧，因而， <code>1 + 2 ≤ 3</code> 将被解析为 <code>(1 + 2) ≤ 3</code>。我们用 <code>infix</code> 来表示运算符既不是左结合的， 也不是右结合的。因为 <code>1 ≤ 2 ≤ 3</code> 解析为 <code>(1 ≤ 2) ≤ 3</code> 或者 <code>1 ≤ (2 ≤ 3)</code> 都没有意义。</p><h2 id="可判定性">可判定性</h2><p>给定两个数，我们可以很直接地决定第一个数是不是小于等于第二个数。我们在此处不给出说明的代码， 但我们会在 <a href="../Decidable/">Decidable</a> 章节重新讨论这个问题。</p><h2 id="反演">反演</h2><p>在我们的定义中，我们从更小的东西得到更大的东西。例如，我们可以从 <code>m ≤ n</code> 得出 <code>suc m ≤ suc n</code> 的结论，这里的 <code>suc m</code> 比 <code>m</code> 更大 （也就是说，前者包含后者），<code>suc n</code> 也比 <code>n</code> 更大。但有时我们也 需要从更大的东西得到更小的东西。</p><p>只有一种方式能够证明对于任意 <code>m</code> 和 <code>n</code> 有 <code>suc m ≤ suc n</code>。 这让我们能够反演（invert）之前的规则。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-s≤s"></a><a id="plfa_plfa-part1-Relations-7705" href="../Relations/#plfa_plfa-part1-Relations-7705" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7713" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7715" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-7717" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-7718" href="../Relations/#plfa_plfa-part1-Relations-7718" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7720" href="../Relations/#plfa_plfa-part1-Relations-7720" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-7722" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7724" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-7725" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-7729" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7735" href="../Relations/#plfa_plfa-part1-Relations-7718" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7737" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7739" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7743" href="../Relations/#plfa_plfa-part1-Relations-7720" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-7749" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-7765" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7767" href="../Relations/#plfa_plfa-part1-Relations-7718" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7769" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7771" href="../Relations/#plfa_plfa-part1-Relations-7720" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-7773" href="../Relations/#plfa_plfa-part1-Relations-7705" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7781" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-7782" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-7786" href="../Relations/#plfa_plfa-part1-Relations-7786" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-7789" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-7791" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-7793" href="../Relations/#plfa_plfa-part1-Relations-7786" class="Bound">m≤n</a>
</pre><p>这里的 <code>m≤n</code>（不带空格）是一个变量名，而 <code>m ≤ n</code>（带空格）是一个类型， 且后者是前者的类型。在 Agda 中，将类型中的空格去掉来作为变量名是一种常见的约定。</p><p>并不是所有规则都可以反演。实际上，<code>z≤n</code> 的规则没有非隐式的假设， 因此它没有可以被反演的规则。但这种反演通常是成立的。</p><p>反演的另一个例子是证明只存在一种情况使得一个数字能够小于或等于零。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-z≤n"></a><a id="plfa_plfa-part1-Relations-8521" href="../Relations/#plfa_plfa-part1-Relations-8521" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8529" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8531" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-8533" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-8534" href="../Relations/#plfa_plfa-part1-Relations-8534" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8536" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8538" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-8539" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-8543" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8545" href="../Relations/#plfa_plfa-part1-Relations-8534" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8547" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-8549" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
    <a id="plfa_plfa-part1-Relations-8558" class="Comment">--------</a>
  <a id="plfa_plfa-part1-Relations-8569" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8571" href="../Relations/#plfa_plfa-part1-Relations-8534" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8573" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-8575" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Relations-8580" href="../Relations/#plfa_plfa-part1-Relations-8521" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8588" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-8592" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-8594" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><h2 id="序关系的性质">序关系的性质</h2><p>数学家对于关系的常见性质给出了约定的名称。</p><ul><li><strong>自反（Reflexive）</strong>：对于所有的 <code>n</code>，关系 <code>n ≤ n</code> 成立。</li><li><strong>传递（Transitive）</strong>：对于所有的 <code>m</code>、 <code>n</code> 和 <code>p</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 也成立。</li><li><strong>反对称（Anti-symmetric）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立。</li><li><strong>完全（Total）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。</li></ul><p><code>_≤_</code> 关系满足上述四条性质。</p><p>对于上述性质的组合也有约定的名称。</p><ul><li><strong>预序（Preorder）</strong>：满足自反和传递的关系。</li><li><strong>偏序（Partial Order）</strong>：满足反对称的预序。</li><li><strong>全序（Total Order）</strong>：满足完全的偏序。</li></ul><p>如果你在派对上偶遇一个『关系』，你现在知道怎么样和人讨论了， 可以讨论关于自反、传递、反对称和完全， 或者问一问这是不是预序、偏序或者全序。</p><p>更认真的来说，如果你在阅读论文时碰到了一个关系，本文的介绍让你可以对关系有基本的了解和判断， 来判断这个关系是不是预序、偏序或者全序。一个认真的作者一般会在文章指出这个关系具有（或者缺少） 上述性质，比如说指出新定义的关系是一个偏序而不是全序。</p><h4 id="orderings">练习 <code>orderings</code>（实践）</h4><p>给出一个不是偏序的预序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10859" class="Comment">-- 请将代码写在此处</a>
</pre><p>给出一个不是全序的偏序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10975" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="自反性">自反性</h2><p>我们第一个来证明的性质是自反性：对于任意自然数 <code>n</code>，关系 <code>n ≤ n</code> 成立。我们使用标准库 的惯例来隐式申明参数，在使用自反性的证明时这样可以更加方便。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-refl"></a><a id="plfa_plfa-part1-Relations-11378" href="../Relations/#plfa_plfa-part1-Relations-11378" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11385" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11387" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-11389" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11390" href="../Relations/#plfa_plfa-part1-Relations-11390" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11392" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-11395" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-11401" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-11409" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-11411" href="../Relations/#plfa_plfa-part1-Relations-11390" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11413" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-11415" href="../Relations/#plfa_plfa-part1-Relations-11390" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-11417" href="../Relations/#plfa_plfa-part1-Relations-11378" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11424" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11425" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-11429" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11431" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11433" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-11437" href="../Relations/#plfa_plfa-part1-Relations-11378" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11444" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11445" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-11449" href="../Relations/#plfa_plfa-part1-Relations-11449" class="Bound">n</a><a id="plfa_plfa-part1-Relations-11450" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11452" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11454" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-11458" href="../Relations/#plfa_plfa-part1-Relations-11378" class="Function">≤-refl</a>
</pre><p>这个证明直接在 <code>n</code> 上进行归纳。在起始步骤中，<code>zero ≤ zero</code> 由 <code>z≤n</code> 证明；在归纳步骤中， 归纳假设 <code>≤-refl {n}</code> 给我们带来了 <code>n ≤ n</code> 的证明，我们只需要使用 <code>s≤s</code>，就可以获得 <code>suc n ≤ suc n</code> 的证明。</p><p>在 Emacs 中来交互式地证明自反性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="传递性">传递性</h2><p>我们第二个证明的性质是传递性：对于任意自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 成立。同样，<code>m</code>、<code>n</code> 和 <code>p</code> 是隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans"></a><a id="plfa_plfa-part1-Relations-12453" href="../Relations/#plfa_plfa-part1-Relations-12453" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12461" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12463" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-12465" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-12466" href="../Relations/#plfa_plfa-part1-Relations-12466" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12468" href="../Relations/#plfa_plfa-part1-Relations-12468" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12470" href="../Relations/#plfa_plfa-part1-Relations-12470" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-12472" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12474" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-12475" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-12479" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12481" href="../Relations/#plfa_plfa-part1-Relations-12466" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12483" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12485" href="../Relations/#plfa_plfa-part1-Relations-12468" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-12489" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12491" href="../Relations/#plfa_plfa-part1-Relations-12468" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12493" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12495" href="../Relations/#plfa_plfa-part1-Relations-12470" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-12501" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-12509" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12511" href="../Relations/#plfa_plfa-part1-Relations-12466" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12513" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12515" href="../Relations/#plfa_plfa-part1-Relations-12470" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-12517" href="../Relations/#plfa_plfa-part1-Relations-12453" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12525" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-12535" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-12546" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12549" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-12553" href="../Relations/#plfa_plfa-part1-Relations-12453" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12561" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12562" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12566" href="../Relations/#plfa_plfa-part1-Relations-12566" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-12569" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-12571" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12572" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12576" href="../Relations/#plfa_plfa-part1-Relations-12576" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12579" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-12582" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12585" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12589" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12590" href="../Relations/#plfa_plfa-part1-Relations-12453" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12598" href="../Relations/#plfa_plfa-part1-Relations-12566" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-12602" href="../Relations/#plfa_plfa-part1-Relations-12576" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12605" class="Symbol">)</a>
</pre><p>这里我们在 <code>m ≤ n</code> 的<strong>证据（Evidence）</strong>上进行归纳。在起始步骤里，第一个不等式因为 <code>z≤n</code> 而成立， 那么结论亦可由 <code>z≤n</code> 而得出。在这里，<code>n ≤ p</code> 的证明是不需要的，我们用 <code>_</code> 来表示这个 证明没有被使用。</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个不等式因为 <code>s≤s n≤p</code> 而成立， 所以我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc p</code>，求证 <code>suc m ≤ suc p</code>。 通过归纳假设 <code>≤-trans m≤n n≤p</code>，我们得知 <code>m ≤ p</code>，在此之上使用 <code>s≤s</code> 即可证。</p><p><code>≤-trans (s≤s m≤n) z≤n</code> 不可能发生，因为第一个不等式告诉我们中间的数是一个 <code>suc n</code>， 而第二个不等式告诉我们中间的数是 <code>zero</code>。Agda 可以推断这样的情况不可能发现，所以我们不需要 （也不可以）列出这种情况。</p><p>我们也可以将隐式参数显式地声明。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans′"></a><a id="plfa_plfa-part1-Relations-14051" href="../Relations/#plfa_plfa-part1-Relations-14051" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14060" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14062" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-14064" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14065" href="../Relations/#plfa_plfa-part1-Relations-14065" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14067" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14069" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14071" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14073" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-14074" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-14078" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14080" href="../Relations/#plfa_plfa-part1-Relations-14065" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14082" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14084" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-14088" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14090" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14092" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14094" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-14100" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-14108" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14110" href="../Relations/#plfa_plfa-part1-Relations-14065" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14112" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14114" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-14116" href="../Relations/#plfa_plfa-part1-Relations-14051" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14125" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-14133" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14141" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14149" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-14159" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-14170" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14173" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-14177" href="../Relations/#plfa_plfa-part1-Relations-14051" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14186" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14191" href="../Relations/#plfa_plfa-part1-Relations-14191" class="Bound">m</a><a id="plfa_plfa-part1-Relations-14192" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14194" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14195" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14199" href="../Relations/#plfa_plfa-part1-Relations-14199" class="Bound">n</a><a id="plfa_plfa-part1-Relations-14200" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14202" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14203" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14207" href="../Relations/#plfa_plfa-part1-Relations-14207" class="Bound">p</a><a id="plfa_plfa-part1-Relations-14208" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14210" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14211" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14215" href="../Relations/#plfa_plfa-part1-Relations-14215" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-14218" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14220" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14221" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14225" href="../Relations/#plfa_plfa-part1-Relations-14225" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14228" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-14231" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14234" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14238" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14239" href="../Relations/#plfa_plfa-part1-Relations-14051" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14248" href="../Relations/#plfa_plfa-part1-Relations-14191" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14250" href="../Relations/#plfa_plfa-part1-Relations-14199" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14252" href="../Relations/#plfa_plfa-part1-Relations-14207" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14254" href="../Relations/#plfa_plfa-part1-Relations-14215" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-14258" href="../Relations/#plfa_plfa-part1-Relations-14225" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14261" class="Symbol">)</a>
</pre><p>有人说这样的证明更加的清晰，也有人说这个更长的证明让人难以抓住证明的重点。 我们一般选择使用简短的证明。</p><p>对于性质成立证明进行的归纳（如上文中对于 <code>m ≤ n</code> 的证明进行归纳），相比于对于性质成立的值进行的归纳 （如对于 <code>m</code> 进行归纳），有非常大的价值。我们会经常使用这样的方法。</p><p>同样，在 Emacs 中来交互式地证明传递性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="反对称性">反对称性</h2><p>我们证明的第三个性质是反对称性：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-antisym"></a><a id="plfa_plfa-part1-Relations-15364" href="../Relations/#plfa_plfa-part1-Relations-15364" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15374" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15376" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-15378" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-15379" href="../Relations/#plfa_plfa-part1-Relations-15379" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15381" href="../Relations/#plfa_plfa-part1-Relations-15381" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15383" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15385" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-15386" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-15390" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15392" href="../Relations/#plfa_plfa-part1-Relations-15379" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15394" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15396" href="../Relations/#plfa_plfa-part1-Relations-15381" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-15400" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15402" href="../Relations/#plfa_plfa-part1-Relations-15381" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15404" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15406" href="../Relations/#plfa_plfa-part1-Relations-15379" class="Bound">m</a>
    <a id="plfa_plfa-part1-Relations-15412" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-15420" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15422" href="../Relations/#plfa_plfa-part1-Relations-15379" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15424" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-15426" href="../Relations/#plfa_plfa-part1-Relations-15381" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-15428" href="../Relations/#plfa_plfa-part1-Relations-15364" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15438" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-15448" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Relations-15459" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15462" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Relations-15467" href="../Relations/#plfa_plfa-part1-Relations-15364" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15477" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15478" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15482" href="../Relations/#plfa_plfa-part1-Relations-15482" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-15485" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-15487" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15488" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15492" href="../Relations/#plfa_plfa-part1-Relations-15492" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15495" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-15498" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15501" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Relations-15506" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-15510" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15511" href="../Relations/#plfa_plfa-part1-Relations-15364" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15521" href="../Relations/#plfa_plfa-part1-Relations-15482" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-15525" href="../Relations/#plfa_plfa-part1-Relations-15492" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15528" class="Symbol">)</a>
</pre><p>同样，我们对于 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明进行归纳。</p><p>在起始步骤中，两个不等式都因为 <code>z≤n</code> 而成立。因此我们已知 <code>zero ≤ zero</code> 和 <code>zero ≤ zero</code>， 求证 <code>zero ≡ zero</code>，由自反性可证。（注：由等式的自反性可证，而不是不等式的自反性）</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个等式因为 <code>s≤s n≤m</code> 而成立。因此我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc m</code>，求证 <code>suc m ≡ suc n</code>。归纳假设 <code>≤-antisym m≤n n≤m</code> 可以证明 <code>m ≡ n</code>，因此我们可以使用同余性完成证明。</p><h4 id="leq-antisym-cases">练习 <code>≤-antisym-cases</code>（实践）</h4><p>上面的证明中省略了一个参数是 <code>z≤n</code>，另一个参数是 <code>s≤s</code> 的情况。为什么可以省略这种情况？</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-16809" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="完全性">完全性</h2><p>我们证明的第四个性质是完全性：对于任何自然数 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。 在 <code>m</code> 和 <code>n</code> 相等时，两者同时成立。</p><p>我们首先来说明怎么样不等式才是完全的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-17194" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total"></a><a id="plfa_plfa-part1-Relations-17199" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17205" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-17206" href="../Relations/#plfa_plfa-part1-Relations-17206" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17208" href="../Relations/#plfa_plfa-part1-Relations-17208" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17210" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17212" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-17213" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-17215" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17217" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-17221" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total.forward"></a><a id="plfa_plfa-part1-Relations-17230" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-17238" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17246" href="../Relations/#plfa_plfa-part1-Relations-17206" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17248" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17250" href="../Relations/#plfa_plfa-part1-Relations-17208" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-17258" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17272" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17274" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17280" href="../Relations/#plfa_plfa-part1-Relations-17206" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17282" href="../Relations/#plfa_plfa-part1-Relations-17208" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total.flipped"></a><a id="plfa_plfa-part1-Relations-17287" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-17295" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17303" href="../Relations/#plfa_plfa-part1-Relations-17208" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17305" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17307" href="../Relations/#plfa_plfa-part1-Relations-17206" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-17315" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17329" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17331" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17337" href="../Relations/#plfa_plfa-part1-Relations-17206" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17339" href="../Relations/#plfa_plfa-part1-Relations-17208" class="Bound">n</a>
</pre><p><code>Total m n</code> 成立的证明有两种形式：<code>forward m≤n</code> 或者 <code>flipped n≤m</code>，其中 <code>m≤n</code> 和 <code>n≤m</code> 分别是 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明。</p><p>（如果你对于逻辑学有所了解，上面的定义可以由析取（Disjunction）表示。 我们会在 <a href="../Connectives/">Connectives</a> 章节介绍析取。）</p><p>这是我们第一次使用带<em>参数</em>的数据类型，这里 <code>m</code> 和 <code>n</code> 是参数。这等同于下面的索引数据类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-18080" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total′"></a><a id="plfa_plfa-part1-Relations-18085" href="../Relations/#plfa_plfa-part1-Relations-18085" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18092" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18094" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18096" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18098" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18100" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-18106" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total′.forward′"></a><a id="plfa_plfa-part1-Relations-18115" href="../Relations/#plfa_plfa-part1-Relations-18115" class="InductiveConstructor">forward′</a> <a id="plfa_plfa-part1-Relations-18124" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18126" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18128" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18129" href="../Relations/#plfa_plfa-part1-Relations-18129" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18131" href="../Relations/#plfa_plfa-part1-Relations-18131" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18133" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18135" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18136" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18142" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18144" href="../Relations/#plfa_plfa-part1-Relations-18129" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18146" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18148" href="../Relations/#plfa_plfa-part1-Relations-18131" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-18156" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18171" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18173" href="../Relations/#plfa_plfa-part1-Relations-18085" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18180" href="../Relations/#plfa_plfa-part1-Relations-18129" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18182" href="../Relations/#plfa_plfa-part1-Relations-18131" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total′.flipped′"></a><a id="plfa_plfa-part1-Relations-18187" href="../Relations/#plfa_plfa-part1-Relations-18187" class="InductiveConstructor">flipped′</a> <a id="plfa_plfa-part1-Relations-18196" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18198" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18200" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18201" href="../Relations/#plfa_plfa-part1-Relations-18201" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18203" href="../Relations/#plfa_plfa-part1-Relations-18203" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18205" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18207" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18208" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18214" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18216" href="../Relations/#plfa_plfa-part1-Relations-18203" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18218" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18220" href="../Relations/#plfa_plfa-part1-Relations-18201" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-18228" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18243" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18245" href="../Relations/#plfa_plfa-part1-Relations-18085" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18252" href="../Relations/#plfa_plfa-part1-Relations-18201" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18254" href="../Relations/#plfa_plfa-part1-Relations-18203" class="Bound">n</a>
</pre><p>类型里的每个参数都转换成构造子的一个隐式参数。索引数据类型中的索引可以变化，正如在 <code>zero ≤ n</code> 和 <code>suc m ≤ suc n</code> 中那样，而参数化数据类型不一样，其参数必须保持相同， 正如在 <code>Total m n</code> 中那样。参数化的声明更短，更易于阅读，而且有时可以帮助到 Agda 的 停机检查器，所以我们尽可能地使用它们，而不是索引数据类型。</p><p>在上述准备工作完成后，我们定义并证明完全性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total"></a><a id="plfa_plfa-part1-Relations-19002" href="../Relations/#plfa_plfa-part1-Relations-19002" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19010" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19012" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-19014" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19015" href="../Relations/#plfa_plfa-part1-Relations-19015" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19017" href="../Relations/#plfa_plfa-part1-Relations-19017" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-19019" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19021" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-19022" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19024" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-19026" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-19032" href="../Relations/#plfa_plfa-part1-Relations-19015" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19034" href="../Relations/#plfa_plfa-part1-Relations-19017" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19036" href="../Relations/#plfa_plfa-part1-Relations-19002" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19044" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-19052" href="../Relations/#plfa_plfa-part1-Relations-19052" class="Bound">n</a>                         <a id="plfa_plfa-part1-Relations-19078" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19081" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19089" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19093" href="../Relations/#plfa_plfa-part1-Relations-19002" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19101" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19106" href="../Relations/#plfa_plfa-part1-Relations-19106" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19107" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19109" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-19135" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19138" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19146" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19150" href="../Relations/#plfa_plfa-part1-Relations-19002" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19158" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19159" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19163" href="../Relations/#plfa_plfa-part1-Relations-19163" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19164" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19166" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19167" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19171" href="../Relations/#plfa_plfa-part1-Relations-19171" class="Bound">n</a><a id="plfa_plfa-part1-Relations-19172" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19174" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-19179" href="../Relations/#plfa_plfa-part1-Relations-19002" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19187" href="../Relations/#plfa_plfa-part1-Relations-19163" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19189" href="../Relations/#plfa_plfa-part1-Relations-19171" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19191" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19218" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19220" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19228" href="../Relations/#plfa_plfa-part1-Relations-19228" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-19233" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19236" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19244" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19245" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19249" href="../Relations/#plfa_plfa-part1-Relations-19228" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-19252" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-19254" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19281" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19283" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19291" href="../Relations/#plfa_plfa-part1-Relations-19291" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-19296" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19299" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19307" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19308" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19312" href="../Relations/#plfa_plfa-part1-Relations-19291" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-19315" class="Symbol">)</a>
</pre><p>这里，我们的证明在两个参数上进行归纳，并按照情况分析：</p><ul><li><p><strong>第一起始步骤</strong>：如果第一个参数是 <code>zero</code>，第二个参数是 <code>n</code>，那么 forward 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ n</code> 的证明。</p></li><li><p><strong>第二起始步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>zero</code>，那么 flipped 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ suc m</code> 的证明。</p></li><li><p><strong>归纳步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>suc n</code>，那么归纳假设 <code>≤-total m n</code> 可以给出如下推断：</p><ul><li><p>归纳假设的 forward 条件成立，以 <code>m≤n</code> 作为 <code>m ≤ n</code> 的证明。以此我们可以使用 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 来证明 forward 条件成立。</p></li><li><p>归纳假设的 flipped 条件成立，以 <code>n≤m</code> 作为 <code>n ≤ m</code> 的证明。以此我们可以使用 <code>s≤s n≤m</code> 作为 <code>suc n ≤ suc m</code> 来证明 flipped 条件成立。</p></li></ul></li></ul><p>这是我们第一次在 Agda 中使用 <code>with</code> 语句。<code>with</code> 关键字后面有一个表达式和一或多行。 每行以省略号（<code>...</code>）和一个竖线（<code>|</code>）开头，后面跟着用来匹配表达式的模式，和等式的右手边。</p><p>使用 <code>with</code> 语句等同于定义一个辅助函数。比如说，上面的定义和下面的等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total′"></a><a id="plfa_plfa-part1-Relations-21492" href="../Relations/#plfa_plfa-part1-Relations-21492" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21501" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21503" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-21505" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21506" href="../Relations/#plfa_plfa-part1-Relations-21506" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21508" href="../Relations/#plfa_plfa-part1-Relations-21508" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21510" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-21513" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21515" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21517" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21523" href="../Relations/#plfa_plfa-part1-Relations-21506" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21525" href="../Relations/#plfa_plfa-part1-Relations-21508" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-21527" href="../Relations/#plfa_plfa-part1-Relations-21492" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21536" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-21544" href="../Relations/#plfa_plfa-part1-Relations-21544" class="Bound">n</a>        <a id="plfa_plfa-part1-Relations-21553" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21556" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21564" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21568" href="../Relations/#plfa_plfa-part1-Relations-21492" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21577" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21578" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21582" href="../Relations/#plfa_plfa-part1-Relations-21582" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21583" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21585" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-21594" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21597" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21605" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21609" href="../Relations/#plfa_plfa-part1-Relations-21492" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21618" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21619" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21623" href="../Relations/#plfa_plfa-part1-Relations-21623" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21624" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21626" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21627" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21631" href="../Relations/#plfa_plfa-part1-Relations-21631" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21632" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21635" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21638" href="../Relations/#plfa_plfa-part1-Relations-21670" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21645" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21646" href="../Relations/#plfa_plfa-part1-Relations-21492" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21655" href="../Relations/#plfa_plfa-part1-Relations-21623" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21657" href="../Relations/#plfa_plfa-part1-Relations-21631" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21658" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21662" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Relations-21670" href="../Relations/#plfa_plfa-part1-Relations-21670" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21677" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21679" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21685" href="../Relations/#plfa_plfa-part1-Relations-21623" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21687" href="../Relations/#plfa_plfa-part1-Relations-21631" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21689" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21691" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21697" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21698" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21702" href="../Relations/#plfa_plfa-part1-Relations-21623" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21703" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21705" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21710" href="../Relations/#plfa_plfa-part1-Relations-21631" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21711" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21715" href="../Relations/#plfa_plfa-part1-Relations-21670" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21722" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21723" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21731" href="../Relations/#plfa_plfa-part1-Relations-21731" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21734" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21737" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21740" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21748" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21749" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21753" href="../Relations/#plfa_plfa-part1-Relations-21731" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21756" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21760" href="../Relations/#plfa_plfa-part1-Relations-21670" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21767" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21768" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21776" href="../Relations/#plfa_plfa-part1-Relations-21776" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21779" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21782" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21785" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21793" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21794" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21798" href="../Relations/#plfa_plfa-part1-Relations-21776" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21801" class="Symbol">)</a>
</pre><p>这也是我们第一次在 Agda 中使用 <code>where</code> 语句。<code>where</code> 关键字后面有一或多条定义，其必须被缩进。 之前等式左手边的约束变量（此例中的 <code>m</code> 和 <code>n</code>）在嵌套的定义中仍然在作用域内。 在嵌套定义中的约束标识符（此例中的 <code>helper</code> ）在等式的右手边的作用域内。</p><p>如果两个参数相同，那么两个情况同时成立，我们可以返回任一证明。上面的代码中我们返回 forward 条件， 但是我们也可以返回 flipped 条件，如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total″"></a><a id="plfa_plfa-part1-Relations-22673" href="../Relations/#plfa_plfa-part1-Relations-22673" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22682" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22684" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-22686" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22687" href="../Relations/#plfa_plfa-part1-Relations-22687" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22689" href="../Relations/#plfa_plfa-part1-Relations-22689" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-22691" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22693" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-22694" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22696" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-22698" href="../Relations/#plfa_plfa-part1-Relations-17199" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-22704" href="../Relations/#plfa_plfa-part1-Relations-22687" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22706" href="../Relations/#plfa_plfa-part1-Relations-22689" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22708" href="../Relations/#plfa_plfa-part1-Relations-22673" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22717" href="../Relations/#plfa_plfa-part1-Relations-22717" class="Bound">m</a>       <a id="plfa_plfa-part1-Relations-22725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-22751" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22754" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22762" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22766" href="../Relations/#plfa_plfa-part1-Relations-22673" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22775" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-22783" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22784" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22788" href="../Relations/#plfa_plfa-part1-Relations-22788" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22789" class="Symbol">)</a>                   <a id="plfa_plfa-part1-Relations-22809" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22812" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22820" href="../Relations/#plfa_plfa-part1-Relations-1391" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22824" href="../Relations/#plfa_plfa-part1-Relations-22673" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22833" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22834" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22838" href="../Relations/#plfa_plfa-part1-Relations-22838" class="Bound">m</a><a id="plfa_plfa-part1-Relations-22839" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22841" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22842" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22846" href="../Relations/#plfa_plfa-part1-Relations-22846" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22847" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22849" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-22854" href="../Relations/#plfa_plfa-part1-Relations-22673" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22863" href="../Relations/#plfa_plfa-part1-Relations-22838" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22865" href="../Relations/#plfa_plfa-part1-Relations-22846" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22867" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22895" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22897" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22905" href="../Relations/#plfa_plfa-part1-Relations-22905" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-22910" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22913" href="../Relations/#plfa_plfa-part1-Relations-17230" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22921" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22922" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-22926" href="../Relations/#plfa_plfa-part1-Relations-22905" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-22929" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-22931" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22959" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22961" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22969" href="../Relations/#plfa_plfa-part1-Relations-22969" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-22974" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22977" href="../Relations/#plfa_plfa-part1-Relations-17287" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22985" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22986" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-22990" href="../Relations/#plfa_plfa-part1-Relations-22969" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-22993" class="Symbol">)</a>
</pre><p>两者的区别在于上述代码在对于第一个参数进行模式匹配之前先对于第二个参数先进行模式匹配。</p><h2 id="单调性">单调性</h2><p>如果在聚会中碰到了一个运算符和一个序，那么有人可能会问这个运算符对于这个序是不是 <strong>单调的（Monotonic）</strong>。比如说，加法对于小于等于是单调的，这意味着：</p><pre><code>∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q</code></pre><p>这个证明可以用我们学会的方法，很直接的来完成。我们最好把它分成三个部分，首先我们证明加法对于 小于等于在右手边是单调的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoʳ-≤"></a><a id="plfa_plfa-part1-Relations-23823" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23833" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23835" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-23837" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23838" href="../Relations/#plfa_plfa-part1-Relations-23838" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23840" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23842" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23844" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23846" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-23847" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-23851" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23853" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23855" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23857" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-23863" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-23879" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23881" href="../Relations/#plfa_plfa-part1-Relations-23838" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23883" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23885" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23887" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23889" href="../Relations/#plfa_plfa-part1-Relations-23838" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23891" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23893" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-23895" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23905" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-23913" href="../Relations/#plfa_plfa-part1-Relations-23913" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23915" href="../Relations/#plfa_plfa-part1-Relations-23915" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23917" href="../Relations/#plfa_plfa-part1-Relations-23917" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23922" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23925" href="../Relations/#plfa_plfa-part1-Relations-23917" class="Bound">p≤q</a>
<a id="plfa_plfa-part1-Relations-23929" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23939" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23940" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-23944" href="../Relations/#plfa_plfa-part1-Relations-23944" class="Bound">n</a><a id="plfa_plfa-part1-Relations-23945" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-23947" href="../Relations/#plfa_plfa-part1-Relations-23947" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23949" href="../Relations/#plfa_plfa-part1-Relations-23949" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23951" href="../Relations/#plfa_plfa-part1-Relations-23951" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23956" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23959" href="../Relations/#plfa_plfa-part1-Relations-1440" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23963" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23964" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23974" href="../Relations/#plfa_plfa-part1-Relations-23944" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23976" href="../Relations/#plfa_plfa-part1-Relations-23947" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23978" href="../Relations/#plfa_plfa-part1-Relations-23949" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23980" href="../Relations/#plfa_plfa-part1-Relations-23951" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-23983" class="Symbol">)</a>
</pre><p>我们对于第一个参数进行归纳。</p><ul><li><p><strong>起始步骤</strong>：第一个参数是 <code>zero</code>，那么 <code>zero + p ≤ zero + q</code> 可以化简为 <code>p ≤ q</code>， 其证明由 <code>p≤q</code> 给出。</p></li><li><p><strong>归纳步骤</strong>：第一个参数是 <code>suc n</code>，那么 <code>suc n + p ≤ suc n + q</code> 可以化简为 <code>suc (n + p) ≤ suc (n + q)</code>。归纳假设 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，我们在此之上使用 <code>s≤s</code> 即可得证。</p></li></ul><p>接下来，我们证明加法对于小于等于在左手边是单调的。我们可以用之前的结论和加法的交换律来证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoˡ-≤"></a><a id="plfa_plfa-part1-Relations-24955" href="../Relations/#plfa_plfa-part1-Relations-24955" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-24965" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24967" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-24969" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-24970" href="../Relations/#plfa_plfa-part1-Relations-24970" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-24972" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-24974" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-24976" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24978" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-24979" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-24983" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-24985" href="../Relations/#plfa_plfa-part1-Relations-24970" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-24987" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-24989" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-24995" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25011" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25013" href="../Relations/#plfa_plfa-part1-Relations-24970" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25015" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25017" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25019" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25021" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25023" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25025" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-25027" href="../Relations/#plfa_plfa-part1-Relations-24955" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25037" href="../Relations/#plfa_plfa-part1-Relations-25037" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25039" href="../Relations/#plfa_plfa-part1-Relations-25039" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25041" href="../Relations/#plfa_plfa-part1-Relations-25041" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25043" href="../Relations/#plfa_plfa-part1-Relations-25043" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-25048" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Relations-25056" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25063" href="../Relations/#plfa_plfa-part1-Relations-25037" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25065" href="../Relations/#plfa_plfa-part1-Relations-25041" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25067" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-25069" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25076" href="../Relations/#plfa_plfa-part1-Relations-25039" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25078" href="../Relations/#plfa_plfa-part1-Relations-25041" class="Bound">p</a>  <a id="plfa_plfa-part1-Relations-25081" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-25083" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25093" href="../Relations/#plfa_plfa-part1-Relations-25041" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25095" href="../Relations/#plfa_plfa-part1-Relations-25037" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25097" href="../Relations/#plfa_plfa-part1-Relations-25039" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25099" href="../Relations/#plfa_plfa-part1-Relations-25043" class="Bound">m≤n</a>
</pre><p>用 <code>+-comm m p</code> 和 <code>+-comm n p</code> 来重写，可以让 <code>m + p ≤ n + p</code> 转换成 <code>p + n ≤ p + m</code>， 而我们可以用 <code>+-moroʳ-≤ p m n m≤n</code> 来证明。</p><p>最后，我们把前两步的结论结合起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-mono-≤"></a><a id="plfa_plfa-part1-Relations-25450" href="../Relations/#plfa_plfa-part1-Relations-25450" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25459" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25461" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-25463" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25464" href="../Relations/#plfa_plfa-part1-Relations-25464" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25466" href="../Relations/#plfa_plfa-part1-Relations-25466" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25468" href="../Relations/#plfa_plfa-part1-Relations-25468" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25470" href="../Relations/#plfa_plfa-part1-Relations-25470" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25472" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25474" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-25475" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25479" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25481" href="../Relations/#plfa_plfa-part1-Relations-25464" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25483" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25485" href="../Relations/#plfa_plfa-part1-Relations-25466" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-25489" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25491" href="../Relations/#plfa_plfa-part1-Relations-25468" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25493" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25495" href="../Relations/#plfa_plfa-part1-Relations-25470" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-25501" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25517" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25519" href="../Relations/#plfa_plfa-part1-Relations-25464" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25521" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25523" href="../Relations/#plfa_plfa-part1-Relations-25468" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25525" href="../Relations/#plfa_plfa-part1-Relations-1364" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25527" href="../Relations/#plfa_plfa-part1-Relations-25466" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25531" href="../Relations/#plfa_plfa-part1-Relations-25470" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-25533" href="../Relations/#plfa_plfa-part1-Relations-25450" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25542" href="../Relations/#plfa_plfa-part1-Relations-25542" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25544" href="../Relations/#plfa_plfa-part1-Relations-25544" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25546" href="../Relations/#plfa_plfa-part1-Relations-25546" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25548" href="../Relations/#plfa_plfa-part1-Relations-25548" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25550" href="../Relations/#plfa_plfa-part1-Relations-25550" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-25554" href="../Relations/#plfa_plfa-part1-Relations-25554" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-25559" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-25562" href="../Relations/#plfa_plfa-part1-Relations-12453" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-25570" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25571" href="../Relations/#plfa_plfa-part1-Relations-24955" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25581" href="../Relations/#plfa_plfa-part1-Relations-25542" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25583" href="../Relations/#plfa_plfa-part1-Relations-25544" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25585" href="../Relations/#plfa_plfa-part1-Relations-25546" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25587" href="../Relations/#plfa_plfa-part1-Relations-25550" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-25590" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-25592" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25593" href="../Relations/#plfa_plfa-part1-Relations-23823" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25603" href="../Relations/#plfa_plfa-part1-Relations-25544" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25605" href="../Relations/#plfa_plfa-part1-Relations-25546" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25607" href="../Relations/#plfa_plfa-part1-Relations-25548" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25609" href="../Relations/#plfa_plfa-part1-Relations-25554" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-25612" class="Symbol">)</a>
</pre><p>使用 <code>+-monoˡ-≤ m n p m≤n</code> 可以证明 <code>m + p ≤ n + p</code>， 使用 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，用传递性把两者连接起来， 我们可以获得 <code>m + p ≤ n + q</code> 的证明，如上所示。</p><h4 id="练习--mono--延伸">练习 <code>*-mono-≤</code> （延伸）</h4><p>证明乘法对于小于等于是单调的。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26136" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="strict-inequality">严格不等关系</h2><p>我们可以用类似于定义不等关系的方法来定义严格不等关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26342" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-26348" class="Number">4</a> <a id="plfa_plfa-part1-Relations-26350" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">_&lt;_</a>

<a id="plfa_plfa-part1-Relations-26355" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_&lt;_"></a><a id="plfa_plfa-part1-Relations-26360" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">_&lt;_</a> <a id="plfa_plfa-part1-Relations-26364" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26366" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26368" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26372" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-26378" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.z&lt;s"></a><a id="plfa_plfa-part1-Relations-26387" href="../Relations/#plfa_plfa-part1-Relations-26387" class="InductiveConstructor">z&lt;s</a> <a id="plfa_plfa-part1-Relations-26391" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26393" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26395" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26396" href="../Relations/#plfa_plfa-part1-Relations-26396" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26398" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26400" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26401" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-26409" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-26426" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26428" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-26433" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26435" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26439" href="../Relations/#plfa_plfa-part1-Relations-26396" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.s&lt;s"></a><a id="plfa_plfa-part1-Relations-26444" href="../Relations/#plfa_plfa-part1-Relations-26444" class="InductiveConstructor">s&lt;s</a> <a id="plfa_plfa-part1-Relations-26448" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26450" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26452" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26453" href="../Relations/#plfa_plfa-part1-Relations-26453" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26455" href="../Relations/#plfa_plfa-part1-Relations-26455" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26457" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26459" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26460" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-26466" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26468" href="../Relations/#plfa_plfa-part1-Relations-26453" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26470" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26472" href="../Relations/#plfa_plfa-part1-Relations-26455" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-26480" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-26498" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26500" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26504" href="../Relations/#plfa_plfa-part1-Relations-26453" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26506" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26508" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26512" href="../Relations/#plfa_plfa-part1-Relations-26455" class="Bound">n</a>
</pre><p>严格不等关系与不等关系最重要的区别在于，0 小于任何数的后继，而不小于 0。</p><p>显然，严格不等关系不是自反的，而是<strong>非自反的（Irreflexive）</strong>，表示 <code>n &lt; n</code> 对于 任何值 <code>n</code> 都不成立。和不等关系一样，严格不等关系是传递的。严格不等关系不是完全的，但是满足 一个相似的性质：<strong>三分律（Trichotomy）</strong>：对于任意的 <code>m</code> 和 <code>n</code>，<code>m &lt; n</code>、<code>m ≡ n</code> 或者 <code>m &gt; n</code> 三者有且仅有一者成立。（我们定义 <code>m &gt; n</code> 当且仅当 <code>n &lt; m</code> 成立时成立） 严格不等关系对于加法和乘法也是单调的。</p><p>我们把一部分上述性质作为习题。非自反性需要逻辑非，三分律需要证明三者是互斥的，因此这两个性质 暂不做为习题。我们会在 <a href="../Negation/">Negation</a> 章节来重新讨论。</p><p>我们可以直接地来证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。 因此我们亦可从不等关系的性质中，使用此性质来证明严格不等关系的性质。</p><h4 id="less-trans">练习 <code>&lt;-trans</code> （推荐）</h4><p>证明严格不等是传递的。请直接证明。（后续的练习中我们将使用 &lt; 和 ≤ 的关系。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-28332" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="trichotomy">练习 <code>trichotomy</code>（实践）</h4><p>证明严格不等关系满足弱化的三元律，证明对于任意 <code>m</code> 和 <code>n</code>，下列命题有一条成立：</p><ul><li><code>m &lt; n</code>，</li><li><code>m ≡ n</code>，或者</li><li><code>m &gt; n</code>。</li></ul><p>定义 <code>m &gt; n</code> 为 <code>n &lt; m</code>。你需要一个合适的数据类型声明，如同我们在证明完全性中使用的那样。 （我们会在介绍完<a href="../Negation/">否定</a>之后证明三者是互斥的。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29055" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="plus-mono-less">练习 <code>+-mono-&lt;</code>（实践）</h4><p>证明加法对于严格不等关系是单调的。正如不等关系中那样，你可以需要额外的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29370" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="leq-iff-less">练习 <code>≤-iff-&lt;</code> (推荐)</h4><p>证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29601" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="less-trans-revisited">练习 <code>&lt;-trans-revisited</code>（实践）</h4><p>用另外一种方法证明严格不等是传递的，使用之前证明的不等关系和严格不等关系的联系， 以及不等关系的传递性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29996" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="even-and-odd">奇和偶</h2><p>作为一个额外的例子，我们来定义奇数和偶数。不等关系和严格不等关系是<strong>二元关系</strong>，而奇偶性 是<strong>一元关系</strong>，有时也被叫做<strong>谓词（Predicate）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30354" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-even"></a><a id="plfa_plfa-part1-Relations-30359" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30364" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30366" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30368" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Relations-30374" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-odd"></a><a id="plfa_plfa-part1-Relations-30379" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Relations-30384" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30386" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30388" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Relations-30395" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30400" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30405" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-even.zero"></a><a id="plfa_plfa-part1-Relations-30414" href="../Relations/#plfa_plfa-part1-Relations-30414" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-30419" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-30427" class="Comment">---------</a>
      <a id="plfa_plfa-part1-Relations-30443" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Relations-even.suc"></a><a id="plfa_plfa-part1-Relations-30456" href="../Relations/#plfa_plfa-part1-Relations-30456" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30461" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30463" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30465" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30466" href="../Relations/#plfa_plfa-part1-Relations-30466" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30468" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30470" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30471" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30477" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30479" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30483" href="../Relations/#plfa_plfa-part1-Relations-30466" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30491" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-30508" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30510" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30515" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30516" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30520" href="../Relations/#plfa_plfa-part1-Relations-30466" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30521" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-30524" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30529" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30533" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-odd.suc"></a><a id="plfa_plfa-part1-Relations-30542" href="../Relations/#plfa_plfa-part1-Relations-30542" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30547" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30549" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30551" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30552" href="../Relations/#plfa_plfa-part1-Relations-30552" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30554" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30557" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30563" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30565" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30570" href="../Relations/#plfa_plfa-part1-Relations-30552" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30578" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Relations-30594" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30596" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30600" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30601" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30605" href="../Relations/#plfa_plfa-part1-Relations-30552" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30606" class="Symbol">)</a>
</pre><p>一个数是偶数，如果它是 0，或者是奇数的后继。一个数是奇数，如果它是偶数的后继。</p><p>这是我们第一次定义一个相互递归的数据类型。因为每个标识符必须在使用前声明，所以 我们首先声明索引数据类型 <code>even</code> 和 <code>odd</code> （省略 <code>where</code> 关键字和其构造子的定义）， 然后声明其构造子（省略其签名 <code>ℕ → Set</code>，因为在之前已经给出）。</p><p>这也是我们第一次使用<strong>重载（Overloaded）</strong>的构造子。这意味着不同类型的构造子 拥有相同的名字。在这里 <code>suc</code> 表示下面三种构造子其中之一：</p><pre><code>suc : ℕ → ℕ

suc : ∀ {n : ℕ}
  → odd n
    ------------
  → even (suc n)

suc : ∀ {n : ℕ}
  → even n
    -----------
  → odd (suc n)</code></pre><p>同理，<code>zero</code> 表示两种构造子的一种。因为类型推导的限制，Agda 不允许重载已定义的名字， 但是允许重载构造子。我们推荐将重载限制在有关联的定义中，如我们所做的这样，但这不是必须的。</p><p>我们证明两个偶数之和是偶数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-e+e≡e"></a><a id="plfa_plfa-part1-Relations-32183" href="../Relations/#plfa_plfa-part1-Relations-32183" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32189" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32191" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32193" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32194" href="../Relations/#plfa_plfa-part1-Relations-32194" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32196" href="../Relations/#plfa_plfa-part1-Relations-32196" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32198" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32200" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32201" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32205" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32207" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32212" href="../Relations/#plfa_plfa-part1-Relations-32194" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32216" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32218" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32223" href="../Relations/#plfa_plfa-part1-Relations-32196" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32229" class="Comment">------------</a>
  <a id="plfa_plfa-part1-Relations-32244" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32246" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32251" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32252" href="../Relations/#plfa_plfa-part1-Relations-32194" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32254" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32256" href="../Relations/#plfa_plfa-part1-Relations-32196" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32257" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-o+e≡o"></a><a id="plfa_plfa-part1-Relations-32260" href="../Relations/#plfa_plfa-part1-Relations-32260" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32266" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32268" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32270" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32271" href="../Relations/#plfa_plfa-part1-Relations-32271" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32273" href="../Relations/#plfa_plfa-part1-Relations-32273" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32275" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32277" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32278" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32282" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32284" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32288" href="../Relations/#plfa_plfa-part1-Relations-32271" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32292" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32294" href="../Relations/#plfa_plfa-part1-Relations-30359" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32299" href="../Relations/#plfa_plfa-part1-Relations-32273" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32305" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Relations-32319" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32321" href="../Relations/#plfa_plfa-part1-Relations-30379" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32325" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32326" href="../Relations/#plfa_plfa-part1-Relations-32271" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32328" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32330" href="../Relations/#plfa_plfa-part1-Relations-32273" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32331" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32334" href="../Relations/#plfa_plfa-part1-Relations-32183" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32340" href="../Relations/#plfa_plfa-part1-Relations-30414" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-32349" href="../Relations/#plfa_plfa-part1-Relations-32349" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32353" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32356" href="../Relations/#plfa_plfa-part1-Relations-32349" class="Bound">en</a>
<a id="plfa_plfa-part1-Relations-32359" href="../Relations/#plfa_plfa-part1-Relations-32183" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32365" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32366" href="../Relations/#plfa_plfa-part1-Relations-30456" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32370" href="../Relations/#plfa_plfa-part1-Relations-32370" class="Bound">om</a><a id="plfa_plfa-part1-Relations-32372" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32374" href="../Relations/#plfa_plfa-part1-Relations-32374" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32378" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32381" href="../Relations/#plfa_plfa-part1-Relations-30456" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32385" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32386" href="../Relations/#plfa_plfa-part1-Relations-32260" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32392" href="../Relations/#plfa_plfa-part1-Relations-32370" class="Bound">om</a> <a id="plfa_plfa-part1-Relations-32395" href="../Relations/#plfa_plfa-part1-Relations-32374" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32397" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32400" href="../Relations/#plfa_plfa-part1-Relations-32260" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32406" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32407" href="../Relations/#plfa_plfa-part1-Relations-30542" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32411" href="../Relations/#plfa_plfa-part1-Relations-32411" class="Bound">em</a><a id="plfa_plfa-part1-Relations-32413" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32415" href="../Relations/#plfa_plfa-part1-Relations-32415" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32419" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32422" href="../Relations/#plfa_plfa-part1-Relations-30542" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32426" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32427" href="../Relations/#plfa_plfa-part1-Relations-32183" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32433" href="../Relations/#plfa_plfa-part1-Relations-32411" class="Bound">em</a> <a id="plfa_plfa-part1-Relations-32436" href="../Relations/#plfa_plfa-part1-Relations-32415" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32438" class="Symbol">)</a>
</pre><p>与相互递归的定义对应，我们用两个相互递归的函数，一个证明两个偶数之和是偶数，另一个证明 一个奇数与一个偶数之和是奇数。</p><p>这是我们第一次使用相互递归的函数。因为每个标识符必须在使用前声明，我们先给出两个函数的签名， 然后再给出其定义。</p><p>要证明两个偶数之和为偶，我们考虑第一个数为偶数的证明。如果是因为第一个数为 0， 那么第二个数为偶数的证明即为和为偶数的证明。如果是因为第一个数为奇数的后继， 那么和为偶数是因为他是一个奇数和一个偶数的和的后续，而这个和是一个奇数。</p><p>要证明一个奇数和一个偶数的和是奇数，我们考虑第一个数是奇数的证明。 如果是因为它是一个偶数的后继，那么和为奇数，因为它是两个偶数之和的后继， 而这个和是一个偶数。</p><h4 id="odd-plus-odd">练习 <code>o+o≡e</code> (延伸)</h4><p>证明两个奇数之和为偶数。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-34011" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="Bin-predicates">练习 <code>Bin-predicates</code> (延伸)</h4><p>回忆我们在练习 <a href="../Naturals/#Bin">Bin</a> 中定义了一个数据类型 <code>Bin</code> 来用二进制字符串表示自然数。 这个表达方法不是唯一的，因为我们在开头加任意个 0。因此，11 可以由以下方法表示：</p><pre><code>⟨⟩ I O I I
⟨⟩ O O I O I I</code></pre><p>定义一个谓词</p><pre><code>Can : Bin → Set</code></pre><p>其在一个二进制字符串的表示是标准的（Canonical）时成立，表示它没有开头的 0。在两个 11 的表达方式中， 第一个是标准的，而第二个不是。在定义这个谓词时，你需要一个辅助谓词：</p><pre><code>One : Bin → Set</code></pre><p>其仅在一个二进制字符串开头为 1 时成立。一个二进制字符串是标准的，如果它开头是 1 （表示一个正数）， 或者它仅是一个 0 （表示 0）。</p><p>证明递增可以保持标准性。</p><pre><code>Can b
------------
Can (inc b)</code></pre><p>证明从自然数转换成的二进制字符串是标准的。</p><pre><code>----------
Can (to n)</code></pre><p>证明将一个标准的二进制字符串转换成自然数之后，再转换回二进制字符串与原二进制字符串相同。</p><pre><code>Can b
---------------
to (from b) ≡ b</code></pre><p>提示：对于每一条习题，先从 <code>One</code> 的性质开始。 证明以下命题也会很有帮助。</p><pre><code>One b
----------
1 ≤ from b

1 ≤ n
---------------------
to (2 * n) ≡ (to n) O</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Relations-35946" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中有类似于本章介绍的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-36121" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36128" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-36137" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36143" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36144" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Relations-36147" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36149" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-36152" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36154" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Relations-36157" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-36159" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36166" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-36186" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36192" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36193" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4565" class="Function">≤-refl</a><a id="plfa_plfa-part1-Relations-36199" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36201" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4748" class="Function">≤-trans</a><a id="plfa_plfa-part1-Relations-36208" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36210" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4615" class="Function">≤-antisym</a><a id="plfa_plfa-part1-Relations-36219" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36221" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4860" class="Function">≤-total</a><a id="plfa_plfa-part1-Relations-36228" class="Symbol">;</a>
                                  <a id="plfa_plfa-part1-Relations-36264" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#18026" class="Function">+-monoʳ-≤</a><a id="plfa_plfa-part1-Relations-36273" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36275" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17936" class="Function">+-monoˡ-≤</a><a id="plfa_plfa-part1-Relations-36284" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36286" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17780" class="Function">+-mono-≤</a><a id="plfa_plfa-part1-Relations-36294" class="Symbol">)</a>
</pre><p>在标准库中，<code>≤-total</code> 是使用析取定义的（我们将在 <a href="../Connectives/">Connectives</a> 章节定义）。 <code>+-monoʳ-≤</code>、<code>+-monoˡ-≤</code> 和 <code>+-mono-≤</code> 的证明方法和本书不同。 更多的参数是隐式申明的。</p><h2 id="unicode">Unicode</h2><p>本章使用了如下 Unicode 符号：</p><pre><code>≤  U+2264  小于等于 (\&lt;=, \le)
≥  U+2265  大于等于 (\&gt;=, \ge)
ˡ  U+02E1  小写字母 L 标识符 (\^l)
ʳ  U+02B3  小写字母 R 标识符 (\^r)</code></pre><p><code>\^l</code> 和 <code>\^r</code> 命令给出了左右箭头，以及上标字母 <code>l</code> 和 <code>r</code>。</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>