<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Relations</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Relations: 关系的归纳定义</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Relations-121" class="Keyword">module</a> <a id="plfa_plfa-part1-Relations-128" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Relations-149" class="Keyword">where</a>
</pre><p>在定义了加法和乘法等运算以后，下一步我们来定义<strong>关系（Relation）</strong>，比如说<strong>小于等于</strong>。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Relations-398" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-405" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Relations-443" class="Symbol">as</a> <a id="plfa_plfa-part1-Relations-446" class="Module">Eq</a>
<a id="plfa_plfa-part1-Relations-449" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-454" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Relations-457" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-463" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-464" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Relations-467" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-469" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Relations-473" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Relations-479" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-481" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-486" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-493" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-502" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-508" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-509" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-516" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-518" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Relations-521" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Relations-526" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-528" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-533" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-540" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-560" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-566" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-567" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Relations-573" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-575" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Relations-586" class="Symbol">)</a>
</pre><h2 id="定义关系">定义关系</h2><p>小于等于这个关系有无穷个实例，如下所示：</p><pre><code>0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...</code></pre><p>但是，我们仍然可以用几行有限的定义来表示所有的实例，如下文所示的一对推理规则：</p><pre><code>z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n</code></pre><p>以及其 Agda 定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-1375" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_≤_"></a><a id="plfa_plfa-part1-Relations-1380" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Relations-1384" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1386" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1388" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1392" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-1398" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_≤_.z≤n"></a><a id="plfa_plfa-part1-Relations-1407" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-1411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1413" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1415" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1416" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1418" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1420" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1421" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-1429" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Relations-1442" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-1449" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1451" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_≤_.s≤s"></a><a id="plfa_plfa-part1-Relations-1456" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-1460" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1462" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1464" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1465" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1467" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1469" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1471" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1472" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-1478" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1480" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1482" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1484" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-1492" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-1510" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1516" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1518" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1520" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1524" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
</pre><p>在这里，<code>z≤n</code> 和 <code>s≤s</code>（无空格）是构造子的名称，<code>zero ≤ n</code>、<code>m ≤ n</code> 和 <code>suc m ≤ suc n</code> （带空格）是类型。在这里我们第一次用到了 <strong>索引数据类型（Indexed datatype）</strong>。我们使用 <code>m</code> 和 <code>n</code> 这两个自然数来索引 <code>m ≤ n</code> 这个类型。在 Agda 里，由两个及以上短横线开始的行是注释行， 我们巧妙利用这一语法特性，用上述形式来表示相应的推理规则。 在后文中，我们还会继续使用这一形式。</p><p>这两条定义告诉我们相同的两件事：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，命题 <code>zero ≤ n</code> 成立。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果命题 <code>m ≤ n</code> 成立， 那么命题 <code>suc m ≤ suc n</code> 成立。</li></ul><p>实际上，他们分别给我们更多的信息：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，构造子 <code>z≤n</code> 提供了 <code>zero ≤ n</code> 成立的证明。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，构造子 <code>s≤s</code> 将 <code>m ≤ n</code> 成立的证明 转化为 <code>suc m ≤ suc n</code> 成立的证明。</li></ul><p>例如，我们在这里以推理规则的形式写出 <code>2 ≤ 4</code> 的证明：</p><pre><code>  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4</code></pre><p>下面是对应的 Agda 证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-3418" href="../Relations/#plfa_plfa-part1-Relations-3418" class="Function">_</a> <a id="plfa_plfa-part1-Relations-3420" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-3422" class="Number">2</a> <a id="plfa_plfa-part1-Relations-3424" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-3426" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-3428" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-3430" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-3432" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3436" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-3437" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3441" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-3444" class="Symbol">)</a>
</pre><h2 id="隐式参数">隐式参数</h2><p>这是我们第一次使用隐式参数。定义不等式时，构造子的定义中使用了 <code>∀</code>， 就像我们在下面的命题中使用 <code>∀</code> 一样：</p><pre><code>+-comm : ∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>但是我们这里的定义使用了花括号 <code>{ }</code>，而不是小括号 <code>( )</code>。 这意味着参数是<strong>隐式的（Implicit）</strong>，不需要额外声明。实际上，Agda 的类型检查器 会<strong>推导（Infer）</strong>出它们。因此，我们在 <code>m + n ≡ n + m</code> 的证明中需要写出 <code>+-comm m n</code>， 在 <code>zero ≤ n</code> 的证明中可以省略 <code>n</code>。同理，如果 <code>m≤n</code> 是 <code>m ≤ n</code>的证明， 那么我们写出 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 的证明，无需声明 <code>m</code> 和 <code>n</code>。</p><p>如果有希望的话，我们也可以在大括号里显式声明隐式参数。例如，下面是 <code>2 ≤ 4</code> 的 Agda 证明，包括了显式声明了的隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4856" href="../Relations/#plfa_plfa-part1-Relations-4856" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4858" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4860" class="Number">2</a> <a id="plfa_plfa-part1-Relations-4862" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-4864" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-4866" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-4868" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-4870" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4874" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4875" class="Number">1</a><a id="plfa_plfa-part1-Relations-4876" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4878" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4879" class="Number">3</a><a id="plfa_plfa-part1-Relations-4880" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4882" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4883" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4887" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4888" class="Number">0</a><a id="plfa_plfa-part1-Relations-4889" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4891" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4892" class="Number">2</a><a id="plfa_plfa-part1-Relations-4893" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4895" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4896" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-4900" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4901" class="Number">2</a><a id="plfa_plfa-part1-Relations-4902" class="Symbol">}))</a>
</pre><p>也可以额外加上参数的名字：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4994" href="../Relations/#plfa_plfa-part1-Relations-4994" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4996" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4998" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5000" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5002" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5004" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5006" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5008" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5012" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5013" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5015" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5017" class="Number">1</a><a id="plfa_plfa-part1-Relations-5018" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5020" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5021" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5023" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5025" class="Number">3</a><a id="plfa_plfa-part1-Relations-5026" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5028" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5029" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5033" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5034" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5036" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5038" class="Number">0</a><a id="plfa_plfa-part1-Relations-5039" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5041" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5042" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5044" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5046" class="Number">2</a><a id="plfa_plfa-part1-Relations-5047" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5049" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5050" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-5054" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5055" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5057" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5059" class="Number">2</a><a id="plfa_plfa-part1-Relations-5060" class="Symbol">}))</a>
</pre><p>在后者的形式中，也可以选择只声明一部分隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-5190" href="../Relations/#plfa_plfa-part1-Relations-5190" class="Function">_</a> <a id="plfa_plfa-part1-Relations-5192" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5194" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5196" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5198" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5200" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5202" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5204" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5208" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5209" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5211" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5213" class="Number">3</a><a id="plfa_plfa-part1-Relations-5214" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5216" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5217" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5221" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5222" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5224" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5226" class="Number">2</a><a id="plfa_plfa-part1-Relations-5227" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5229" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-5232" class="Symbol">)</a>
</pre><p>但是不可以改变隐式参数的顺序，即便加上了名字。</p><p>我们可以写出 <code>_</code> 来让 Agda 用相同的推导方式试着推导一个<strong>显式</strong>的项。 例如，我们可以为命题 <code>+-identityʳ</code> 定义一个带有隐式参数的变体：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-identityʳ′"></a><a id="plfa_plfa-part1-Relations-5632" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5645" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5647" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-5649" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5650" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5652" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5654" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-5655" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5657" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-5659" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5661" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-5663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-5668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-5670" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a>
<a id="plfa_plfa-part1-Relations-5672" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5685" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5687" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Relations-5699" class="Symbol">_</a>
</pre><p>我们用 <code>_</code> 来让 Agda 从上下文中推导<strong>显式参数</strong>的值。只有 <code>m</code> 这一个值能够给出正确的证明，因此 Agda 愉快地填入了它。 如果 Agda 推导值失败，那么它会报一个错误。</p><h2 id="优先级">优先级</h2><p>我们如下定义比较的优先级：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-6163" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-6169" class="Number">4</a> <a id="plfa_plfa-part1-Relations-6171" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a>
</pre><p>我们将 <code>_≤_</code> 的优先级设置为 4，所以它不如优先级为 6 的 <code>_+_</code> 结合得紧，因而， <code>1 + 2 ≤ 3</code> 将被解析为 <code>(1 + 2) ≤ 3</code>。我们用 <code>infix</code> 来表示运算符既不是左结合的， 也不是右结合的。因为 <code>1 ≤ 2 ≤ 3</code> 解析为 <code>(1 ≤ 2) ≤ 3</code> 或者 <code>1 ≤ (2 ≤ 3)</code> 都没有意义。</p><h2 id="可决定性">可决定性</h2><p>给定两个数，我们可以很直接地决定第一个数是不是小于等于第二个数。我们在此处不给出说明的代码， 但我们会在 <a href="../Decidable/">Decidable</a> 章节重新讨论这个问题。</p><h2 id="反演">反演</h2><p>在我们的定义中，我们从更小的东西得到更大的东西。例如，我们可以从 <code>m ≤ n</code> 得出 <code>suc m ≤ suc n</code> 的结论，这里的 <code>suc m</code> 比 <code>m</code> 更大 （也就是说，前者包含后者），<code>suc n</code> 也比 <code>n</code> 更大。但有时我们也 需要从更大的东西得到更小的东西。</p><p>只有一种方式能够证明对于任意 <code>m</code> 和 <code>n</code> 有 <code>suc m ≤ suc n</code>。 这让我们能够反演（invert）之前的规则。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-s≤s"></a><a id="plfa_plfa-part1-Relations-7722" href="../Relations/#plfa_plfa-part1-Relations-7722" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7730" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7732" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-7734" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-7735" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7737" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-7739" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7741" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-7742" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-7746" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7748" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7752" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7754" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7760" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-7766" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-7782" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7784" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7786" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7788" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-7790" href="../Relations/#plfa_plfa-part1-Relations-7722" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7798" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-7799" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-7803" href="../Relations/#plfa_plfa-part1-Relations-7803" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-7806" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-7808" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-7810" href="../Relations/#plfa_plfa-part1-Relations-7803" class="Bound">m≤n</a>
</pre><p>这里的 <code>m≤n</code>（不带空格）是一个变量名，而 <code>m ≤ n</code>（带空格）是一个类型， 且后者是前者的类型。在 Agda 中，将类型中的空格去掉来作为变量名是一种常见的约定。</p><p>并不是所有规则都可以反演。实际上，<code>z≤n</code> 的规则没有非隐式的假设， 因此它没有可以被反演的规则。但这种反演通常是成立的。</p><p>反演的另一个例子是证明只存在一种情况使得一个数字能够小于或等于零。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-z≤n"></a><a id="plfa_plfa-part1-Relations-8538" href="../Relations/#plfa_plfa-part1-Relations-8538" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8546" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8548" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-8550" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-8551" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8553" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8555" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-8556" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-8560" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8562" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8564" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-8566" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
    <a id="plfa_plfa-part1-Relations-8575" class="Comment">--------</a>
  <a id="plfa_plfa-part1-Relations-8586" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8588" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-8592" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Relations-8597" href="../Relations/#plfa_plfa-part1-Relations-8538" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8605" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-8609" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-8611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><h2 id="序关系的性质">序关系的性质</h2><p>数学家对于关系的常见性质给出了约定的名称。</p><ul><li><strong>自反（Reflexive）</strong>：对于所有的 <code>n</code>，关系 <code>n ≤ n</code> 成立。</li><li><strong>传递（Transitive）</strong>：对于所有的 <code>m</code>、 <code>n</code> 和 <code>p</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 也成立。</li><li><strong>反对称（Anti-symmetric）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立。</li><li><strong>完全（Total）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。</li></ul><p><code>_≤_</code> 关系满足上述四条性质。</p><p>对于上述性质的组合也有约定的名称。</p><ul><li><strong>预序（Preorder）</strong>：满足自反和传递的关系。</li><li><strong>偏序（Partial Order）</strong>：满足反对称的预序。</li><li><strong>全序（Total Order）</strong>：满足完全的偏序。</li></ul><p>如果你进入了关于关系的聚会，你现在知道怎么样和人讨论了，可以讨论关于自反、传递、反对称和完全， 或者问一问这是不是预序、偏序或者全序。</p><p>更认真的来说，如果你在阅读论文时碰到了一个关系，本文的介绍让你可以对关系有基本的了解和判断， 来判断这个关系是不是预序、偏序或者全序。一个认真的作者一般会在文章指出这个关系具有（或者缺少） 上述性质，比如说指出新定义的关系是一个偏序而不是全序。</p><h4 id="orderings">练习 <code>orderings</code>（实践）</h4><p>给出一个不是偏序的预序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10873" class="Comment">-- 请将代码写在此处。</a>
</pre><p>给出一个不是全序的偏序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10990" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="自反性">自反性</h2><p>我们第一个来证明的性质是自反性：对于任意自然数 <code>n</code>，关系 <code>n ≤ n</code> 成立。我们使用标准库 的惯例来隐式申明参数，在使用自反性的证明时这样可以更加方便。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-refl"></a><a id="plfa_plfa-part1-Relations-11394" href="../Relations/#plfa_plfa-part1-Relations-11394" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11401" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11403" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-11405" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11406" href="../Relations/#plfa_plfa-part1-Relations-11406" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11408" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11410" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-11411" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-11417" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-11425" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-11427" href="../Relations/#plfa_plfa-part1-Relations-11406" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11429" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-11431" href="../Relations/#plfa_plfa-part1-Relations-11406" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-11433" href="../Relations/#plfa_plfa-part1-Relations-11394" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11440" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11441" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-11445" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11447" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11449" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-11453" href="../Relations/#plfa_plfa-part1-Relations-11394" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11460" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11461" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-11465" href="../Relations/#plfa_plfa-part1-Relations-11465" class="Bound">n</a><a id="plfa_plfa-part1-Relations-11466" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11468" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11470" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-11474" href="../Relations/#plfa_plfa-part1-Relations-11394" class="Function">≤-refl</a>
</pre><p>这个证明直接在 <code>n</code> 上进行归纳。在起始步骤中，<code>zero ≤ zero</code> 由 <code>z≤n</code> 证明；在归纳步骤中， 归纳假设 <code>≤-refl {n}</code> 给我们带来了 <code>n ≤ n</code> 的证明，我们只需要使用 <code>s≤s</code>，就可以获得 <code>suc n ≤ suc n</code> 的证明。</p><p>在 Emacs 中来交互式地证明自反性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="传递性">传递性</h2><p>我们第二个证明的性质是传递性：对于任意自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 成立。同样，<code>m</code>、<code>n</code> 和 <code>p</code> 是隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans"></a><a id="plfa_plfa-part1-Relations-12469" href="../Relations/#plfa_plfa-part1-Relations-12469" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12477" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12479" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-12481" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-12482" href="../Relations/#plfa_plfa-part1-Relations-12482" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12484" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12486" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-12488" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12490" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-12491" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-12495" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12497" href="../Relations/#plfa_plfa-part1-Relations-12482" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12499" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12501" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-12505" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12507" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12509" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12511" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-12517" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-12525" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12527" href="../Relations/#plfa_plfa-part1-Relations-12482" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12529" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12531" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-12533" href="../Relations/#plfa_plfa-part1-Relations-12469" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12541" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-12551" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-12562" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12565" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-12569" href="../Relations/#plfa_plfa-part1-Relations-12469" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12577" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12578" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12582" href="../Relations/#plfa_plfa-part1-Relations-12582" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-12585" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-12587" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12588" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12592" href="../Relations/#plfa_plfa-part1-Relations-12592" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12595" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-12598" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12601" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12605" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12606" href="../Relations/#plfa_plfa-part1-Relations-12469" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12614" href="../Relations/#plfa_plfa-part1-Relations-12582" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-12618" href="../Relations/#plfa_plfa-part1-Relations-12592" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12621" class="Symbol">)</a>
</pre><p>这里我们在 <code>m ≤ n</code> 的<strong>证据（Evidence）</strong>上进行归纳。在起始步骤里，第一个不等式因为 <code>z≤n</code> 而成立， 那么结论亦可由 <code>z≤n</code> 而得出。在这里，<code>n ≤ p</code> 的证明是不需要的，我们用 <code>_</code> 来表示这个 证明没有被使用。</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个不等式因为 <code>s≤s n≤p</code> 而成立， 所以我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc p</code>，求证 <code>suc m ≤ suc p</code>。 通过归纳假设 <code>≤-trans m≤n n≤p</code>，我们得知 <code>m ≤ p</code>，在此之上使用 <code>s≤s</code> 即可证。</p><p><code>≤-trans (s≤s m≤n) z≤n</code> 不可能发生，因为第一个不等式告诉我们中间的数是一个 <code>suc n</code>， 而第二个不等式告诉我们中间的数是 <code>zero</code>。Agda 可以推断这样的情况不可能发现，所以我们不需要 （也不可以）列出这种情况。</p><p>我们也可以将隐式参数显式地声明。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans′"></a><a id="plfa_plfa-part1-Relations-14067" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14076" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14078" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-14080" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14081" href="../Relations/#plfa_plfa-part1-Relations-14081" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14083" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14085" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14087" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14089" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-14090" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-14094" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14096" href="../Relations/#plfa_plfa-part1-Relations-14081" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14098" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14100" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-14104" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14106" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14108" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14110" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-14116" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-14124" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14126" href="../Relations/#plfa_plfa-part1-Relations-14081" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14128" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14130" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-14132" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14141" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-14149" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14157" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14165" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-14175" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-14186" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14189" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-14193" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14202" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14203" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14207" href="../Relations/#plfa_plfa-part1-Relations-14207" class="Bound">m</a><a id="plfa_plfa-part1-Relations-14208" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14210" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14211" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14215" href="../Relations/#plfa_plfa-part1-Relations-14215" class="Bound">n</a><a id="plfa_plfa-part1-Relations-14216" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14218" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14219" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14223" href="../Relations/#plfa_plfa-part1-Relations-14223" class="Bound">p</a><a id="plfa_plfa-part1-Relations-14224" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14226" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14227" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14231" href="../Relations/#plfa_plfa-part1-Relations-14231" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-14234" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14236" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14237" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14241" href="../Relations/#plfa_plfa-part1-Relations-14241" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14244" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-14247" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14250" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14254" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14255" href="../Relations/#plfa_plfa-part1-Relations-14067" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14264" href="../Relations/#plfa_plfa-part1-Relations-14207" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14266" href="../Relations/#plfa_plfa-part1-Relations-14215" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14268" href="../Relations/#plfa_plfa-part1-Relations-14223" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14270" href="../Relations/#plfa_plfa-part1-Relations-14231" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-14274" href="../Relations/#plfa_plfa-part1-Relations-14241" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14277" class="Symbol">)</a>
</pre><p>有人说这样的证明更加的清晰，也有人说这个更长的证明让人难以抓住证明的重点。 我们一般选择使用简短的证明。</p><p>对于性质成立证明进行的归纳（如上文中对于 <code>m ≤ n</code> 的证明进行归纳），相比于对于性质成立的值进行的归纳 （如对于 <code>m</code> 进行归纳），有非常大的价值。我们会经常使用这样的方法。</p><p>同样，在 Emacs 中来交互式地证明传递性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="反对称性">反对称性</h2><p>我们证明的第三个性质是反对称性：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-antisym"></a><a id="plfa_plfa-part1-Relations-15380" href="../Relations/#plfa_plfa-part1-Relations-15380" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15390" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15392" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-15394" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-15395" href="../Relations/#plfa_plfa-part1-Relations-15395" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15397" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15399" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15401" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-15402" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-15406" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15408" href="../Relations/#plfa_plfa-part1-Relations-15395" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15410" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15412" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-15416" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15418" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15420" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15422" href="../Relations/#plfa_plfa-part1-Relations-15395" class="Bound">m</a>
    <a id="plfa_plfa-part1-Relations-15428" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-15436" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15438" href="../Relations/#plfa_plfa-part1-Relations-15395" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15440" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-15442" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-15444" href="../Relations/#plfa_plfa-part1-Relations-15380" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15454" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-15464" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Relations-15475" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15478" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Relations-15483" href="../Relations/#plfa_plfa-part1-Relations-15380" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15493" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15494" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15498" href="../Relations/#plfa_plfa-part1-Relations-15498" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-15501" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-15503" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15504" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15508" href="../Relations/#plfa_plfa-part1-Relations-15508" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15511" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-15514" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15517" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Relations-15522" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-15526" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15527" href="../Relations/#plfa_plfa-part1-Relations-15380" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15537" href="../Relations/#plfa_plfa-part1-Relations-15498" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-15541" href="../Relations/#plfa_plfa-part1-Relations-15508" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15544" class="Symbol">)</a>
</pre><p>同样，我们对于 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明进行归纳。</p><p>在起始步骤中，两个不等式都因为 <code>z≤n</code> 而成立。因此我们已知 <code>zero ≤ zero</code> 和 <code>zero ≤ zero</code>， 求证 <code>zero ≡ zero</code>，由自反性可证。（注：由等式的自反性可证，而不是不等式的自反性）</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个等式因为 <code>s≤s n≤m</code> 而成立。因此我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc m</code>，求证 <code>suc m ≡ suc n</code>。归纳假设 <code>≤-antisym m≤n n≤m</code> 可以证明 <code>m ≡ n</code>，因此我们可以使用同余性完成证明。</p><h4 id="leq-antisym-cases">练习 <code>≤-antisym-cases</code>（实践）</h4><p>上面的证明中省略了一个参数是 <code>z≤n</code>，另一个参数是 <code>s≤s</code> 的情况。为什么可以省略这种情况？</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-16825" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="完全性">完全性</h2><p>我们证明的第四个性质是完全性：对于任何自然数 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。 在 <code>m</code> 和 <code>n</code> 相等时，两者同时成立。</p><p>我们首先来说明怎么样不等式才是完全的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-17211" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total"></a><a id="plfa_plfa-part1-Relations-17216" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17222" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-17223" href="../Relations/#plfa_plfa-part1-Relations-17223" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17225" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17227" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17229" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-17230" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-17232" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17234" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-17238" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total.forward"></a><a id="plfa_plfa-part1-Relations-17247" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-17255" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17263" href="../Relations/#plfa_plfa-part1-Relations-17223" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17265" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17267" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-17275" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17289" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17291" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17297" href="../Relations/#plfa_plfa-part1-Relations-17223" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17299" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total.flipped"></a><a id="plfa_plfa-part1-Relations-17304" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-17312" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17320" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17322" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17324" href="../Relations/#plfa_plfa-part1-Relations-17223" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-17332" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17346" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17348" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17354" href="../Relations/#plfa_plfa-part1-Relations-17223" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17356" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">n</a>
</pre><p><code>Total m n</code> 成立的证明有两种形式：<code>forward m≤n</code> 或者 <code>flipped n≤m</code>，其中 <code>m≤n</code> 和 <code>n≤m</code> 分别是 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明。</p><p>（如果你对于逻辑学有所了解，上面的定义可以由析取（Disjunction）表示。 我们会在 <a href="../Connectives/">Connectives</a> 章节介绍析取。）</p><p>这是我们第一次使用带<em>参数</em>的数据类型，这里 <code>m</code> 和 <code>n</code> 是参数。这等同于下面的索引数据类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-18097" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total′"></a><a id="plfa_plfa-part1-Relations-18102" href="../Relations/#plfa_plfa-part1-Relations-18102" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18109" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18111" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18113" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18115" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18117" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-18123" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total′.forward′"></a><a id="plfa_plfa-part1-Relations-18132" href="../Relations/#plfa_plfa-part1-Relations-18132" class="InductiveConstructor">forward′</a> <a id="plfa_plfa-part1-Relations-18141" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18143" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18145" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18146" href="../Relations/#plfa_plfa-part1-Relations-18146" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18148" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18150" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18152" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18153" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18159" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18161" href="../Relations/#plfa_plfa-part1-Relations-18146" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18163" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18165" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-18173" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18188" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18190" href="../Relations/#plfa_plfa-part1-Relations-18102" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18197" href="../Relations/#plfa_plfa-part1-Relations-18146" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18199" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total′.flipped′"></a><a id="plfa_plfa-part1-Relations-18204" href="../Relations/#plfa_plfa-part1-Relations-18204" class="InductiveConstructor">flipped′</a> <a id="plfa_plfa-part1-Relations-18213" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18215" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18217" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18218" href="../Relations/#plfa_plfa-part1-Relations-18218" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18220" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18222" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18224" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18225" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18231" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18233" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18235" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18237" href="../Relations/#plfa_plfa-part1-Relations-18218" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-18245" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18260" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18262" href="../Relations/#plfa_plfa-part1-Relations-18102" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18269" href="../Relations/#plfa_plfa-part1-Relations-18218" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18271" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">n</a>
</pre><p>类型里的每个参数都转换成构造子的一个隐式参数。索引数据类型中的索引可以变化，正如在 <code>zero ≤ n</code> 和 <code>suc m ≤ suc n</code> 中那样，而参数化数据类型不一样，其参数必须保持相同， 正如在 <code>Total m n</code> 中那样。参数化的声明更短，更易于阅读，而且有时可以帮助到 Agda 的 停机检查器，所以我们尽可能地使用它们，而不是索引数据类型。</p><p>在上述准备工作完成后，我们定义并证明完全性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total"></a><a id="plfa_plfa-part1-Relations-19019" href="../Relations/#plfa_plfa-part1-Relations-19019" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19027" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19029" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-19031" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19032" href="../Relations/#plfa_plfa-part1-Relations-19032" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19034" href="../Relations/#plfa_plfa-part1-Relations-19034" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-19036" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19038" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-19039" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19041" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-19043" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-19049" href="../Relations/#plfa_plfa-part1-Relations-19032" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19051" href="../Relations/#plfa_plfa-part1-Relations-19034" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19053" href="../Relations/#plfa_plfa-part1-Relations-19019" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19061" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-19069" href="../Relations/#plfa_plfa-part1-Relations-19069" class="Bound">n</a>                         <a id="plfa_plfa-part1-Relations-19095" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19098" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19106" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19110" href="../Relations/#plfa_plfa-part1-Relations-19019" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19118" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19123" href="../Relations/#plfa_plfa-part1-Relations-19123" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19124" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19126" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-19152" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19155" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19163" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19167" href="../Relations/#plfa_plfa-part1-Relations-19019" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19175" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19176" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19180" href="../Relations/#plfa_plfa-part1-Relations-19180" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19181" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19183" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19184" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19188" href="../Relations/#plfa_plfa-part1-Relations-19188" class="Bound">n</a><a id="plfa_plfa-part1-Relations-19189" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19191" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-19196" href="../Relations/#plfa_plfa-part1-Relations-19019" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19204" href="../Relations/#plfa_plfa-part1-Relations-19180" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19206" href="../Relations/#plfa_plfa-part1-Relations-19188" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19208" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19235" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19237" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19245" href="../Relations/#plfa_plfa-part1-Relations-19245" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-19250" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19253" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19261" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19262" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19266" href="../Relations/#plfa_plfa-part1-Relations-19245" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-19269" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-19271" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19298" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19300" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19308" href="../Relations/#plfa_plfa-part1-Relations-19308" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-19313" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19316" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19324" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19325" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19329" href="../Relations/#plfa_plfa-part1-Relations-19308" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-19332" class="Symbol">)</a>
</pre><p>这里，我们的证明在两个参数上进行归纳，并按照情况分析：</p><ul><li><p><strong>第一起始步骤</strong>：如果第一个参数是 <code>zero</code>，第二个参数是 <code>n</code>，那么 forward 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ n</code> 的证明。</p></li><li><p><strong>第二起始步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>zero</code>，那么 flipped 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ suc m</code> 的证明。</p></li><li><p><strong>归纳步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>suc n</code>，那么归纳假设 <code>≤-total m n</code> 可以给出如下推断：</p><ul><li><p>归纳假设的 forward 条件成立，以 <code>m≤n</code> 作为 <code>m ≤ n</code> 的证明。以此我们可以使用 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 来证明 forward 条件成立。</p></li><li><p>归纳假设的 flipped 条件成立，以 <code>n≤m</code> 作为 <code>n ≤ m</code> 的证明。以此我们可以使用 <code>s≤s n≤m</code> 作为 <code>suc n ≤ suc m</code> 来证明 flipped 条件成立。</p></li></ul></li></ul><p>这是我们第一次在 Agda 中使用 <code>with</code> 语句。<code>with</code> 关键字后面有一个表达式和一或多行。 每行以省略号（<code>...</code>）和一个竖线（<code>|</code>）开头，后面跟着用来匹配表达式的模式，和等式的右手边。</p><p>使用 <code>with</code> 语句等同于定义一个辅助函数。比如说，上面的定义和下面的等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total′"></a><a id="plfa_plfa-part1-Relations-21509" href="../Relations/#plfa_plfa-part1-Relations-21509" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21518" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21520" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-21522" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21523" href="../Relations/#plfa_plfa-part1-Relations-21523" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21525" href="../Relations/#plfa_plfa-part1-Relations-21525" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21527" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-21530" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21532" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21534" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21540" href="../Relations/#plfa_plfa-part1-Relations-21523" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21542" href="../Relations/#plfa_plfa-part1-Relations-21525" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-21544" href="../Relations/#plfa_plfa-part1-Relations-21509" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21553" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-21561" href="../Relations/#plfa_plfa-part1-Relations-21561" class="Bound">n</a>        <a id="plfa_plfa-part1-Relations-21570" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21573" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21581" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21585" href="../Relations/#plfa_plfa-part1-Relations-21509" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21594" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21599" href="../Relations/#plfa_plfa-part1-Relations-21599" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21600" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21602" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-21611" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21614" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21622" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21626" href="../Relations/#plfa_plfa-part1-Relations-21509" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21635" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21636" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21640" href="../Relations/#plfa_plfa-part1-Relations-21640" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21641" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21643" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21644" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21648" href="../Relations/#plfa_plfa-part1-Relations-21648" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21649" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21652" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21655" href="../Relations/#plfa_plfa-part1-Relations-21687" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21662" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21663" href="../Relations/#plfa_plfa-part1-Relations-21509" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21672" href="../Relations/#plfa_plfa-part1-Relations-21640" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21674" href="../Relations/#plfa_plfa-part1-Relations-21648" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21675" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21679" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Relations-21687" href="../Relations/#plfa_plfa-part1-Relations-21687" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21694" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21696" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21702" href="../Relations/#plfa_plfa-part1-Relations-21640" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21704" href="../Relations/#plfa_plfa-part1-Relations-21648" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21706" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21708" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21714" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21719" href="../Relations/#plfa_plfa-part1-Relations-21640" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21720" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21722" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21723" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21727" href="../Relations/#plfa_plfa-part1-Relations-21648" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21728" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21732" href="../Relations/#plfa_plfa-part1-Relations-21687" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21739" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21740" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21748" href="../Relations/#plfa_plfa-part1-Relations-21748" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21751" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21754" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21757" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21765" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21766" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21770" href="../Relations/#plfa_plfa-part1-Relations-21748" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21773" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21777" href="../Relations/#plfa_plfa-part1-Relations-21687" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21784" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21785" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21793" href="../Relations/#plfa_plfa-part1-Relations-21793" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21796" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21799" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21802" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21810" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21811" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21815" href="../Relations/#plfa_plfa-part1-Relations-21793" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21818" class="Symbol">)</a>
</pre><p>这也是我们第一次在 Agda 中使用 <code>where</code> 语句。<code>where</code> 关键字后面有一或多条定义，其必须被缩进。 之前等式左手边的约束变量（此例中的 <code>m</code> 和 <code>n</code>）在嵌套的定义中仍然在作用域内。 在嵌套定义中的约束标识符（此例中的 <code>helper</code> ）在等式的右手边的作用域内。</p><p>如果两个参数相同，那么两个情况同时成立，我们可以返回任一证明。上面的代码中我们返回 forward 条件， 但是我们也可以返回 flipped 条件，如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total″"></a><a id="plfa_plfa-part1-Relations-22690" href="../Relations/#plfa_plfa-part1-Relations-22690" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22699" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22701" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-22703" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22704" href="../Relations/#plfa_plfa-part1-Relations-22704" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22706" href="../Relations/#plfa_plfa-part1-Relations-22706" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-22708" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-22711" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22713" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-22715" href="../Relations/#plfa_plfa-part1-Relations-17216" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-22721" href="../Relations/#plfa_plfa-part1-Relations-22704" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22723" href="../Relations/#plfa_plfa-part1-Relations-22706" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22725" href="../Relations/#plfa_plfa-part1-Relations-22690" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22734" href="../Relations/#plfa_plfa-part1-Relations-22734" class="Bound">m</a>       <a id="plfa_plfa-part1-Relations-22742" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-22768" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22771" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22779" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22783" href="../Relations/#plfa_plfa-part1-Relations-22690" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22792" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-22800" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22801" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22805" href="../Relations/#plfa_plfa-part1-Relations-22805" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22806" class="Symbol">)</a>                   <a id="plfa_plfa-part1-Relations-22826" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22829" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22837" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22841" href="../Relations/#plfa_plfa-part1-Relations-22690" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22850" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22851" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22855" href="../Relations/#plfa_plfa-part1-Relations-22855" class="Bound">m</a><a id="plfa_plfa-part1-Relations-22856" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22858" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22859" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22863" href="../Relations/#plfa_plfa-part1-Relations-22863" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22864" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22866" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-22871" href="../Relations/#plfa_plfa-part1-Relations-22690" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22880" href="../Relations/#plfa_plfa-part1-Relations-22855" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22882" href="../Relations/#plfa_plfa-part1-Relations-22863" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22884" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22912" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22914" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22922" href="../Relations/#plfa_plfa-part1-Relations-22922" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-22927" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22930" href="../Relations/#plfa_plfa-part1-Relations-17247" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22938" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22939" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-22943" href="../Relations/#plfa_plfa-part1-Relations-22922" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-22946" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-22948" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22976" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22978" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22986" href="../Relations/#plfa_plfa-part1-Relations-22986" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-22991" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22994" href="../Relations/#plfa_plfa-part1-Relations-17304" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-23002" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23003" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23007" href="../Relations/#plfa_plfa-part1-Relations-22986" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-23010" class="Symbol">)</a>
</pre><p>两者的区别在于上述代码在对于第一个参数进行模式匹配之前先对于第二个参数先进行模式匹配。</p><h2 id="单调性">单调性</h2><p>如果在聚会中碰到了一个运算符和一个序，那么有人可能会问这个运算符对于这个序是不是 <strong>单调的（Monotonic）</strong>。比如说，加法对于小于等于是单调的，这意味着：</p><pre><code>∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q</code></pre><p>这个证明可以用我们学会的方法，很直接的来完成。我们最好把它分成三个部分，首先我们证明加法对于 小于等于在右手边是单调的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoʳ-≤"></a><a id="plfa_plfa-part1-Relations-23840" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23850" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23852" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-23854" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23855" href="../Relations/#plfa_plfa-part1-Relations-23855" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23857" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23859" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23861" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23863" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-23864" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-23868" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23870" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23872" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23874" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-23880" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-23896" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23898" href="../Relations/#plfa_plfa-part1-Relations-23855" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23900" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23902" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23904" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23906" href="../Relations/#plfa_plfa-part1-Relations-23855" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23908" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23910" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-23912" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23922" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-23930" href="../Relations/#plfa_plfa-part1-Relations-23930" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23932" href="../Relations/#plfa_plfa-part1-Relations-23932" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23934" href="../Relations/#plfa_plfa-part1-Relations-23934" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23939" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23942" href="../Relations/#plfa_plfa-part1-Relations-23934" class="Bound">p≤q</a>
<a id="plfa_plfa-part1-Relations-23946" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23956" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23957" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-23961" href="../Relations/#plfa_plfa-part1-Relations-23961" class="Bound">n</a><a id="plfa_plfa-part1-Relations-23962" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-23964" href="../Relations/#plfa_plfa-part1-Relations-23964" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23966" href="../Relations/#plfa_plfa-part1-Relations-23966" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23968" href="../Relations/#plfa_plfa-part1-Relations-23968" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23973" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23976" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23980" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23981" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23991" href="../Relations/#plfa_plfa-part1-Relations-23961" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23993" href="../Relations/#plfa_plfa-part1-Relations-23964" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23995" href="../Relations/#plfa_plfa-part1-Relations-23966" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23997" href="../Relations/#plfa_plfa-part1-Relations-23968" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-24000" class="Symbol">)</a>
</pre><p>我们对于第一个参数进行归纳。</p><ul><li><p><strong>起始步骤</strong>：第一个参数是 <code>zero</code>，那么 <code>zero + p ≤ zero + q</code> 可以化简为 <code>p ≤ q</code>， 其证明由 <code>p≤q</code> 给出。</p></li><li><p><strong>归纳步骤</strong>：第一个参数是 <code>suc n</code>，那么 <code>suc n + p ≤ suc n + q</code> 可以化简为 <code>suc (n + p) ≤ suc (n + q)</code>。归纳假设 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，我们在此之上使用 <code>s≤s</code> 即可得证。</p></li></ul><p>接下来，我们证明加法对于小于等于在左手边是单调的。我们可以用之前的结论和加法的交换律来证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoˡ-≤"></a><a id="plfa_plfa-part1-Relations-24972" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-24982" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24984" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-24986" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-24987" href="../Relations/#plfa_plfa-part1-Relations-24987" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-24989" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-24991" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-24993" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24995" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-24996" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25000" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25002" href="../Relations/#plfa_plfa-part1-Relations-24987" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25004" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25006" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-25012" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25028" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25030" href="../Relations/#plfa_plfa-part1-Relations-24987" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25032" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25034" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25036" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25038" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25040" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25042" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-25044" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25054" href="../Relations/#plfa_plfa-part1-Relations-25054" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25056" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25058" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25060" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-25065" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Relations-25073" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25080" href="../Relations/#plfa_plfa-part1-Relations-25054" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25082" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25084" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-25086" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25093" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25095" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">p</a>  <a id="plfa_plfa-part1-Relations-25098" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-25100" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25110" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25112" href="../Relations/#plfa_plfa-part1-Relations-25054" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25114" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25116" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">m≤n</a>
</pre><p>用 <code>+-comm m p</code> 和 <code>+-comm n p</code> 来重写，可以让 <code>m + p ≤ n + p</code> 转换成 <code>p + n ≤ p + m</code>， 而我们可以用 <code>+-moroʳ-≤ p m n m≤n</code> 来证明。</p><p>最后，我们把前两步的结论结合起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-mono-≤"></a><a id="plfa_plfa-part1-Relations-25467" href="../Relations/#plfa_plfa-part1-Relations-25467" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25476" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25478" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-25480" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25481" href="../Relations/#plfa_plfa-part1-Relations-25481" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25483" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25485" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25487" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25489" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25491" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-25492" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25496" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25498" href="../Relations/#plfa_plfa-part1-Relations-25481" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25500" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25502" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-25506" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25508" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25510" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25512" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-25518" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25534" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25536" href="../Relations/#plfa_plfa-part1-Relations-25481" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25538" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25540" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25542" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25544" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25546" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25548" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-25550" href="../Relations/#plfa_plfa-part1-Relations-25467" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25559" href="../Relations/#plfa_plfa-part1-Relations-25559" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25561" href="../Relations/#plfa_plfa-part1-Relations-25561" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25563" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25565" href="../Relations/#plfa_plfa-part1-Relations-25565" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25567" href="../Relations/#plfa_plfa-part1-Relations-25567" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-25571" href="../Relations/#plfa_plfa-part1-Relations-25571" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-25576" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-25579" href="../Relations/#plfa_plfa-part1-Relations-12469" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-25587" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25588" href="../Relations/#plfa_plfa-part1-Relations-24972" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25598" href="../Relations/#plfa_plfa-part1-Relations-25559" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25600" href="../Relations/#plfa_plfa-part1-Relations-25561" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25602" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25604" href="../Relations/#plfa_plfa-part1-Relations-25567" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-25607" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-25609" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25610" href="../Relations/#plfa_plfa-part1-Relations-23840" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25620" href="../Relations/#plfa_plfa-part1-Relations-25561" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25622" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25624" href="../Relations/#plfa_plfa-part1-Relations-25565" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25626" href="../Relations/#plfa_plfa-part1-Relations-25571" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-25629" class="Symbol">)</a>
</pre><p>使用 <code>+-monoˡ-≤ m n p m≤n</code> 可以证明 <code>m + p ≤ n + p</code>， 使用 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，用传递性把两者连接起来， 我们可以获得 <code>m + p ≤ n + q</code> 的证明，如上所示。</p><h4 id="练习--mono--延伸">练习 <code>*-mono-≤</code> （延伸）</h4><p>证明乘法对于小于等于是单调的。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26153" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="strict-inequality">严格不等关系</h2><p>我们可以用类似于定义不等关系的方法来定义严格不等关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26360" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-26366" class="Number">4</a> <a id="plfa_plfa-part1-Relations-26368" href="../Relations/#plfa_plfa-part1-Relations-26378" class="Datatype Operator">_&lt;_</a>

<a id="plfa_plfa-part1-Relations-26373" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_&lt;_"></a><a id="plfa_plfa-part1-Relations-26378" href="../Relations/#plfa_plfa-part1-Relations-26378" class="Datatype Operator">_&lt;_</a> <a id="plfa_plfa-part1-Relations-26382" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26384" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26386" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26388" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26390" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26392" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-26396" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.z&lt;s"></a><a id="plfa_plfa-part1-Relations-26405" href="../Relations/#plfa_plfa-part1-Relations-26405" class="InductiveConstructor">z&lt;s</a> <a id="plfa_plfa-part1-Relations-26409" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26411" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26413" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26414" href="../Relations/#plfa_plfa-part1-Relations-26414" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26416" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26418" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26419" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-26427" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-26444" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26446" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-26451" href="../Relations/#plfa_plfa-part1-Relations-26378" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26453" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26457" href="../Relations/#plfa_plfa-part1-Relations-26414" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.s&lt;s"></a><a id="plfa_plfa-part1-Relations-26462" href="../Relations/#plfa_plfa-part1-Relations-26462" class="InductiveConstructor">s&lt;s</a> <a id="plfa_plfa-part1-Relations-26466" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26468" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26470" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26471" href="../Relations/#plfa_plfa-part1-Relations-26471" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26473" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26475" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26478" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-26484" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26486" href="../Relations/#plfa_plfa-part1-Relations-26471" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26488" href="../Relations/#plfa_plfa-part1-Relations-26378" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26490" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-26498" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-26516" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26518" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26522" href="../Relations/#plfa_plfa-part1-Relations-26471" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26524" href="../Relations/#plfa_plfa-part1-Relations-26378" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26526" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26530" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">n</a>
</pre><p>严格不等关系与不等关系最重要的区别在于，0 小于任何数的后继，而不小于 0。</p><p>显然，严格不等关系不是自反的，而是<strong>非自反的（Irreflexive）</strong>，表示 <code>n &lt; n</code> 对于 任何值 <code>n</code> 都不成立。和不等关系一样，严格不等关系是传递的。严格不等关系不是完全的，但是满足 一个相似的性质：<strong>三分律（Trichotomy）</strong>：对于任意的 <code>m</code> 和 <code>n</code>，<code>m &lt; n</code>、<code>m ≡ n</code> 或者 <code>m &gt; n</code> 三者有且仅有一者成立。（我们定义 <code>m &gt; n</code> 当且仅当 <code>n &lt; m</code> 成立时成立） 严格不等关系对于加法和乘法也是单调的。</p><p>我们把一部分上述性质作为习题。非自反性需要逻辑非，三分律需要证明三者是互斥的，因此这两个性质 暂不做为习题。我们会在 <a href="../Negation/">Negation</a> 章节来重新讨论。</p><p>我们可以直接地来证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。 因此我们亦可从不等关系的性质中，使用此性质来证明严格不等关系的性质。</p><h4 id="less-trans">练习 <code>&lt;-trans</code> （推荐）</h4><p>证明严格不等是传递的。请直接证明。（后续的练习中我们将使用 &lt; 和 ≤ 的关系。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-28350" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="trichotomy">练习 <code>trichotomy</code>（实践）</h4><p>证明严格不等关系满足弱化的三元律，证明对于任意 <code>m</code> 和 <code>n</code>，下列命题有一条成立：</p><ul><li><code>m &lt; n</code>，</li><li><code>m ≡ n</code>，或者</li><li><code>m &gt; n</code>。</li></ul><p>定义 <code>m &gt; n</code> 为 <code>n &lt; m</code>。你需要一个合适的数据类型声明，如同我们在证明完全性中使用的那样。 （我们会在介绍完<a href="../Negation/">否定</a>之后证明三者是互斥的。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29074" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="plus-mono-less">练习 <code>+-mono-&lt;</code>（实践）</h4><p>证明加法对于严格不等关系是单调的。正如不等关系中那样，你可以需要额外的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29390" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="leq-iff-less">练习 <code>≤-iff-&lt;</code> (推荐)</h4><p>证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29623" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="less-trans-revisited">练习 <code>&lt;-trans-revisited</code>（实践）</h4><p>用另外一种方法证明严格不等是传递的，使用之前证明的不等关系和严格不等关系的联系， 以及不等关系的传递性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30019" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="奇和偶">奇和偶</h2><p>作为一个额外的例子，我们来定义奇数和偶数。不等关系和严格不等关系是<strong>二元关系</strong>，而奇偶性 是<strong>一元关系</strong>，有时也被叫做<strong>谓词（Predicate）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30362" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-even"></a><a id="plfa_plfa-part1-Relations-30367" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30372" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30374" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30376" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30378" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Relations-30382" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-odd"></a><a id="plfa_plfa-part1-Relations-30387" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Relations-30392" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30396" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30398" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Relations-30403" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30408" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30413" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-even.zero"></a><a id="plfa_plfa-part1-Relations-30422" href="../Relations/#plfa_plfa-part1-Relations-30422" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-30427" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-30435" class="Comment">---------</a>
      <a id="plfa_plfa-part1-Relations-30451" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30456" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Relations-even.suc"></a><a id="plfa_plfa-part1-Relations-30464" href="../Relations/#plfa_plfa-part1-Relations-30464" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30469" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30471" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30473" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30474" href="../Relations/#plfa_plfa-part1-Relations-30474" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30476" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30478" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30479" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30485" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30487" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30491" href="../Relations/#plfa_plfa-part1-Relations-30474" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30499" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-30516" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30518" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30523" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30528" href="../Relations/#plfa_plfa-part1-Relations-30474" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30529" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-30532" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30537" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30541" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-odd.suc"></a><a id="plfa_plfa-part1-Relations-30550" href="../Relations/#plfa_plfa-part1-Relations-30550" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30555" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30557" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30559" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30560" href="../Relations/#plfa_plfa-part1-Relations-30560" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30562" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30564" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30565" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30571" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30573" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30578" href="../Relations/#plfa_plfa-part1-Relations-30560" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30586" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Relations-30602" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30604" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30608" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30609" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30613" href="../Relations/#plfa_plfa-part1-Relations-30560" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30614" class="Symbol">)</a>
</pre><p>一个数是偶数，如果它是 0，或者是奇数的后继。一个数是奇数，如果它是偶数的后继。</p><p>这是我们第一次定义一个相互递归的数据类型。因为每个标识符必须在使用前声明，所以 我们首先声明索引数据类型 <code>even</code> 和 <code>odd</code> （省略 <code>where</code> 关键字和其构造子的定义）， 然后声明其构造子（省略其签名 <code>ℕ → Set</code>，因为在之前已经给出）。</p><p>这也是我们第一次使用<strong>重载（Overloaded）</strong>的构造子。这意味着不同类型的构造子 拥有相同的名字。在这里 <code>suc</code> 表示下面三种构造子其中之一：</p><pre><code>suc : ℕ → ℕ

suc : ∀ {n : ℕ}
  → odd n
    ------------
  → even (suc n)

suc : ∀ {n : ℕ}
  → even n
    -----------
  → odd (suc n)</code></pre><p>同理，<code>zero</code> 表示两种构造子的一种。因为类型推导的限制，Agda 不允许重载已定义的名字， 但是允许重载构造子。我们推荐将重载限制在有关联的定义中，如我们所做的这样，但这不是必须的。</p><p>我们证明两个偶数之和是偶数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-e+e≡e"></a><a id="plfa_plfa-part1-Relations-32191" href="../Relations/#plfa_plfa-part1-Relations-32191" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32197" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32199" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32201" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32202" href="../Relations/#plfa_plfa-part1-Relations-32202" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32204" href="../Relations/#plfa_plfa-part1-Relations-32204" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32206" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32208" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32209" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32213" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32215" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32220" href="../Relations/#plfa_plfa-part1-Relations-32202" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32224" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32226" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32231" href="../Relations/#plfa_plfa-part1-Relations-32204" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32237" class="Comment">------------</a>
  <a id="plfa_plfa-part1-Relations-32252" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32254" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32259" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32260" href="../Relations/#plfa_plfa-part1-Relations-32202" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32262" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32264" href="../Relations/#plfa_plfa-part1-Relations-32204" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32265" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-o+e≡o"></a><a id="plfa_plfa-part1-Relations-32268" href="../Relations/#plfa_plfa-part1-Relations-32268" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32274" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32276" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32278" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32279" href="../Relations/#plfa_plfa-part1-Relations-32279" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32281" href="../Relations/#plfa_plfa-part1-Relations-32281" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32283" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32285" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32286" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32290" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32292" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32296" href="../Relations/#plfa_plfa-part1-Relations-32279" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32300" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32302" href="../Relations/#plfa_plfa-part1-Relations-30367" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32307" href="../Relations/#plfa_plfa-part1-Relations-32281" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32313" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Relations-32327" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32329" href="../Relations/#plfa_plfa-part1-Relations-30387" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32333" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32334" href="../Relations/#plfa_plfa-part1-Relations-32279" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32336" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32338" href="../Relations/#plfa_plfa-part1-Relations-32281" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32339" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32342" href="../Relations/#plfa_plfa-part1-Relations-32191" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32348" href="../Relations/#plfa_plfa-part1-Relations-30422" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-32357" href="../Relations/#plfa_plfa-part1-Relations-32357" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32361" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32364" href="../Relations/#plfa_plfa-part1-Relations-32357" class="Bound">en</a>
<a id="plfa_plfa-part1-Relations-32367" href="../Relations/#plfa_plfa-part1-Relations-32191" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32373" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32374" href="../Relations/#plfa_plfa-part1-Relations-30464" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32378" href="../Relations/#plfa_plfa-part1-Relations-32378" class="Bound">om</a><a id="plfa_plfa-part1-Relations-32380" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32382" href="../Relations/#plfa_plfa-part1-Relations-32382" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32386" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32389" href="../Relations/#plfa_plfa-part1-Relations-30464" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32393" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32394" href="../Relations/#plfa_plfa-part1-Relations-32268" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32400" href="../Relations/#plfa_plfa-part1-Relations-32378" class="Bound">om</a> <a id="plfa_plfa-part1-Relations-32403" href="../Relations/#plfa_plfa-part1-Relations-32382" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32405" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32408" href="../Relations/#plfa_plfa-part1-Relations-32268" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32414" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32415" href="../Relations/#plfa_plfa-part1-Relations-30550" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32419" href="../Relations/#plfa_plfa-part1-Relations-32419" class="Bound">em</a><a id="plfa_plfa-part1-Relations-32421" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32423" href="../Relations/#plfa_plfa-part1-Relations-32423" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32427" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32430" href="../Relations/#plfa_plfa-part1-Relations-30550" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32434" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32435" href="../Relations/#plfa_plfa-part1-Relations-32191" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32441" href="../Relations/#plfa_plfa-part1-Relations-32419" class="Bound">em</a> <a id="plfa_plfa-part1-Relations-32444" href="../Relations/#plfa_plfa-part1-Relations-32423" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32446" class="Symbol">)</a>
</pre><p>与相互递归的定义对应，我们用两个相互递归的函数，一个证明两个偶数之和是偶数，另一个证明 一个奇数与一个偶数之和是奇数。</p><p>这是我们第一次使用相互递归的函数。因为每个标识符必须在使用前声明，我们先给出两个函数的签名， 然后再给出其定义。</p><p>要证明两个偶数之和为偶，我们考虑第一个数为偶数的证明。如果是因为第一个数为 0， 那么第二个数为偶数的证明即为和为偶数的证明。如果是因为第一个数为奇数的后继， 那么和为偶数是因为他是一个奇数和一个偶数的和的后续，而这个和是一个奇数。</p><p>要证明一个奇数和一个偶数的和是奇数，我们考虑第一个数是奇数的证明。 如果是因为它是一个偶数的后继，那么和为奇数，因为它是两个偶数之和的后继， 而这个和是一个偶数。</p><h4 id="odd-plus-odd">练习 <code>o+o≡e</code> (延伸)</h4><p>证明两个奇数之和为偶数。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-34019" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-predicates">练习 <code>Bin-predicates</code> (延伸)</h4><p>回忆我们在练习 <a href="../Naturals/#Bin">Bin</a> 中定义了一个数据类型 <code>Bin</code> 来用二进制字符串表示自然数。 这个表达方法不是唯一的，因为我们在开头加任意个 0。因此，11 可以由以下方法表示：</p><pre><code>⟨⟩ I O I I
⟨⟩ O O I O I I</code></pre><p>定义一个谓词</p><pre><code>Can : Bin → Set</code></pre><p>其在一个二进制字符串的表示是标准的（Canonical）时成立，表示它没有开头的 0。在两个 11 的表达方式中， 第一个是标准的，而第二个不是。在定义这个谓词时，你需要一个辅助谓词：</p><pre><code>One : Bin → Set</code></pre><p>其仅在一个二进制字符串开头为 1 时成立。一个二进制字符串是标准的，如果它开头是 1 （表示一个正数）， 或者它仅是一个 0 （表示 0）。</p><p>证明递增可以保持标准性。</p><pre><code>Can b
------------
Can (inc b)</code></pre><p>证明从自然数转换成的二进制字符串是标准的。</p><pre><code>----------
Can (to n)</code></pre><p>证明将一个标准的二进制字符串转换成自然数之后，再转换回二进制字符串与原二进制字符串相同。</p><pre><code>Can b
---------------
to (from b) ≡ b</code></pre><p>（提示：对于每一条习题，先从 <code>One</code> 的性质开始。此外，你或许还需要证明若 <code>One b</code> 成立，则 <code>1</code> 小于或等于 <code>from b</code> 的结果。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-35947" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中有类似于本章介绍的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-36123" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36130" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-36139" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36145" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36146" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Relations-36149" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36151" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-36154" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36156" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Relations-36159" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-36161" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36168" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-36188" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36194" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36195" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4565" class="Function">≤-refl</a><a id="plfa_plfa-part1-Relations-36201" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36203" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4748" class="Function">≤-trans</a><a id="plfa_plfa-part1-Relations-36210" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36212" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4615" class="Function">≤-antisym</a><a id="plfa_plfa-part1-Relations-36221" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36223" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4860" class="Function">≤-total</a><a id="plfa_plfa-part1-Relations-36230" class="Symbol">;</a>
                                  <a id="plfa_plfa-part1-Relations-36266" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#18026" class="Function">+-monoʳ-≤</a><a id="plfa_plfa-part1-Relations-36275" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36277" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17936" class="Function">+-monoˡ-≤</a><a id="plfa_plfa-part1-Relations-36286" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36288" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17780" class="Function">+-mono-≤</a><a id="plfa_plfa-part1-Relations-36296" class="Symbol">)</a>
</pre><p>在标准库中，<code>≤-total</code> 是使用析取定义的（我们将在 <a href="../Connectives/">Connectives</a> 章节定义）。 <code>+-monoʳ-≤</code>、<code>+-monoˡ-≤</code> 和 <code>+-mono-≤</code> 的证明方法和本书不同。 更多的参数是隐式申明的。</p><h2 id="unicode">Unicode</h2><p>本章使用了如下 Unicode 符号：</p><pre><code>≤  U+2264  小于等于 (\&lt;=, \le)
≥  U+2265  大于等于 (\&gt;=, \ge)
ˡ  U+02E1  小写字母 L 标识符 (\^l)
ʳ  U+02B3  小写字母 R 标识符 (\^r)</code></pre><p><code>\^l</code> 和 <code>\^r</code> 命令给出了左右箭头，以及上标字母 <code>l</code> 和 <code>r</code>。</p></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>