<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-ZX/aBpdCBW4Eu5Bjc7USrGeiSiN2UpIuetQ1YMRtplE4MkM78yNQ+KiJYTWqFueppZ1C//BgkiOd+Vvx//iabw==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-w0U8MAmTKZwYGKoZzBaimTEtI6cRyPxTv78JtkqDmvfjljTGU55Nppb++dx5aDvdhoY6R1UMRQzTOYg0Z9DOoQ==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Relations</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon" aria-hidden="true"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book" aria-hidden="true"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Relations: 关系的归纳定义</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Relations-121" class="Keyword">module</a> <a id="plfa_plfa-part1-Relations-128" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Relations-149" class="Keyword">where</a>
</pre><p>在定义了加法和乘法等运算以后，下一步我们来定义<strong>关系（Relation）</strong>，比如说<strong>小于等于</strong>。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Relations-398" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-405" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Relations-443" class="Symbol">as</a> <a id="plfa_plfa-part1-Relations-446" class="Module">Eq</a>
<a id="plfa_plfa-part1-Relations-449" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-454" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Relations-457" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-463" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-464" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Relations-467" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-469" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Relations-473" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Relations-479" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-481" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-486" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-493" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-502" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-508" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-509" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-516" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-518" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Relations-521" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Relations-526" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-528" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-533" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-540" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-560" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-566" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-567" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Relations-573" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-575" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Relations-586" class="Symbol">)</a>
</pre><h2 id="定义关系">定义关系</h2><p>小于等于这个关系有无穷个实例，如下所示：</p><pre><code>0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...</code></pre><p>但是，我们仍然可以用几行有限的定义来表示所有的实例，如下文所示的一对推理规则：</p><pre><code>z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n</code></pre><p>以及其 Agda 定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-1375" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_≤_"></a><a id="plfa_plfa-part1-Relations-1380" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Relations-1384" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1386" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1388" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1392" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-1398" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_≤_.z≤n"></a><a id="plfa_plfa-part1-Relations-1407" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-1411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1413" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1415" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1416" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1418" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1420" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1421" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-1429" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Relations-1442" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-1449" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1451" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_≤_.s≤s"></a><a id="plfa_plfa-part1-Relations-1456" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-1460" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1462" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1464" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1465" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1467" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1469" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1471" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1472" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-1478" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1480" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1482" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1484" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-1492" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-1510" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1516" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1518" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1520" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1524" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
</pre><p>在这里，<code>z≤n</code> 和 <code>s≤s</code>（无空格）是构造子的名称，<code>zero ≤ n</code>、<code>m ≤ n</code> 和 <code>suc m ≤ suc n</code> （带空格）是类型。在这里我们第一次用到了 <strong>索引数据类型（Indexed datatype）</strong>。我们使用 <code>m</code> 和 <code>n</code> 这两个自然数来索引 <code>m ≤ n</code> 这个类型。在 Agda 里，由两个及以上短横线开始的行是注释行， 我们巧妙利用这一语法特性，用上述形式来表示相应的推理规则。 在后文中，我们还会继续使用这一形式。</p><p>这两条定义告诉我们相同的两件事：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，命题 <code>zero ≤ n</code> 成立。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果命题 <code>m ≤ n</code> 成立， 那么命题 <code>suc m ≤ suc n</code> 成立。</li></ul><p>实际上，他们分别给我们更多的信息：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，构造子 <code>z≤n</code> 提供了 <code>zero ≤ n</code> 成立的证明。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，构造子 <code>s≤s</code> 将 <code>m ≤ n</code> 成立的证明 转化为 <code>suc m ≤ suc n</code> 成立的证明。</li></ul><p>例如，我们在这里以推理规则的形式写出 <code>2 ≤ 4</code> 的证明：</p><pre><code>  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4</code></pre><p>下面是对应的 Agda 证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-3418" href="../Relations/#plfa_plfa-part1-Relations-3418" class="Function">_</a> <a id="plfa_plfa-part1-Relations-3420" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-3422" class="Number">2</a> <a id="plfa_plfa-part1-Relations-3424" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-3426" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-3428" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-3430" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-3432" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3436" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-3437" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3441" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-3444" class="Symbol">)</a>
</pre><h2 id="隐式参数">隐式参数</h2><p>这是我们第一次使用隐式参数。定义不等式时，构造子的定义中使用了 <code>∀</code>， 就像我们在下面的命题中使用 <code>∀</code> 一样：</p><pre><code>+-comm : ∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>但是我们这里的定义使用了花括号 <code>{ }</code>，而不是小括号 <code>( )</code>。 这意味着参数是<strong>隐式的（Implicit）</strong>，不需要额外声明。实际上，Agda 的类型检查器 会<strong>推导（Infer）</strong>出它们。因此，我们在 <code>m + n ≡ n + m</code> 的证明中需要写出 <code>+-comm m n</code>， 在 <code>zero ≤ n</code> 的证明中可以省略 <code>n</code>。同理，如果 <code>m≤n</code> 是 <code>m ≤ n</code>的证明， 那么我们写出 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 的证明，无需声明 <code>m</code> 和 <code>n</code>。</p><p>如果有希望的话，我们也可以在大括号里显式声明隐式参数。例如，下面是 <code>2 ≤ 4</code> 的 Agda 证明，包括了显式声明了的隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4856" href="../Relations/#plfa_plfa-part1-Relations-4856" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4858" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4860" class="Number">2</a> <a id="plfa_plfa-part1-Relations-4862" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-4864" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-4866" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-4868" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-4870" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4874" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4875" class="Number">1</a><a id="plfa_plfa-part1-Relations-4876" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4878" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4879" class="Number">3</a><a id="plfa_plfa-part1-Relations-4880" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4882" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4883" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4887" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4888" class="Number">0</a><a id="plfa_plfa-part1-Relations-4889" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4891" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4892" class="Number">2</a><a id="plfa_plfa-part1-Relations-4893" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4895" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4896" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-4900" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4901" class="Number">2</a><a id="plfa_plfa-part1-Relations-4902" class="Symbol">}))</a>
</pre><p>也可以额外加上参数的名字：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4994" href="../Relations/#plfa_plfa-part1-Relations-4994" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4996" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4998" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5000" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5002" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5004" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5006" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5008" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5012" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5013" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5015" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5017" class="Number">1</a><a id="plfa_plfa-part1-Relations-5018" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5020" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5021" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5023" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5025" class="Number">3</a><a id="plfa_plfa-part1-Relations-5026" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5028" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5029" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5033" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5034" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5036" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5038" class="Number">0</a><a id="plfa_plfa-part1-Relations-5039" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5041" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5042" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5044" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5046" class="Number">2</a><a id="plfa_plfa-part1-Relations-5047" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5049" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5050" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-5054" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5055" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5057" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5059" class="Number">2</a><a id="plfa_plfa-part1-Relations-5060" class="Symbol">}))</a>
</pre><p>在后者的形式中，也可以选择只声明一部分隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-5190" href="../Relations/#plfa_plfa-part1-Relations-5190" class="Function">_</a> <a id="plfa_plfa-part1-Relations-5192" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5194" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5196" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5198" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5200" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5202" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5204" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5208" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5209" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5211" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5213" class="Number">3</a><a id="plfa_plfa-part1-Relations-5214" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5216" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5217" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5221" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5222" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5224" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5226" class="Number">2</a><a id="plfa_plfa-part1-Relations-5227" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5229" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-5232" class="Symbol">)</a>
</pre><p>但是不可以改变隐式参数的顺序，即便加上了名字。</p><p>我们可以写出 <code>_</code> 来让 Agda 用相同的推导方式试着推导一个<strong>显式</strong>的项。 例如，我们可以为命题 <code>+-identityʳ</code> 定义一个带有隐式参数的变体：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-identityʳ′"></a><a id="plfa_plfa-part1-Relations-5632" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5645" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5647" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-5649" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5650" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5652" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5654" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-5655" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5657" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-5659" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5661" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-5663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-5668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-5670" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a>
<a id="plfa_plfa-part1-Relations-5672" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5685" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5687" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Relations-5699" class="Symbol">_</a>
</pre><p>我们用 <code>_</code> 来让 Agda 从上下文中推导<strong>显式参数</strong>的值。只有 <code>m</code> 这一个值能够给出正确的证明，因此 Agda 愉快地填入了它。 如果 Agda 推导值失败，那么它会报一个错误。</p><h2 id="优先级">优先级</h2><p>我们如下定义比较的优先级：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-6163" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-6169" class="Number">4</a> <a id="plfa_plfa-part1-Relations-6171" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a>
</pre><p>我们将 <code>_≤_</code> 的优先级设置为 4，所以它不如优先级为 6 的 <code>_+_</code> 结合得紧，因而， <code>1 + 2 ≤ 3</code> 将被解析为 <code>(1 + 2) ≤ 3</code>。我们用 <code>infix</code> 来表示运算符既不是左结合的， 也不是右结合的。因为 <code>1 ≤ 2 ≤ 3</code> 解析为 <code>(1 ≤ 2) ≤ 3</code> 或者 <code>1 ≤ (2 ≤ 3)</code> 都没有意义。</p><h2 id="可决定性">可决定性</h2><p>给定两个数，我们可以很直接地决定第一个数是不是小于等于第二个数。我们在此处不给出说明的代码， 但我们会在 <a href="../Decidable/">Decidable</a> 章节重新讨论这个问题。</p><h2 id="反演">反演</h2><p>在我们的定义中，我们从更小的东西得到更大的东西。例如，我们可以从 <code>m ≤ n</code> 得出 <code>suc m ≤ suc n</code> 的结论，这里的 <code>suc m</code> 比 <code>m</code> 更大 （也就是说，前者包含后者），<code>suc n</code> 也比 <code>n</code> 更大。但有时我们也 需要从更大的东西得到更小的东西。</p><p>只有一种方式能够证明对于任意 <code>m</code> 和 <code>n</code> 有 <code>suc m ≤ suc n</code>。 这让我们能够反演（invert）之前的规则。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-s≤s"></a><a id="plfa_plfa-part1-Relations-7722" href="../Relations/#plfa_plfa-part1-Relations-7722" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7730" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7732" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-7734" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-7735" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7737" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-7739" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7741" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-7742" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-7746" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7748" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7752" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7754" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7760" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-7766" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-7782" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7784" href="../Relations/#plfa_plfa-part1-Relations-7735" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7786" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7788" href="../Relations/#plfa_plfa-part1-Relations-7737" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-7790" href="../Relations/#plfa_plfa-part1-Relations-7722" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7798" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-7799" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-7803" href="../Relations/#plfa_plfa-part1-Relations-7803" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-7806" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-7808" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-7810" href="../Relations/#plfa_plfa-part1-Relations-7803" class="Bound">m≤n</a>
</pre><p>这里的 <code>m≤n</code>（不带空格）是一个变量名，而 <code>m ≤ n</code>（带空格）是一个类型， 且后者是前者的类型。在 Agda 中，将类型中的空格去掉来作为变量名是一种常见的约定。</p><p>并不是所有规则都可以反演。实际上，<code>z≤n</code> 的规则没有非隐式的假设， 因此它没有可以被反演的规则。但这种反演通常是成立的。</p><p>反演的另一个例子是证明只存在一种情况使得一个数字能够小于或等于零。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-z≤n"></a><a id="plfa_plfa-part1-Relations-8538" href="../Relations/#plfa_plfa-part1-Relations-8538" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8546" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8548" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-8550" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-8551" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8553" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8555" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-8556" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-8560" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8562" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8564" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-8566" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
    <a id="plfa_plfa-part1-Relations-8575" class="Comment">--------</a>
  <a id="plfa_plfa-part1-Relations-8586" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8588" href="../Relations/#plfa_plfa-part1-Relations-8551" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-8592" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Relations-8597" href="../Relations/#plfa_plfa-part1-Relations-8538" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8605" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-8609" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-8611" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><h2 id="序关系的性质">序关系的性质</h2><p>数学家对于关系的常见性质给出了约定的名称。</p><ul><li><strong>自反（Reflexive）</strong>：对于所有的 <code>n</code>，关系 <code>n ≤ n</code> 成立。</li><li><strong>传递（Transitive）</strong>：对于所有的 <code>m</code>、 <code>n</code> 和 <code>p</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 也成立。</li><li><strong>反对称（Anti-symmetric）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立。</li><li><strong>完全（Total）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。</li></ul><p><code>_≤_</code> 关系满足上述四条性质。</p><p>对于上述性质的组合也有约定的名称。</p><ul><li><strong>预序（Preorder）</strong>：满足自反和传递的关系。</li><li><strong>偏序（Partial Order）</strong>：满足反对称的预序。</li><li><strong>全序（Total Order）</strong>：满足完全的偏序。</li></ul><p>如果你在派对上偶遇一个『关系』，你现在知道怎么样和人讨论了， 可以讨论关于自反、传递、反对称和完全， 或者问一问这是不是预序、偏序或者全序。</p><p>更认真的来说，如果你在阅读论文时碰到了一个关系，本文的介绍让你可以对关系有基本的了解和判断， 来判断这个关系是不是预序、偏序或者全序。一个认真的作者一般会在文章指出这个关系具有（或者缺少） 上述性质，比如说指出新定义的关系是一个偏序而不是全序。</p><h4 id="orderings">练习 <code>orderings</code>（实践）</h4><p>给出一个不是偏序的预序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10876" class="Comment">-- 请将代码写在此处。</a>
</pre><p>给出一个不是全序的偏序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10993" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="自反性">自反性</h2><p>我们第一个来证明的性质是自反性：对于任意自然数 <code>n</code>，关系 <code>n ≤ n</code> 成立。我们使用标准库 的惯例来隐式申明参数，在使用自反性的证明时这样可以更加方便。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-refl"></a><a id="plfa_plfa-part1-Relations-11397" href="../Relations/#plfa_plfa-part1-Relations-11397" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11404" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11406" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-11408" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11409" href="../Relations/#plfa_plfa-part1-Relations-11409" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-11414" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-11420" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-11428" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-11430" href="../Relations/#plfa_plfa-part1-Relations-11409" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11432" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-11434" href="../Relations/#plfa_plfa-part1-Relations-11409" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-11436" href="../Relations/#plfa_plfa-part1-Relations-11397" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11443" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-11448" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11450" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11452" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-11456" href="../Relations/#plfa_plfa-part1-Relations-11397" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11463" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11464" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-11468" href="../Relations/#plfa_plfa-part1-Relations-11468" class="Bound">n</a><a id="plfa_plfa-part1-Relations-11469" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11471" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11473" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-11477" href="../Relations/#plfa_plfa-part1-Relations-11397" class="Function">≤-refl</a>
</pre><p>这个证明直接在 <code>n</code> 上进行归纳。在起始步骤中，<code>zero ≤ zero</code> 由 <code>z≤n</code> 证明；在归纳步骤中， 归纳假设 <code>≤-refl {n}</code> 给我们带来了 <code>n ≤ n</code> 的证明，我们只需要使用 <code>s≤s</code>，就可以获得 <code>suc n ≤ suc n</code> 的证明。</p><p>在 Emacs 中来交互式地证明自反性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="传递性">传递性</h2><p>我们第二个证明的性质是传递性：对于任意自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 成立。同样，<code>m</code>、<code>n</code> 和 <code>p</code> 是隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans"></a><a id="plfa_plfa-part1-Relations-12472" href="../Relations/#plfa_plfa-part1-Relations-12472" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12480" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12482" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-12484" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-12485" href="../Relations/#plfa_plfa-part1-Relations-12485" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12487" href="../Relations/#plfa_plfa-part1-Relations-12487" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12489" href="../Relations/#plfa_plfa-part1-Relations-12489" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-12491" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-12494" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-12498" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12500" href="../Relations/#plfa_plfa-part1-Relations-12485" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12502" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12504" href="../Relations/#plfa_plfa-part1-Relations-12487" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-12508" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12510" href="../Relations/#plfa_plfa-part1-Relations-12487" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12512" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12514" href="../Relations/#plfa_plfa-part1-Relations-12489" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-12520" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-12528" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12530" href="../Relations/#plfa_plfa-part1-Relations-12485" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12532" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12534" href="../Relations/#plfa_plfa-part1-Relations-12489" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-12536" href="../Relations/#plfa_plfa-part1-Relations-12472" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12544" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-12554" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-12565" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12568" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-12572" href="../Relations/#plfa_plfa-part1-Relations-12472" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12580" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12581" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12585" href="../Relations/#plfa_plfa-part1-Relations-12585" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-12588" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-12590" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12591" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12595" href="../Relations/#plfa_plfa-part1-Relations-12595" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12598" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-12601" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12604" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12608" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12609" href="../Relations/#plfa_plfa-part1-Relations-12472" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12617" href="../Relations/#plfa_plfa-part1-Relations-12585" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-12621" href="../Relations/#plfa_plfa-part1-Relations-12595" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12624" class="Symbol">)</a>
</pre><p>这里我们在 <code>m ≤ n</code> 的<strong>证据（Evidence）</strong>上进行归纳。在起始步骤里，第一个不等式因为 <code>z≤n</code> 而成立， 那么结论亦可由 <code>z≤n</code> 而得出。在这里，<code>n ≤ p</code> 的证明是不需要的，我们用 <code>_</code> 来表示这个 证明没有被使用。</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个不等式因为 <code>s≤s n≤p</code> 而成立， 所以我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc p</code>，求证 <code>suc m ≤ suc p</code>。 通过归纳假设 <code>≤-trans m≤n n≤p</code>，我们得知 <code>m ≤ p</code>，在此之上使用 <code>s≤s</code> 即可证。</p><p><code>≤-trans (s≤s m≤n) z≤n</code> 不可能发生，因为第一个不等式告诉我们中间的数是一个 <code>suc n</code>， 而第二个不等式告诉我们中间的数是 <code>zero</code>。Agda 可以推断这样的情况不可能发现，所以我们不需要 （也不可以）列出这种情况。</p><p>我们也可以将隐式参数显式地声明。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans′"></a><a id="plfa_plfa-part1-Relations-14070" href="../Relations/#plfa_plfa-part1-Relations-14070" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14079" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14081" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-14083" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14084" href="../Relations/#plfa_plfa-part1-Relations-14084" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14086" href="../Relations/#plfa_plfa-part1-Relations-14086" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14088" href="../Relations/#plfa_plfa-part1-Relations-14088" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14090" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14092" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-14093" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-14097" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14099" href="../Relations/#plfa_plfa-part1-Relations-14084" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14101" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14103" href="../Relations/#plfa_plfa-part1-Relations-14086" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-14107" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14109" href="../Relations/#plfa_plfa-part1-Relations-14086" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14111" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14113" href="../Relations/#plfa_plfa-part1-Relations-14088" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-14119" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-14127" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14129" href="../Relations/#plfa_plfa-part1-Relations-14084" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14131" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14133" href="../Relations/#plfa_plfa-part1-Relations-14088" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-14135" href="../Relations/#plfa_plfa-part1-Relations-14070" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14144" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-14152" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14160" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14168" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-14178" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-14189" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14192" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-14196" href="../Relations/#plfa_plfa-part1-Relations-14070" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14205" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14206" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14210" href="../Relations/#plfa_plfa-part1-Relations-14210" class="Bound">m</a><a id="plfa_plfa-part1-Relations-14211" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14213" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14214" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14218" href="../Relations/#plfa_plfa-part1-Relations-14218" class="Bound">n</a><a id="plfa_plfa-part1-Relations-14219" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14221" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14222" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14226" href="../Relations/#plfa_plfa-part1-Relations-14226" class="Bound">p</a><a id="plfa_plfa-part1-Relations-14227" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14229" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14230" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14234" href="../Relations/#plfa_plfa-part1-Relations-14234" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-14237" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14239" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14240" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14244" href="../Relations/#plfa_plfa-part1-Relations-14244" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14247" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-14250" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14253" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14257" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14258" href="../Relations/#plfa_plfa-part1-Relations-14070" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14267" href="../Relations/#plfa_plfa-part1-Relations-14210" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14269" href="../Relations/#plfa_plfa-part1-Relations-14218" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14271" href="../Relations/#plfa_plfa-part1-Relations-14226" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14273" href="../Relations/#plfa_plfa-part1-Relations-14234" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-14277" href="../Relations/#plfa_plfa-part1-Relations-14244" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14280" class="Symbol">)</a>
</pre><p>有人说这样的证明更加的清晰，也有人说这个更长的证明让人难以抓住证明的重点。 我们一般选择使用简短的证明。</p><p>对于性质成立证明进行的归纳（如上文中对于 <code>m ≤ n</code> 的证明进行归纳），相比于对于性质成立的值进行的归纳 （如对于 <code>m</code> 进行归纳），有非常大的价值。我们会经常使用这样的方法。</p><p>同样，在 Emacs 中来交互式地证明传递性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="反对称性">反对称性</h2><p>我们证明的第三个性质是反对称性：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-antisym"></a><a id="plfa_plfa-part1-Relations-15383" href="../Relations/#plfa_plfa-part1-Relations-15383" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15393" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15395" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-15397" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-15398" href="../Relations/#plfa_plfa-part1-Relations-15398" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15400" href="../Relations/#plfa_plfa-part1-Relations-15400" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15402" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15404" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-15405" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-15409" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15411" href="../Relations/#plfa_plfa-part1-Relations-15398" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15413" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15415" href="../Relations/#plfa_plfa-part1-Relations-15400" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-15419" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15421" href="../Relations/#plfa_plfa-part1-Relations-15400" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15423" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15425" href="../Relations/#plfa_plfa-part1-Relations-15398" class="Bound">m</a>
    <a id="plfa_plfa-part1-Relations-15431" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-15439" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15441" href="../Relations/#plfa_plfa-part1-Relations-15398" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15443" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-15445" href="../Relations/#plfa_plfa-part1-Relations-15400" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-15447" href="../Relations/#plfa_plfa-part1-Relations-15383" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15457" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-15467" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Relations-15478" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15481" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Relations-15486" href="../Relations/#plfa_plfa-part1-Relations-15383" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15496" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15497" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15501" href="../Relations/#plfa_plfa-part1-Relations-15501" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-15504" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-15506" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15507" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15511" href="../Relations/#plfa_plfa-part1-Relations-15511" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15514" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-15517" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15520" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Relations-15525" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-15529" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15530" href="../Relations/#plfa_plfa-part1-Relations-15383" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15540" href="../Relations/#plfa_plfa-part1-Relations-15501" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-15544" href="../Relations/#plfa_plfa-part1-Relations-15511" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15547" class="Symbol">)</a>
</pre><p>同样，我们对于 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明进行归纳。</p><p>在起始步骤中，两个不等式都因为 <code>z≤n</code> 而成立。因此我们已知 <code>zero ≤ zero</code> 和 <code>zero ≤ zero</code>， 求证 <code>zero ≡ zero</code>，由自反性可证。（注：由等式的自反性可证，而不是不等式的自反性）</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个等式因为 <code>s≤s n≤m</code> 而成立。因此我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc m</code>，求证 <code>suc m ≡ suc n</code>。归纳假设 <code>≤-antisym m≤n n≤m</code> 可以证明 <code>m ≡ n</code>，因此我们可以使用同余性完成证明。</p><h4 id="leq-antisym-cases">练习 <code>≤-antisym-cases</code>（实践）</h4><p>上面的证明中省略了一个参数是 <code>z≤n</code>，另一个参数是 <code>s≤s</code> 的情况。为什么可以省略这种情况？</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-16828" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="完全性">完全性</h2><p>我们证明的第四个性质是完全性：对于任何自然数 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。 在 <code>m</code> 和 <code>n</code> 相等时，两者同时成立。</p><p>我们首先来说明怎么样不等式才是完全的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-17214" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total"></a><a id="plfa_plfa-part1-Relations-17219" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17225" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-17226" href="../Relations/#plfa_plfa-part1-Relations-17226" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17228" href="../Relations/#plfa_plfa-part1-Relations-17228" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17230" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17232" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-17233" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-17235" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-17241" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total.forward"></a><a id="plfa_plfa-part1-Relations-17250" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-17258" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17266" href="../Relations/#plfa_plfa-part1-Relations-17226" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17268" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17270" href="../Relations/#plfa_plfa-part1-Relations-17228" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-17278" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17292" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17294" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17300" href="../Relations/#plfa_plfa-part1-Relations-17226" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17302" href="../Relations/#plfa_plfa-part1-Relations-17228" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total.flipped"></a><a id="plfa_plfa-part1-Relations-17307" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-17315" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17323" href="../Relations/#plfa_plfa-part1-Relations-17228" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17325" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17327" href="../Relations/#plfa_plfa-part1-Relations-17226" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-17335" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17349" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17351" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17357" href="../Relations/#plfa_plfa-part1-Relations-17226" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17359" href="../Relations/#plfa_plfa-part1-Relations-17228" class="Bound">n</a>
</pre><p><code>Total m n</code> 成立的证明有两种形式：<code>forward m≤n</code> 或者 <code>flipped n≤m</code>，其中 <code>m≤n</code> 和 <code>n≤m</code> 分别是 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明。</p><p>（如果你对于逻辑学有所了解，上面的定义可以由析取（Disjunction）表示。 我们会在 <a href="../Connectives/">Connectives</a> 章节介绍析取。）</p><p>这是我们第一次使用带<em>参数</em>的数据类型，这里 <code>m</code> 和 <code>n</code> 是参数。这等同于下面的索引数据类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-18100" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total′"></a><a id="plfa_plfa-part1-Relations-18105" href="../Relations/#plfa_plfa-part1-Relations-18105" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18112" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18114" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18116" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18118" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18120" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18122" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-18126" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total′.forward′"></a><a id="plfa_plfa-part1-Relations-18135" href="../Relations/#plfa_plfa-part1-Relations-18135" class="InductiveConstructor">forward′</a> <a id="plfa_plfa-part1-Relations-18144" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18146" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18148" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18149" href="../Relations/#plfa_plfa-part1-Relations-18149" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18151" href="../Relations/#plfa_plfa-part1-Relations-18151" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18153" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18155" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18156" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18162" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18164" href="../Relations/#plfa_plfa-part1-Relations-18149" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18166" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18168" href="../Relations/#plfa_plfa-part1-Relations-18151" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-18176" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18191" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18193" href="../Relations/#plfa_plfa-part1-Relations-18105" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18200" href="../Relations/#plfa_plfa-part1-Relations-18149" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18202" href="../Relations/#plfa_plfa-part1-Relations-18151" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total′.flipped′"></a><a id="plfa_plfa-part1-Relations-18207" href="../Relations/#plfa_plfa-part1-Relations-18207" class="InductiveConstructor">flipped′</a> <a id="plfa_plfa-part1-Relations-18216" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18218" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18220" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18221" href="../Relations/#plfa_plfa-part1-Relations-18221" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18223" href="../Relations/#plfa_plfa-part1-Relations-18223" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18225" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18227" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18228" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18234" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18236" href="../Relations/#plfa_plfa-part1-Relations-18223" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18238" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18240" href="../Relations/#plfa_plfa-part1-Relations-18221" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-18248" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18263" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18265" href="../Relations/#plfa_plfa-part1-Relations-18105" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18272" href="../Relations/#plfa_plfa-part1-Relations-18221" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18274" href="../Relations/#plfa_plfa-part1-Relations-18223" class="Bound">n</a>
</pre><p>类型里的每个参数都转换成构造子的一个隐式参数。索引数据类型中的索引可以变化，正如在 <code>zero ≤ n</code> 和 <code>suc m ≤ suc n</code> 中那样，而参数化数据类型不一样，其参数必须保持相同， 正如在 <code>Total m n</code> 中那样。参数化的声明更短，更易于阅读，而且有时可以帮助到 Agda 的 停机检查器，所以我们尽可能地使用它们，而不是索引数据类型。</p><p>在上述准备工作完成后，我们定义并证明完全性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total"></a><a id="plfa_plfa-part1-Relations-19022" href="../Relations/#plfa_plfa-part1-Relations-19022" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19030" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19032" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-19034" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19035" href="../Relations/#plfa_plfa-part1-Relations-19035" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19037" href="../Relations/#plfa_plfa-part1-Relations-19037" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-19039" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19041" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-19042" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19044" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-19046" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-19052" href="../Relations/#plfa_plfa-part1-Relations-19035" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19054" href="../Relations/#plfa_plfa-part1-Relations-19037" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19056" href="../Relations/#plfa_plfa-part1-Relations-19022" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19064" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-19072" href="../Relations/#plfa_plfa-part1-Relations-19072" class="Bound">n</a>                         <a id="plfa_plfa-part1-Relations-19098" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19101" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19109" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19113" href="../Relations/#plfa_plfa-part1-Relations-19022" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19121" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19122" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19126" href="../Relations/#plfa_plfa-part1-Relations-19126" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19127" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19129" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-19155" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19158" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19166" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19170" href="../Relations/#plfa_plfa-part1-Relations-19022" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19178" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19183" href="../Relations/#plfa_plfa-part1-Relations-19183" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19184" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19186" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19191" href="../Relations/#plfa_plfa-part1-Relations-19191" class="Bound">n</a><a id="plfa_plfa-part1-Relations-19192" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19194" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-19199" href="../Relations/#plfa_plfa-part1-Relations-19022" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19207" href="../Relations/#plfa_plfa-part1-Relations-19183" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19209" href="../Relations/#plfa_plfa-part1-Relations-19191" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19211" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19238" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19240" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19248" href="../Relations/#plfa_plfa-part1-Relations-19248" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-19253" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19256" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19264" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19265" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19269" href="../Relations/#plfa_plfa-part1-Relations-19248" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-19272" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-19274" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19301" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19303" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19311" href="../Relations/#plfa_plfa-part1-Relations-19311" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-19316" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19319" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19327" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19328" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19332" href="../Relations/#plfa_plfa-part1-Relations-19311" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-19335" class="Symbol">)</a>
</pre><p>这里，我们的证明在两个参数上进行归纳，并按照情况分析：</p><ul><li><p><strong>第一起始步骤</strong>：如果第一个参数是 <code>zero</code>，第二个参数是 <code>n</code>，那么 forward 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ n</code> 的证明。</p></li><li><p><strong>第二起始步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>zero</code>，那么 flipped 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ suc m</code> 的证明。</p></li><li><p><strong>归纳步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>suc n</code>，那么归纳假设 <code>≤-total m n</code> 可以给出如下推断：</p><ul><li><p>归纳假设的 forward 条件成立，以 <code>m≤n</code> 作为 <code>m ≤ n</code> 的证明。以此我们可以使用 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 来证明 forward 条件成立。</p></li><li><p>归纳假设的 flipped 条件成立，以 <code>n≤m</code> 作为 <code>n ≤ m</code> 的证明。以此我们可以使用 <code>s≤s n≤m</code> 作为 <code>suc n ≤ suc m</code> 来证明 flipped 条件成立。</p></li></ul></li></ul><p>这是我们第一次在 Agda 中使用 <code>with</code> 语句。<code>with</code> 关键字后面有一个表达式和一或多行。 每行以省略号（<code>...</code>）和一个竖线（<code>|</code>）开头，后面跟着用来匹配表达式的模式，和等式的右手边。</p><p>使用 <code>with</code> 语句等同于定义一个辅助函数。比如说，上面的定义和下面的等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total′"></a><a id="plfa_plfa-part1-Relations-21512" href="../Relations/#plfa_plfa-part1-Relations-21512" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21521" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21523" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-21525" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21526" href="../Relations/#plfa_plfa-part1-Relations-21526" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21528" href="../Relations/#plfa_plfa-part1-Relations-21528" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21530" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21532" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-21533" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21535" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21537" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21543" href="../Relations/#plfa_plfa-part1-Relations-21526" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21545" href="../Relations/#plfa_plfa-part1-Relations-21528" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-21547" href="../Relations/#plfa_plfa-part1-Relations-21512" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-21564" href="../Relations/#plfa_plfa-part1-Relations-21564" class="Bound">n</a>        <a id="plfa_plfa-part1-Relations-21573" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21576" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21584" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21588" href="../Relations/#plfa_plfa-part1-Relations-21512" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21597" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21598" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21602" href="../Relations/#plfa_plfa-part1-Relations-21602" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21603" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21605" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-21614" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21617" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21625" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21629" href="../Relations/#plfa_plfa-part1-Relations-21512" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21638" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21643" href="../Relations/#plfa_plfa-part1-Relations-21643" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21644" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21646" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21651" href="../Relations/#plfa_plfa-part1-Relations-21651" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21652" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21655" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21658" href="../Relations/#plfa_plfa-part1-Relations-21690" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21665" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21666" href="../Relations/#plfa_plfa-part1-Relations-21512" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21675" href="../Relations/#plfa_plfa-part1-Relations-21643" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21677" href="../Relations/#plfa_plfa-part1-Relations-21651" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21678" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21682" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Relations-21690" href="../Relations/#plfa_plfa-part1-Relations-21690" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21697" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21699" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21705" href="../Relations/#plfa_plfa-part1-Relations-21643" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21707" href="../Relations/#plfa_plfa-part1-Relations-21651" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21709" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21711" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21717" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21718" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21722" href="../Relations/#plfa_plfa-part1-Relations-21643" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21723" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21725" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21730" href="../Relations/#plfa_plfa-part1-Relations-21651" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21731" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21735" href="../Relations/#plfa_plfa-part1-Relations-21690" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21742" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21743" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21751" href="../Relations/#plfa_plfa-part1-Relations-21751" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21754" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21757" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21760" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21768" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21769" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21773" href="../Relations/#plfa_plfa-part1-Relations-21751" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21776" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21780" href="../Relations/#plfa_plfa-part1-Relations-21690" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21787" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21788" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21796" href="../Relations/#plfa_plfa-part1-Relations-21796" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21799" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21802" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21805" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21813" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21814" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21818" href="../Relations/#plfa_plfa-part1-Relations-21796" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21821" class="Symbol">)</a>
</pre><p>这也是我们第一次在 Agda 中使用 <code>where</code> 语句。<code>where</code> 关键字后面有一或多条定义，其必须被缩进。 之前等式左手边的约束变量（此例中的 <code>m</code> 和 <code>n</code>）在嵌套的定义中仍然在作用域内。 在嵌套定义中的约束标识符（此例中的 <code>helper</code> ）在等式的右手边的作用域内。</p><p>如果两个参数相同，那么两个情况同时成立，我们可以返回任一证明。上面的代码中我们返回 forward 条件， 但是我们也可以返回 flipped 条件，如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total″"></a><a id="plfa_plfa-part1-Relations-22693" href="../Relations/#plfa_plfa-part1-Relations-22693" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22702" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22704" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-22706" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22707" href="../Relations/#plfa_plfa-part1-Relations-22707" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22709" href="../Relations/#plfa_plfa-part1-Relations-22709" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-22711" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22713" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-22714" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22716" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-22718" href="../Relations/#plfa_plfa-part1-Relations-17219" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-22724" href="../Relations/#plfa_plfa-part1-Relations-22707" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22726" href="../Relations/#plfa_plfa-part1-Relations-22709" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22728" href="../Relations/#plfa_plfa-part1-Relations-22693" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22737" href="../Relations/#plfa_plfa-part1-Relations-22737" class="Bound">m</a>       <a id="plfa_plfa-part1-Relations-22745" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-22771" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22774" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22782" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22786" href="../Relations/#plfa_plfa-part1-Relations-22693" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22795" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-22803" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22804" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22808" href="../Relations/#plfa_plfa-part1-Relations-22808" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22809" class="Symbol">)</a>                   <a id="plfa_plfa-part1-Relations-22829" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22832" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22840" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22844" href="../Relations/#plfa_plfa-part1-Relations-22693" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22853" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22854" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22858" href="../Relations/#plfa_plfa-part1-Relations-22858" class="Bound">m</a><a id="plfa_plfa-part1-Relations-22859" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22861" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22862" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22866" href="../Relations/#plfa_plfa-part1-Relations-22866" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22867" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22869" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-22874" href="../Relations/#plfa_plfa-part1-Relations-22693" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22883" href="../Relations/#plfa_plfa-part1-Relations-22858" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22885" href="../Relations/#plfa_plfa-part1-Relations-22866" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22887" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22915" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22917" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22925" href="../Relations/#plfa_plfa-part1-Relations-22925" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-22930" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22933" href="../Relations/#plfa_plfa-part1-Relations-17250" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22941" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22942" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-22946" href="../Relations/#plfa_plfa-part1-Relations-22925" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-22949" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-22951" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22979" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22981" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22989" href="../Relations/#plfa_plfa-part1-Relations-22989" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-22994" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22997" href="../Relations/#plfa_plfa-part1-Relations-17307" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-23005" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23006" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23010" href="../Relations/#plfa_plfa-part1-Relations-22989" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-23013" class="Symbol">)</a>
</pre><p>两者的区别在于上述代码在对于第一个参数进行模式匹配之前先对于第二个参数先进行模式匹配。</p><h2 id="单调性">单调性</h2><p>如果在聚会中碰到了一个运算符和一个序，那么有人可能会问这个运算符对于这个序是不是 <strong>单调的（Monotonic）</strong>。比如说，加法对于小于等于是单调的，这意味着：</p><pre><code>∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q</code></pre><p>这个证明可以用我们学会的方法，很直接的来完成。我们最好把它分成三个部分，首先我们证明加法对于 小于等于在右手边是单调的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoʳ-≤"></a><a id="plfa_plfa-part1-Relations-23843" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23853" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23855" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-23857" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23858" href="../Relations/#plfa_plfa-part1-Relations-23858" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23860" href="../Relations/#plfa_plfa-part1-Relations-23860" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23862" href="../Relations/#plfa_plfa-part1-Relations-23862" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23864" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23866" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-23867" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-23871" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23873" href="../Relations/#plfa_plfa-part1-Relations-23860" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23875" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23877" href="../Relations/#plfa_plfa-part1-Relations-23862" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-23883" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-23899" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23901" href="../Relations/#plfa_plfa-part1-Relations-23858" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23903" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23905" href="../Relations/#plfa_plfa-part1-Relations-23860" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23907" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23909" href="../Relations/#plfa_plfa-part1-Relations-23858" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23911" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23913" href="../Relations/#plfa_plfa-part1-Relations-23862" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-23915" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23925" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-23933" href="../Relations/#plfa_plfa-part1-Relations-23933" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23935" href="../Relations/#plfa_plfa-part1-Relations-23935" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23937" href="../Relations/#plfa_plfa-part1-Relations-23937" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23942" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23945" href="../Relations/#plfa_plfa-part1-Relations-23937" class="Bound">p≤q</a>
<a id="plfa_plfa-part1-Relations-23949" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23959" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23960" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-23964" href="../Relations/#plfa_plfa-part1-Relations-23964" class="Bound">n</a><a id="plfa_plfa-part1-Relations-23965" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-23967" href="../Relations/#plfa_plfa-part1-Relations-23967" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23969" href="../Relations/#plfa_plfa-part1-Relations-23969" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23971" href="../Relations/#plfa_plfa-part1-Relations-23971" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23976" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23979" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23983" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23984" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23994" href="../Relations/#plfa_plfa-part1-Relations-23964" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23996" href="../Relations/#plfa_plfa-part1-Relations-23967" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23998" href="../Relations/#plfa_plfa-part1-Relations-23969" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-24000" href="../Relations/#plfa_plfa-part1-Relations-23971" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-24003" class="Symbol">)</a>
</pre><p>我们对于第一个参数进行归纳。</p><ul><li><p><strong>起始步骤</strong>：第一个参数是 <code>zero</code>，那么 <code>zero + p ≤ zero + q</code> 可以化简为 <code>p ≤ q</code>， 其证明由 <code>p≤q</code> 给出。</p></li><li><p><strong>归纳步骤</strong>：第一个参数是 <code>suc n</code>，那么 <code>suc n + p ≤ suc n + q</code> 可以化简为 <code>suc (n + p) ≤ suc (n + q)</code>。归纳假设 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，我们在此之上使用 <code>s≤s</code> 即可得证。</p></li></ul><p>接下来，我们证明加法对于小于等于在左手边是单调的。我们可以用之前的结论和加法的交换律来证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoˡ-≤"></a><a id="plfa_plfa-part1-Relations-24975" href="../Relations/#plfa_plfa-part1-Relations-24975" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-24985" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24987" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-24989" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-24990" href="../Relations/#plfa_plfa-part1-Relations-24990" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-24992" href="../Relations/#plfa_plfa-part1-Relations-24992" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-24994" href="../Relations/#plfa_plfa-part1-Relations-24994" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-24996" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24998" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-24999" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25003" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25005" href="../Relations/#plfa_plfa-part1-Relations-24990" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25007" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25009" href="../Relations/#plfa_plfa-part1-Relations-24992" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-25015" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25031" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25033" href="../Relations/#plfa_plfa-part1-Relations-24990" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25035" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25037" href="../Relations/#plfa_plfa-part1-Relations-24994" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25039" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25041" href="../Relations/#plfa_plfa-part1-Relations-24992" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25043" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25045" href="../Relations/#plfa_plfa-part1-Relations-24994" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-25047" href="../Relations/#plfa_plfa-part1-Relations-24975" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25057" href="../Relations/#plfa_plfa-part1-Relations-25057" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25059" href="../Relations/#plfa_plfa-part1-Relations-25059" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25061" href="../Relations/#plfa_plfa-part1-Relations-25061" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25063" href="../Relations/#plfa_plfa-part1-Relations-25063" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-25068" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Relations-25076" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25083" href="../Relations/#plfa_plfa-part1-Relations-25057" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25085" href="../Relations/#plfa_plfa-part1-Relations-25061" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25087" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-25089" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25096" href="../Relations/#plfa_plfa-part1-Relations-25059" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25098" href="../Relations/#plfa_plfa-part1-Relations-25061" class="Bound">p</a>  <a id="plfa_plfa-part1-Relations-25101" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-25103" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25113" href="../Relations/#plfa_plfa-part1-Relations-25061" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25115" href="../Relations/#plfa_plfa-part1-Relations-25057" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25117" href="../Relations/#plfa_plfa-part1-Relations-25059" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25119" href="../Relations/#plfa_plfa-part1-Relations-25063" class="Bound">m≤n</a>
</pre><p>用 <code>+-comm m p</code> 和 <code>+-comm n p</code> 来重写，可以让 <code>m + p ≤ n + p</code> 转换成 <code>p + n ≤ p + m</code>， 而我们可以用 <code>+-moroʳ-≤ p m n m≤n</code> 来证明。</p><p>最后，我们把前两步的结论结合起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-mono-≤"></a><a id="plfa_plfa-part1-Relations-25470" href="../Relations/#plfa_plfa-part1-Relations-25470" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25479" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25481" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-25483" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25484" href="../Relations/#plfa_plfa-part1-Relations-25484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25486" href="../Relations/#plfa_plfa-part1-Relations-25486" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25488" href="../Relations/#plfa_plfa-part1-Relations-25488" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25490" href="../Relations/#plfa_plfa-part1-Relations-25490" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25492" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25494" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-25495" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25499" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25501" href="../Relations/#plfa_plfa-part1-Relations-25484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25503" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25505" href="../Relations/#plfa_plfa-part1-Relations-25486" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-25509" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25511" href="../Relations/#plfa_plfa-part1-Relations-25488" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25513" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25515" href="../Relations/#plfa_plfa-part1-Relations-25490" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-25521" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25537" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25539" href="../Relations/#plfa_plfa-part1-Relations-25484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25541" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25543" href="../Relations/#plfa_plfa-part1-Relations-25488" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25545" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25547" href="../Relations/#plfa_plfa-part1-Relations-25486" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25549" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25551" href="../Relations/#plfa_plfa-part1-Relations-25490" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-25553" href="../Relations/#plfa_plfa-part1-Relations-25470" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25562" href="../Relations/#plfa_plfa-part1-Relations-25562" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25564" href="../Relations/#plfa_plfa-part1-Relations-25564" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25566" href="../Relations/#plfa_plfa-part1-Relations-25566" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25568" href="../Relations/#plfa_plfa-part1-Relations-25568" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25570" href="../Relations/#plfa_plfa-part1-Relations-25570" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-25574" href="../Relations/#plfa_plfa-part1-Relations-25574" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-25579" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-25582" href="../Relations/#plfa_plfa-part1-Relations-12472" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-25590" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25591" href="../Relations/#plfa_plfa-part1-Relations-24975" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25601" href="../Relations/#plfa_plfa-part1-Relations-25562" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25603" href="../Relations/#plfa_plfa-part1-Relations-25564" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25605" href="../Relations/#plfa_plfa-part1-Relations-25566" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25607" href="../Relations/#plfa_plfa-part1-Relations-25570" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-25610" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-25612" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25613" href="../Relations/#plfa_plfa-part1-Relations-23843" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25623" href="../Relations/#plfa_plfa-part1-Relations-25564" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25625" href="../Relations/#plfa_plfa-part1-Relations-25566" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25627" href="../Relations/#plfa_plfa-part1-Relations-25568" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25629" href="../Relations/#plfa_plfa-part1-Relations-25574" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-25632" class="Symbol">)</a>
</pre><p>使用 <code>+-monoˡ-≤ m n p m≤n</code> 可以证明 <code>m + p ≤ n + p</code>， 使用 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，用传递性把两者连接起来， 我们可以获得 <code>m + p ≤ n + q</code> 的证明，如上所示。</p><h4 id="练习--mono--延伸">练习 <code>*-mono-≤</code> （延伸）</h4><p>证明乘法对于小于等于是单调的。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26156" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="strict-inequality">严格不等关系</h2><p>我们可以用类似于定义不等关系的方法来定义严格不等关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26363" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-26369" class="Number">4</a> <a id="plfa_plfa-part1-Relations-26371" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">_&lt;_</a>

<a id="plfa_plfa-part1-Relations-26376" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_&lt;_"></a><a id="plfa_plfa-part1-Relations-26381" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">_&lt;_</a> <a id="plfa_plfa-part1-Relations-26385" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26387" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26389" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26391" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26393" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26395" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-26399" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.z&lt;s"></a><a id="plfa_plfa-part1-Relations-26408" href="../Relations/#plfa_plfa-part1-Relations-26408" class="InductiveConstructor">z&lt;s</a> <a id="plfa_plfa-part1-Relations-26412" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26414" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26416" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26417" href="../Relations/#plfa_plfa-part1-Relations-26417" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26419" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26421" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26422" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-26430" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-26447" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26449" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-26454" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26456" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26460" href="../Relations/#plfa_plfa-part1-Relations-26417" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.s&lt;s"></a><a id="plfa_plfa-part1-Relations-26465" href="../Relations/#plfa_plfa-part1-Relations-26465" class="InductiveConstructor">s&lt;s</a> <a id="plfa_plfa-part1-Relations-26469" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26471" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26473" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26474" href="../Relations/#plfa_plfa-part1-Relations-26474" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26476" href="../Relations/#plfa_plfa-part1-Relations-26476" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26478" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26480" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26481" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-26487" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26489" href="../Relations/#plfa_plfa-part1-Relations-26474" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26491" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26493" href="../Relations/#plfa_plfa-part1-Relations-26476" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-26501" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-26519" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26521" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26525" href="../Relations/#plfa_plfa-part1-Relations-26474" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26527" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26533" href="../Relations/#plfa_plfa-part1-Relations-26476" class="Bound">n</a>
</pre><p>严格不等关系与不等关系最重要的区别在于，0 小于任何数的后继，而不小于 0。</p><p>显然，严格不等关系不是自反的，而是<strong>非自反的（Irreflexive）</strong>，表示 <code>n &lt; n</code> 对于 任何值 <code>n</code> 都不成立。和不等关系一样，严格不等关系是传递的。严格不等关系不是完全的，但是满足 一个相似的性质：<strong>三分律（Trichotomy）</strong>：对于任意的 <code>m</code> 和 <code>n</code>，<code>m &lt; n</code>、<code>m ≡ n</code> 或者 <code>m &gt; n</code> 三者有且仅有一者成立。（我们定义 <code>m &gt; n</code> 当且仅当 <code>n &lt; m</code> 成立时成立） 严格不等关系对于加法和乘法也是单调的。</p><p>我们把一部分上述性质作为习题。非自反性需要逻辑非，三分律需要证明三者是互斥的，因此这两个性质 暂不做为习题。我们会在 <a href="../Negation/">Negation</a> 章节来重新讨论。</p><p>我们可以直接地来证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。 因此我们亦可从不等关系的性质中，使用此性质来证明严格不等关系的性质。</p><h4 id="less-trans">练习 <code>&lt;-trans</code> （推荐）</h4><p>证明严格不等是传递的。请直接证明。（后续的练习中我们将使用 &lt; 和 ≤ 的关系。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-28353" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="trichotomy">练习 <code>trichotomy</code>（实践）</h4><p>证明严格不等关系满足弱化的三元律，证明对于任意 <code>m</code> 和 <code>n</code>，下列命题有一条成立：</p><ul><li><code>m &lt; n</code>，</li><li><code>m ≡ n</code>，或者</li><li><code>m &gt; n</code>。</li></ul><p>定义 <code>m &gt; n</code> 为 <code>n &lt; m</code>。你需要一个合适的数据类型声明，如同我们在证明完全性中使用的那样。 （我们会在介绍完<a href="../Negation/">否定</a>之后证明三者是互斥的。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29077" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="plus-mono-less">练习 <code>+-mono-&lt;</code>（实践）</h4><p>证明加法对于严格不等关系是单调的。正如不等关系中那样，你可以需要额外的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29393" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="leq-iff-less">练习 <code>≤-iff-&lt;</code> (推荐)</h4><p>证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29626" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="less-trans-revisited">练习 <code>&lt;-trans-revisited</code>（实践）</h4><p>用另外一种方法证明严格不等是传递的，使用之前证明的不等关系和严格不等关系的联系， 以及不等关系的传递性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30022" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="even-and-odd">奇和偶</h2><p>作为一个额外的例子，我们来定义奇数和偶数。不等关系和严格不等关系是<strong>二元关系</strong>，而奇偶性 是<strong>一元关系</strong>，有时也被叫做<strong>谓词（Predicate）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30381" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-even"></a><a id="plfa_plfa-part1-Relations-30386" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30391" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30393" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30395" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30397" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Relations-30401" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-odd"></a><a id="plfa_plfa-part1-Relations-30406" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Relations-30411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30415" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30417" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Relations-30422" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30427" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30432" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-even.zero"></a><a id="plfa_plfa-part1-Relations-30441" href="../Relations/#plfa_plfa-part1-Relations-30441" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-30446" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-30454" class="Comment">---------</a>
      <a id="plfa_plfa-part1-Relations-30470" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30475" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Relations-even.suc"></a><a id="plfa_plfa-part1-Relations-30483" href="../Relations/#plfa_plfa-part1-Relations-30483" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30488" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30490" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30492" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30493" href="../Relations/#plfa_plfa-part1-Relations-30493" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30495" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30497" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30498" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30504" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30506" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30510" href="../Relations/#plfa_plfa-part1-Relations-30493" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30518" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-30535" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30537" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30542" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30543" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30547" href="../Relations/#plfa_plfa-part1-Relations-30493" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30548" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-30551" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30556" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30560" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-odd.suc"></a><a id="plfa_plfa-part1-Relations-30569" href="../Relations/#plfa_plfa-part1-Relations-30569" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30574" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30576" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30578" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30579" href="../Relations/#plfa_plfa-part1-Relations-30579" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30581" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30583" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30584" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30590" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30592" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30597" href="../Relations/#plfa_plfa-part1-Relations-30579" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30605" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Relations-30621" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30623" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30627" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30628" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30632" href="../Relations/#plfa_plfa-part1-Relations-30579" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30633" class="Symbol">)</a>
</pre><p>一个数是偶数，如果它是 0，或者是奇数的后继。一个数是奇数，如果它是偶数的后继。</p><p>这是我们第一次定义一个相互递归的数据类型。因为每个标识符必须在使用前声明，所以 我们首先声明索引数据类型 <code>even</code> 和 <code>odd</code> （省略 <code>where</code> 关键字和其构造子的定义）， 然后声明其构造子（省略其签名 <code>ℕ → Set</code>，因为在之前已经给出）。</p><p>这也是我们第一次使用<strong>重载（Overloaded）</strong>的构造子。这意味着不同类型的构造子 拥有相同的名字。在这里 <code>suc</code> 表示下面三种构造子其中之一：</p><pre><code>suc : ℕ → ℕ

suc : ∀ {n : ℕ}
  → odd n
    ------------
  → even (suc n)

suc : ∀ {n : ℕ}
  → even n
    -----------
  → odd (suc n)</code></pre><p>同理，<code>zero</code> 表示两种构造子的一种。因为类型推导的限制，Agda 不允许重载已定义的名字， 但是允许重载构造子。我们推荐将重载限制在有关联的定义中，如我们所做的这样，但这不是必须的。</p><p>我们证明两个偶数之和是偶数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-e+e≡e"></a><a id="plfa_plfa-part1-Relations-32210" href="../Relations/#plfa_plfa-part1-Relations-32210" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32216" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32218" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32220" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32221" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32223" href="../Relations/#plfa_plfa-part1-Relations-32223" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32225" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32227" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32228" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32232" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32234" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32239" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32243" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32245" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32250" href="../Relations/#plfa_plfa-part1-Relations-32223" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32256" class="Comment">------------</a>
  <a id="plfa_plfa-part1-Relations-32271" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32273" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32278" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32279" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32281" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32283" href="../Relations/#plfa_plfa-part1-Relations-32223" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32284" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-o+e≡o"></a><a id="plfa_plfa-part1-Relations-32287" href="../Relations/#plfa_plfa-part1-Relations-32287" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32293" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32295" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32297" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32298" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32300" href="../Relations/#plfa_plfa-part1-Relations-32300" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32302" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32304" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32305" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32309" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32311" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32315" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32319" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32321" href="../Relations/#plfa_plfa-part1-Relations-30386" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32326" href="../Relations/#plfa_plfa-part1-Relations-32300" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32332" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Relations-32346" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32348" href="../Relations/#plfa_plfa-part1-Relations-30406" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32352" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32353" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32355" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32357" href="../Relations/#plfa_plfa-part1-Relations-32300" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32358" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32361" href="../Relations/#plfa_plfa-part1-Relations-32210" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32367" href="../Relations/#plfa_plfa-part1-Relations-30441" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-32376" href="../Relations/#plfa_plfa-part1-Relations-32376" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32380" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32383" href="../Relations/#plfa_plfa-part1-Relations-32376" class="Bound">en</a>
<a id="plfa_plfa-part1-Relations-32386" href="../Relations/#plfa_plfa-part1-Relations-32210" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32392" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32393" href="../Relations/#plfa_plfa-part1-Relations-30483" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32397" href="../Relations/#plfa_plfa-part1-Relations-32397" class="Bound">om</a><a id="plfa_plfa-part1-Relations-32399" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32401" href="../Relations/#plfa_plfa-part1-Relations-32401" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32405" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32408" href="../Relations/#plfa_plfa-part1-Relations-30483" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32412" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32413" href="../Relations/#plfa_plfa-part1-Relations-32287" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32419" href="../Relations/#plfa_plfa-part1-Relations-32397" class="Bound">om</a> <a id="plfa_plfa-part1-Relations-32422" href="../Relations/#plfa_plfa-part1-Relations-32401" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32424" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32427" href="../Relations/#plfa_plfa-part1-Relations-32287" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32433" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32434" href="../Relations/#plfa_plfa-part1-Relations-30569" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32438" href="../Relations/#plfa_plfa-part1-Relations-32438" class="Bound">em</a><a id="plfa_plfa-part1-Relations-32440" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32442" href="../Relations/#plfa_plfa-part1-Relations-32442" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32446" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32449" href="../Relations/#plfa_plfa-part1-Relations-30569" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32453" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32454" href="../Relations/#plfa_plfa-part1-Relations-32210" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32460" href="../Relations/#plfa_plfa-part1-Relations-32438" class="Bound">em</a> <a id="plfa_plfa-part1-Relations-32463" href="../Relations/#plfa_plfa-part1-Relations-32442" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32465" class="Symbol">)</a>
</pre><p>与相互递归的定义对应，我们用两个相互递归的函数，一个证明两个偶数之和是偶数，另一个证明 一个奇数与一个偶数之和是奇数。</p><p>这是我们第一次使用相互递归的函数。因为每个标识符必须在使用前声明，我们先给出两个函数的签名， 然后再给出其定义。</p><p>要证明两个偶数之和为偶，我们考虑第一个数为偶数的证明。如果是因为第一个数为 0， 那么第二个数为偶数的证明即为和为偶数的证明。如果是因为第一个数为奇数的后继， 那么和为偶数是因为他是一个奇数和一个偶数的和的后续，而这个和是一个奇数。</p><p>要证明一个奇数和一个偶数的和是奇数，我们考虑第一个数是奇数的证明。 如果是因为它是一个偶数的后继，那么和为奇数，因为它是两个偶数之和的后继， 而这个和是一个偶数。</p><h4 id="odd-plus-odd">练习 <code>o+o≡e</code> (延伸)</h4><p>证明两个奇数之和为偶数。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-34038" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-predicates">练习 <code>Bin-predicates</code> (延伸)</h4><p>回忆我们在练习 <a href="../Naturals/#Bin">Bin</a> 中定义了一个数据类型 <code>Bin</code> 来用二进制字符串表示自然数。 这个表达方法不是唯一的，因为我们在开头加任意个 0。因此，11 可以由以下方法表示：</p><pre><code>⟨⟩ I O I I
⟨⟩ O O I O I I</code></pre><p>定义一个谓词</p><pre><code>Can : Bin → Set</code></pre><p>其在一个二进制字符串的表示是标准的（Canonical）时成立，表示它没有开头的 0。在两个 11 的表达方式中， 第一个是标准的，而第二个不是。在定义这个谓词时，你需要一个辅助谓词：</p><pre><code>One : Bin → Set</code></pre><p>其仅在一个二进制字符串开头为 1 时成立。一个二进制字符串是标准的，如果它开头是 1 （表示一个正数）， 或者它仅是一个 0 （表示 0）。</p><p>证明递增可以保持标准性。</p><pre><code>Can b
------------
Can (inc b)</code></pre><p>证明从自然数转换成的二进制字符串是标准的。</p><pre><code>----------
Can (to n)</code></pre><p>证明将一个标准的二进制字符串转换成自然数之后，再转换回二进制字符串与原二进制字符串相同。</p><pre><code>Can b
---------------
to (from b) ≡ b</code></pre><p>（提示：对于每一条习题，先从 <code>One</code> 的性质开始。此外，你或许还需要证明若 <code>One b</code> 成立，则 <code>1</code> 小于或等于 <code>from b</code> 的结果。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-35967" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中有类似于本章介绍的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-36143" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36150" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-36159" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36165" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36166" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Relations-36169" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36171" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-36174" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36176" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Relations-36179" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-36181" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36188" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-36208" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36214" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36215" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4565" class="Function">≤-refl</a><a id="plfa_plfa-part1-Relations-36221" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36223" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4748" class="Function">≤-trans</a><a id="plfa_plfa-part1-Relations-36230" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36232" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4615" class="Function">≤-antisym</a><a id="plfa_plfa-part1-Relations-36241" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36243" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4860" class="Function">≤-total</a><a id="plfa_plfa-part1-Relations-36250" class="Symbol">;</a>
                                  <a id="plfa_plfa-part1-Relations-36286" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#18026" class="Function">+-monoʳ-≤</a><a id="plfa_plfa-part1-Relations-36295" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36297" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17936" class="Function">+-monoˡ-≤</a><a id="plfa_plfa-part1-Relations-36306" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36308" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17780" class="Function">+-mono-≤</a><a id="plfa_plfa-part1-Relations-36316" class="Symbol">)</a>
</pre><p>在标准库中，<code>≤-total</code> 是使用析取定义的（我们将在 <a href="../Connectives/">Connectives</a> 章节定义）。 <code>+-monoʳ-≤</code>、<code>+-monoˡ-≤</code> 和 <code>+-mono-≤</code> 的证明方法和本书不同。 更多的参数是隐式申明的。</p><h2 id="unicode">Unicode</h2><p>本章使用了如下 Unicode 符号：</p><pre><code>≤  U+2264  小于等于 (\&lt;=, \le)
≥  U+2265  大于等于 (\&gt;=, \ge)
ˡ  U+02E1  小写字母 L 标识符 (\^l)
ʳ  U+02B3  小写字母 R 标识符 (\^r)</code></pre><p><code>\^l</code> 和 <code>\^r</code> 命令给出了左右箭头，以及上标字母 <code>l</code> 和 <code>r</code>。</p></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>