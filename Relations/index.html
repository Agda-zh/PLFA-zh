<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Relations</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Relations: 关系的归纳定义</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Relations-121" class="Keyword">module</a> <a id="plfa_plfa-part1-Relations-128" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Relations-149" class="Keyword">where</a>
</pre><p>在定义了加法和乘法等运算以后，下一步我们来定义<strong>关系（Relation）</strong>，比如说<strong>小于等于</strong>。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Relations-398" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-405" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Relations-443" class="Symbol">as</a> <a id="plfa_plfa-part1-Relations-446" class="Module">Eq</a>
<a id="plfa_plfa-part1-Relations-449" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-454" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Relations-457" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-463" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-464" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Relations-467" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-469" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Relations-473" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Relations-479" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-481" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-486" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-493" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-502" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-508" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-509" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-516" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-518" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Relations-521" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Relations-526" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-528" class="Keyword">open</a> <a id="plfa_plfa-part1-Relations-533" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-540" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-560" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-566" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-567" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a><a id="plfa_plfa-part1-Relations-573" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-575" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Relations-586" class="Symbol">)</a>
</pre><h2 id="定义关系">定义关系</h2><p>小于等于这个关系有无穷个实例，如下所示：</p><pre><code>0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...</code></pre><p>但是，我们仍然可以用几行有限的定义来表示所有的实例，如下文所示的一对推理规则：</p><pre><code>z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n</code></pre><p>以及其 Agda 定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-1375" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_≤_"></a><a id="plfa_plfa-part1-Relations-1380" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Relations-1384" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1386" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1388" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-1392" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-1398" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_≤_.z≤n"></a><a id="plfa_plfa-part1-Relations-1407" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-1411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1413" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1415" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1416" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1418" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1420" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1421" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-1429" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Relations-1442" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1444" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-1449" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1451" href="../Relations/#plfa_plfa-part1-Relations-1416" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_≤_.s≤s"></a><a id="plfa_plfa-part1-Relations-1456" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-1460" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1462" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-1464" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-1465" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1467" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-1469" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-1471" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-1472" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-1478" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1480" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1482" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1484" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-1492" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-1510" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-1512" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1516" href="../Relations/#plfa_plfa-part1-Relations-1465" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-1518" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-1520" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-1524" href="../Relations/#plfa_plfa-part1-Relations-1467" class="Bound">n</a>
</pre><p>在这里，<code>z≤n</code> 和 <code>s≤s</code>（无空格）是构造子的名称，<code>zero ≤ n</code>、<code>m ≤ n</code> 和 <code>suc m ≤ suc n</code> （带空格）是类型。在这里我们第一次用到了 <strong>索引数据类型（Indexed datatype）</strong>。我们使用 <code>m</code> 和 <code>n</code> 这两个自然数来索引 <code>m ≤ n</code> 这个类型。在 Agda 里，由两个及以上短横线开始的行是注释行， 我们巧妙利用这一语法特性，用上述形式来表示相应的推理规则。 在后文中，我们还会继续使用这一形式。</p><p>这两条定义告诉我们相同的两件事：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，命题 <code>zero ≤ n</code> 成立。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果命题 <code>m ≤ n</code> 成立， 那么命题 <code>suc m ≤ suc n</code> 成立。</li></ul><p>实际上，他们分别给我们更多的信息：</p><ul><li><strong>起始步骤</strong>: 对于所有的自然数 <code>n</code>，构造子 <code>z≤n</code> 提供了 <code>zero ≤ n</code> 成立的证明。</li><li><strong>归纳步骤</strong>：对于所有的自然数 <code>m</code> 和 <code>n</code>，构造子 <code>s≤s</code> 将 <code>m ≤ n</code> 成立的证明 转化为 <code>suc m ≤ suc n</code> 成立的证明。</li></ul><p>例如，我们在这里以推理规则的形式写出 <code>2 ≤ 4</code> 的证明：</p><pre><code>  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4</code></pre><p>下面是对应的 Agda 证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-3418" href="../Relations/#plfa_plfa-part1-Relations-3418" class="Function">_</a> <a id="plfa_plfa-part1-Relations-3420" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-3422" class="Number">2</a> <a id="plfa_plfa-part1-Relations-3424" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-3426" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-3428" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-3430" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-3432" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3436" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-3437" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-3441" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-3444" class="Symbol">)</a>
</pre><h2 id="隐式参数">隐式参数</h2><p>这是我们第一次使用隐式参数。定义不等式时，构造子的定义中使用了 <code>∀</code>， 就像我们在下面的命题中使用 <code>∀</code> 一样：</p><pre><code>+-comm : ∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>但是我们这里的定义使用了花括号 <code>{ }</code>，而不是小括号 <code>( )</code>。 这意味着参数是<strong>隐式的（Implicit）</strong>，不需要额外声明。实际上，Agda 的类型检查器 会<strong>推导（Infer）</strong>出它们。因此，我们在 <code>m + n ≡ n + m</code> 的证明中需要写出 <code>+-comm m n</code>， 在 <code>zero ≤ n</code> 的证明中可以省略 <code>n</code>。同理，如果 <code>m≤n</code> 是 <code>m ≤ n</code>的证明， 那么我们写出 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 的证明，无需声明 <code>m</code> 和 <code>n</code>。</p><p>如果有希望的话，我们也可以在大括号里显式声明隐式参数。例如，下面是 <code>2 ≤ 4</code> 的 Agda 证明，包括了显式声明了的隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4856" href="../Relations/#plfa_plfa-part1-Relations-4856" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4858" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4860" class="Number">2</a> <a id="plfa_plfa-part1-Relations-4862" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-4864" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-4866" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-4868" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-4870" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4874" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4875" class="Number">1</a><a id="plfa_plfa-part1-Relations-4876" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4878" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4879" class="Number">3</a><a id="plfa_plfa-part1-Relations-4880" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4882" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4883" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-4887" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4888" class="Number">0</a><a id="plfa_plfa-part1-Relations-4889" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4891" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4892" class="Number">2</a><a id="plfa_plfa-part1-Relations-4893" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-4895" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-4896" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-4900" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-4901" class="Number">2</a><a id="plfa_plfa-part1-Relations-4902" class="Symbol">}))</a>
</pre><p>也可以额外加上参数的名字：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-4994" href="../Relations/#plfa_plfa-part1-Relations-4994" class="Function">_</a> <a id="plfa_plfa-part1-Relations-4996" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-4998" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5000" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5002" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5004" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5006" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5008" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5012" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5013" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5015" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5017" class="Number">1</a><a id="plfa_plfa-part1-Relations-5018" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5020" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5021" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5023" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5025" class="Number">3</a><a id="plfa_plfa-part1-Relations-5026" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5028" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5029" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5033" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5034" class="Argument">m</a> <a id="plfa_plfa-part1-Relations-5036" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5038" class="Number">0</a><a id="plfa_plfa-part1-Relations-5039" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5041" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5042" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5044" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5046" class="Number">2</a><a id="plfa_plfa-part1-Relations-5047" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5049" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5050" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-5054" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5055" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5057" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5059" class="Number">2</a><a id="plfa_plfa-part1-Relations-5060" class="Symbol">}))</a>
</pre><p>在后者的形式中，也可以选择只声明一部分隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-5190" href="../Relations/#plfa_plfa-part1-Relations-5190" class="Function">_</a> <a id="plfa_plfa-part1-Relations-5192" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5194" class="Number">2</a> <a id="plfa_plfa-part1-Relations-5196" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-5198" class="Number">4</a>
<a id="plfa_plfa-part1-Relations-5200" class="Symbol">_</a> <a id="plfa_plfa-part1-Relations-5202" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5204" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5208" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5209" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5211" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5213" class="Number">3</a><a id="plfa_plfa-part1-Relations-5214" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5216" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-5217" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-5221" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5222" class="Argument">n</a> <a id="plfa_plfa-part1-Relations-5224" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5226" class="Number">2</a><a id="plfa_plfa-part1-Relations-5227" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5229" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-5232" class="Symbol">)</a>
</pre><p>但是不可以改变隐式参数的顺序，即便加上了名字。</p><p>我们可以写出 <code>_</code> 来让 Agda 用相同的推导方式试着推导一个<strong>显式</strong>的项。 例如，我们可以为命题 <code>+-identityʳ</code> 定义一个带有隐式参数的变体：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-identityʳ′"></a><a id="plfa_plfa-part1-Relations-5632" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5645" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5647" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-5649" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-5650" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5652" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-5654" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-5655" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-5657" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-5659" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-5661" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-5663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-5668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-5670" href="../Relations/#plfa_plfa-part1-Relations-5650" class="Bound">m</a>
<a id="plfa_plfa-part1-Relations-5672" href="../Relations/#plfa_plfa-part1-Relations-5632" class="Function">+-identityʳ′</a> <a id="plfa_plfa-part1-Relations-5685" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-5687" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Relations-5699" class="Symbol">_</a>
</pre><p>我们用 <code>_</code> 来让 Agda 从语境中推导<strong>显式参数</strong>的值。只有 <code>m</code> 这一个值能够给出正确的证明，因此 Agda 愉快地填入了它。 如果 Agda 推导值失败，那么它会报一个错误。</p><h2 id="优先级">优先级</h2><p>我们如下定义比较的优先级：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-6162" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-6168" class="Number">4</a> <a id="plfa_plfa-part1-Relations-6170" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">_≤_</a>
</pre><p>我们将 <code>_≤_</code> 的优先级设置为 4，所以它不如优先级为 6 的 <code>_+_</code> 结合得紧，因而， <code>1 + 2 ≤ 3</code> 将被解析为 <code>(1 + 2) ≤ 3</code>。我们用 <code>infix</code> 来表示运算符既不是左结合的， 也不是右结合的。因为 <code>1 ≤ 2 ≤ 3</code> 解析为 <code>(1 ≤ 2) ≤ 3</code> 或者 <code>1 ≤ (2 ≤ 3)</code> 都没有意义。</p><h2 id="可判定性">可判定性</h2><p>给定两个数，我们可以很直接地决定第一个数是不是小于等于第二个数。我们在此处不给出说明的代码， 但我们会在 <a href="../Decidable/">Decidable</a> 章节重新讨论这个问题。</p><h2 id="反演">反演</h2><p>在我们的定义中，我们从更小的东西得到更大的东西。例如，我们可以从 <code>m ≤ n</code> 得出 <code>suc m ≤ suc n</code> 的结论，这里的 <code>suc m</code> 比 <code>m</code> 更大 （也就是说，前者包含后者），<code>suc n</code> 也比 <code>n</code> 更大。但有时我们也 需要从更大的东西得到更小的东西。</p><p>只有一种方式能够证明对于任意 <code>m</code> 和 <code>n</code> 有 <code>suc m ≤ suc n</code>。 这让我们能够反演（invert）之前的规则。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-s≤s"></a><a id="plfa_plfa-part1-Relations-7721" href="../Relations/#plfa_plfa-part1-Relations-7721" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7729" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7731" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-7733" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-7734" href="../Relations/#plfa_plfa-part1-Relations-7734" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7736" href="../Relations/#plfa_plfa-part1-Relations-7736" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-7738" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-7740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-7741" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-7745" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7747" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7751" href="../Relations/#plfa_plfa-part1-Relations-7734" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7753" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7755" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-7759" href="../Relations/#plfa_plfa-part1-Relations-7736" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-7765" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-7781" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-7783" href="../Relations/#plfa_plfa-part1-Relations-7734" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-7785" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-7787" href="../Relations/#plfa_plfa-part1-Relations-7736" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-7789" href="../Relations/#plfa_plfa-part1-Relations-7721" class="Function">inv-s≤s</a> <a id="plfa_plfa-part1-Relations-7797" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-7798" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-7802" href="../Relations/#plfa_plfa-part1-Relations-7802" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-7805" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-7807" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-7809" href="../Relations/#plfa_plfa-part1-Relations-7802" class="Bound">m≤n</a>
</pre><p>这里的 <code>m≤n</code>（不带空格）是一个变量名，而 <code>m ≤ n</code>（带空格）是一个类型， 且后者是前者的类型。在 Agda 中，将类型中的空格去掉来作为变量名是一种常见的约定。</p><p>并不是所有规则都可以反演。实际上，<code>z≤n</code> 的规则没有非隐式的假设， 因此它没有可以被反演的规则。但这种反演通常是成立的。</p><p>反演的另一个例子是证明只存在一种情况使得一个数字能够小于或等于零。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-inv-z≤n"></a><a id="plfa_plfa-part1-Relations-8537" href="../Relations/#plfa_plfa-part1-Relations-8537" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8545" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8547" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-8549" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-8550" href="../Relations/#plfa_plfa-part1-Relations-8550" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8552" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-8554" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-8555" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-8559" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8561" href="../Relations/#plfa_plfa-part1-Relations-8550" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8563" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-8565" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
    <a id="plfa_plfa-part1-Relations-8574" class="Comment">--------</a>
  <a id="plfa_plfa-part1-Relations-8585" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-8587" href="../Relations/#plfa_plfa-part1-Relations-8550" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-8589" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-8591" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Relations-8596" href="../Relations/#plfa_plfa-part1-Relations-8537" class="Function">inv-z≤n</a> <a id="plfa_plfa-part1-Relations-8604" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Relations-8608" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-8610" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><h2 id="序关系的性质">序关系的性质</h2><p>数学家对于关系的常见性质给出了约定的名称。</p><ul><li><strong>自反（Reflexive）</strong>：对于所有的 <code>n</code>，关系 <code>n ≤ n</code> 成立。</li><li><strong>传递（Transitive）</strong>：对于所有的 <code>m</code>、 <code>n</code> 和 <code>p</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 也成立。</li><li><strong>反对称（Anti-symmetric）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立。</li><li><strong>完全（Total）</strong>：对于所有的 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。</li></ul><p><code>_≤_</code> 关系满足上述四条性质。</p><p>对于上述性质的组合也有约定的名称。</p><ul><li><strong>预序（Preorder）</strong>：满足自反和传递的关系。</li><li><strong>偏序（Partial Order）</strong>：满足反对称的预序。</li><li><strong>全序（Total Order）</strong>：满足完全的偏序。</li></ul><p>如果你在派对上偶遇一个『关系』，你现在知道怎么样和人讨论了， 可以讨论关于自反、传递、反对称和完全， 或者问一问这是不是预序、偏序或者全序。</p><p>更认真的来说，如果你在阅读论文时碰到了一个关系，本文的介绍让你可以对关系有基本的了解和判断， 来判断这个关系是不是预序、偏序或者全序。一个认真的作者一般会在文章指出这个关系具有（或者缺少） 上述性质，比如说指出新定义的关系是一个偏序而不是全序。</p><h4 id="orderings">练习 <code>orderings</code>（实践）</h4><p>给出一个不是偏序的预序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10875" class="Comment">-- 请将代码写在此处。</a>
</pre><p>给出一个不是全序的偏序的例子。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-10992" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="自反性">自反性</h2><p>我们第一个来证明的性质是自反性：对于任意自然数 <code>n</code>，关系 <code>n ≤ n</code> 成立。我们使用标准库 的惯例来隐式申明参数，在使用自反性的证明时这样可以更加方便。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-refl"></a><a id="plfa_plfa-part1-Relations-11396" href="../Relations/#plfa_plfa-part1-Relations-11396" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11403" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11405" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-11407" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11408" href="../Relations/#plfa_plfa-part1-Relations-11408" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11410" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-11412" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-11413" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-11419" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-11427" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-11429" href="../Relations/#plfa_plfa-part1-Relations-11408" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-11431" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-11433" href="../Relations/#plfa_plfa-part1-Relations-11408" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-11435" href="../Relations/#plfa_plfa-part1-Relations-11396" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11442" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11443" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Relations-11447" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11449" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11451" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-11455" href="../Relations/#plfa_plfa-part1-Relations-11396" class="Function">≤-refl</a> <a id="plfa_plfa-part1-Relations-11462" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-11463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-11467" href="../Relations/#plfa_plfa-part1-Relations-11467" class="Bound">n</a><a id="plfa_plfa-part1-Relations-11468" class="Symbol">}</a> <a id="plfa_plfa-part1-Relations-11470" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-11472" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-11476" href="../Relations/#plfa_plfa-part1-Relations-11396" class="Function">≤-refl</a>
</pre><p>这个证明直接在 <code>n</code> 上进行归纳。在起始步骤中，<code>zero ≤ zero</code> 由 <code>z≤n</code> 证明；在归纳步骤中， 归纳假设 <code>≤-refl {n}</code> 给我们带来了 <code>n ≤ n</code> 的证明，我们只需要使用 <code>s≤s</code>，就可以获得 <code>suc n ≤ suc n</code> 的证明。</p><p>在 Emacs 中来交互式地证明自反性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="传递性">传递性</h2><p>我们第二个证明的性质是传递性：对于任意自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ p</code> 成立，那么 <code>m ≤ p</code> 成立。同样，<code>m</code>、<code>n</code> 和 <code>p</code> 是隐式参数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans"></a><a id="plfa_plfa-part1-Relations-12471" href="../Relations/#plfa_plfa-part1-Relations-12471" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12479" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12481" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-12483" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-12484" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12486" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12488" href="../Relations/#plfa_plfa-part1-Relations-12488" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-12490" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-12492" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-12493" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-12497" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12499" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12501" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12503" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-12507" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12509" href="../Relations/#plfa_plfa-part1-Relations-12486" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-12511" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12513" href="../Relations/#plfa_plfa-part1-Relations-12488" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-12519" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-12527" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-12529" href="../Relations/#plfa_plfa-part1-Relations-12484" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-12531" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-12533" href="../Relations/#plfa_plfa-part1-Relations-12488" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-12535" href="../Relations/#plfa_plfa-part1-Relations-12471" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12543" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-12553" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-12564" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12567" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-12571" href="../Relations/#plfa_plfa-part1-Relations-12471" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12579" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12580" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12584" href="../Relations/#plfa_plfa-part1-Relations-12584" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-12587" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-12589" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12590" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12594" href="../Relations/#plfa_plfa-part1-Relations-12594" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12597" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-12600" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-12603" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-12607" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-12608" href="../Relations/#plfa_plfa-part1-Relations-12471" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-12616" href="../Relations/#plfa_plfa-part1-Relations-12584" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-12620" href="../Relations/#plfa_plfa-part1-Relations-12594" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-12623" class="Symbol">)</a>
</pre><p>这里我们在 <code>m ≤ n</code> 的<strong>证据（Evidence）</strong>上进行归纳。在起始步骤里，第一个不等式因为 <code>z≤n</code> 而成立， 那么结论亦可由 <code>z≤n</code> 而得出。在这里，<code>n ≤ p</code> 的证明是不需要的，我们用 <code>_</code> 来表示这个 证明没有被使用。</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个不等式因为 <code>s≤s n≤p</code> 而成立， 所以我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc p</code>，求证 <code>suc m ≤ suc p</code>。 通过归纳假设 <code>≤-trans m≤n n≤p</code>，我们得知 <code>m ≤ p</code>，在此之上使用 <code>s≤s</code> 即可证。</p><p><code>≤-trans (s≤s m≤n) z≤n</code> 不可能发生，因为第一个不等式告诉我们中间的数是一个 <code>suc n</code>， 而第二个不等式告诉我们中间的数是 <code>zero</code>。Agda 可以推断这样的情况不可能发现，所以我们不需要 （也不可以）列出这种情况。</p><p>我们也可以将隐式参数显式地声明。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-trans′"></a><a id="plfa_plfa-part1-Relations-14069" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14078" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14080" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-14082" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14083" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14085" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14087" href="../Relations/#plfa_plfa-part1-Relations-14087" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14089" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-14091" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-14092" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-14096" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14098" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14100" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14102" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-14106" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14108" href="../Relations/#plfa_plfa-part1-Relations-14085" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14110" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14112" href="../Relations/#plfa_plfa-part1-Relations-14087" class="Bound">p</a>
    <a id="plfa_plfa-part1-Relations-14118" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-14126" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-14128" href="../Relations/#plfa_plfa-part1-Relations-14083" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14130" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-14132" href="../Relations/#plfa_plfa-part1-Relations-14087" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-14134" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-14151" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14159" class="Symbol">_</a>       <a id="plfa_plfa-part1-Relations-14167" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-14177" class="Symbol">_</a>          <a id="plfa_plfa-part1-Relations-14188" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14191" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-14195" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14204" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14205" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14209" href="../Relations/#plfa_plfa-part1-Relations-14209" class="Bound">m</a><a id="plfa_plfa-part1-Relations-14210" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14212" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14213" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14217" href="../Relations/#plfa_plfa-part1-Relations-14217" class="Bound">n</a><a id="plfa_plfa-part1-Relations-14218" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14220" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14221" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-14225" href="../Relations/#plfa_plfa-part1-Relations-14225" class="Bound">p</a><a id="plfa_plfa-part1-Relations-14226" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14228" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14229" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14233" href="../Relations/#plfa_plfa-part1-Relations-14233" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-14236" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-14238" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14239" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14243" href="../Relations/#plfa_plfa-part1-Relations-14243" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14246" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-14249" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-14252" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-14256" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-14257" href="../Relations/#plfa_plfa-part1-Relations-14069" class="Function">≤-trans′</a> <a id="plfa_plfa-part1-Relations-14266" href="../Relations/#plfa_plfa-part1-Relations-14209" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-14268" href="../Relations/#plfa_plfa-part1-Relations-14217" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-14270" href="../Relations/#plfa_plfa-part1-Relations-14225" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-14272" href="../Relations/#plfa_plfa-part1-Relations-14233" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-14276" href="../Relations/#plfa_plfa-part1-Relations-14243" class="Bound">n≤p</a><a id="plfa_plfa-part1-Relations-14279" class="Symbol">)</a>
</pre><p>有人说这样的证明更加的清晰，也有人说这个更长的证明让人难以抓住证明的重点。 我们一般选择使用简短的证明。</p><p>对于性质成立证明进行的归纳（如上文中对于 <code>m ≤ n</code> 的证明进行归纳），相比于对于性质成立的值进行的归纳 （如对于 <code>m</code> 进行归纳），有非常大的价值。我们会经常使用这样的方法。</p><p>同样，在 Emacs 中来交互式地证明传递性是一个很好的练习，可以使用洞，以及 <code>C-c C-c</code>、 <code>C-c C-,</code> 和 <code>C-c C-r</code> 命令。</p><h2 id="反对称性">反对称性</h2><p>我们证明的第三个性质是反对称性：对于所有的自然数 <code>m</code> 和 <code>n</code>，如果 <code>m ≤ n</code> 和 <code>n ≤ m</code> 同时成立，那么 <code>m ≡ n</code> 成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-antisym"></a><a id="plfa_plfa-part1-Relations-15382" href="../Relations/#plfa_plfa-part1-Relations-15382" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15392" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15394" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-15396" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-15397" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15399" href="../Relations/#plfa_plfa-part1-Relations-15399" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15401" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-15403" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-15404" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-15408" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15410" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15412" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15414" href="../Relations/#plfa_plfa-part1-Relations-15399" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-15418" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15420" href="../Relations/#plfa_plfa-part1-Relations-15399" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-15422" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-15424" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">m</a>
    <a id="plfa_plfa-part1-Relations-15430" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Relations-15438" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-15440" href="../Relations/#plfa_plfa-part1-Relations-15397" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-15442" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Relations-15444" href="../Relations/#plfa_plfa-part1-Relations-15399" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-15446" href="../Relations/#plfa_plfa-part1-Relations-15382" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15456" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>       <a id="plfa_plfa-part1-Relations-15466" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Relations-15477" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15480" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Relations-15485" href="../Relations/#plfa_plfa-part1-Relations-15382" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15495" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15496" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15500" href="../Relations/#plfa_plfa-part1-Relations-15500" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-15503" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-15505" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15506" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-15510" href="../Relations/#plfa_plfa-part1-Relations-15510" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15513" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-15516" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-15519" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Relations-15524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-15528" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-15529" href="../Relations/#plfa_plfa-part1-Relations-15382" class="Function">≤-antisym</a> <a id="plfa_plfa-part1-Relations-15539" href="../Relations/#plfa_plfa-part1-Relations-15500" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-15543" href="../Relations/#plfa_plfa-part1-Relations-15510" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-15546" class="Symbol">)</a>
</pre><p>同样，我们对于 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明进行归纳。</p><p>在起始步骤中，两个不等式都因为 <code>z≤n</code> 而成立。因此我们已知 <code>zero ≤ zero</code> 和 <code>zero ≤ zero</code>， 求证 <code>zero ≡ zero</code>，由自反性可证。（注：由等式的自反性可证，而不是不等式的自反性）</p><p>在归纳步骤中，第一个不等式因为 <code>s≤s m≤n</code> 而成立，第二个等式因为 <code>s≤s n≤m</code> 而成立。因此我们已知 <code>suc m ≤ suc n</code> 和 <code>suc n ≤ suc m</code>，求证 <code>suc m ≡ suc n</code>。归纳假设 <code>≤-antisym m≤n n≤m</code> 可以证明 <code>m ≡ n</code>，因此我们可以使用同余性完成证明。</p><h4 id="leq-antisym-cases">练习 <code>≤-antisym-cases</code>（实践）</h4><p>上面的证明中省略了一个参数是 <code>z≤n</code>，另一个参数是 <code>s≤s</code> 的情况。为什么可以省略这种情况？</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-16827" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="完全性">完全性</h2><p>我们证明的第四个性质是完全性：对于任何自然数 <code>m</code> 和 <code>n</code>，<code>m ≤ n</code> 或者 <code>n ≤ m</code> 成立。 在 <code>m</code> 和 <code>n</code> 相等时，两者同时成立。</p><p>我们首先来说明怎么样不等式才是完全的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-17213" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total"></a><a id="plfa_plfa-part1-Relations-17218" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17224" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-17225" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17227" href="../Relations/#plfa_plfa-part1-Relations-17227" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17229" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17231" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-17232" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-17234" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-17236" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-17240" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total.forward"></a><a id="plfa_plfa-part1-Relations-17249" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-17257" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17265" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17267" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17269" href="../Relations/#plfa_plfa-part1-Relations-17227" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-17277" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17291" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17293" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17299" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17301" href="../Relations/#plfa_plfa-part1-Relations-17227" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total.flipped"></a><a id="plfa_plfa-part1-Relations-17306" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-17314" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-17322" href="../Relations/#plfa_plfa-part1-Relations-17227" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-17324" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-17326" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-17334" class="Comment">---------</a>
    <a id="plfa_plfa-part1-Relations-17348" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-17350" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-17356" href="../Relations/#plfa_plfa-part1-Relations-17225" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-17358" href="../Relations/#plfa_plfa-part1-Relations-17227" class="Bound">n</a>
</pre><p><code>Total m n</code> 成立的证明有两种形式：<code>forward m≤n</code> 或者 <code>flipped n≤m</code>，其中 <code>m≤n</code> 和 <code>n≤m</code> 分别是 <code>m ≤ n</code> 和 <code>n ≤ m</code> 的证明。</p><p>（如果你对于逻辑学有所了解，上面的定义可以由析取（Disjunction）表示。 我们会在 <a href="../Connectives/">Connectives</a> 章节介绍析取。）</p><p>这是我们第一次使用带<em>参数</em>的数据类型，这里 <code>m</code> 和 <code>n</code> 是参数。这等同于下面的索引数据类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-18099" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-Total′"></a><a id="plfa_plfa-part1-Relations-18104" href="../Relations/#plfa_plfa-part1-Relations-18104" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18111" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18113" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18115" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18117" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-18119" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18121" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-18125" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-Total′.forward′"></a><a id="plfa_plfa-part1-Relations-18134" href="../Relations/#plfa_plfa-part1-Relations-18134" class="InductiveConstructor">forward′</a> <a id="plfa_plfa-part1-Relations-18143" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18145" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18147" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18148" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18150" href="../Relations/#plfa_plfa-part1-Relations-18150" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18152" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18154" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18155" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18161" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18163" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18165" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18167" href="../Relations/#plfa_plfa-part1-Relations-18150" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-18175" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18190" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18192" href="../Relations/#plfa_plfa-part1-Relations-18104" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18199" href="../Relations/#plfa_plfa-part1-Relations-18148" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18201" href="../Relations/#plfa_plfa-part1-Relations-18150" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-Total′.flipped′"></a><a id="plfa_plfa-part1-Relations-18206" href="../Relations/#plfa_plfa-part1-Relations-18206" class="InductiveConstructor">flipped′</a> <a id="plfa_plfa-part1-Relations-18215" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18217" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-18219" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-18220" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18222" href="../Relations/#plfa_plfa-part1-Relations-18222" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18224" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-18226" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-18227" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-18233" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18235" href="../Relations/#plfa_plfa-part1-Relations-18222" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-18237" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-18239" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">m</a>
      <a id="plfa_plfa-part1-Relations-18247" class="Comment">----------</a>
    <a id="plfa_plfa-part1-Relations-18262" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-18264" href="../Relations/#plfa_plfa-part1-Relations-18104" class="Datatype">Total′</a> <a id="plfa_plfa-part1-Relations-18271" href="../Relations/#plfa_plfa-part1-Relations-18220" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-18273" href="../Relations/#plfa_plfa-part1-Relations-18222" class="Bound">n</a>
</pre><p>类型里的每个参数都转换成构造子的一个隐式参数。索引数据类型中的索引可以变化，正如在 <code>zero ≤ n</code> 和 <code>suc m ≤ suc n</code> 中那样，而参数化数据类型不一样，其参数必须保持相同， 正如在 <code>Total m n</code> 中那样。参数化的声明更短，更易于阅读，而且有时可以帮助到 Agda 的 停机检查器，所以我们尽可能地使用它们，而不是索引数据类型。</p><p>在上述准备工作完成后，我们定义并证明完全性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total"></a><a id="plfa_plfa-part1-Relations-19021" href="../Relations/#plfa_plfa-part1-Relations-19021" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19029" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19031" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-19033" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19034" href="../Relations/#plfa_plfa-part1-Relations-19034" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19036" href="../Relations/#plfa_plfa-part1-Relations-19036" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-19038" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-19040" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-19041" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19043" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-19045" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-19051" href="../Relations/#plfa_plfa-part1-Relations-19034" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19053" href="../Relations/#plfa_plfa-part1-Relations-19036" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19055" href="../Relations/#plfa_plfa-part1-Relations-19021" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19063" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-19071" href="../Relations/#plfa_plfa-part1-Relations-19071" class="Bound">n</a>                         <a id="plfa_plfa-part1-Relations-19097" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19100" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19108" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19112" href="../Relations/#plfa_plfa-part1-Relations-19021" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19120" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19121" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19125" href="../Relations/#plfa_plfa-part1-Relations-19125" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19126" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19128" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-19154" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19157" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19165" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-19169" href="../Relations/#plfa_plfa-part1-Relations-19021" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19177" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19178" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19182" href="../Relations/#plfa_plfa-part1-Relations-19182" class="Bound">m</a><a id="plfa_plfa-part1-Relations-19183" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19185" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19186" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-19190" href="../Relations/#plfa_plfa-part1-Relations-19190" class="Bound">n</a><a id="plfa_plfa-part1-Relations-19191" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-19193" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-19198" href="../Relations/#plfa_plfa-part1-Relations-19021" class="Function">≤-total</a> <a id="plfa_plfa-part1-Relations-19206" href="../Relations/#plfa_plfa-part1-Relations-19182" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-19208" href="../Relations/#plfa_plfa-part1-Relations-19190" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-19210" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19237" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19239" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19247" href="../Relations/#plfa_plfa-part1-Relations-19247" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-19252" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19255" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-19263" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19264" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19268" href="../Relations/#plfa_plfa-part1-Relations-19247" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-19271" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-19273" class="Symbol">...</a>                        <a id="plfa_plfa-part1-Relations-19300" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-19302" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19310" href="../Relations/#plfa_plfa-part1-Relations-19310" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-19315" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-19318" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-19326" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-19327" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-19331" href="../Relations/#plfa_plfa-part1-Relations-19310" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-19334" class="Symbol">)</a>
</pre><p>这里，我们的证明在两个参数上进行归纳，并按照情况分析：</p><ul><li><p><strong>第一起始步骤</strong>：如果第一个参数是 <code>zero</code>，第二个参数是 <code>n</code>，那么 forward 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ n</code> 的证明。</p></li><li><p><strong>第二起始步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>zero</code>，那么 flipped 条件成立，我们使用 <code>z≤n</code> 作为 <code>zero ≤ suc m</code> 的证明。</p></li><li><p><strong>归纳步骤</strong>：如果第一个参数是 <code>suc m</code>，第二个参数是 <code>suc n</code>，那么归纳假设 <code>≤-total m n</code> 可以给出如下推断：</p><ul><li><p>归纳假设的 forward 条件成立，以 <code>m≤n</code> 作为 <code>m ≤ n</code> 的证明。以此我们可以使用 <code>s≤s m≤n</code> 作为 <code>suc m ≤ suc n</code> 来证明 forward 条件成立。</p></li><li><p>归纳假设的 flipped 条件成立，以 <code>n≤m</code> 作为 <code>n ≤ m</code> 的证明。以此我们可以使用 <code>s≤s n≤m</code> 作为 <code>suc n ≤ suc m</code> 来证明 flipped 条件成立。</p></li></ul></li></ul><p>这是我们第一次在 Agda 中使用 <code>with</code> 语句。<code>with</code> 关键字后面有一个表达式和一或多行。 每行以省略号（<code>...</code>）和一个竖线（<code>|</code>）开头，后面跟着用来匹配表达式的模式，和等式的右手边。</p><p>使用 <code>with</code> 语句等同于定义一个辅助函数。比如说，上面的定义和下面的等价：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total′"></a><a id="plfa_plfa-part1-Relations-21511" href="../Relations/#plfa_plfa-part1-Relations-21511" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21520" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21522" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-21524" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21525" href="../Relations/#plfa_plfa-part1-Relations-21525" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21527" href="../Relations/#plfa_plfa-part1-Relations-21527" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21529" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21531" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-21532" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21534" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21536" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21542" href="../Relations/#plfa_plfa-part1-Relations-21525" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21544" href="../Relations/#plfa_plfa-part1-Relations-21527" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-21546" href="../Relations/#plfa_plfa-part1-Relations-21511" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21555" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-21563" href="../Relations/#plfa_plfa-part1-Relations-21563" class="Bound">n</a>        <a id="plfa_plfa-part1-Relations-21572" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21575" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21583" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21587" href="../Relations/#plfa_plfa-part1-Relations-21511" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21596" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21597" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21601" href="../Relations/#plfa_plfa-part1-Relations-21601" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21602" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21604" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-21613" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21616" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21624" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-21628" href="../Relations/#plfa_plfa-part1-Relations-21511" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21637" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21638" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21642" href="../Relations/#plfa_plfa-part1-Relations-21642" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21643" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21645" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21646" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21650" href="../Relations/#plfa_plfa-part1-Relations-21650" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21651" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21654" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21657" href="../Relations/#plfa_plfa-part1-Relations-21689" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21664" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21665" href="../Relations/#plfa_plfa-part1-Relations-21511" class="Function">≤-total′</a> <a id="plfa_plfa-part1-Relations-21674" href="../Relations/#plfa_plfa-part1-Relations-21642" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21676" href="../Relations/#plfa_plfa-part1-Relations-21650" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21677" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21681" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Relations-21689" href="../Relations/#plfa_plfa-part1-Relations-21689" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21696" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-21698" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21704" href="../Relations/#plfa_plfa-part1-Relations-21642" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-21706" href="../Relations/#plfa_plfa-part1-Relations-21650" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-21708" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-21710" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-21716" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21717" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21721" href="../Relations/#plfa_plfa-part1-Relations-21642" class="Bound">m</a><a id="plfa_plfa-part1-Relations-21722" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-21724" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-21729" href="../Relations/#plfa_plfa-part1-Relations-21650" class="Bound">n</a><a id="plfa_plfa-part1-Relations-21730" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21734" href="../Relations/#plfa_plfa-part1-Relations-21689" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21741" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21742" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21750" href="../Relations/#plfa_plfa-part1-Relations-21750" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21753" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21756" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21759" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-21767" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21768" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21772" href="../Relations/#plfa_plfa-part1-Relations-21750" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-21775" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-21779" href="../Relations/#plfa_plfa-part1-Relations-21689" class="Function">helper</a> <a id="plfa_plfa-part1-Relations-21786" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21787" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21795" href="../Relations/#plfa_plfa-part1-Relations-21795" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21798" class="Symbol">)</a>  <a id="plfa_plfa-part1-Relations-21801" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-21804" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-21812" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-21813" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-21817" href="../Relations/#plfa_plfa-part1-Relations-21795" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-21820" class="Symbol">)</a>
</pre><p>这也是我们第一次在 Agda 中使用 <code>where</code> 语句。<code>where</code> 关键字后面有一或多条定义，其必须被缩进。 之前等式左手边的约束变量（此例中的 <code>m</code> 和 <code>n</code>）在嵌套的定义中仍然在作用域内。 在嵌套定义中的约束标识符（此例中的 <code>helper</code> ）在等式的右手边的作用域内。</p><p>如果两个参数相同，那么两个情况同时成立，我们可以返回任一证明。上面的代码中我们返回 forward 条件， 但是我们也可以返回 flipped 条件，如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-≤-total″"></a><a id="plfa_plfa-part1-Relations-22692" href="../Relations/#plfa_plfa-part1-Relations-22692" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22701" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22703" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-22705" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22706" href="../Relations/#plfa_plfa-part1-Relations-22706" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22708" href="../Relations/#plfa_plfa-part1-Relations-22708" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-22710" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-22712" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-22713" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22715" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-22717" href="../Relations/#plfa_plfa-part1-Relations-17218" class="Datatype">Total</a> <a id="plfa_plfa-part1-Relations-22723" href="../Relations/#plfa_plfa-part1-Relations-22706" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22725" href="../Relations/#plfa_plfa-part1-Relations-22708" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22727" href="../Relations/#plfa_plfa-part1-Relations-22692" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22736" href="../Relations/#plfa_plfa-part1-Relations-22736" class="Bound">m</a>       <a id="plfa_plfa-part1-Relations-22744" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>                      <a id="plfa_plfa-part1-Relations-22770" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22773" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22781" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22785" href="../Relations/#plfa_plfa-part1-Relations-22692" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22794" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-22802" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22803" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22807" href="../Relations/#plfa_plfa-part1-Relations-22807" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22808" class="Symbol">)</a>                   <a id="plfa_plfa-part1-Relations-22828" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22831" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22839" href="../Relations/#plfa_plfa-part1-Relations-1407" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Relations-22843" href="../Relations/#plfa_plfa-part1-Relations-22692" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22852" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22853" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22857" href="../Relations/#plfa_plfa-part1-Relations-22857" class="Bound">m</a><a id="plfa_plfa-part1-Relations-22858" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22860" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22861" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-22865" href="../Relations/#plfa_plfa-part1-Relations-22865" class="Bound">n</a><a id="plfa_plfa-part1-Relations-22866" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-22868" class="Keyword">with</a> <a id="plfa_plfa-part1-Relations-22873" href="../Relations/#plfa_plfa-part1-Relations-22692" class="Function">≤-total″</a> <a id="plfa_plfa-part1-Relations-22882" href="../Relations/#plfa_plfa-part1-Relations-22857" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-22884" href="../Relations/#plfa_plfa-part1-Relations-22865" class="Bound">n</a>
<a id="plfa_plfa-part1-Relations-22886" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22914" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22916" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22924" href="../Relations/#plfa_plfa-part1-Relations-22924" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-22929" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22932" href="../Relations/#plfa_plfa-part1-Relations-17249" class="InductiveConstructor">forward</a> <a id="plfa_plfa-part1-Relations-22940" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-22941" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-22945" href="../Relations/#plfa_plfa-part1-Relations-22924" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-22948" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-22950" class="Symbol">...</a>                         <a id="plfa_plfa-part1-Relations-22978" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-22980" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-22988" href="../Relations/#plfa_plfa-part1-Relations-22988" class="Bound">n≤m</a>  <a id="plfa_plfa-part1-Relations-22993" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-22996" href="../Relations/#plfa_plfa-part1-Relations-17306" class="InductiveConstructor">flipped</a> <a id="plfa_plfa-part1-Relations-23004" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23005" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23009" href="../Relations/#plfa_plfa-part1-Relations-22988" class="Bound">n≤m</a><a id="plfa_plfa-part1-Relations-23012" class="Symbol">)</a>
</pre><p>两者的区别在于上述代码在对于第一个参数进行模式匹配之前先对于第二个参数先进行模式匹配。</p><h2 id="单调性">单调性</h2><p>如果在聚会中碰到了一个运算符和一个序，那么有人可能会问这个运算符对于这个序是不是 <strong>单调的（Monotonic）</strong>。比如说，加法对于小于等于是单调的，这意味着：</p><pre><code>∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q</code></pre><p>这个证明可以用我们学会的方法，很直接的来完成。我们最好把它分成三个部分，首先我们证明加法对于 小于等于在右手边是单调的：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoʳ-≤"></a><a id="plfa_plfa-part1-Relations-23842" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23852" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23854" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-23856" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23857" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23859" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23861" href="../Relations/#plfa_plfa-part1-Relations-23861" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23863" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-23865" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-23866" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-23870" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23872" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23874" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23876" href="../Relations/#plfa_plfa-part1-Relations-23861" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-23882" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-23898" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-23900" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23902" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23904" href="../Relations/#plfa_plfa-part1-Relations-23859" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23906" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-23908" href="../Relations/#plfa_plfa-part1-Relations-23857" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23910" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-23912" href="../Relations/#plfa_plfa-part1-Relations-23861" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-23914" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Relations-23932" href="../Relations/#plfa_plfa-part1-Relations-23932" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23934" href="../Relations/#plfa_plfa-part1-Relations-23934" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23936" href="../Relations/#plfa_plfa-part1-Relations-23936" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23941" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23944" href="../Relations/#plfa_plfa-part1-Relations-23936" class="Bound">p≤q</a>
<a id="plfa_plfa-part1-Relations-23948" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23958" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23959" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-23963" href="../Relations/#plfa_plfa-part1-Relations-23963" class="Bound">n</a><a id="plfa_plfa-part1-Relations-23964" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-23966" href="../Relations/#plfa_plfa-part1-Relations-23966" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23968" href="../Relations/#plfa_plfa-part1-Relations-23968" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23970" href="../Relations/#plfa_plfa-part1-Relations-23970" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-23975" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-23978" href="../Relations/#plfa_plfa-part1-Relations-1456" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Relations-23982" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-23983" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-23993" href="../Relations/#plfa_plfa-part1-Relations-23963" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-23995" href="../Relations/#plfa_plfa-part1-Relations-23966" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-23997" href="../Relations/#plfa_plfa-part1-Relations-23968" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-23999" href="../Relations/#plfa_plfa-part1-Relations-23970" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-24002" class="Symbol">)</a>
</pre><p>我们对于第一个参数进行归纳。</p><ul><li><p><strong>起始步骤</strong>：第一个参数是 <code>zero</code>，那么 <code>zero + p ≤ zero + q</code> 可以化简为 <code>p ≤ q</code>， 其证明由 <code>p≤q</code> 给出。</p></li><li><p><strong>归纳步骤</strong>：第一个参数是 <code>suc n</code>，那么 <code>suc n + p ≤ suc n + q</code> 可以化简为 <code>suc (n + p) ≤ suc (n + q)</code>。归纳假设 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，我们在此之上使用 <code>s≤s</code> 即可得证。</p></li></ul><p>接下来，我们证明加法对于小于等于在左手边是单调的。我们可以用之前的结论和加法的交换律来证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-monoˡ-≤"></a><a id="plfa_plfa-part1-Relations-24974" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-24984" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24986" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-24988" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-24989" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-24991" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-24993" href="../Relations/#plfa_plfa-part1-Relations-24993" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-24995" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-24997" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-24998" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25002" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25004" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25006" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25008" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-25014" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25030" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25032" href="../Relations/#plfa_plfa-part1-Relations-24989" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25034" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25036" href="../Relations/#plfa_plfa-part1-Relations-24993" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25038" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25040" href="../Relations/#plfa_plfa-part1-Relations-24991" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25042" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25044" href="../Relations/#plfa_plfa-part1-Relations-24993" class="Bound">p</a>
<a id="plfa_plfa-part1-Relations-25046" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25056" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25058" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25060" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25062" href="../Relations/#plfa_plfa-part1-Relations-25062" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Relations-25067" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Relations-25075" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25082" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25084" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25086" class="Symbol">|</a> <a id="plfa_plfa-part1-Relations-25088" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="plfa_plfa-part1-Relations-25095" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25097" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">p</a>  <a id="plfa_plfa-part1-Relations-25100" class="Symbol">=</a> <a id="plfa_plfa-part1-Relations-25102" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25112" href="../Relations/#plfa_plfa-part1-Relations-25060" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25114" href="../Relations/#plfa_plfa-part1-Relations-25056" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25116" href="../Relations/#plfa_plfa-part1-Relations-25058" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25118" href="../Relations/#plfa_plfa-part1-Relations-25062" class="Bound">m≤n</a>
</pre><p>用 <code>+-comm m p</code> 和 <code>+-comm n p</code> 来重写，可以让 <code>m + p ≤ n + p</code> 转换成 <code>p + n ≤ p + m</code>， 而我们可以用 <code>+-moroʳ-≤ p m n m≤n</code> 来证明。</p><p>最后，我们把前两步的结论结合起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-+-mono-≤"></a><a id="plfa_plfa-part1-Relations-25469" href="../Relations/#plfa_plfa-part1-Relations-25469" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25478" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25480" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-25482" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25483" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25485" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25487" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25489" href="../Relations/#plfa_plfa-part1-Relations-25489" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25491" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-25493" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-25494" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Relations-25498" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25500" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25502" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25504" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">n</a>
  <a id="plfa_plfa-part1-Relations-25508" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25510" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25512" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25514" href="../Relations/#plfa_plfa-part1-Relations-25489" class="Bound">q</a>
    <a id="plfa_plfa-part1-Relations-25520" class="Comment">-------------</a>
  <a id="plfa_plfa-part1-Relations-25536" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-25538" href="../Relations/#plfa_plfa-part1-Relations-25483" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25540" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25542" href="../Relations/#plfa_plfa-part1-Relations-25487" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25544" href="../Relations/#plfa_plfa-part1-Relations-1380" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Relations-25546" href="../Relations/#plfa_plfa-part1-Relations-25485" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25548" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-25550" href="../Relations/#plfa_plfa-part1-Relations-25489" class="Bound">q</a>
<a id="plfa_plfa-part1-Relations-25552" href="../Relations/#plfa_plfa-part1-Relations-25469" class="Function">+-mono-≤</a> <a id="plfa_plfa-part1-Relations-25561" href="../Relations/#plfa_plfa-part1-Relations-25561" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25563" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25565" href="../Relations/#plfa_plfa-part1-Relations-25565" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25567" href="../Relations/#plfa_plfa-part1-Relations-25567" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25569" href="../Relations/#plfa_plfa-part1-Relations-25569" class="Bound">m≤n</a> <a id="plfa_plfa-part1-Relations-25573" href="../Relations/#plfa_plfa-part1-Relations-25573" class="Bound">p≤q</a>  <a id="plfa_plfa-part1-Relations-25578" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-25581" href="../Relations/#plfa_plfa-part1-Relations-12471" class="Function">≤-trans</a> <a id="plfa_plfa-part1-Relations-25589" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25590" href="../Relations/#plfa_plfa-part1-Relations-24974" class="Function">+-monoˡ-≤</a> <a id="plfa_plfa-part1-Relations-25600" href="../Relations/#plfa_plfa-part1-Relations-25561" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-25602" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25604" href="../Relations/#plfa_plfa-part1-Relations-25565" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25606" href="../Relations/#plfa_plfa-part1-Relations-25569" class="Bound">m≤n</a><a id="plfa_plfa-part1-Relations-25609" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-25611" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-25612" href="../Relations/#plfa_plfa-part1-Relations-23842" class="Function">+-monoʳ-≤</a> <a id="plfa_plfa-part1-Relations-25622" href="../Relations/#plfa_plfa-part1-Relations-25563" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-25624" href="../Relations/#plfa_plfa-part1-Relations-25565" class="Bound">p</a> <a id="plfa_plfa-part1-Relations-25626" href="../Relations/#plfa_plfa-part1-Relations-25567" class="Bound">q</a> <a id="plfa_plfa-part1-Relations-25628" href="../Relations/#plfa_plfa-part1-Relations-25573" class="Bound">p≤q</a><a id="plfa_plfa-part1-Relations-25631" class="Symbol">)</a>
</pre><p>使用 <code>+-monoˡ-≤ m n p m≤n</code> 可以证明 <code>m + p ≤ n + p</code>， 使用 <code>+-monoʳ-≤ n p q p≤q</code> 可以证明 <code>n + p ≤ n + q</code>，用传递性把两者连接起来， 我们可以获得 <code>m + p ≤ n + q</code> 的证明，如上所示。</p><h4 id="练习--mono--延伸">练习 <code>*-mono-≤</code> （延伸）</h4><p>证明乘法对于小于等于是单调的。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26155" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="strict-inequality">严格不等关系</h2><p>我们可以用类似于定义不等关系的方法来定义严格不等关系。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-26362" class="Keyword">infix</a> <a id="plfa_plfa-part1-Relations-26368" class="Number">4</a> <a id="plfa_plfa-part1-Relations-26370" href="../Relations/#plfa_plfa-part1-Relations-26380" class="Datatype Operator">_&lt;_</a>

<a id="plfa_plfa-part1-Relations-26375" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-_&lt;_"></a><a id="plfa_plfa-part1-Relations-26380" href="../Relations/#plfa_plfa-part1-Relations-26380" class="Datatype Operator">_&lt;_</a> <a id="plfa_plfa-part1-Relations-26384" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26386" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26388" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-26392" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26394" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Relations-26398" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.z&lt;s"></a><a id="plfa_plfa-part1-Relations-26407" href="../Relations/#plfa_plfa-part1-Relations-26407" class="InductiveConstructor">z&lt;s</a> <a id="plfa_plfa-part1-Relations-26411" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26413" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26415" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26416" href="../Relations/#plfa_plfa-part1-Relations-26416" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26418" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26420" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26421" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Relations-26429" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-26446" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26448" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-26453" href="../Relations/#plfa_plfa-part1-Relations-26380" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26455" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26459" href="../Relations/#plfa_plfa-part1-Relations-26416" class="Bound">n</a>

  <a id="plfa_plfa-part1-Relations-_&lt;_.s&lt;s"></a><a id="plfa_plfa-part1-Relations-26464" href="../Relations/#plfa_plfa-part1-Relations-26464" class="InductiveConstructor">s&lt;s</a> <a id="plfa_plfa-part1-Relations-26468" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26470" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-26472" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-26473" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26475" href="../Relations/#plfa_plfa-part1-Relations-26475" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-26477" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-26479" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-26480" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-26486" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26488" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26490" href="../Relations/#plfa_plfa-part1-Relations-26380" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26492" href="../Relations/#plfa_plfa-part1-Relations-26475" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-26500" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Relations-26518" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-26520" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26524" href="../Relations/#plfa_plfa-part1-Relations-26473" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-26526" href="../Relations/#plfa_plfa-part1-Relations-26380" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Relations-26528" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-26532" href="../Relations/#plfa_plfa-part1-Relations-26475" class="Bound">n</a>
</pre><p>严格不等关系与不等关系最重要的区别在于，0 小于任何数的后继，而不小于 0。</p><p>显然，严格不等关系不是自反的，而是<strong>非自反的（Irreflexive）</strong>，表示 <code>n &lt; n</code> 对于 任何值 <code>n</code> 都不成立。和不等关系一样，严格不等关系是传递的。严格不等关系不是完全的，但是满足 一个相似的性质：<strong>三分律（Trichotomy）</strong>：对于任意的 <code>m</code> 和 <code>n</code>，<code>m &lt; n</code>、<code>m ≡ n</code> 或者 <code>m &gt; n</code> 三者有且仅有一者成立。（我们定义 <code>m &gt; n</code> 当且仅当 <code>n &lt; m</code> 成立时成立） 严格不等关系对于加法和乘法也是单调的。</p><p>我们把一部分上述性质作为习题。非自反性需要逻辑非，三分律需要证明三者是互斥的，因此这两个性质 暂不做为习题。我们会在 <a href="../Negation/">Negation</a> 章节来重新讨论。</p><p>我们可以直接地来证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。 因此我们亦可从不等关系的性质中，使用此性质来证明严格不等关系的性质。</p><h4 id="less-trans">练习 <code>&lt;-trans</code> （推荐）</h4><p>证明严格不等是传递的。请直接证明。（后续的练习中我们将使用 &lt; 和 ≤ 的关系。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-28352" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="trichotomy">练习 <code>trichotomy</code>（实践）</h4><p>证明严格不等关系满足弱化的三元律，证明对于任意 <code>m</code> 和 <code>n</code>，下列命题有一条成立：</p><ul><li><code>m &lt; n</code>，</li><li><code>m ≡ n</code>，或者</li><li><code>m &gt; n</code>。</li></ul><p>定义 <code>m &gt; n</code> 为 <code>n &lt; m</code>。你需要一个合适的数据类型声明，如同我们在证明完全性中使用的那样。 （我们会在介绍完<a href="../Negation/">否定</a>之后证明三者是互斥的。）</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29076" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="plus-mono-less">练习 <code>+-mono-&lt;</code>（实践）</h4><p>证明加法对于严格不等关系是单调的。正如不等关系中那样，你可以需要额外的定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29392" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="leq-iff-less">练习 <code>≤-iff-&lt;</code> (推荐)</h4><p>证明 <code>suc m ≤ n</code> 蕴涵了 <code>m &lt; n</code>，及其逆命题。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-29624" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="less-trans-revisited">练习 <code>&lt;-trans-revisited</code>（实践）</h4><p>用另外一种方法证明严格不等是传递的，使用之前证明的不等关系和严格不等关系的联系， 以及不等关系的传递性。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30020" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="even-and-odd">奇和偶</h2><p>作为一个额外的例子，我们来定义奇数和偶数。不等关系和严格不等关系是<strong>二元关系</strong>，而奇偶性 是<strong>一元关系</strong>，有时也被叫做<strong>谓词（Predicate）</strong>：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-30379" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-even"></a><a id="plfa_plfa-part1-Relations-30384" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30389" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30391" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30393" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30395" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Relations-30399" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-odd"></a><a id="plfa_plfa-part1-Relations-30404" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Relations-30409" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30411" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Relations-30413" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30415" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Relations-30420" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30425" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30430" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-even.zero"></a><a id="plfa_plfa-part1-Relations-30439" href="../Relations/#plfa_plfa-part1-Relations-30439" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Relations-30444" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Relations-30452" class="Comment">---------</a>
      <a id="plfa_plfa-part1-Relations-30468" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30473" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Relations-even.suc"></a><a id="plfa_plfa-part1-Relations-30481" href="../Relations/#plfa_plfa-part1-Relations-30481" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30486" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30488" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30490" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30491" href="../Relations/#plfa_plfa-part1-Relations-30491" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30493" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30495" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30496" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30502" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30504" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30508" href="../Relations/#plfa_plfa-part1-Relations-30491" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30516" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Relations-30533" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30535" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30540" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30541" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30545" href="../Relations/#plfa_plfa-part1-Relations-30491" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30546" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-30549" class="Keyword">data</a> <a id="plfa_plfa-part1-Relations-30554" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30558" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Relations-odd.suc"></a><a id="plfa_plfa-part1-Relations-30567" href="../Relations/#plfa_plfa-part1-Relations-30567" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Relations-30572" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30574" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-30576" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-30577" href="../Relations/#plfa_plfa-part1-Relations-30577" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-30579" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-30581" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-30582" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Relations-30588" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30590" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-30595" href="../Relations/#plfa_plfa-part1-Relations-30577" class="Bound">n</a>
      <a id="plfa_plfa-part1-Relations-30603" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Relations-30619" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-30621" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-30625" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-30626" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-30630" href="../Relations/#plfa_plfa-part1-Relations-30577" class="Bound">n</a><a id="plfa_plfa-part1-Relations-30631" class="Symbol">)</a>
</pre><p>一个数是偶数，如果它是 0，或者是奇数的后继。一个数是奇数，如果它是偶数的后继。</p><p>这是我们第一次定义一个相互递归的数据类型。因为每个标识符必须在使用前声明，所以 我们首先声明索引数据类型 <code>even</code> 和 <code>odd</code> （省略 <code>where</code> 关键字和其构造子的定义）， 然后声明其构造子（省略其签名 <code>ℕ → Set</code>，因为在之前已经给出）。</p><p>这也是我们第一次使用<strong>重载（Overloaded）</strong>的构造子。这意味着不同类型的构造子 拥有相同的名字。在这里 <code>suc</code> 表示下面三种构造子其中之一：</p><pre><code>suc : ℕ → ℕ

suc : ∀ {n : ℕ}
  → odd n
    ------------
  → even (suc n)

suc : ∀ {n : ℕ}
  → even n
    -----------
  → odd (suc n)</code></pre><p>同理，<code>zero</code> 表示两种构造子的一种。因为类型推导的限制，Agda 不允许重载已定义的名字， 但是允许重载构造子。我们推荐将重载限制在有关联的定义中，如我们所做的这样，但这不是必须的。</p><p>我们证明两个偶数之和是偶数：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-e+e≡e"></a><a id="plfa_plfa-part1-Relations-32208" href="../Relations/#plfa_plfa-part1-Relations-32208" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32214" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32216" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32218" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32219" href="../Relations/#plfa_plfa-part1-Relations-32219" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32221" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32223" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32225" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32226" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32230" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32232" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32237" href="../Relations/#plfa_plfa-part1-Relations-32219" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32241" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32243" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32248" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32254" class="Comment">------------</a>
  <a id="plfa_plfa-part1-Relations-32269" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32271" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32276" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32277" href="../Relations/#plfa_plfa-part1-Relations-32219" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32279" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32281" href="../Relations/#plfa_plfa-part1-Relations-32221" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32282" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-o+e≡o"></a><a id="plfa_plfa-part1-Relations-32285" href="../Relations/#plfa_plfa-part1-Relations-32285" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32291" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32293" class="Symbol">∀</a> <a id="plfa_plfa-part1-Relations-32295" class="Symbol">{</a><a id="plfa_plfa-part1-Relations-32296" href="../Relations/#plfa_plfa-part1-Relations-32296" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32298" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">n</a> <a id="plfa_plfa-part1-Relations-32300" class="Symbol">:</a> <a id="plfa_plfa-part1-Relations-32302" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Relations-32303" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Relations-32307" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32309" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32313" href="../Relations/#plfa_plfa-part1-Relations-32296" class="Bound">m</a>
  <a id="plfa_plfa-part1-Relations-32317" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32319" href="../Relations/#plfa_plfa-part1-Relations-30384" class="Datatype">even</a> <a id="plfa_plfa-part1-Relations-32324" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">n</a>
    <a id="plfa_plfa-part1-Relations-32330" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Relations-32344" class="Symbol">→</a> <a id="plfa_plfa-part1-Relations-32346" href="../Relations/#plfa_plfa-part1-Relations-30404" class="Datatype">odd</a> <a id="plfa_plfa-part1-Relations-32350" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32351" href="../Relations/#plfa_plfa-part1-Relations-32296" class="Bound">m</a> <a id="plfa_plfa-part1-Relations-32353" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Relations-32355" href="../Relations/#plfa_plfa-part1-Relations-32298" class="Bound">n</a><a id="plfa_plfa-part1-Relations-32356" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32359" href="../Relations/#plfa_plfa-part1-Relations-32208" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32365" href="../Relations/#plfa_plfa-part1-Relations-30439" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Relations-32374" href="../Relations/#plfa_plfa-part1-Relations-32374" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32378" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32381" href="../Relations/#plfa_plfa-part1-Relations-32374" class="Bound">en</a>
<a id="plfa_plfa-part1-Relations-32384" href="../Relations/#plfa_plfa-part1-Relations-32208" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32390" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32391" href="../Relations/#plfa_plfa-part1-Relations-30481" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32395" href="../Relations/#plfa_plfa-part1-Relations-32395" class="Bound">om</a><a id="plfa_plfa-part1-Relations-32397" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32399" href="../Relations/#plfa_plfa-part1-Relations-32399" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32403" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32406" href="../Relations/#plfa_plfa-part1-Relations-30481" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32410" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32411" href="../Relations/#plfa_plfa-part1-Relations-32285" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32417" href="../Relations/#plfa_plfa-part1-Relations-32395" class="Bound">om</a> <a id="plfa_plfa-part1-Relations-32420" href="../Relations/#plfa_plfa-part1-Relations-32399" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32422" class="Symbol">)</a>

<a id="plfa_plfa-part1-Relations-32425" href="../Relations/#plfa_plfa-part1-Relations-32285" class="Function">o+e≡o</a> <a id="plfa_plfa-part1-Relations-32431" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32432" href="../Relations/#plfa_plfa-part1-Relations-30567" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32436" href="../Relations/#plfa_plfa-part1-Relations-32436" class="Bound">em</a><a id="plfa_plfa-part1-Relations-32438" class="Symbol">)</a> <a id="plfa_plfa-part1-Relations-32440" href="../Relations/#plfa_plfa-part1-Relations-32440" class="Bound">en</a>  <a id="plfa_plfa-part1-Relations-32444" class="Symbol">=</a>  <a id="plfa_plfa-part1-Relations-32447" href="../Relations/#plfa_plfa-part1-Relations-30567" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Relations-32451" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-32452" href="../Relations/#plfa_plfa-part1-Relations-32208" class="Function">e+e≡e</a> <a id="plfa_plfa-part1-Relations-32458" href="../Relations/#plfa_plfa-part1-Relations-32436" class="Bound">em</a> <a id="plfa_plfa-part1-Relations-32461" href="../Relations/#plfa_plfa-part1-Relations-32440" class="Bound">en</a><a id="plfa_plfa-part1-Relations-32463" class="Symbol">)</a>
</pre><p>与相互递归的定义对应，我们用两个相互递归的函数，一个证明两个偶数之和是偶数，另一个证明 一个奇数与一个偶数之和是奇数。</p><p>这是我们第一次使用相互递归的函数。因为每个标识符必须在使用前声明，我们先给出两个函数的签名， 然后再给出其定义。</p><p>要证明两个偶数之和为偶，我们考虑第一个数为偶数的证明。如果是因为第一个数为 0， 那么第二个数为偶数的证明即为和为偶数的证明。如果是因为第一个数为奇数的后继， 那么和为偶数是因为他是一个奇数和一个偶数的和的后续，而这个和是一个奇数。</p><p>要证明一个奇数和一个偶数的和是奇数，我们考虑第一个数是奇数的证明。 如果是因为它是一个偶数的后继，那么和为奇数，因为它是两个偶数之和的后继， 而这个和是一个偶数。</p><h4 id="odd-plus-odd">练习 <code>o+o≡e</code> (延伸)</h4><p>证明两个奇数之和为偶数。</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-34036" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="Bin-predicates">练习 <code>Bin-predicates</code> (延伸)</h4><p>回忆我们在练习 <a href="../Naturals/#Bin">Bin</a> 中定义了一个数据类型 <code>Bin</code> 来用二进制字符串表示自然数。 这个表达方法不是唯一的，因为我们在开头加任意个 0。因此，11 可以由以下方法表示：</p><pre><code>⟨⟩ I O I I
⟨⟩ O O I O I I</code></pre><p>定义一个谓词</p><pre><code>Can : Bin → Set</code></pre><p>其在一个二进制字符串的表示是标准的（Canonical）时成立，表示它没有开头的 0。在两个 11 的表达方式中， 第一个是标准的，而第二个不是。在定义这个谓词时，你需要一个辅助谓词：</p><pre><code>One : Bin → Set</code></pre><p>其仅在一个二进制字符串开头为 1 时成立。一个二进制字符串是标准的，如果它开头是 1 （表示一个正数）， 或者它仅是一个 0 （表示 0）。</p><p>证明递增可以保持标准性。</p><pre><code>Can b
------------
Can (inc b)</code></pre><p>证明从自然数转换成的二进制字符串是标准的。</p><pre><code>----------
Can (to n)</code></pre><p>证明将一个标准的二进制字符串转换成自然数之后，再转换回二进制字符串与原二进制字符串相同。</p><pre><code>Can b
---------------
to (from b) ≡ b</code></pre><p>提示：对于每一条习题，先从 <code>One</code> 的性质开始。 证明以下命题也会很有帮助。</p><pre><code>One b
----------
1 ≤ from b

1 ≤ n
---------------------
to (2 * n) ≡ (to n) O</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Relations-35972" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="标准库">标准库</h2><p>标准库中有类似于本章介绍的定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Relations-36148" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36155" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Relations-36164" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36170" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36171" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Relations-36174" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36176" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Relations-36179" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36181" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Relations-36184" class="Symbol">)</a>
<a id="plfa_plfa-part1-Relations-36186" class="Keyword">import</a> <a id="plfa_plfa-part1-Relations-36193" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Relations-36213" class="Keyword">using</a> <a id="plfa_plfa-part1-Relations-36219" class="Symbol">(</a><a id="plfa_plfa-part1-Relations-36220" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4565" class="Function">≤-refl</a><a id="plfa_plfa-part1-Relations-36226" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36228" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4748" class="Function">≤-trans</a><a id="plfa_plfa-part1-Relations-36235" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36237" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4615" class="Function">≤-antisym</a><a id="plfa_plfa-part1-Relations-36246" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36248" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#4860" class="Function">≤-total</a><a id="plfa_plfa-part1-Relations-36255" class="Symbol">;</a>
                                  <a id="plfa_plfa-part1-Relations-36291" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#18026" class="Function">+-monoʳ-≤</a><a id="plfa_plfa-part1-Relations-36300" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36302" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17936" class="Function">+-monoˡ-≤</a><a id="plfa_plfa-part1-Relations-36311" class="Symbol">;</a> <a id="plfa_plfa-part1-Relations-36313" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#17780" class="Function">+-mono-≤</a><a id="plfa_plfa-part1-Relations-36321" class="Symbol">)</a>
</pre><p>在标准库中，<code>≤-total</code> 是使用析取定义的（我们将在 <a href="../Connectives/">Connectives</a> 章节定义）。 <code>+-monoʳ-≤</code>、<code>+-monoˡ-≤</code> 和 <code>+-mono-≤</code> 的证明方法和本书不同。 更多的参数是隐式申明的。</p><h2 id="unicode">Unicode</h2><p>本章使用了如下 Unicode 符号：</p><pre><code>≤  U+2264  小于等于 (\&lt;=, \le)
≥  U+2265  大于等于 (\&gt;=, \ge)
ˡ  U+02E1  小写字母 L 标识符 (\^l)
ʳ  U+02B3  小写字母 R 标识符 (\^r)</code></pre><p><code>\^l</code> 和 <code>\^r</code> 命令给出了左右箭头，以及上标字母 <code>l</code> 和 <code>r</code>。</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Induction/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Relations.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Equality/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>