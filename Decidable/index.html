<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-oald/giFwKDrcy9DORpCxMSq2IAFjgwVUM5pRbyPtm60xZT/52VIm0b9qqbL2UcrxYzxM4cYrtRk02or57bQsA==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-3emtxUSJDVriAZnzOyZFTRu0beO+lk81E2cRDhzd62DQrlh2u4kR6+lz2dOUNZwPDvGwcqfFRrKJO2Zu0O4IJA==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Decidable</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Decidable: 布尔值与判定过程</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Decidable-122" class="Keyword">module</a> <a id="plfa_plfa-part1-Decidable-129" href="../Decidable/#" class="Module">plfa.part1.Decidable</a> <a id="plfa_plfa-part1-Decidable-150" class="Keyword">where</a>
</pre><p>我们有两种不同的方式来表示关系：一是表示为由关系成立的<strong>证明（Evidence）</strong>所构成的数据类型； 二是表示为一个<strong>计算（Compute）</strong>关系是否成立的函数。在本章中，我们将探讨这两种方式之间的关系。 我们首先研究大家熟悉的<strong>布尔值（Boolean）</strong>记法，但是之后我们会发现，相较布尔值记法， 使用一种新的<strong>可判定性（Decidable）</strong>记法将会是更好的选择。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-771" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-778" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Decidable-816" class="Symbol">as</a> <a id="plfa_plfa-part1-Decidable-819" class="Module">Eq</a>
<a id="plfa_plfa-part1-Decidable-822" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-827" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Decidable-830" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-836" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-837" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Decidable-840" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-842" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Decidable-846" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-848" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-853" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Decidable-868" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-873" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-880" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Decidable-894" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-900" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-901" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-902" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-904" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-908" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-910" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Decidable-913" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-915" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-920" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-927" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="plfa_plfa-part1-Decidable-945" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-951" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-952" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Decidable-955" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-957" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-966" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-967" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Decidable-971" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Decidable-979" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-981" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-986" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-993" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="plfa_plfa-part1-Decidable-1007" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1013" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1014" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Decidable-1017" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1019" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Decidable-1023" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1025" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Decidable-1029" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1031" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1036" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1043" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-1069" class="Symbol">as</a> <a id="plfa_plfa-part1-Decidable-1072" class="Module">Neg</a> <a id="plfa_plfa-part1-Decidable-1076" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1082" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1083" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Decidable-1085" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Decidable-1089" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-1098" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1099" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1270" class="Function">contradiction</a> <a id="plfa_plfa-part1-Decidable-1113" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-1116" class="Function">¬¬-intro</a><a id="plfa_plfa-part1-Decidable-1124" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1126" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1131" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1138" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Decidable-1148" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1154" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1155" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="plfa_plfa-part1-Decidable-1156" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1158" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-1160" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1162" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1167" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1174" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Decidable-1185" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1191" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1192" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a><a id="plfa_plfa-part1-Decidable-1193" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1195" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1200" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1207" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Decidable-1228" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1234" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1235" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">_&lt;_</a><a id="plfa_plfa-part1-Decidable-1238" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1240" href="../Relations/#plfa_plfa-part1-Relations-26387" class="InductiveConstructor">z&lt;s</a><a id="plfa_plfa-part1-Decidable-1243" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1245" href="../Relations/#plfa_plfa-part1-Relations-26444" class="InductiveConstructor">s&lt;s</a><a id="plfa_plfa-part1-Decidable-1248" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1250" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1255" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1262" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Decidable-1285" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1291" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1292" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14965" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Decidable-1295" class="Symbol">)</a>
</pre><h2 id="证据-vs-计算">证据 vs 计算</h2><p>回忆我们在 <a href="../Relations/">Relations</a> 章节中将比较定义为一个归纳数据类型，其提供了一个数小于或等于另外一个数的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-1608" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-1614" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1616" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">_≤_</a>

<a id="plfa_plfa-part1-Decidable-1621" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-_≤_"></a><a id="plfa_plfa-part1-Decidable-1626" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Decidable-1630" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1632" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1634" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1636" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1638" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1640" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-1644" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.z≤n"></a><a id="plfa_plfa-part1-Decidable-1653" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Decidable-1657" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1659" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1661" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1662" href="../Decidable/#plfa_plfa-part1-Decidable-1662" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1664" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1666" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1667" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Decidable-1675" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Decidable-1688" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1690" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-1695" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1697" href="../Decidable/#plfa_plfa-part1-Decidable-1662" class="Bound">n</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.s≤s"></a><a id="plfa_plfa-part1-Decidable-1702" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1706" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1708" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1710" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1711" href="../Decidable/#plfa_plfa-part1-Decidable-1711" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1713" href="../Decidable/#plfa_plfa-part1-Decidable-1713" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1715" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1717" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1718" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Decidable-1724" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1726" href="../Decidable/#plfa_plfa-part1-Decidable-1711" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1728" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1730" href="../Decidable/#plfa_plfa-part1-Decidable-1713" class="Bound">n</a>
      <a id="plfa_plfa-part1-Decidable-1738" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Decidable-1756" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1758" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1762" href="../Decidable/#plfa_plfa-part1-Decidable-1711" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1764" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1766" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1770" href="../Decidable/#plfa_plfa-part1-Decidable-1713" class="Bound">n</a>
</pre><p>举例来说，我们提供 <code>2 ≤ 4</code> 成立的证明，也可以证明没有 <code>4 ≤ 2</code> 成立的证明。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2≤4"></a><a id="plfa_plfa-part1-Decidable-1947" href="../Decidable/#plfa_plfa-part1-Decidable-1947" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1951" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1953" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-1955" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1957" class="Number">4</a>
<a id="plfa_plfa-part1-Decidable-1959" href="../Decidable/#plfa_plfa-part1-Decidable-1947" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1963" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-1965" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1969" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1970" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1974" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-1977" class="Symbol">)</a>

<a id="plfa_plfa-part1-Decidable-¬4≤2"></a><a id="plfa_plfa-part1-Decidable-1980" href="../Decidable/#plfa_plfa-part1-Decidable-1980" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-1985" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1987" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-1989" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1990" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1992" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1994" class="Number">2</a><a id="plfa_plfa-part1-Decidable-1995" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1997" href="../Decidable/#plfa_plfa-part1-Decidable-1980" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-2002" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2003" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2007" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2008" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2012" class="Symbol">()))</a>
</pre><p><code>()</code> 的出现表明了没有 <code>2 ≤ 0</code> 成立的证明：<code>z≤n</code> 不能匹配（因为 <code>2</code> 不是 <code>zero</code>），<code>s≤s</code> 也不能匹配（因为 <code>0</code> 不能匹配 <code>suc n</code>）。</p><p>作为替代的定义，我们可以定义一个大家可能比较熟悉的布尔类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2456" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Bool"></a><a id="plfa_plfa-part1-Decidable-2461" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-2466" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2468" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-2472" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Bool.true"></a><a id="plfa_plfa-part1-Decidable-2480" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-2486" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2488" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-Bool.false"></a><a id="plfa_plfa-part1-Decidable-2495" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-2501" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2503" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
</pre><p>给定了布尔类型，我们可以定义一个两个数的函数在比较关系成立时来<strong>计算</strong>出 <code>true</code>， 否则计算出 <code>false</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2726" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-2732" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2734" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">_≤ᵇ_</a>

<a id="plfa_plfa-part1-Decidable-_≤ᵇ_"></a><a id="plfa_plfa-part1-Decidable-2740" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">_≤ᵇ_</a> <a id="plfa_plfa-part1-Decidable-2745" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2747" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2749" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2751" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2753" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2755" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-2760" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-2765" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2768" href="../Decidable/#plfa_plfa-part1-Decidable-2768" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-2776" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2779" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-2784" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2788" href="../Decidable/#plfa_plfa-part1-Decidable-2788" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2790" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2793" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>   <a id="plfa_plfa-part1-Decidable-2800" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2803" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-2809" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2813" href="../Decidable/#plfa_plfa-part1-Decidable-2813" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2815" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2818" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2822" href="../Decidable/#plfa_plfa-part1-Decidable-2822" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-2825" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2828" href="../Decidable/#plfa_plfa-part1-Decidable-2813" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2830" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2833" href="../Decidable/#plfa_plfa-part1-Decidable-2822" class="Bound">n</a>
</pre><p>定义中的第一条与最后一条与归纳数据类型中的两个构造子相对应。因为对于任意的 <code>m</code>，不可能出现 <code>suc m ≤ zero</code> 的证明，我们使用中间一条定义来表示。 举个例子，我们可以计算 <code>2 ≤ᵇ 4</code> 成立，也可以计算 <code>4 ≤ᵇ 2</code> 不成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-3301" href="../Decidable/#plfa_plfa-part1-Decidable-3301" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3303" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3305" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3306" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3308" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3311" class="Number">4</a><a id="plfa_plfa-part1-Decidable-3312" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3314" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3316" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-3321" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3323" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3327" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3337" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3339" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3342" class="Number">4</a>
  <a id="plfa_plfa-part1-Decidable-3346" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3354" class="Number">1</a> <a id="plfa_plfa-part1-Decidable-3356" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3359" class="Number">3</a>
  <a id="plfa_plfa-part1-Decidable-3363" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3371" class="Number">0</a> <a id="plfa_plfa-part1-Decidable-3373" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3376" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3380" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3388" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
  <a id="plfa_plfa-part1-Decidable-3395" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Decidable-3398" href="../Decidable/#plfa_plfa-part1-Decidable-3398" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3400" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3402" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3403" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3405" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3408" class="Number">2</a><a id="plfa_plfa-part1-Decidable-3409" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3411" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3413" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-3419" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3421" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3425" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3435" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3437" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3440" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3444" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3452" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-3454" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3457" class="Number">1</a>
  <a id="plfa_plfa-part1-Decidable-3461" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3469" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3471" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3474" class="Number">0</a>
  <a id="plfa_plfa-part1-Decidable-3478" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3486" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
  <a id="plfa_plfa-part1-Decidable-3494" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>在第一种情况中，我们需要两步来将第一个参数降低到 0，再用一步来计算出真，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>z≤n</code> 来证明 <code>2 ≤ 4</code>。 在第二种情况中，我们需要两步来将第二个参数降低到 0，再用一步来计算出假，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>()</code> 来说明没有 <code>4 ≤ 2</code> 的证明。</p><h2 id="relating-evidence-and-computation">将证明与计算相联系</h2><p>我们希望能够证明这两种方法是有联系的，而我们的确可以。 首先，我们定义一个函数来把计算世界映射到证明世界：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T"></a><a id="plfa_plfa-part1-Decidable-4472" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4474" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4476" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-4481" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4483" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-4487" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4489" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-4496" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4499" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="plfa_plfa-part1-Decidable-4501" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4503" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-4510" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4513" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a>
</pre><p>回忆到 <code>⊤</code> 是只有一个元素 <code>tt</code> 的单元类型，<code>⊥</code> 是没有值的空类型。（注意 <code>T</code> 是大写字母 <code>t</code>， 与 <code>⊤</code> 不同。）如果 <code>b</code> 是 <code>Bool</code> 类型的，那么如果 <code>b</code> 为真，<code>tt</code> 可以提供 <code>T b</code> 成立的证明； 如果 <code>b</code> 为假，则不可能有 <code>T b</code> 成立的证明。</p><p>换句话说，<code>T b</code> 当且仅当 <code>b ≡ true</code> 成立时成立。在向前的方向，我们需要针对 <code>b</code> 进行情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T→≡"></a><a id="plfa_plfa-part1-Decidable-5282" href="../Decidable/#plfa_plfa-part1-Decidable-5282" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5286" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5288" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5290" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-5291" href="../Decidable/#plfa_plfa-part1-Decidable-5291" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5293" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5295" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5299" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-5301" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5303" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5305" href="../Decidable/#plfa_plfa-part1-Decidable-5291" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5307" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5309" href="../Decidable/#plfa_plfa-part1-Decidable-5291" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5311" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5313" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-5318" href="../Decidable/#plfa_plfa-part1-Decidable-5282" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5322" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5327" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>   <a id="plfa_plfa-part1-Decidable-5332" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5335" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Decidable-5340" href="../Decidable/#plfa_plfa-part1-Decidable-5282" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5344" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-5350" class="Symbol">()</a>
</pre><p>如果 <code>b</code> 为真，那么 <code>T b</code> 由 <code>tt</code> 证明，<code>b ≡ true</code> 由 <code>refl</code> 证明。 当 <code>b</code> 为假，那么 <code>T b</code> 无法证明。</p><p>在向后的方向，不需要针对布尔值 <code>b</code> 的情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≡→T"></a><a id="plfa_plfa-part1-Decidable-5710" href="../Decidable/#plfa_plfa-part1-Decidable-5710" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5714" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5716" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5718" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-5719" href="../Decidable/#plfa_plfa-part1-Decidable-5719" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5721" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5723" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5727" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-5729" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5731" href="../Decidable/#plfa_plfa-part1-Decidable-5719" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5733" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5735" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5740" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5742" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5744" href="../Decidable/#plfa_plfa-part1-Decidable-5719" class="Bound">b</a>
<a id="plfa_plfa-part1-Decidable-5746" href="../Decidable/#plfa_plfa-part1-Decidable-5710" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5750" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>  <a id="plfa_plfa-part1-Decidable-5756" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5759" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
</pre><p>如果 <code>b ≡ true</code> 由 <code>refl</code> 证明，我们知道 <code>b</code> 是 <code>true</code>，因此 <code>T b</code> 由 <code>tt</code> 证明。</p><p>现在我们可以证明 <code>T (m ≤ᵇ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><p>在向前的方向，我们考虑 <code>_≤ᵇ_</code> 定义中的三条语句：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ→≤"></a><a id="plfa_plfa-part1-Decidable-6212" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6217" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6219" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-6221" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6222" href="../Decidable/#plfa_plfa-part1-Decidable-6222" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6224" href="../Decidable/#plfa_plfa-part1-Decidable-6224" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6226" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6228" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-6229" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6231" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6233" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-6235" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6236" href="../Decidable/#plfa_plfa-part1-Decidable-6222" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6238" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-6241" href="../Decidable/#plfa_plfa-part1-Decidable-6224" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6242" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6244" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6246" href="../Decidable/#plfa_plfa-part1-Decidable-6222" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6248" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-6250" href="../Decidable/#plfa_plfa-part1-Decidable-6224" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-6252" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6257" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6265" href="../Decidable/#plfa_plfa-part1-Decidable-6265" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-6273" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-6277" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6280" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-6284" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6289" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6290" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6294" href="../Decidable/#plfa_plfa-part1-Decidable-6294" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6295" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6297" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6305" class="Symbol">()</a>
<a id="plfa_plfa-part1-Decidable-6308" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6313" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6314" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6318" href="../Decidable/#plfa_plfa-part1-Decidable-6318" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6319" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6321" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6322" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6326" href="../Decidable/#plfa_plfa-part1-Decidable-6326" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6327" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6329" href="../Decidable/#plfa_plfa-part1-Decidable-6329" class="Bound">t</a>   <a id="plfa_plfa-part1-Decidable-6333" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6336" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-6340" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6341" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6346" href="../Decidable/#plfa_plfa-part1-Decidable-6318" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6348" href="../Decidable/#plfa_plfa-part1-Decidable-6326" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6350" href="../Decidable/#plfa_plfa-part1-Decidable-6329" class="Bound">t</a><a id="plfa_plfa-part1-Decidable-6351" class="Symbol">)</a>
</pre><p>第一条语句中，我们立即可以得出 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 而得， 相对应地 <code>m ≤ n</code> 由 <code>z≤n</code> 而证明。在中间的语句中，我们立刻得出 <code>suc m ≤ᵇ zero</code> 为假，则 <code>T (m ≤ᵇ n)</code> 为空，因此我们无需证明 <code>m ≤ n</code>，同时也不存在这样的证明。在最后的语句中，我们对于 <code>suc m ≤ᵇ suc n</code> 递归至 <code>m ≤ᵇ n</code>。令 <code>t</code> 为 <code>T (suc m ≤ᵇ suc n)</code> 的证明，如果其存在。 根据 <code>_≤ᵇ_</code> 的定义，这也是 <code>T (m ≤ᵇ n)</code> 的证明。我们递归地应用函数来获得 <code>m ≤ n</code> 的证明，再使用 <code>s≤s</code> 将其转换成为 <code>suc m ≤ suc n</code> 的证明。</p><p>在向后的方向，我们考虑 <code>m ≤ n</code> 成立证明的可能形式：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤→≤ᵇ"></a><a id="plfa_plfa-part1-Decidable-7540" href="../Decidable/#plfa_plfa-part1-Decidable-7540" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7545" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7547" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-7549" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-7550" href="../Decidable/#plfa_plfa-part1-Decidable-7550" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7552" href="../Decidable/#plfa_plfa-part1-Decidable-7552" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7554" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7556" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-7557" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-7559" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7561" href="../Decidable/#plfa_plfa-part1-Decidable-7550" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7563" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7565" href="../Decidable/#plfa_plfa-part1-Decidable-7552" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7567" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7569" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-7571" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7572" href="../Decidable/#plfa_plfa-part1-Decidable-7550" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7574" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7577" href="../Decidable/#plfa_plfa-part1-Decidable-7552" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-7578" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-7580" href="../Decidable/#plfa_plfa-part1-Decidable-7540" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7585" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Decidable-7596" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7599" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-7602" href="../Decidable/#plfa_plfa-part1-Decidable-7540" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7607" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7608" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-7612" href="../Decidable/#plfa_plfa-part1-Decidable-7612" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-7615" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-7618" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7621" href="../Decidable/#plfa_plfa-part1-Decidable-7540" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7626" href="../Decidable/#plfa_plfa-part1-Decidable-7612" class="Bound">m≤n</a>
</pre><p>如果证明是 <code>z≤n</code>，我们立即可以得到 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 证明。 如果证明是 <code>s≤s</code> 作用于 <code>m≤n</code>，那么 <code>suc m ≤ᵇ suc n</code> 归约到 <code>m ≤ᵇ n</code>，我们可以递归地使用函数 来获得 <code>T (m ≤ᵇ n)</code> 的证明。</p><p>向前方向的证明比向后方向的证明多一条语句，因为在向前方向的证明中我们需要考虑比较结果为真和假 的语句，而向后方向的证明只需要考虑比较成立的语句。这也是为什么我们比起计算的形式，更加偏爱证明的形式， 因为这样让我们做更少的工作：我们只需要考虑关系成立时的情况，而可以忽略不成立的情况。</p><p>从另一个角度来说，有时计算的性质可能正是我们所需要的。面对一个大数值上的非显然关系， 使用电脑来计算出答案可能会更加方便。幸运的是，比起在<strong>证明</strong>或<strong>计算</strong>之中犹豫， 我们有一种更好的方法来兼取其优。</p><h2 id="the-best-of-both-worlds">取二者之精华</h2><p>一个返回布尔值的函数提供恰好一比特的信息：这个关系成立或是不成立。相反地，证明的形式告诉我们 为什么这个关系成立，但却需要我们自行完成这个证明。不过，我们其实可以简单地定义一个类型来取二者之精华。 我们把它叫做：<code>Dec A</code>，其中 <code>Dec</code> 是<strong>可判定的（Decidable）</strong>的意思。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-9820" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Dec"></a><a id="plfa_plfa-part1-Decidable-9825" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9829" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9830" href="../Decidable/#plfa_plfa-part1-Decidable-9830" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9832" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9834" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-9837" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-9839" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9841" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-9845" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Dec.yes"></a><a id="plfa_plfa-part1-Decidable-9853" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-9857" class="Symbol">:</a>   <a id="plfa_plfa-part1-Decidable-9861" href="../Decidable/#plfa_plfa-part1-Decidable-9830" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9863" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9865" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9869" href="../Decidable/#plfa_plfa-part1-Decidable-9830" class="Bound">A</a>
  <a id="plfa_plfa-part1-Decidable-Dec.no"></a><a id="plfa_plfa-part1-Decidable-9873" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a>  <a id="plfa_plfa-part1-Decidable-9877" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9879" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-9881" href="../Decidable/#plfa_plfa-part1-Decidable-9830" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9883" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9885" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9889" href="../Decidable/#plfa_plfa-part1-Decidable-9830" class="Bound">A</a>
</pre><p>正如布尔值，这个类型有两个构造子。一个 <code>Dec A</code> 类型的值要么是以 <code>yes x</code> 的形式，其中 <code>x</code> 提供 <code>A</code> 成立的证明，或者是以 <code>no ¬x</code> 的形式，其中 <code>x</code> 提供了 <code>A</code> 无法成立的证明。（也就是说，<code>¬x</code> 是一个给定 <code>A</code> 成立的证据，返回矛盾的函数）</p><p>比如说，我们定义一个函数 <code>_≤?_</code>，给定两个数，判定是否一个数小于等于另一个，并提供证明来说明结论。</p><p>首先，我们使用两个有用的函数，用于构造不等式不成立的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬s≤z"></a><a id="plfa_plfa-part1-Decidable-10738" href="../Decidable/#plfa_plfa-part1-Decidable-10738" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10743" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10745" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10747" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10748" href="../Decidable/#plfa_plfa-part1-Decidable-10748" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10750" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10752" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10753" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10755" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10757" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10759" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10760" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10764" href="../Decidable/#plfa_plfa-part1-Decidable-10748" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10766" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10768" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-10772" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10774" href="../Decidable/#plfa_plfa-part1-Decidable-10738" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10779" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-¬s≤s"></a><a id="plfa_plfa-part1-Decidable-10783" href="../Decidable/#plfa_plfa-part1-Decidable-10783" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10788" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10790" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10792" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10793" href="../Decidable/#plfa_plfa-part1-Decidable-10793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10795" href="../Decidable/#plfa_plfa-part1-Decidable-10795" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-10797" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10799" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10800" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10802" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10804" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10806" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10807" href="../Decidable/#plfa_plfa-part1-Decidable-10793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10809" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10811" href="../Decidable/#plfa_plfa-part1-Decidable-10795" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10812" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10814" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10816" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10818" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10819" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10823" href="../Decidable/#plfa_plfa-part1-Decidable-10793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10825" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10827" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10831" href="../Decidable/#plfa_plfa-part1-Decidable-10795" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10832" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10834" href="../Decidable/#plfa_plfa-part1-Decidable-10783" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10839" href="../Decidable/#plfa_plfa-part1-Decidable-10839" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10844" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10845" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-10849" href="../Decidable/#plfa_plfa-part1-Decidable-10849" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-10852" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10854" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-10856" href="../Decidable/#plfa_plfa-part1-Decidable-10839" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10861" href="../Decidable/#plfa_plfa-part1-Decidable-10849" class="Bound">m≤n</a>
</pre><p>第一个函数断言了 <code>¬ (suc m ≤ zero)</code>，由荒谬可得。因为每个不等式的成立证明必须是 <code>zero ≤ n</code> 或者 <code>suc m ≤ suc n</code> 的形式，两者都无法匹配 <code>suc m ≤ zero</code>。 第二个函数取 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，返回 <code>¬ (suc m ≤ suc n)</code> 的证明。 所有形如 <code>suc m ≤ suc n</code> 的证明必须是以 <code>s≤s m≤n</code> 的形式给出。因此我们可以构造一个 矛盾，以 <code>¬m≤n m≤n</code> 来证明。</p><p>使用这些，我们可以直接的判定不等关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?_"></a><a id="plfa_plfa-part1-Decidable-11676" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">_≤?_</a> <a id="plfa_plfa-part1-Decidable-11681" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11683" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-11685" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11686" href="../Decidable/#plfa_plfa-part1-Decidable-11686" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11688" href="../Decidable/#plfa_plfa-part1-Decidable-11688" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11690" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11692" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-11693" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-11695" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-11697" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-11701" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11702" href="../Decidable/#plfa_plfa-part1-Decidable-11686" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11704" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-11706" href="../Decidable/#plfa_plfa-part1-Decidable-11688" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-11707" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11709" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="plfa_plfa-part1-Decidable-11715" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11718" href="../Decidable/#plfa_plfa-part1-Decidable-11718" class="Bound">n</a>                   <a id="plfa_plfa-part1-Decidable-11738" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11741" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11745" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-11749" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11753" href="../Decidable/#plfa_plfa-part1-Decidable-11753" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11755" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11758" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>                <a id="plfa_plfa-part1-Decidable-11778" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11781" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11784" href="../Decidable/#plfa_plfa-part1-Decidable-10738" class="Function">¬s≤z</a>
<a id="plfa_plfa-part1-Decidable-11789" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11793" href="../Decidable/#plfa_plfa-part1-Decidable-11793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11795" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11798" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11802" href="../Decidable/#plfa_plfa-part1-Decidable-11802" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11804" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-11809" href="../Decidable/#plfa_plfa-part1-Decidable-11793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11811" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11814" href="../Decidable/#plfa_plfa-part1-Decidable-11802" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-11816" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11834" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11836" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11840" href="../Decidable/#plfa_plfa-part1-Decidable-11840" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Decidable-11845" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11848" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11852" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11853" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-11857" href="../Decidable/#plfa_plfa-part1-Decidable-11840" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-11860" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11862" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11880" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11882" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11885" href="../Decidable/#plfa_plfa-part1-Decidable-11885" class="Bound">¬m≤n</a>  <a id="plfa_plfa-part1-Decidable-11891" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11894" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11897" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11898" href="../Decidable/#plfa_plfa-part1-Decidable-10783" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-11903" href="../Decidable/#plfa_plfa-part1-Decidable-11885" class="Bound">¬m≤n</a><a id="plfa_plfa-part1-Decidable-11907" class="Symbol">)</a>
</pre><p>与 <code>_≤ᵇ_</code> 一样，定义有三条语句。第一条语句中，<code>zero ≤ n</code> 立即成立，由 <code>z≤n</code> 证明。 第二条语句中，<code>suc m ≤ zero</code> 立即不成立，由 <code>¬s≤z</code> 证明。 第三条语句中，我们需要递归地应用 <code>m ≤? n</code>。有两种可能性，在 <code>yes</code> 的情况中，它会返回 <code>m ≤ n</code> 的证明 <code>m≤n</code>，所以 <code>s≤s m≤n</code> 即可作为 <code>suc m ≤ suc n</code> 的证明；在 <code>no</code> 的情况中， 它会返回 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，所以 <code>¬s≤s ¬m≤n</code> 即可作为 <code>¬ (suc m ≤ suc n)</code> 的证明。</p><p>当我们写 <code>_≤ᵇ_</code> 时，我们必须写两个其他的函数 <code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 来证明其正确性。 作为对比，<code>_≤?_</code> 的定义自身就证明了其正确性，由类型即可得知。<code>_≤?_</code> 的代码也比 <code>_≤ᵇ_</code>、<code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 加起来要简洁的多。我们稍后将会证明，如果我们需要后三者， 我们亦可简单地从 <code>_≤?_</code> 中派生出来。</p><p>我们可以使用我们新的函数来<strong>计算</strong>出我们之前需要自己想出来的<strong>证明</strong>。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-13562" href="../Decidable/#plfa_plfa-part1-Decidable-13562" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13564" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13566" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13568" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13571" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13573" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13575" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13579" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13580" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13584" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13585" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13589" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-13592" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13595" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13597" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13599" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Decidable-13605" href="../Decidable/#plfa_plfa-part1-Decidable-13605" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13607" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13609" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13611" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13614" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13616" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13618" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-13621" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13622" href="../Decidable/#plfa_plfa-part1-Decidable-10783" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13627" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13628" href="../Decidable/#plfa_plfa-part1-Decidable-10783" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13633" href="../Decidable/#plfa_plfa-part1-Decidable-10738" class="Function">¬s≤z</a><a id="plfa_plfa-part1-Decidable-13637" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13640" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13642" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13644" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>你可以验证 Agda 的确计算出了这些值。输入 <code>C-c C-n</code> 并给出 <code>2 ≤? 4</code> 或者 <code>4 ≤? 2</code> 作为 需要的表达式，Agda 会输出如上的值。</p><p>（小细节：如果我们不把 <code>¬s≤z</code> 和 <code>¬s≤s</code> 作为顶层函数来定义，而是使用内嵌的匿名函数， Agda 可能会在规范化否定的证明中出现问题。）</p><h4 id="练习-__-推荐">练习 <code>_&lt;?_</code> （推荐）</h4><p>与上面的函数相似，定义一个判定严格不等性的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14390" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_&lt;?_"></a><a id="plfa_plfa-part1-Decidable-14402" href="../Decidable/#plfa_plfa-part1-Decidable-14402" class="Postulate Operator">_&lt;?_</a> <a id="plfa_plfa-part1-Decidable-14407" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14409" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14411" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14412" href="../Decidable/#plfa_plfa-part1-Decidable-14412" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14414" href="../Decidable/#plfa_plfa-part1-Decidable-14414" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14416" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14418" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14419" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14421" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14423" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14427" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14428" href="../Decidable/#plfa_plfa-part1-Decidable-14412" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14430" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Decidable-14432" href="../Decidable/#plfa_plfa-part1-Decidable-14414" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14433" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14450" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-_ℕ_实践">练习 <code>_≡ℕ?_</code>（实践）</h4><p>定义一个函数来判定两个自然数是否相等。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14630" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_≡ℕ?_"></a><a id="plfa_plfa-part1-Decidable-14642" href="../Decidable/#plfa_plfa-part1-Decidable-14642" class="Postulate Operator">_≡ℕ?_</a> <a id="plfa_plfa-part1-Decidable-14648" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14650" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14652" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14653" href="../Decidable/#plfa_plfa-part1-Decidable-14653" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14655" href="../Decidable/#plfa_plfa-part1-Decidable-14655" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14657" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14659" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14660" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14662" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14664" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14668" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14669" href="../Decidable/#plfa_plfa-part1-Decidable-14653" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14671" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-14673" href="../Decidable/#plfa_plfa-part1-Decidable-14655" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14674" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14691" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="decidables-from-booleans-and-booleans-from-decidables">从可判定的值到布尔值，从布尔值到可判定的值</h2><p>好奇的读者可能会思考能不能重用 <code>m ≤ᵇ n</code> 的定义，加上它与 <code>m ≤ n</code> 等价的证明， 来证明可判定性。的确，我们是可以做到的：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?′_"></a><a id="plfa_plfa-part1-Decidable-15139" href="../Decidable/#plfa_plfa-part1-Decidable-15139" class="Function Operator">_≤?′_</a> <a id="plfa_plfa-part1-Decidable-15145" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15147" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-15149" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15150" href="../Decidable/#plfa_plfa-part1-Decidable-15150" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15152" href="../Decidable/#plfa_plfa-part1-Decidable-15152" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15154" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15156" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-15157" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-15159" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15161" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15165" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15166" href="../Decidable/#plfa_plfa-part1-Decidable-15150" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15168" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-15170" href="../Decidable/#plfa_plfa-part1-Decidable-15152" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15171" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15173" href="../Decidable/#plfa_plfa-part1-Decidable-15173" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15175" href="../Decidable/#plfa_plfa-part1-Decidable-15139" class="Function Operator">≤?′</a> <a id="plfa_plfa-part1-Decidable-15179" href="../Decidable/#plfa_plfa-part1-Decidable-15179" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15181" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-15186" href="../Decidable/#plfa_plfa-part1-Decidable-15173" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15188" href="../Decidable/#plfa_plfa-part1-Decidable-2740" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15191" href="../Decidable/#plfa_plfa-part1-Decidable-15179" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15193" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15195" href="../Decidable/#plfa_plfa-part1-Decidable-6212" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-15200" href="../Decidable/#plfa_plfa-part1-Decidable-15173" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15202" href="../Decidable/#plfa_plfa-part1-Decidable-15179" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15204" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15206" href="../Decidable/#plfa_plfa-part1-Decidable-7540" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15211" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15212" href="../Decidable/#plfa_plfa-part1-Decidable-15173" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-15213" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-15215" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15216" href="../Decidable/#plfa_plfa-part1-Decidable-15179" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15217" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-15219" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15230" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15232" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-15239" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15241" href="../Decidable/#plfa_plfa-part1-Decidable-15241" class="Bound">p</a>        <a id="plfa_plfa-part1-Decidable-15250" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15252" class="Symbol">_</a>            <a id="plfa_plfa-part1-Decidable-15265" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15267" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15271" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15272" href="../Decidable/#plfa_plfa-part1-Decidable-15241" class="Bound">p</a> <a id="plfa_plfa-part1-Decidable-15274" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-15276" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15278" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15289" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15291" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-15298" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15300" class="Symbol">_</a>        <a id="plfa_plfa-part1-Decidable-15309" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15311" href="../Decidable/#plfa_plfa-part1-Decidable-15311" class="Bound">¬p</a>           <a id="plfa_plfa-part1-Decidable-15324" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15326" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15329" href="../Decidable/#plfa_plfa-part1-Decidable-15311" class="Bound">¬p</a>
</pre><p>如果 <code>m ≤ᵇ n</code> 为真，那么 <code>≤ᵇ→≤</code> 会返回一个 <code>m ≤ n</code> 成立的证明。 如果 <code>m ≤ᵇ n</code> 为假，那么 <code>≤→≤ᵇ</code> 会取一个 <code>m ≤ n</code> 成立的证明，将其转换为一个矛盾。</p><p>在这个证明中，<code>with</code> 语句的三重约束是必须的。如果我们取而代之的写：</p><pre><code>_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})</code></pre><p>那么 Agda 对于每条语句会有一个抱怨：</p><pre><code>⊤ !=&lt; (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=&lt; ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n</code></pre><p>将表达式放在 <code>with</code> 语句中能让 Agda 利用下列事实：当 <code>m ≤ᵇ n</code> 为真时，<code>T (m ≤ᵇ n)</code> 是 <code>⊤</code>；当 <code>m ≤ᵇ n</code> 为假时，<code>T (m ≤ᵇ n)</code> 是 <code>⊥</code>。</p><p>然而，总体来说还是直接定义 <code>_≤?_</code> 比较方便，正如之前部分中那样。如果有人真的很需要 <code>_≤ᵇ_</code>， 那么它和它的性质可以简单地从 <code>_≤?_</code> 中派生出来，正如我们接下来要展示的一样。</p><p>擦除（Erasure）将一个可判定的值转换为一个布尔值：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-⌊_⌋"></a><a id="plfa_plfa-part1-Decidable-16866" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊_⌋</a> <a id="plfa_plfa-part1-Decidable-16870" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16872" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-16874" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-16875" href="../Decidable/#plfa_plfa-part1-Decidable-16875" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16877" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16879" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-16882" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-16884" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16886" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-16890" href="../Decidable/#plfa_plfa-part1-Decidable-16875" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16892" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16894" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-16899" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16901" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-16905" href="../Decidable/#plfa_plfa-part1-Decidable-16905" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-16907" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16910" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16913" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-16918" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16920" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-16923" href="../Decidable/#plfa_plfa-part1-Decidable-16923" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-16926" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16929" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16932" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
</pre><p>使用擦除，我们可以简单地从 <code>_≤?_</code> 中派生出 <code>_≤ᵇ_</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤ᵇ′_"></a><a id="plfa_plfa-part1-Decidable-17052" href="../Decidable/#plfa_plfa-part1-Decidable-17052" class="Function Operator">_≤ᵇ′_</a> <a id="plfa_plfa-part1-Decidable-17058" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17060" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17062" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17064" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17066" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17068" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-17073" href="../Decidable/#plfa_plfa-part1-Decidable-17073" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17075" href="../Decidable/#plfa_plfa-part1-Decidable-17052" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17079" href="../Decidable/#plfa_plfa-part1-Decidable-17079" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-17082" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17085" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17087" href="../Decidable/#plfa_plfa-part1-Decidable-17073" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17089" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-17092" href="../Decidable/#plfa_plfa-part1-Decidable-17079" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17094" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
</pre>更进一步来说，如果 <code>D</code> 是一个类型为 <code>Dec A</code> 的值，那么 <code>T ⌊ D ⌋</code> 当且仅当 <code>A</code> 成立时成立：<pre class="Agda"><a id="plfa_plfa-part1-Decidable-toWitness"></a><a id="plfa_plfa-part1-Decidable-17283" href="../Decidable/#plfa_plfa-part1-Decidable-17283" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17293" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17295" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17297" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17298" href="../Decidable/#plfa_plfa-part1-Decidable-17298" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17300" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17302" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17305" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17307" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17308" href="../Decidable/#plfa_plfa-part1-Decidable-17308" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17310" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17312" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17316" href="../Decidable/#plfa_plfa-part1-Decidable-17298" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17317" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17319" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17321" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17323" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17325" href="../Decidable/#plfa_plfa-part1-Decidable-17308" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17327" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-17329" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17331" href="../Decidable/#plfa_plfa-part1-Decidable-17298" class="Bound">A</a>
<a id="plfa_plfa-part1-Decidable-17333" href="../Decidable/#plfa_plfa-part1-Decidable-17283" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17343" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17344" href="../Decidable/#plfa_plfa-part1-Decidable-17344" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17345" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17347" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17348" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17352" href="../Decidable/#plfa_plfa-part1-Decidable-17352" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17353" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17355" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-17359" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17362" href="../Decidable/#plfa_plfa-part1-Decidable-17352" class="Bound">x</a>
<a id="plfa_plfa-part1-Decidable-17364" href="../Decidable/#plfa_plfa-part1-Decidable-17283" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17374" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17375" href="../Decidable/#plfa_plfa-part1-Decidable-17375" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17376" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17378" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17379" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17382" href="../Decidable/#plfa_plfa-part1-Decidable-17382" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17384" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17386" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-fromWitness"></a><a id="plfa_plfa-part1-Decidable-17390" href="../Decidable/#plfa_plfa-part1-Decidable-17390" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17402" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17404" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17406" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17407" href="../Decidable/#plfa_plfa-part1-Decidable-17407" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17409" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17411" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17414" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17416" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17417" href="../Decidable/#plfa_plfa-part1-Decidable-17417" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17419" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17421" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17425" href="../Decidable/#plfa_plfa-part1-Decidable-17407" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17426" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17428" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17430" href="../Decidable/#plfa_plfa-part1-Decidable-17407" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17432" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17434" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17436" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17438" href="../Decidable/#plfa_plfa-part1-Decidable-17417" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17440" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
<a id="plfa_plfa-part1-Decidable-17442" href="../Decidable/#plfa_plfa-part1-Decidable-17390" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17454" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17455" href="../Decidable/#plfa_plfa-part1-Decidable-17455" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17456" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17458" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17459" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17463" href="../Decidable/#plfa_plfa-part1-Decidable-17463" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17464" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17466" class="Symbol">_</a>  <a id="plfa_plfa-part1-Decidable-17469" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17472" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-17475" href="../Decidable/#plfa_plfa-part1-Decidable-17390" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17487" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17488" href="../Decidable/#plfa_plfa-part1-Decidable-17488" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17489" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17491" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17492" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17495" href="../Decidable/#plfa_plfa-part1-Decidable-17495" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17497" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17499" href="../Decidable/#plfa_plfa-part1-Decidable-17499" class="Bound">x</a>  <a id="plfa_plfa-part1-Decidable-17502" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17505" href="../Decidable/#plfa_plfa-part1-Decidable-17495" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-17508" href="../Decidable/#plfa_plfa-part1-Decidable-17499" class="Bound">x</a>
</pre><p>使用这些，我们可以简单地派生出 <code>T (m ≤ᵇ′ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ′→≤"></a><a id="plfa_plfa-part1-Decidable-17685" href="../Decidable/#plfa_plfa-part1-Decidable-17685" class="Function">≤ᵇ′→≤</a> <a id="plfa_plfa-part1-Decidable-17691" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17693" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17695" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17696" href="../Decidable/#plfa_plfa-part1-Decidable-17696" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17698" href="../Decidable/#plfa_plfa-part1-Decidable-17698" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17700" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17702" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17703" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17705" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17707" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17709" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17710" href="../Decidable/#plfa_plfa-part1-Decidable-17696" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17712" href="../Decidable/#plfa_plfa-part1-Decidable-17052" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17716" href="../Decidable/#plfa_plfa-part1-Decidable-17698" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17717" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-17719" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17721" href="../Decidable/#plfa_plfa-part1-Decidable-17696" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17723" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17725" href="../Decidable/#plfa_plfa-part1-Decidable-17698" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-17727" href="../Decidable/#plfa_plfa-part1-Decidable-17685" class="Function">≤ᵇ′→≤</a>  <a id="plfa_plfa-part1-Decidable-17734" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17737" href="../Decidable/#plfa_plfa-part1-Decidable-17283" class="Function">toWitness</a>

<a id="plfa_plfa-part1-Decidable-≤→≤ᵇ′"></a><a id="plfa_plfa-part1-Decidable-17748" href="../Decidable/#plfa_plfa-part1-Decidable-17748" class="Function">≤→≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17754" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17756" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17758" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17759" href="../Decidable/#plfa_plfa-part1-Decidable-17759" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17761" href="../Decidable/#plfa_plfa-part1-Decidable-17761" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17763" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17765" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17766" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17768" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17770" href="../Decidable/#plfa_plfa-part1-Decidable-17759" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17772" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17774" href="../Decidable/#plfa_plfa-part1-Decidable-17761" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17776" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17778" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17780" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17781" href="../Decidable/#plfa_plfa-part1-Decidable-17759" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17783" href="../Decidable/#plfa_plfa-part1-Decidable-17052" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17787" href="../Decidable/#plfa_plfa-part1-Decidable-17761" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17788" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-17790" href="../Decidable/#plfa_plfa-part1-Decidable-17748" class="Function">≤→≤ᵇ′</a>  <a id="plfa_plfa-part1-Decidable-17797" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17800" href="../Decidable/#plfa_plfa-part1-Decidable-17390" class="Function">fromWitness</a>
</pre><p>总结来说，最好避免直接使用布尔值，而使用可判定的值。如果有需要布尔值的时候，它们和它们的性质 可以简单地从对应的可判定的值中派生而来。</p><h2 id="logical-connectives">逻辑连接符</h2><p>大多数读者对于布尔值的逻辑运算符很熟悉了。每个逻辑运算符都可以被延伸至可判定的值。</p><p>两个布尔值的合取当两者都为真时为真，当任一为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-18436" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-18443" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-18445" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="Function Operator">_∧_</a>

<a id="plfa_plfa-part1-Decidable-_∧_"></a><a id="plfa_plfa-part1-Decidable-18450" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Decidable-18454" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18456" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18461" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18463" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18468" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18470" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-18475" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18481" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18483" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18489" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18491" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-18496" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18502" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18504" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-18510" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18512" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-18518" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-18519" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-18524" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="CatchallClause Function Operator">∧</a><a id="plfa_plfa-part1-Decidable-18525" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-18526" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="CatchallClause InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18532" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18534" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第三个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第二条还是第三条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-18994" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-19001" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-19003" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="Function Operator">_×-dec_</a>

<a id="plfa_plfa-part1-Decidable-_×-dec_"></a><a id="plfa_plfa-part1-Decidable-19012" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="Function Operator">_×-dec_</a> <a id="plfa_plfa-part1-Decidable-19020" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19022" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-19024" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-19025" href="../Decidable/#plfa_plfa-part1-Decidable-19025" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19027" href="../Decidable/#plfa_plfa-part1-Decidable-19027" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19029" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19031" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-19034" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-19036" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19038" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19042" href="../Decidable/#plfa_plfa-part1-Decidable-19025" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19044" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19046" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19050" href="../Decidable/#plfa_plfa-part1-Decidable-19027" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19052" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19054" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19058" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19059" href="../Decidable/#plfa_plfa-part1-Decidable-19025" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19061" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Decidable-19063" href="../Decidable/#plfa_plfa-part1-Decidable-19027" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-19064" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-19066" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19070" href="../Decidable/#plfa_plfa-part1-Decidable-19070" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19072" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19078" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19082" href="../Decidable/#plfa_plfa-part1-Decidable-19082" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19084" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19086" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19090" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19092" href="../Decidable/#plfa_plfa-part1-Decidable-19070" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19094" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19096" href="../Decidable/#plfa_plfa-part1-Decidable-19082" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19098" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Decidable-19100" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19103" href="../Decidable/#plfa_plfa-part1-Decidable-19103" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19106" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19112" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-19118" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19120" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19123" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19126" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19128" href="../Decidable/#plfa_plfa-part1-Decidable-19128" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19130" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19132" href="../Decidable/#plfa_plfa-part1-Decidable-19132" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19134" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19136" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19138" href="../Decidable/#plfa_plfa-part1-Decidable-19103" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19141" href="../Decidable/#plfa_plfa-part1-Decidable-19128" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19143" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-19145" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-19146" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-19151" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="CatchallClause Function Operator">×-dec</a><a id="plfa_plfa-part1-Decidable-19156" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19157" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-19159" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19160" href="../Decidable/#plfa_plfa-part1-Decidable-19160" class="CatchallClause Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19163" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19165" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19168" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19171" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19173" href="../Decidable/#plfa_plfa-part1-Decidable-19173" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19175" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19177" href="../Decidable/#plfa_plfa-part1-Decidable-19177" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19179" href="../Decidable/#plfa_plfa-part1-Decidable-974" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19181" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19183" href="../Decidable/#plfa_plfa-part1-Decidable-19160" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19186" href="../Decidable/#plfa_plfa-part1-Decidable-19177" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19188" class="Symbol">}</a>
</pre><p>两个命题的合取当两者都成立时成立，其否定则当任意一者否定成立时成立。如果两个都成立， 我们将每一证明放入数据对中，作为合取的证明。如果任意一者的否定成立，假设整个合取将会引入一个矛盾。</p><p>同样地，在 Emacs 中，第三条等式在左手边以灰色显示，说明等式的顺序决定了第二条还是第三条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都不成立，我们选择第一个来构造矛盾， 但选择第二个也是同样正确的。</p><p>两个布尔值的析取当任意为真时为真，当两者为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20215" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20222" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20224" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="Function Operator">_∨_</a>

<a id="plfa_plfa-part1-Decidable-_∨_"></a><a id="plfa_plfa-part1-Decidable-20229" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="Function Operator">_∨_</a> <a id="plfa_plfa-part1-Decidable-20233" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20235" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20240" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20242" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20247" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20249" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-20254" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-20260" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20262" class="Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-20269" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20271" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20276" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20277" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20282" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="CatchallClause Function Operator">∨</a><a id="plfa_plfa-part1-Decidable-20283" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20284" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="CatchallClause InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-20291" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20293" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20298" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-20304" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20306" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-20313" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20315" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20776" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20783" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20785" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="Function Operator">_⊎-dec_</a>

<a id="plfa_plfa-part1-Decidable-_⊎-dec_"></a><a id="plfa_plfa-part1-Decidable-20794" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="Function Operator">_⊎-dec_</a> <a id="plfa_plfa-part1-Decidable-20802" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20804" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-20806" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-20807" href="../Decidable/#plfa_plfa-part1-Decidable-20807" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20809" href="../Decidable/#plfa_plfa-part1-Decidable-20809" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20811" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20813" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-20816" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-20818" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20820" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20824" href="../Decidable/#plfa_plfa-part1-Decidable-20807" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20826" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20828" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20832" href="../Decidable/#plfa_plfa-part1-Decidable-20809" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20834" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20836" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20840" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20841" href="../Decidable/#plfa_plfa-part1-Decidable-20807" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20843" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Decidable-20845" href="../Decidable/#plfa_plfa-part1-Decidable-20809" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-20846" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20848" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20852" href="../Decidable/#plfa_plfa-part1-Decidable-20852" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20854" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20860" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-20866" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20868" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20872" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20873" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20878" href="../Decidable/#plfa_plfa-part1-Decidable-20852" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20879" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20881" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20882" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20887" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="CatchallClause Function Operator">⊎-dec</a><a id="plfa_plfa-part1-Decidable-20892" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20893" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="CatchallClause InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-20896" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20897" href="../Decidable/#plfa_plfa-part1-Decidable-20897" class="CatchallClause Bound">y</a> <a id="plfa_plfa-part1-Decidable-20899" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20901" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20905" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20906" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-20911" href="../Decidable/#plfa_plfa-part1-Decidable-20897" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-20912" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20914" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20917" href="../Decidable/#plfa_plfa-part1-Decidable-20917" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20920" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20926" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20929" href="../Decidable/#plfa_plfa-part1-Decidable-20929" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-20932" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20934" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20937" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-20940" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20941" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20946" href="../Decidable/#plfa_plfa-part1-Decidable-20946" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20947" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-20949" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20951" href="../Decidable/#plfa_plfa-part1-Decidable-20917" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20954" href="../Decidable/#plfa_plfa-part1-Decidable-20946" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20956" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-20958" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20959" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-20964" href="../Decidable/#plfa_plfa-part1-Decidable-20964" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-20965" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-20967" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20969" href="../Decidable/#plfa_plfa-part1-Decidable-20929" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-20972" href="../Decidable/#plfa_plfa-part1-Decidable-20964" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-20974" class="Symbol">}</a>
</pre><p>两个命题的析取当任意一者成立时成立，其否定则当两者的否定成立时成立。如果任意一者成立， 我们使用其证明来作为析取的证明。如果两个的否定都成立，假设任意一者都会引入一个矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都成立，我们选择第一个来构造析取， 但选择第二个也是同样正确的。</p><p>一个布尔值的否定当值为真时为假，反之亦然：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-not"></a><a id="plfa_plfa-part1-Decidable-21929" href="../Decidable/#plfa_plfa-part1-Decidable-21929" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21933" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21935" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-21940" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21942" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-21947" href="../Decidable/#plfa_plfa-part1-Decidable-21929" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21951" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-21957" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21959" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-21965" href="../Decidable/#plfa_plfa-part1-Decidable-21929" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21969" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-21975" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21977" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
</pre><p>相应地，给定一个可判定的命题，我们可以判定它的否定：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬?"></a><a id="plfa_plfa-part1-Decidable-22109" href="../Decidable/#plfa_plfa-part1-Decidable-22109" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22112" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22114" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-22116" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-22117" href="../Decidable/#plfa_plfa-part1-Decidable-22117" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22119" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22121" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-22124" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-22126" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22128" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22132" href="../Decidable/#plfa_plfa-part1-Decidable-22117" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22134" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22136" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22140" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22141" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-22143" href="../Decidable/#plfa_plfa-part1-Decidable-22117" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-22144" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22146" href="../Decidable/#plfa_plfa-part1-Decidable-22109" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22149" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22150" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22154" href="../Decidable/#plfa_plfa-part1-Decidable-22154" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22155" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22158" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22161" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22164" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22165" href="../Decidable/#plfa_plfa-part1-Decidable-1116" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Decidable-22174" href="../Decidable/#plfa_plfa-part1-Decidable-22154" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22175" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22177" href="../Decidable/#plfa_plfa-part1-Decidable-22109" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22180" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22181" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22184" href="../Decidable/#plfa_plfa-part1-Decidable-22184" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-22186" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22189" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22192" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22196" href="../Decidable/#plfa_plfa-part1-Decidable-22184" class="Bound">¬x</a>
</pre><p>我们直接把 yes 和 no 交换。在第一个等式中，右手边断言了 <code>¬ A</code> 的否定成立，也就是说 <code>¬ ¬ A</code> 成立——这是一个 <code>A</code> 成立时可以简单得到的推论。</p><p>还有一个与蕴涵相对应，但是稍微不那么知名的运算符：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_⊃_"></a><a id="plfa_plfa-part1-Decidable-22632" href="../Decidable/#plfa_plfa-part1-Decidable-22632" class="Function Operator">_⊃_</a> <a id="plfa_plfa-part1-Decidable-22636" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22638" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22643" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22645" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22650" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22652" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-22657" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-22663" href="../Decidable/#plfa_plfa-part1-Decidable-22632" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22665" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-22672" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22675" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22680" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="CatchallClause InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-22685" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22686" href="../Decidable/#plfa_plfa-part1-Decidable-22632" class="CatchallClause Function Operator">⊃</a><a id="plfa_plfa-part1-Decidable-22687" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22688" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-22695" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22698" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22703" href="../Decidable/#plfa_plfa-part1-Decidable-2480" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-22709" href="../Decidable/#plfa_plfa-part1-Decidable-22632" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22711" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-22718" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22721" href="../Decidable/#plfa_plfa-part1-Decidable-2495" class="InductiveConstructor">false</a>
</pre><p>当任何一个布尔值为真的时候，另一个布尔值恒为真，我们成为第一个布尔值蕴涵第二个布尔值。 因此，两者的蕴涵在第二个为真或者第一个为假时为真，在第一个为真而第二个为假时为假。 在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_→-dec_"></a><a id="plfa_plfa-part1-Decidable-23513" href="../Decidable/#plfa_plfa-part1-Decidable-23513" class="Function Operator">_→-dec_</a> <a id="plfa_plfa-part1-Decidable-23521" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23523" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-23525" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-23526" href="../Decidable/#plfa_plfa-part1-Decidable-23526" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23528" href="../Decidable/#plfa_plfa-part1-Decidable-23528" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23530" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23532" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-23535" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-23537" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23539" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23543" href="../Decidable/#plfa_plfa-part1-Decidable-23526" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23545" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23547" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23551" href="../Decidable/#plfa_plfa-part1-Decidable-23528" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23553" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23555" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23559" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23560" href="../Decidable/#plfa_plfa-part1-Decidable-23526" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23562" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23564" href="../Decidable/#plfa_plfa-part1-Decidable-23528" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-23565" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23567" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-23573" href="../Decidable/#plfa_plfa-part1-Decidable-23513" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23579" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23583" href="../Decidable/#plfa_plfa-part1-Decidable-23583" class="Bound">y</a>  <a id="plfa_plfa-part1-Decidable-23586" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23589" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23593" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23596" href="../Decidable/#plfa_plfa-part1-Decidable-23596" class="Bound">_</a> <a id="plfa_plfa-part1-Decidable-23598" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23600" href="../Decidable/#plfa_plfa-part1-Decidable-23583" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-23601" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23603" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-23605" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23606" href="../Decidable/#plfa_plfa-part1-Decidable-23606" class="CatchallClause Bound">¬x</a><a id="plfa_plfa-part1-Decidable-23608" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23609" href="../Decidable/#plfa_plfa-part1-Decidable-23513" class="CatchallClause Function Operator">→-dec</a><a id="plfa_plfa-part1-Decidable-23614" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23615" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-23622" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23625" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23629" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23632" href="../Decidable/#plfa_plfa-part1-Decidable-23632" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23634" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23636" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1270" class="Function">Neg.contradiction</a> <a id="plfa_plfa-part1-Decidable-23654" href="../Decidable/#plfa_plfa-part1-Decidable-23632" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23656" href="../Decidable/#plfa_plfa-part1-Decidable-23606" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-23658" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23660" href="../Decidable/#plfa_plfa-part1-Decidable-9853" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23664" href="../Decidable/#plfa_plfa-part1-Decidable-23664" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23666" href="../Decidable/#plfa_plfa-part1-Decidable-23513" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23672" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23675" href="../Decidable/#plfa_plfa-part1-Decidable-23675" class="Bound">¬y</a>  <a id="plfa_plfa-part1-Decidable-23679" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23682" href="../Decidable/#plfa_plfa-part1-Decidable-9873" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23685" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23688" href="../Decidable/#plfa_plfa-part1-Decidable-23688" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23690" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23692" href="../Decidable/#plfa_plfa-part1-Decidable-23675" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-23695" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23696" href="../Decidable/#plfa_plfa-part1-Decidable-23688" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23698" href="../Decidable/#plfa_plfa-part1-Decidable-23664" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-23699" class="Symbol">))</a>
</pre><p>两者的蕴涵在第二者成立或者第一者的否定成立时成立，其否定在第一者成立而第二者否定成立时成立。 蕴涵成立的证明是一个从第一者成立的证明到第二者成立的证明的函数。如果第二者成立，那么这个函数 直接返回第二者的证明。如果第一者的否定成立，那么使用第一者成立的证明，构造一个矛盾。 如果第一者成立，第二者不成立，给定蕴涵成立的证明，我们必须构造一个矛盾：我们将成立的证明 <code>f</code> 应用于第一者成立的证明 <code>x</code>，再加以第二者否定成立的证明 <code>¬y</code> 来构造矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是哪一条被匹配而不一样，但两者都是同样正确的。</p><h4 id="练习-erasure实践">练习 <code>erasure</code>（实践）</h4><p>证明擦除将对应的布尔值和可判定的值的操作联系了起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25218" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-∧-×"></a><a id="plfa_plfa-part1-Decidable-25230" href="../Decidable/#plfa_plfa-part1-Decidable-25230" class="Postulate">∧-×</a> <a id="plfa_plfa-part1-Decidable-25234" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25236" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25238" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25239" href="../Decidable/#plfa_plfa-part1-Decidable-25239" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25241" href="../Decidable/#plfa_plfa-part1-Decidable-25241" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25243" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25245" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25248" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25250" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25251" href="../Decidable/#plfa_plfa-part1-Decidable-25251" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25253" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25255" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25259" href="../Decidable/#plfa_plfa-part1-Decidable-25239" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25260" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25262" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25263" href="../Decidable/#plfa_plfa-part1-Decidable-25263" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25265" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25267" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25271" href="../Decidable/#plfa_plfa-part1-Decidable-25241" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25272" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25274" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25276" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25278" href="../Decidable/#plfa_plfa-part1-Decidable-25251" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25280" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25282" href="../Decidable/#plfa_plfa-part1-Decidable-18450" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-25284" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25286" href="../Decidable/#plfa_plfa-part1-Decidable-25263" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25288" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25290" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25292" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25294" href="../Decidable/#plfa_plfa-part1-Decidable-25251" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25296" href="../Decidable/#plfa_plfa-part1-Decidable-19012" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-25302" href="../Decidable/#plfa_plfa-part1-Decidable-25263" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25304" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-∨-⊎"></a><a id="plfa_plfa-part1-Decidable-25308" href="../Decidable/#plfa_plfa-part1-Decidable-25308" class="Postulate">∨-⊎</a> <a id="plfa_plfa-part1-Decidable-25312" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25314" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25316" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25317" href="../Decidable/#plfa_plfa-part1-Decidable-25317" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25319" href="../Decidable/#plfa_plfa-part1-Decidable-25319" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25321" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25323" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25326" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25328" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25329" href="../Decidable/#plfa_plfa-part1-Decidable-25329" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25331" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25333" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25337" href="../Decidable/#plfa_plfa-part1-Decidable-25317" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25338" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25340" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25341" href="../Decidable/#plfa_plfa-part1-Decidable-25341" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25343" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25345" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25349" href="../Decidable/#plfa_plfa-part1-Decidable-25319" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25350" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25352" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25354" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25356" href="../Decidable/#plfa_plfa-part1-Decidable-25329" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25358" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25360" href="../Decidable/#plfa_plfa-part1-Decidable-20229" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-25362" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25364" href="../Decidable/#plfa_plfa-part1-Decidable-25341" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25366" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25368" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25370" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25372" href="../Decidable/#plfa_plfa-part1-Decidable-25329" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25374" href="../Decidable/#plfa_plfa-part1-Decidable-20794" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-25380" href="../Decidable/#plfa_plfa-part1-Decidable-25341" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25382" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-not-¬"></a><a id="plfa_plfa-part1-Decidable-25386" href="../Decidable/#plfa_plfa-part1-Decidable-25386" class="Postulate">not-¬</a> <a id="plfa_plfa-part1-Decidable-25392" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25394" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25396" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25397" href="../Decidable/#plfa_plfa-part1-Decidable-25397" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25399" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25401" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25404" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25406" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25407" href="../Decidable/#plfa_plfa-part1-Decidable-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25409" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25411" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25415" href="../Decidable/#plfa_plfa-part1-Decidable-25397" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25416" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25418" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25420" href="../Decidable/#plfa_plfa-part1-Decidable-21929" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-25424" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25426" href="../Decidable/#plfa_plfa-part1-Decidable-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25428" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25430" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25432" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25434" href="../Decidable/#plfa_plfa-part1-Decidable-22109" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-25437" href="../Decidable/#plfa_plfa-part1-Decidable-25407" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25439" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
</pre><h4 id="练习-iff-erasure-推荐">练习 <code>iff-erasure</code> （推荐）</h4><p>给出与<a href="../Isomorphism/#iff">同构与嵌入</a>章节中 <code>_↔︎_</code> 相对应的布尔值与可判定的值的操作， 并证明其对应的擦除：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25777" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_iff_"></a><a id="plfa_plfa-part1-Decidable-25789" href="../Decidable/#plfa_plfa-part1-Decidable-25789" class="Postulate Operator">_iff_</a> <a id="plfa_plfa-part1-Decidable-25795" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25797" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25802" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25804" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25809" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25811" href="../Decidable/#plfa_plfa-part1-Decidable-2461" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-_⇔-dec_"></a><a id="plfa_plfa-part1-Decidable-25818" href="../Decidable/#plfa_plfa-part1-Decidable-25818" class="Postulate Operator">_⇔-dec_</a> <a id="plfa_plfa-part1-Decidable-25826" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25828" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25830" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25831" href="../Decidable/#plfa_plfa-part1-Decidable-25831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25833" href="../Decidable/#plfa_plfa-part1-Decidable-25833" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25835" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25837" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25840" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25842" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25844" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25848" href="../Decidable/#plfa_plfa-part1-Decidable-25831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25850" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25852" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25856" href="../Decidable/#plfa_plfa-part1-Decidable-25833" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25858" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25860" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25864" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25865" href="../Decidable/#plfa_plfa-part1-Decidable-25831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25867" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14965" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Decidable-25869" href="../Decidable/#plfa_plfa-part1-Decidable-25833" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25870" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Decidable-iff-⇔"></a><a id="plfa_plfa-part1-Decidable-25874" href="../Decidable/#plfa_plfa-part1-Decidable-25874" class="Postulate">iff-⇔</a> <a id="plfa_plfa-part1-Decidable-25880" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25882" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25884" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25885" href="../Decidable/#plfa_plfa-part1-Decidable-25885" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25887" href="../Decidable/#plfa_plfa-part1-Decidable-25887" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25889" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25891" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25894" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25896" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25897" href="../Decidable/#plfa_plfa-part1-Decidable-25897" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25899" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25901" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25905" href="../Decidable/#plfa_plfa-part1-Decidable-25885" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25906" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25908" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25909" href="../Decidable/#plfa_plfa-part1-Decidable-25909" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25911" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25913" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25917" href="../Decidable/#plfa_plfa-part1-Decidable-25887" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25918" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25920" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25922" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25924" href="../Decidable/#plfa_plfa-part1-Decidable-25897" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25926" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25928" href="../Decidable/#plfa_plfa-part1-Decidable-25789" class="Postulate Operator">iff</a> <a id="plfa_plfa-part1-Decidable-25932" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25934" href="../Decidable/#plfa_plfa-part1-Decidable-25909" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25936" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25938" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25940" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25942" href="../Decidable/#plfa_plfa-part1-Decidable-25897" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25944" href="../Decidable/#plfa_plfa-part1-Decidable-25818" class="Postulate Operator">⇔-dec</a> <a id="plfa_plfa-part1-Decidable-25950" href="../Decidable/#plfa_plfa-part1-Decidable-25909" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25952" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25969" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="proof-by-reflection">互映证明</h2><p>让我们回顾一下章节<a href="../Naturals/">自然数</a>中 <code>monus</code> 的定义。 如果从一个较小的数中减去一个较大的数，结果为零。毕竟我们总是要得到一个结果。 我们可以用其他方式定义吗？可以定义一版带有<strong>守卫（guarded）</strong>的减法──只有当 <code>n ≤ m</code> 时才能从 <code>m</code> 中减去 <code>n</code> ：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-minus"></a><a id="plfa_plfa-part1-Decidable-26586" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26592" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26594" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26595" href="../Decidable/#plfa_plfa-part1-Decidable-26595" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26597" href="../Decidable/#plfa_plfa-part1-Decidable-26597" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26599" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26601" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-26602" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26604" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26605" href="../Decidable/#plfa_plfa-part1-Decidable-26605" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-26609" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26611" href="../Decidable/#plfa_plfa-part1-Decidable-26597" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26613" href="../Decidable/#plfa_plfa-part1-Decidable-1626" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-26615" href="../Decidable/#plfa_plfa-part1-Decidable-26595" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26616" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26618" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-26620" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-26622" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26628" href="../Decidable/#plfa_plfa-part1-Decidable-26628" class="Bound">m</a>       <a id="plfa_plfa-part1-Decidable-26636" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-26644" class="Symbol">_</a>         <a id="plfa_plfa-part1-Decidable-26654" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26656" href="../Decidable/#plfa_plfa-part1-Decidable-26628" class="Bound">m</a>
<a id="plfa_plfa-part1-Decidable-26658" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26664" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26665" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26669" href="../Decidable/#plfa_plfa-part1-Decidable-26669" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26670" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26672" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26673" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26677" href="../Decidable/#plfa_plfa-part1-Decidable-26677" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-26678" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26680" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26681" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26685" href="../Decidable/#plfa_plfa-part1-Decidable-26685" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-26688" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26690" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26692" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26698" href="../Decidable/#plfa_plfa-part1-Decidable-26669" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26700" href="../Decidable/#plfa_plfa-part1-Decidable-26677" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26702" href="../Decidable/#plfa_plfa-part1-Decidable-26685" class="Bound">n≤m</a>
</pre><p>然而这种定义难以使用，因为我们必须显式地为 <code>n ≤ m</code> 提供证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-26863" href="../Decidable/#plfa_plfa-part1-Decidable-26863" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-26865" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26867" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26873" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-26875" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-26877" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26878" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26882" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26883" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26887" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26888" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26892" href="../Decidable/#plfa_plfa-part1-Decidable-1653" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-26895" class="Symbol">)))</a> <a id="plfa_plfa-part1-Decidable-26899" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-26901" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-26903" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-26905" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26907" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>这个问题没有通用的解决方案，但是在上述的情景下，我们恰好<strong>静态地</strong>知道这两个数字。这种情况下，我们可以使用一种被称为<strong>互映证明（proof by reflection）</strong>的技术。 实质上，在类型检查的时候我们可以让 Agda 运行可判定的等式 <code>n ≤? m</code> 并且保证 <code>n ≤ m</code>！</p><p>我们使用「隐式参数」的一个特性来实现这个功能。如果 Agda 可以填充一个记录类型的所有字段，那么 Agda 就可以填充此记录类型的隐式参数。 由于空记录类型没有任何字段，Agda 总是会设法填充空记录类型的隐式参数。这就是 <code>⊤</code> 类型被定义成空记录的原因。</p><p>这里的技巧是设置一个类型为 <code>T ⌊ n ≤? m ⌋</code> 的隐式参数。让我们一步一步阐述这句话的含义。 首先，我们运行判定过程 <code>n ≤? m</code>。它向我们提供了 <code>n ≤ m</code> 是否成立的证据。我们擦除证据得到布尔值。 最后，我们应用 <code>T</code>。回想一下，<code>T</code> 将布尔值映射到证据的世界：<code>true</code> 变成了单位类型 <code>⊤</code>， <code>false</code> 变成了空类型 <code>⊥</code> 。在操作上，这个类型的隐式参数起到了守卫的作用。</p><ul><li>如果 <code>n ≤ m</code> 成立，隐式参数的类型归约为 <code>⊤</code>。 然后 Agda 会欣然地提供隐式参数。</li><li>否则，类型归约为 <code>⊥</code> ，Agda 无法为此类型提供对应的值，因此会报错。例如，如果我们调用 <code>3 - 5</code> 会得到 <code>_n≤m_254 : ⊥</code>。</li></ul><p>我们使用之前定义的 <code>toWitness</code> 获得了 <code>n ≤ m</code> 的证据：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_-_"></a><a id="plfa_plfa-part1-Decidable-29070" href="../Decidable/#plfa_plfa-part1-Decidable-29070" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29074" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29076" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29077" href="../Decidable/#plfa_plfa-part1-Decidable-29077" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29079" href="../Decidable/#plfa_plfa-part1-Decidable-29079" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29081" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29083" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-29084" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-29086" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29087" href="../Decidable/#plfa_plfa-part1-Decidable-29087" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-29091" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29093" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29095" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29097" href="../Decidable/#plfa_plfa-part1-Decidable-29079" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29099" href="../Decidable/#plfa_plfa-part1-Decidable-11676" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-29102" href="../Decidable/#plfa_plfa-part1-Decidable-29077" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29104" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a><a id="plfa_plfa-part1-Decidable-29105" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29107" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29109" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-29111" href="../Decidable/#plfa_plfa-part1-Decidable-29070" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29115" href="../Decidable/#plfa_plfa-part1-Decidable-29115" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29117" href="../Decidable/#plfa_plfa-part1-Decidable-29117" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29119" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29120" href="../Decidable/#plfa_plfa-part1-Decidable-29120" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29123" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29125" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29127" href="../Decidable/#plfa_plfa-part1-Decidable-26586" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-29133" href="../Decidable/#plfa_plfa-part1-Decidable-29115" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29135" href="../Decidable/#plfa_plfa-part1-Decidable-29117" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29137" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29138" href="../Decidable/#plfa_plfa-part1-Decidable-17283" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-29148" href="../Decidable/#plfa_plfa-part1-Decidable-29120" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29151" class="Symbol">)</a>
</pre><p>我们现在只要能静态地知道这两个数就可以安全地使用 <code>_-_</code> 了：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-29282" href="../Decidable/#plfa_plfa-part1-Decidable-29282" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-29284" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29286" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-29288" href="../Decidable/#plfa_plfa-part1-Decidable-29070" class="Function Operator">-</a> <a id="plfa_plfa-part1-Decidable-29290" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-29292" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-29294" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-29296" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-29298" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29300" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>事实上，这种惯用语法非常普遍。标准库为 <code>T ⌊ ? ⌋</code> 定义了叫做 <code>True</code> 的同义词：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-True"></a><a id="plfa_plfa-part1-Decidable-29491" href="../Decidable/#plfa_plfa-part1-Decidable-29491" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29496" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29498" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-29500" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29501" href="../Decidable/#plfa_plfa-part1-Decidable-29501" class="Bound">Q</a><a id="plfa_plfa-part1-Decidable-29502" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29504" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29506" href="../Decidable/#plfa_plfa-part1-Decidable-9825" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-29510" href="../Decidable/#plfa_plfa-part1-Decidable-29501" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29512" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29514" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-29518" href="../Decidable/#plfa_plfa-part1-Decidable-29491" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29523" href="../Decidable/#plfa_plfa-part1-Decidable-29523" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29525" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29527" href="../Decidable/#plfa_plfa-part1-Decidable-4472" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29529" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29531" href="../Decidable/#plfa_plfa-part1-Decidable-29523" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29533" href="../Decidable/#plfa_plfa-part1-Decidable-16866" class="Function Operator">⌋</a>
</pre><h4 id="练习-false-实践">练习 <code>False</code> （实践）</h4><p>给出 <code>True</code>，<code>toWitness</code> 和 <code>fromWitness</code> 的<strong>相反</strong>定义。分别称为 <code>False</code>，<code>toWitnessFalse</code> 和 <code>fromWitnessFalse</code>。</p><h4 id="练习-bin-decidable延伸">练习 <code>Bin-decidable</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a>、 <a href="../Induction/#Bin-laws">Bin-laws</a> 和 <a href="../Relations/#Bin-predicates">Bin-predicates</a>，定义一个用比特串表示自然数的数据类型 <code>Bin</code>，并定义以下谓词：</p><pre><code>One  : Bin → Set
Can  : Bin → Set</code></pre><p>证明以上二者是可判定的。</p><pre><code>One? : ∀ (b : Bin) → Dec (One b)
Can? : ∀ (b : Bin) → Dec (Can b)</code></pre><h2 id="标准库">标准库</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-30581" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30588" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Decidable-30603" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30609" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30610" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-30614" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30616" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Decidable-30620" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30622" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-30627" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30629" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#1348" class="Function">T</a><a id="plfa_plfa-part1-Decidable-30630" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30632" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#995" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Decidable-30635" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30637" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Decidable-30640" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30642" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Bool.Base.html#941" class="Function">not</a><a id="plfa_plfa-part1-Decidable-30645" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30647" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30654" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-30663" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30669" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30670" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Properties.html#6709" class="Function Operator">_≤?_</a><a id="plfa_plfa-part1-Decidable-30674" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30676" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30683" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-30700" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30706" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30707" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a><a id="plfa_plfa-part1-Decidable-30710" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30712" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-30715" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30717" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-30719" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30721" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30728" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="plfa_plfa-part1-Decidable-30755" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Decidable-30763" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30764" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#4636" class="Function Operator">⌊_⌋</a><a id="plfa_plfa-part1-Decidable-30767" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30769" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#4481" class="Function">True</a><a id="plfa_plfa-part1-Decidable-30773" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30775" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#4771" class="Function">toWitness</a><a id="plfa_plfa-part1-Decidable-30784" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30786" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#4943" class="Function">fromWitness</a><a id="plfa_plfa-part1-Decidable-30797" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30799" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#3103" class="Function Operator">_×-dec_</a><a id="plfa_plfa-part1-Decidable-30806" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30808" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#3233" class="Function Operator">_⊎-dec_</a><a id="plfa_plfa-part1-Decidable-30815" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30817" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Decidable.Core.html#3011" class="Function">¬?</a><a id="plfa_plfa-part1-Decidable-30819" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30821" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30828" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Definitions.html" class="Module">Relation.Binary.Definitions</a> <a id="plfa_plfa-part1-Decidable-30856" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30862" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30863" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.Definitions.html#6713" class="Function">Decidable</a><a id="plfa_plfa-part1-Decidable-30872" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><pre><code>∧  U+2227  逻辑和 (\and, \wedge)
∨  U+2228  逻辑或 (\or, \vee)
⊃  U+2283  超集 (\sup)
ᵇ  U+1D47  修饰符小写 B  (\^b)
⌊  U+230A  左向下取整 (\clL)
⌋  U+230B  右向下取整 (\clR)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou、Oshmkufa2010<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>