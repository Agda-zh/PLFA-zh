<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Decidable</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Decidable: 布尔值与判定过程</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Decidable-122" class="Keyword">module</a> <a id="plfa_plfa-part1-Decidable-129" href="../Decidable/#" class="Module">plfa.part1.Decidable</a> <a id="plfa_plfa-part1-Decidable-150" class="Keyword">where</a>
</pre><p>我们有两种不同的方式来表示关系：一是表示为由关系成立的<strong>证明（Evidence）</strong>所构成的数据类型； 二是表示为一个<strong>计算（Compute）</strong>关系是否成立的函数。在本章中，我们将探讨这两种方式之间的关系。 我们首先研究大家熟悉的<strong>布尔值（Boolean）</strong>记法，但是之后我们会发现，相较布尔值记法， 使用一种新的<strong>可判定性（Decidable）</strong>记法将会是更好的选择。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-771" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-778" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Decidable-816" class="Symbol">as</a> <a id="plfa_plfa-part1-Decidable-819" class="Module">Eq</a>
<a id="plfa_plfa-part1-Decidable-822" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-827" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Decidable-830" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-836" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-837" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Decidable-840" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-842" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Decidable-846" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-848" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-853" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Decidable-868" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-873" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-880" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-889" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-895" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-896" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-897" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-899" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-903" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-905" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Decidable-908" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-910" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-915" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-922" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Decidable-935" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-941" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-942" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Decidable-945" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-947" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-956" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-957" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Decidable-961" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Decidable-969" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-971" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-976" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-983" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Decidable-992" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-998" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-999" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Decidable-1002" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1004" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Decidable-1008" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1010" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Decidable-1014" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1016" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1021" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1028" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-1045" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1051" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1052" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Decidable-1054" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1056" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1061" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1068" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-1094" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1100" class="Symbol">()</a>
  <a id="plfa_plfa-part1-Decidable-1105" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-1114" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1115" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="plfa_plfa-part1-Decidable-1129" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-1132" class="Function">¬¬-intro</a><a id="plfa_plfa-part1-Decidable-1140" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1142" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1147" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1154" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Decidable-1164" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1170" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1171" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="plfa_plfa-part1-Decidable-1172" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1174" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-1176" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1178" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1183" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1190" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Decidable-1201" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1207" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1208" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Decidable-1209" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1211" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Decidable-1217" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1219" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1224" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1231" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Decidable-1252" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1258" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1259" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">_&lt;_</a><a id="plfa_plfa-part1-Decidable-1262" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1264" href="../Relations/#plfa_plfa-part1-Relations-26387" class="InductiveConstructor">z&lt;s</a><a id="plfa_plfa-part1-Decidable-1267" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1269" href="../Relations/#plfa_plfa-part1-Relations-26444" class="InductiveConstructor">s&lt;s</a><a id="plfa_plfa-part1-Decidable-1272" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1274" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1279" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1286" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Decidable-1309" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1315" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1316" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14960" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Decidable-1319" class="Symbol">)</a>
</pre><h2 id="证据-vs-计算">证据 vs 计算</h2><p>回忆我们在 <a href="../Relations/">Relations</a> 章节中将比较定义为一个归纳数据类型，其提供了一个数小于或等于另外一个数的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-1632" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-1638" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1640" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">_≤_</a>

<a id="plfa_plfa-part1-Decidable-1645" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-_≤_"></a><a id="plfa_plfa-part1-Decidable-1650" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Decidable-1654" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1656" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1658" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1660" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1662" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1664" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-1668" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.z≤n"></a><a id="plfa_plfa-part1-Decidable-1677" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Decidable-1681" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1683" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1685" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1686" href="../Decidable/#plfa_plfa-part1-Decidable-1686" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1688" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1690" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1691" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Decidable-1699" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Decidable-1712" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1714" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-1719" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1721" href="../Decidable/#plfa_plfa-part1-Decidable-1686" class="Bound">n</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.s≤s"></a><a id="plfa_plfa-part1-Decidable-1726" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1730" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1732" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1734" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1735" href="../Decidable/#plfa_plfa-part1-Decidable-1735" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1737" href="../Decidable/#plfa_plfa-part1-Decidable-1737" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1739" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1741" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1742" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Decidable-1748" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1750" href="../Decidable/#plfa_plfa-part1-Decidable-1735" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1752" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1754" href="../Decidable/#plfa_plfa-part1-Decidable-1737" class="Bound">n</a>
      <a id="plfa_plfa-part1-Decidable-1762" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Decidable-1780" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1786" href="../Decidable/#plfa_plfa-part1-Decidable-1735" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1788" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1790" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1794" href="../Decidable/#plfa_plfa-part1-Decidable-1737" class="Bound">n</a>
</pre><p>举例来说，我们提供 <code>2 ≤ 4</code> 成立的证明，也可以证明没有 <code>4 ≤ 2</code> 成立的证明。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2≤4"></a><a id="plfa_plfa-part1-Decidable-1971" href="../Decidable/#plfa_plfa-part1-Decidable-1971" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1975" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1977" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-1979" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1981" class="Number">4</a>
<a id="plfa_plfa-part1-Decidable-1983" href="../Decidable/#plfa_plfa-part1-Decidable-1971" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1987" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-1989" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1993" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1994" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1998" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-2001" class="Symbol">)</a>

<a id="plfa_plfa-part1-Decidable-¬4≤2"></a><a id="plfa_plfa-part1-Decidable-2004" href="../Decidable/#plfa_plfa-part1-Decidable-2004" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-2009" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2011" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-2013" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2014" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2016" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-2018" class="Number">2</a><a id="plfa_plfa-part1-Decidable-2019" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-2021" href="../Decidable/#plfa_plfa-part1-Decidable-2004" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-2026" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2027" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2031" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2032" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2036" class="Symbol">()))</a>
</pre><p><code>()</code> 的出现表明了没有 <code>2 ≤ 0</code> 成立的证明：<code>z≤n</code> 不能匹配（因为 <code>2</code> 不是 <code>zero</code>），<code>s≤s</code> 也不能匹配（因为 <code>0</code> 不能匹配 <code>suc n</code>）。</p><p>作为替代的定义，我们可以定义一个大家可能比较熟悉的布尔类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2480" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Bool"></a><a id="plfa_plfa-part1-Decidable-2485" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-2490" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2492" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-2496" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Bool.true"></a><a id="plfa_plfa-part1-Decidable-2504" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-2510" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2512" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-Bool.false"></a><a id="plfa_plfa-part1-Decidable-2519" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-2525" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2527" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
</pre><p>给定了布尔类型，我们可以定义一个两个数的函数在比较关系成立时来<strong>计算</strong>出 <code>true</code>， 否则计算出 <code>false</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2750" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-2756" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2758" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">_≤ᵇ_</a>

<a id="plfa_plfa-part1-Decidable-_≤ᵇ_"></a><a id="plfa_plfa-part1-Decidable-2764" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">_≤ᵇ_</a> <a id="plfa_plfa-part1-Decidable-2769" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2771" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2773" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2775" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2777" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2779" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-2784" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-2789" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2792" href="../Decidable/#plfa_plfa-part1-Decidable-2792" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-2800" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2803" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-2808" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2812" href="../Decidable/#plfa_plfa-part1-Decidable-2812" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2814" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2817" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>   <a id="plfa_plfa-part1-Decidable-2824" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2827" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-2833" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2837" href="../Decidable/#plfa_plfa-part1-Decidable-2837" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2839" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2842" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2846" href="../Decidable/#plfa_plfa-part1-Decidable-2846" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-2849" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2852" href="../Decidable/#plfa_plfa-part1-Decidable-2837" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2854" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2857" href="../Decidable/#plfa_plfa-part1-Decidable-2846" class="Bound">n</a>
</pre><p>定义中的第一条与最后一条与归纳数据类型中的两个构造子相对应。因为对于任意的 <code>m</code>，不可能出现 <code>suc m ≤ zero</code> 的证明，我们使用中间一条定义来表示。 举个例子，我们可以计算 <code>2 ≤ᵇ 4</code> 成立，也可以计算 <code>4 ≤ᵇ 2</code> 不成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-3325" href="../Decidable/#plfa_plfa-part1-Decidable-3325" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3327" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3329" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3330" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3332" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3335" class="Number">4</a><a id="plfa_plfa-part1-Decidable-3336" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3338" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3340" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-3345" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3347" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3351" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3361" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3363" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3366" class="Number">4</a>
  <a id="plfa_plfa-part1-Decidable-3370" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3378" class="Number">1</a> <a id="plfa_plfa-part1-Decidable-3380" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3383" class="Number">3</a>
  <a id="plfa_plfa-part1-Decidable-3387" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3395" class="Number">0</a> <a id="plfa_plfa-part1-Decidable-3397" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3400" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3404" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3412" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
  <a id="plfa_plfa-part1-Decidable-3419" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Decidable-3422" href="../Decidable/#plfa_plfa-part1-Decidable-3422" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3424" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3426" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3427" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3429" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3432" class="Number">2</a><a id="plfa_plfa-part1-Decidable-3433" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3435" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3437" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-3443" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3445" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3449" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3459" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3461" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3464" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3468" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3476" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-3478" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3481" class="Number">1</a>
  <a id="plfa_plfa-part1-Decidable-3485" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3493" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3495" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3498" class="Number">0</a>
  <a id="plfa_plfa-part1-Decidable-3502" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3510" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
  <a id="plfa_plfa-part1-Decidable-3518" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在第一种情况中，我们需要两步来将第一个参数降低到 0，再用一步来计算出真，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>z≤n</code> 来证明 <code>2 ≤ 4</code>。 在第二种情况中，我们需要两步来将第二个参数降低到 0，再用一步来计算出假，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>()</code> 来说明没有 <code>4 ≤ 2</code> 的证明。</p><h2 id="relating-evidence-and-computation">将证明与计算相联系</h2><p>我们希望能够证明这两种方法是有联系的，而我们的确可以。 首先，我们定义一个函数来把计算世界映射到证明世界：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T"></a><a id="plfa_plfa-part1-Decidable-4496" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4498" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4500" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-4505" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4507" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-4511" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4513" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-4520" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="plfa_plfa-part1-Decidable-4525" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4527" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-4534" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4537" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>回忆到 <code>⊤</code> 是只有一个元素 <code>tt</code> 的单元类型，<code>⊥</code> 是没有值的空类型。（注意 <code>T</code> 是大写字母 <code>t</code>， 与 <code>⊤</code> 不同。）如果 <code>b</code> 是 <code>Bool</code> 类型的，那么如果 <code>b</code> 为真，<code>tt</code> 可以提供 <code>T b</code> 成立的证明； 如果 <code>b</code> 为假，则不可能有 <code>T b</code> 成立的证明。</p><p>换句话说，<code>T b</code> 当且仅当 <code>b ≡ true</code> 成立时成立。在向前的方向，我们需要针对 <code>b</code> 进行情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T→≡"></a><a id="plfa_plfa-part1-Decidable-5306" href="../Decidable/#plfa_plfa-part1-Decidable-5306" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5310" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5312" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5314" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-5315" href="../Decidable/#plfa_plfa-part1-Decidable-5315" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5317" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5319" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5323" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-5325" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5327" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5329" href="../Decidable/#plfa_plfa-part1-Decidable-5315" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5331" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5333" href="../Decidable/#plfa_plfa-part1-Decidable-5315" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5335" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5337" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-5342" href="../Decidable/#plfa_plfa-part1-Decidable-5306" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5346" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>   <a id="plfa_plfa-part1-Decidable-5356" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5359" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Decidable-5364" href="../Decidable/#plfa_plfa-part1-Decidable-5306" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5368" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-5374" class="Symbol">()</a>
</pre><p>如果 <code>b</code> 为真，那么 <code>T b</code> 由 <code>tt</code> 证明，<code>b ≡ true</code> 由 <code>refl</code> 证明。 当 <code>b</code> 为假，那么 <code>T b</code> 无法证明。</p><p>在向后的方向，不需要针对布尔值 <code>b</code> 的情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≡→T"></a><a id="plfa_plfa-part1-Decidable-5734" href="../Decidable/#plfa_plfa-part1-Decidable-5734" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5738" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5740" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5742" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-5743" href="../Decidable/#plfa_plfa-part1-Decidable-5743" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5745" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5747" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5751" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-5753" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5755" href="../Decidable/#plfa_plfa-part1-Decidable-5743" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5757" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5759" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5764" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5766" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5768" href="../Decidable/#plfa_plfa-part1-Decidable-5743" class="Bound">b</a>
<a id="plfa_plfa-part1-Decidable-5770" href="../Decidable/#plfa_plfa-part1-Decidable-5734" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5774" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>  <a id="plfa_plfa-part1-Decidable-5780" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5783" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>
</pre><p>如果 <code>b ≡ true</code> 由 <code>refl</code> 证明，我们知道 <code>b</code> 是 <code>true</code>，因此 <code>T b</code> 由 <code>tt</code> 证明。</p><p>现在我们可以证明 <code>T (m ≤ᵇ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><p>在向前的方向，我们考虑 <code>_≤ᵇ_</code> 定义中的三条语句：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ→≤"></a><a id="plfa_plfa-part1-Decidable-6236" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6241" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6243" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-6245" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6246" href="../Decidable/#plfa_plfa-part1-Decidable-6246" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6248" href="../Decidable/#plfa_plfa-part1-Decidable-6248" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6250" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6252" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-6253" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6255" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6257" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-6259" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6260" href="../Decidable/#plfa_plfa-part1-Decidable-6246" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6262" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-6265" href="../Decidable/#plfa_plfa-part1-Decidable-6248" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6266" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6268" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6270" href="../Decidable/#plfa_plfa-part1-Decidable-6246" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6272" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-6274" href="../Decidable/#plfa_plfa-part1-Decidable-6248" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-6276" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6281" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6289" href="../Decidable/#plfa_plfa-part1-Decidable-6289" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-6297" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-6301" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6304" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-6308" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6313" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6314" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6318" href="../Decidable/#plfa_plfa-part1-Decidable-6318" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6319" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6321" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6329" class="Symbol">()</a>
<a id="plfa_plfa-part1-Decidable-6332" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6337" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6338" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6342" href="../Decidable/#plfa_plfa-part1-Decidable-6342" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6343" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6345" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6346" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6350" href="../Decidable/#plfa_plfa-part1-Decidable-6350" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6351" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6353" href="../Decidable/#plfa_plfa-part1-Decidable-6353" class="Bound">t</a>   <a id="plfa_plfa-part1-Decidable-6357" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6360" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-6364" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6365" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6370" href="../Decidable/#plfa_plfa-part1-Decidable-6342" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6372" href="../Decidable/#plfa_plfa-part1-Decidable-6350" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6374" href="../Decidable/#plfa_plfa-part1-Decidable-6353" class="Bound">t</a><a id="plfa_plfa-part1-Decidable-6375" class="Symbol">)</a>
</pre><p>第一条语句中，我们立即可以得出 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 而得， 相对应地 <code>m ≤ n</code> 由 <code>z≤n</code> 而证明。在中间的语句中，我们立刻得出 <code>suc m ≤ᵇ zero</code> 为假，则 <code>T (m ≤ᵇ n)</code> 为空，因此我们无需证明 <code>m ≤ n</code>，同时也不存在这样的证明。在最后的语句中，我们对于 <code>suc m ≤ᵇ suc n</code> 递归至 <code>m ≤ᵇ n</code>。令 <code>t</code> 为 <code>T (suc m ≤ᵇ suc n)</code> 的证明，如果其存在。 根据 <code>_≤ᵇ_</code> 的定义，这也是 <code>T (m ≤ᵇ n)</code> 的证明。我们递归地应用函数来获得 <code>m ≤ n</code> 的证明，再使用 <code>s≤s</code> 将其转换成为 <code>suc m ≤ suc n</code> 的证明。</p><p>在向后的方向，我们考虑 <code>m ≤ n</code> 成立证明的可能形式：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤→≤ᵇ"></a><a id="plfa_plfa-part1-Decidable-7564" href="../Decidable/#plfa_plfa-part1-Decidable-7564" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7569" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7571" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-7573" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-7574" href="../Decidable/#plfa_plfa-part1-Decidable-7574" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7576" href="../Decidable/#plfa_plfa-part1-Decidable-7576" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7578" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7580" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-7581" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-7583" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7585" href="../Decidable/#plfa_plfa-part1-Decidable-7574" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7587" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7589" href="../Decidable/#plfa_plfa-part1-Decidable-7576" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7591" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7593" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-7595" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7596" href="../Decidable/#plfa_plfa-part1-Decidable-7574" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7598" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7601" href="../Decidable/#plfa_plfa-part1-Decidable-7576" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-7602" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-7604" href="../Decidable/#plfa_plfa-part1-Decidable-7564" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7609" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Decidable-7620" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7623" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-7626" href="../Decidable/#plfa_plfa-part1-Decidable-7564" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7631" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7632" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-7636" href="../Decidable/#plfa_plfa-part1-Decidable-7636" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-7639" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-7642" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7645" href="../Decidable/#plfa_plfa-part1-Decidable-7564" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7650" href="../Decidable/#plfa_plfa-part1-Decidable-7636" class="Bound">m≤n</a>
</pre><p>如果证明是 <code>z≤n</code>，我们立即可以得到 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 证明。 如果证明是 <code>s≤s</code> 作用于 <code>m≤n</code>，那么 <code>suc m ≤ᵇ suc n</code> 归约到 <code>m ≤ᵇ n</code>，我们可以递归地使用函数 来获得 <code>T (m ≤ᵇ n)</code> 的证明。</p><p>向前方向的证明比向后方向的证明多一条语句，因为在向前方向的证明中我们需要考虑比较结果为真和假 的语句，而向后方向的证明只需要考虑比较成立的语句。这也是为什么我们比起计算的形式，更加偏爱证明的形式， 因为这样让我们做更少的工作：我们只需要考虑关系成立时的情况，而可以忽略不成立的情况。</p><p>从另一个角度来说，有时计算的性质可能正是我们所需要的。面对一个大数值上的非显然关系， 使用电脑来计算出答案可能会更加方便。幸运的是，比起在<strong>证明</strong>或<strong>计算</strong>之中犹豫， 我们有一种更好的方法来兼取其优。</p><h2 id="the-best-of-both-worlds">取二者之精华</h2><p>一个返回布尔值的函数提供恰好一比特的信息：这个关系成立或是不成立。相反地，证明的形式告诉我们 为什么这个关系成立，但却需要我们自行完成这个证明。不过，我们其实可以简单地定义一个类型来取二者之精华。 我们把它叫做：<code>Dec A</code>，其中 <code>Dec</code> 是<strong>可判定的（Decidable）</strong>的意思。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-9844" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Dec"></a><a id="plfa_plfa-part1-Decidable-9849" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9853" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9854" href="../Decidable/#plfa_plfa-part1-Decidable-9854" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9856" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9858" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-9861" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-9863" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9865" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-9869" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Dec.yes"></a><a id="plfa_plfa-part1-Decidable-9877" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-9881" class="Symbol">:</a>   <a id="plfa_plfa-part1-Decidable-9885" href="../Decidable/#plfa_plfa-part1-Decidable-9854" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9887" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9889" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9893" href="../Decidable/#plfa_plfa-part1-Decidable-9854" class="Bound">A</a>
  <a id="plfa_plfa-part1-Decidable-Dec.no"></a><a id="plfa_plfa-part1-Decidable-9897" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a>  <a id="plfa_plfa-part1-Decidable-9901" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9903" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-9905" href="../Decidable/#plfa_plfa-part1-Decidable-9854" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9907" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9909" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9913" href="../Decidable/#plfa_plfa-part1-Decidable-9854" class="Bound">A</a>
</pre><p>正如布尔值，这个类型有两个构造子。一个 <code>Dec A</code> 类型的值要么是以 <code>yes x</code> 的形式，其中 <code>x</code> 提供 <code>A</code> 成立的证明，或者是以 <code>no ¬x</code> 的形式，其中 <code>x</code> 提供了 <code>A</code> 无法成立的证明。（也就是说，<code>¬x</code> 是一个给定 <code>A</code> 成立的证据，返回矛盾的函数）</p><p>比如说，我们定义一个函数 <code>_≤?_</code>，给定两个数，判定是否一个数小于等于另一个，并提供证明来说明结论。</p><p>首先，我们使用两个有用的函数，用于构造不等式不成立的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬s≤z"></a><a id="plfa_plfa-part1-Decidable-10762" href="../Decidable/#plfa_plfa-part1-Decidable-10762" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10767" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10769" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10771" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10772" href="../Decidable/#plfa_plfa-part1-Decidable-10772" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10774" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10776" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10777" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10779" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10781" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10783" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10784" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10788" href="../Decidable/#plfa_plfa-part1-Decidable-10772" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10790" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10792" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-10796" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10798" href="../Decidable/#plfa_plfa-part1-Decidable-10762" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10803" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-¬s≤s"></a><a id="plfa_plfa-part1-Decidable-10807" href="../Decidable/#plfa_plfa-part1-Decidable-10807" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10812" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10814" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10816" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10817" href="../Decidable/#plfa_plfa-part1-Decidable-10817" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10819" href="../Decidable/#plfa_plfa-part1-Decidable-10819" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-10821" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10823" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10824" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10826" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10828" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10830" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10831" href="../Decidable/#plfa_plfa-part1-Decidable-10817" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10833" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10835" href="../Decidable/#plfa_plfa-part1-Decidable-10819" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10836" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10838" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10840" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10842" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10843" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10847" href="../Decidable/#plfa_plfa-part1-Decidable-10817" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10849" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10851" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10855" href="../Decidable/#plfa_plfa-part1-Decidable-10819" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10856" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10858" href="../Decidable/#plfa_plfa-part1-Decidable-10807" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10863" href="../Decidable/#plfa_plfa-part1-Decidable-10863" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10868" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10869" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-10873" href="../Decidable/#plfa_plfa-part1-Decidable-10873" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-10876" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10878" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-10880" href="../Decidable/#plfa_plfa-part1-Decidable-10863" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10885" href="../Decidable/#plfa_plfa-part1-Decidable-10873" class="Bound">m≤n</a>
</pre><p>第一个函数断言了 <code>¬ (suc m ≤ zero)</code>，由荒谬可得。因为每个不等式的成立证明必须是 <code>zero ≤ n</code> 或者 <code>suc m ≤ suc n</code> 的形式，两者都无法匹配 <code>suc m ≤ zero</code>。 第二个函数取 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，返回 <code>¬ (suc m ≤ suc n)</code> 的证明。 所有形如 <code>suc m ≤ suc n</code> 的证明必须是以 <code>s≤s m≤n</code> 的形式给出。因此我们可以构造一个 矛盾，以 <code>¬m≤n m≤n</code> 来证明。</p><p>使用这些，我们可以直接的判定不等关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?_"></a><a id="plfa_plfa-part1-Decidable-11700" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">_≤?_</a> <a id="plfa_plfa-part1-Decidable-11705" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11707" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-11709" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11710" href="../Decidable/#plfa_plfa-part1-Decidable-11710" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11712" href="../Decidable/#plfa_plfa-part1-Decidable-11712" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11714" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11716" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-11717" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-11719" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-11721" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-11725" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11726" href="../Decidable/#plfa_plfa-part1-Decidable-11710" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11728" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-11730" href="../Decidable/#plfa_plfa-part1-Decidable-11712" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-11731" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11733" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="plfa_plfa-part1-Decidable-11739" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11742" href="../Decidable/#plfa_plfa-part1-Decidable-11742" class="Bound">n</a>                   <a id="plfa_plfa-part1-Decidable-11762" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11765" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11769" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-11773" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11777" href="../Decidable/#plfa_plfa-part1-Decidable-11777" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11779" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>                <a id="plfa_plfa-part1-Decidable-11802" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11805" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11808" href="../Decidable/#plfa_plfa-part1-Decidable-10762" class="Function">¬s≤z</a>
<a id="plfa_plfa-part1-Decidable-11813" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11817" href="../Decidable/#plfa_plfa-part1-Decidable-11817" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11819" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11822" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11826" href="../Decidable/#plfa_plfa-part1-Decidable-11826" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11828" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-11833" href="../Decidable/#plfa_plfa-part1-Decidable-11817" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11835" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11838" href="../Decidable/#plfa_plfa-part1-Decidable-11826" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-11840" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11858" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11860" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11864" href="../Decidable/#plfa_plfa-part1-Decidable-11864" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Decidable-11869" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11872" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11876" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11877" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-11881" href="../Decidable/#plfa_plfa-part1-Decidable-11864" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-11884" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11886" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11904" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11906" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11909" href="../Decidable/#plfa_plfa-part1-Decidable-11909" class="Bound">¬m≤n</a>  <a id="plfa_plfa-part1-Decidable-11915" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11918" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11921" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11922" href="../Decidable/#plfa_plfa-part1-Decidable-10807" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-11927" href="../Decidable/#plfa_plfa-part1-Decidable-11909" class="Bound">¬m≤n</a><a id="plfa_plfa-part1-Decidable-11931" class="Symbol">)</a>
</pre><p>与 <code>_≤ᵇ_</code> 一样，定义有三条语句。第一条语句中，<code>zero ≤ n</code> 立即成立，由 <code>z≤n</code> 证明。 第二条语句中，<code>suc m ≤ zero</code> 立即不成立，由 <code>¬s≤z</code> 证明。 第三条语句中，我们需要递归地应用 <code>m ≤? n</code>。有两种可能性，在 <code>yes</code> 的情况中，它会返回 <code>m ≤ n</code> 的证明 <code>m≤n</code>，所以 <code>s≤s m≤n</code> 即可作为 <code>suc m ≤ suc n</code> 的证明；在 <code>no</code> 的情况中， 它会返回 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，所以 <code>¬s≤s ¬m≤n</code> 即可作为 <code>¬ (suc m ≤ suc n)</code> 的证明。</p><p>当我们写 <code>_≤ᵇ_</code> 时，我们必须写两个其他的函数 <code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 来证明其正确性。 作为对比，<code>_≤?_</code> 的定义自身就证明了其正确性，由类型即可得知。<code>_≤?_</code> 的代码也比 <code>_≤ᵇ_</code>、<code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 加起来要简洁的多。我们稍后将会证明，如果我们需要后三者， 我们亦可简单地从 <code>_≤?_</code> 中派生出来。</p><p>我们可以使用我们新的函数来<strong>计算</strong>出我们之前需要自己想出来的<strong>证明</strong>。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-13586" href="../Decidable/#plfa_plfa-part1-Decidable-13586" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13588" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13590" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13592" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13595" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13597" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13599" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13603" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13604" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13608" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13609" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13613" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-13616" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13619" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13621" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13623" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Decidable-13629" href="../Decidable/#plfa_plfa-part1-Decidable-13629" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13631" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13633" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13635" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13638" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13640" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13642" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-13645" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13646" href="../Decidable/#plfa_plfa-part1-Decidable-10807" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13651" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13652" href="../Decidable/#plfa_plfa-part1-Decidable-10807" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13657" href="../Decidable/#plfa_plfa-part1-Decidable-10762" class="Function">¬s≤z</a><a id="plfa_plfa-part1-Decidable-13661" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13664" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13666" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13668" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>你可以验证 Agda 的确计算出了这些值。输入 <code>C-c C-n</code> 并给出 <code>2 ≤? 4</code> 或者 <code>4 ≤? 2</code> 作为 需要的表达式，Agda 会输出如上的值。</p><p>（小细节：如果我们不把 <code>¬s≤z</code> 和 <code>¬s≤s</code> 作为顶层函数来定义，而是使用内嵌的匿名函数， Agda 可能会在规范化否定的证明中出现问题。）</p><h4 id="练习-__-推荐">练习 <code>_&lt;?_</code> （推荐）</h4><p>与上面的函数相似，定义一个判定严格不等性的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14414" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_&lt;?_"></a><a id="plfa_plfa-part1-Decidable-14426" href="../Decidable/#plfa_plfa-part1-Decidable-14426" class="Postulate Operator">_&lt;?_</a> <a id="plfa_plfa-part1-Decidable-14431" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14433" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14435" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14436" href="../Decidable/#plfa_plfa-part1-Decidable-14436" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14438" href="../Decidable/#plfa_plfa-part1-Decidable-14438" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14440" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14442" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14443" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14445" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14447" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14451" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14452" href="../Decidable/#plfa_plfa-part1-Decidable-14436" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14454" href="../Relations/#plfa_plfa-part1-Relations-26360" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Decidable-14456" href="../Decidable/#plfa_plfa-part1-Decidable-14438" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14457" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14474" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-_ℕ_实践">练习 <code>_≡ℕ?_</code>（实践）</h4><p>定义一个函数来判定两个自然数是否相等。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14654" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_≡ℕ?_"></a><a id="plfa_plfa-part1-Decidable-14666" href="../Decidable/#plfa_plfa-part1-Decidable-14666" class="Postulate Operator">_≡ℕ?_</a> <a id="plfa_plfa-part1-Decidable-14672" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14674" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14676" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14677" href="../Decidable/#plfa_plfa-part1-Decidable-14677" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14679" href="../Decidable/#plfa_plfa-part1-Decidable-14679" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14681" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14683" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14684" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14686" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14688" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14692" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14693" href="../Decidable/#plfa_plfa-part1-Decidable-14677" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14695" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-14697" href="../Decidable/#plfa_plfa-part1-Decidable-14679" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14698" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14715" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="decidables-from-booleans-and-booleans-from-decidables">从可判定的值到布尔值，从布尔值到可判定的值</h2><p>好奇的读者可能会思考能不能重用 <code>m ≤ᵇ n</code> 的定义，加上它与 <code>m ≤ n</code> 等价的证明， 来证明可判定性。的确，我们是可以做到的：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?′_"></a><a id="plfa_plfa-part1-Decidable-15163" href="../Decidable/#plfa_plfa-part1-Decidable-15163" class="Function Operator">_≤?′_</a> <a id="plfa_plfa-part1-Decidable-15169" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15171" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-15173" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15174" href="../Decidable/#plfa_plfa-part1-Decidable-15174" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15176" href="../Decidable/#plfa_plfa-part1-Decidable-15176" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15178" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15180" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-15181" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-15183" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15185" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15189" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15190" href="../Decidable/#plfa_plfa-part1-Decidable-15174" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15192" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-15194" href="../Decidable/#plfa_plfa-part1-Decidable-15176" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15195" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15197" href="../Decidable/#plfa_plfa-part1-Decidable-15197" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15199" href="../Decidable/#plfa_plfa-part1-Decidable-15163" class="Function Operator">≤?′</a> <a id="plfa_plfa-part1-Decidable-15203" href="../Decidable/#plfa_plfa-part1-Decidable-15203" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15205" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-15210" href="../Decidable/#plfa_plfa-part1-Decidable-15197" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15212" href="../Decidable/#plfa_plfa-part1-Decidable-2764" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15215" href="../Decidable/#plfa_plfa-part1-Decidable-15203" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15217" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15219" href="../Decidable/#plfa_plfa-part1-Decidable-6236" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-15224" href="../Decidable/#plfa_plfa-part1-Decidable-15197" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15226" href="../Decidable/#plfa_plfa-part1-Decidable-15203" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15228" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15230" href="../Decidable/#plfa_plfa-part1-Decidable-7564" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15235" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15236" href="../Decidable/#plfa_plfa-part1-Decidable-15197" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-15237" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-15239" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15240" href="../Decidable/#plfa_plfa-part1-Decidable-15203" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15241" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-15243" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15254" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15256" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-15263" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15265" href="../Decidable/#plfa_plfa-part1-Decidable-15265" class="Bound">p</a>        <a id="plfa_plfa-part1-Decidable-15274" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15276" class="Symbol">_</a>            <a id="plfa_plfa-part1-Decidable-15289" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15291" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15295" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15296" href="../Decidable/#plfa_plfa-part1-Decidable-15265" class="Bound">p</a> <a id="plfa_plfa-part1-Decidable-15298" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-15300" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15302" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15313" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15315" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-15322" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15324" class="Symbol">_</a>        <a id="plfa_plfa-part1-Decidable-15333" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15335" href="../Decidable/#plfa_plfa-part1-Decidable-15335" class="Bound">¬p</a>           <a id="plfa_plfa-part1-Decidable-15348" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15350" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15353" href="../Decidable/#plfa_plfa-part1-Decidable-15335" class="Bound">¬p</a>
</pre><p>如果 <code>m ≤ᵇ n</code> 为真，那么 <code>≤ᵇ→≤</code> 会返回一个 <code>m ≤ n</code> 成立的证明。 如果 <code>m ≤ᵇ n</code> 为假，那么 <code>≤→≤ᵇ</code> 会取一个 <code>m ≤ n</code> 成立的证明，将其转换为一个矛盾。</p><p>在这个证明中，<code>with</code> 语句的三重约束是必须的。如果我们取而代之的写：</p><pre><code>_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})</code></pre><p>那么 Agda 对于每条语句会有一个抱怨：</p><pre><code>⊤ !=&lt; (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=&lt; ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n</code></pre><p>将表达式放在 <code>with</code> 语句中能让 Agda 利用下列事实：当 <code>m ≤ᵇ n</code> 为真时，<code>T (m ≤ᵇ n)</code> 是 <code>⊤</code>；当 <code>m ≤ᵇ n</code> 为假时，<code>T (m ≤ᵇ n)</code> 是 <code>⊥</code>。</p><p>然而，总体来说还是直接定义 <code>_≤?_</code> 比较方便，正如之前部分中那样。如果有人真的很需要 <code>_≤ᵇ_</code>， 那么它和它的性质可以简单地从 <code>_≤?_</code> 中派生出来，正如我们接下来要展示的一样。</p><p>擦除（Erasure）将一个可判定的值转换为一个布尔值：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-⌊_⌋"></a><a id="plfa_plfa-part1-Decidable-16890" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊_⌋</a> <a id="plfa_plfa-part1-Decidable-16894" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16896" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-16898" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-16899" href="../Decidable/#plfa_plfa-part1-Decidable-16899" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16901" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16903" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-16906" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-16908" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16910" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-16914" href="../Decidable/#plfa_plfa-part1-Decidable-16899" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16916" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16918" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-16923" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16925" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-16929" href="../Decidable/#plfa_plfa-part1-Decidable-16929" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-16931" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16934" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16937" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-16942" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16944" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-16947" href="../Decidable/#plfa_plfa-part1-Decidable-16947" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-16950" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16953" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16956" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
</pre><p>使用擦除，我们可以简单地从 <code>_≤?_</code> 中派生出 <code>_≤ᵇ_</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤ᵇ′_"></a><a id="plfa_plfa-part1-Decidable-17076" href="../Decidable/#plfa_plfa-part1-Decidable-17076" class="Function Operator">_≤ᵇ′_</a> <a id="plfa_plfa-part1-Decidable-17082" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17084" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17086" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17088" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17090" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17092" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-17097" href="../Decidable/#plfa_plfa-part1-Decidable-17097" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17099" href="../Decidable/#plfa_plfa-part1-Decidable-17076" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17103" href="../Decidable/#plfa_plfa-part1-Decidable-17103" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-17106" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17109" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17111" href="../Decidable/#plfa_plfa-part1-Decidable-17097" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17113" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-17116" href="../Decidable/#plfa_plfa-part1-Decidable-17103" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17118" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
</pre>更进一步来说，如果 <code>D</code> 是一个类型为 <code>Dec A</code> 的值，那么 <code>T ⌊ D ⌋</code> 当且仅当 <code>A</code> 成立时成立：<pre class="Agda"><a id="plfa_plfa-part1-Decidable-toWitness"></a><a id="plfa_plfa-part1-Decidable-17307" href="../Decidable/#plfa_plfa-part1-Decidable-17307" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17317" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17319" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17321" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17322" href="../Decidable/#plfa_plfa-part1-Decidable-17322" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17324" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17326" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17329" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17331" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17332" href="../Decidable/#plfa_plfa-part1-Decidable-17332" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17334" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17336" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17340" href="../Decidable/#plfa_plfa-part1-Decidable-17322" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17341" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17343" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17345" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17347" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17349" href="../Decidable/#plfa_plfa-part1-Decidable-17332" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17351" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-17353" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17355" href="../Decidable/#plfa_plfa-part1-Decidable-17322" class="Bound">A</a>
<a id="plfa_plfa-part1-Decidable-17357" href="../Decidable/#plfa_plfa-part1-Decidable-17307" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17367" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17368" href="../Decidable/#plfa_plfa-part1-Decidable-17368" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17369" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17371" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17372" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17376" href="../Decidable/#plfa_plfa-part1-Decidable-17376" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17377" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17379" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-17383" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17386" href="../Decidable/#plfa_plfa-part1-Decidable-17376" class="Bound">x</a>
<a id="plfa_plfa-part1-Decidable-17388" href="../Decidable/#plfa_plfa-part1-Decidable-17307" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17398" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17399" href="../Decidable/#plfa_plfa-part1-Decidable-17399" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17400" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17402" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17403" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17406" href="../Decidable/#plfa_plfa-part1-Decidable-17406" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17408" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17410" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-fromWitness"></a><a id="plfa_plfa-part1-Decidable-17414" href="../Decidable/#plfa_plfa-part1-Decidable-17414" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17426" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17428" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17430" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17431" href="../Decidable/#plfa_plfa-part1-Decidable-17431" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17433" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17435" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17438" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17440" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17441" href="../Decidable/#plfa_plfa-part1-Decidable-17441" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17443" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17445" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17449" href="../Decidable/#plfa_plfa-part1-Decidable-17431" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17450" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17452" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17454" href="../Decidable/#plfa_plfa-part1-Decidable-17431" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17456" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17458" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17460" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17462" href="../Decidable/#plfa_plfa-part1-Decidable-17441" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17464" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
<a id="plfa_plfa-part1-Decidable-17466" href="../Decidable/#plfa_plfa-part1-Decidable-17414" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17478" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17479" href="../Decidable/#plfa_plfa-part1-Decidable-17479" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17480" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17482" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17483" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17487" href="../Decidable/#plfa_plfa-part1-Decidable-17487" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17488" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17490" class="Symbol">_</a>  <a id="plfa_plfa-part1-Decidable-17493" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17496" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-17499" href="../Decidable/#plfa_plfa-part1-Decidable-17414" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17511" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17512" href="../Decidable/#plfa_plfa-part1-Decidable-17512" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17513" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17515" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17516" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17519" href="../Decidable/#plfa_plfa-part1-Decidable-17519" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17521" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17523" href="../Decidable/#plfa_plfa-part1-Decidable-17523" class="Bound">x</a>  <a id="plfa_plfa-part1-Decidable-17526" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17529" href="../Decidable/#plfa_plfa-part1-Decidable-17519" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-17532" href="../Decidable/#plfa_plfa-part1-Decidable-17523" class="Bound">x</a>
</pre><p>使用这些，我们可以简单地派生出 <code>T (m ≤ᵇ′ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ′→≤"></a><a id="plfa_plfa-part1-Decidable-17709" href="../Decidable/#plfa_plfa-part1-Decidable-17709" class="Function">≤ᵇ′→≤</a> <a id="plfa_plfa-part1-Decidable-17715" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17717" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17719" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17720" href="../Decidable/#plfa_plfa-part1-Decidable-17720" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17722" href="../Decidable/#plfa_plfa-part1-Decidable-17722" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17724" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17726" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17727" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17729" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17731" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17733" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17734" href="../Decidable/#plfa_plfa-part1-Decidable-17720" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17736" href="../Decidable/#plfa_plfa-part1-Decidable-17076" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17740" href="../Decidable/#plfa_plfa-part1-Decidable-17722" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17741" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-17743" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17745" href="../Decidable/#plfa_plfa-part1-Decidable-17720" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17747" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17749" href="../Decidable/#plfa_plfa-part1-Decidable-17722" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-17751" href="../Decidable/#plfa_plfa-part1-Decidable-17709" class="Function">≤ᵇ′→≤</a>  <a id="plfa_plfa-part1-Decidable-17758" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17761" href="../Decidable/#plfa_plfa-part1-Decidable-17307" class="Function">toWitness</a>

<a id="plfa_plfa-part1-Decidable-≤→≤ᵇ′"></a><a id="plfa_plfa-part1-Decidable-17772" href="../Decidable/#plfa_plfa-part1-Decidable-17772" class="Function">≤→≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17778" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17780" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17782" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17783" href="../Decidable/#plfa_plfa-part1-Decidable-17783" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17785" href="../Decidable/#plfa_plfa-part1-Decidable-17785" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17787" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17789" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17790" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17792" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17794" href="../Decidable/#plfa_plfa-part1-Decidable-17783" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17796" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17798" href="../Decidable/#plfa_plfa-part1-Decidable-17785" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17800" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17802" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17804" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17805" href="../Decidable/#plfa_plfa-part1-Decidable-17783" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17807" href="../Decidable/#plfa_plfa-part1-Decidable-17076" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17811" href="../Decidable/#plfa_plfa-part1-Decidable-17785" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17812" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-17814" href="../Decidable/#plfa_plfa-part1-Decidable-17772" class="Function">≤→≤ᵇ′</a>  <a id="plfa_plfa-part1-Decidable-17821" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17824" href="../Decidable/#plfa_plfa-part1-Decidable-17414" class="Function">fromWitness</a>
</pre><p>总结来说，最好避免直接使用布尔值，而使用可判定的值。如果有需要布尔值的时候，它们和它们的性质 可以简单地从对应的可判定的值中派生而来。</p><h2 id="logical-connectives">逻辑连接符</h2><p>大多数读者对于布尔值的逻辑运算符很熟悉了。每个逻辑运算符都可以被延伸至可判定的值。</p><p>两个布尔值的合取当两者都为真时为真，当任一为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-18460" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-18467" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-18469" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="Function Operator">_∧_</a>

<a id="plfa_plfa-part1-Decidable-_∧_"></a><a id="plfa_plfa-part1-Decidable-18474" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Decidable-18478" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18480" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18485" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18487" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18492" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18494" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-18499" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18505" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18507" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18513" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18515" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-18520" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18526" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18528" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-18534" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18536" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-18542" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-18543" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-18548" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="CatchallClause Function Operator">∧</a><a id="plfa_plfa-part1-Decidable-18549" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-18550" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="CatchallClause InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18556" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18558" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第三个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第二条还是第三条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-19018" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-19025" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-19027" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="Function Operator">_×-dec_</a>

<a id="plfa_plfa-part1-Decidable-_×-dec_"></a><a id="plfa_plfa-part1-Decidable-19036" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="Function Operator">_×-dec_</a> <a id="plfa_plfa-part1-Decidable-19044" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19046" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-19048" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-19049" href="../Decidable/#plfa_plfa-part1-Decidable-19049" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19051" href="../Decidable/#plfa_plfa-part1-Decidable-19051" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19053" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19055" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-19058" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-19060" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19062" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19066" href="../Decidable/#plfa_plfa-part1-Decidable-19049" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19068" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19070" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19074" href="../Decidable/#plfa_plfa-part1-Decidable-19051" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19076" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19078" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19082" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19083" href="../Decidable/#plfa_plfa-part1-Decidable-19049" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19085" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Decidable-19087" href="../Decidable/#plfa_plfa-part1-Decidable-19051" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-19088" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-19090" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19094" href="../Decidable/#plfa_plfa-part1-Decidable-19094" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19096" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19102" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19106" href="../Decidable/#plfa_plfa-part1-Decidable-19106" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19108" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19110" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19114" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19116" href="../Decidable/#plfa_plfa-part1-Decidable-19094" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19118" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19120" href="../Decidable/#plfa_plfa-part1-Decidable-19106" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19122" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Decidable-19124" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19127" href="../Decidable/#plfa_plfa-part1-Decidable-19127" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19130" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19136" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-19142" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19144" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19147" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19150" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19152" href="../Decidable/#plfa_plfa-part1-Decidable-19152" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19154" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19156" href="../Decidable/#plfa_plfa-part1-Decidable-19156" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19158" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19160" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19162" href="../Decidable/#plfa_plfa-part1-Decidable-19127" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19165" href="../Decidable/#plfa_plfa-part1-Decidable-19152" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19167" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-19169" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-19170" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-19175" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="CatchallClause Function Operator">×-dec</a><a id="plfa_plfa-part1-Decidable-19180" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19181" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-19183" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19184" href="../Decidable/#plfa_plfa-part1-Decidable-19184" class="CatchallClause Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19187" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19189" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19192" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19195" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19197" href="../Decidable/#plfa_plfa-part1-Decidable-19197" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19199" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19201" href="../Decidable/#plfa_plfa-part1-Decidable-19201" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19203" href="../Decidable/#plfa_plfa-part1-Decidable-964" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19205" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19207" href="../Decidable/#plfa_plfa-part1-Decidable-19184" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19210" href="../Decidable/#plfa_plfa-part1-Decidable-19201" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19212" class="Symbol">}</a>
</pre><p>两个命题的合取当两者都成立时成立，其否定则当任意一者否定成立时成立。如果两个都成立， 我们将每一证明放入数据对中，作为合取的证明。如果任意一者的否定成立，假设整个合取将会引入一个矛盾。</p><p>同样地，在 Emacs 中，第三条等式在左手边以灰色显示，说明等式的顺序决定了第二条还是第三条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都不成立，我们选择第一个来构造矛盾， 但选择第二个也是同样正确的。</p><p>两个布尔值的析取当任意为真时为真，当两者为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20239" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20246" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20248" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="Function Operator">_∨_</a>

<a id="plfa_plfa-part1-Decidable-_∨_"></a><a id="plfa_plfa-part1-Decidable-20253" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="Function Operator">_∨_</a> <a id="plfa_plfa-part1-Decidable-20257" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20259" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20264" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20266" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20271" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20273" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-20278" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-20284" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20286" class="Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-20293" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20295" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20300" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20301" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20306" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="CatchallClause Function Operator">∨</a><a id="plfa_plfa-part1-Decidable-20307" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20308" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="CatchallClause InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-20315" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20317" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20322" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-20328" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20330" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-20337" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20339" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20800" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20807" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20809" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="Function Operator">_⊎-dec_</a>

<a id="plfa_plfa-part1-Decidable-_⊎-dec_"></a><a id="plfa_plfa-part1-Decidable-20818" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="Function Operator">_⊎-dec_</a> <a id="plfa_plfa-part1-Decidable-20826" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20828" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-20830" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-20831" href="../Decidable/#plfa_plfa-part1-Decidable-20831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20833" href="../Decidable/#plfa_plfa-part1-Decidable-20833" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20835" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20837" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-20840" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-20842" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20844" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20848" href="../Decidable/#plfa_plfa-part1-Decidable-20831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20850" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20852" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20856" href="../Decidable/#plfa_plfa-part1-Decidable-20833" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20858" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20860" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20864" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20865" href="../Decidable/#plfa_plfa-part1-Decidable-20831" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20867" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Decidable-20869" href="../Decidable/#plfa_plfa-part1-Decidable-20833" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-20870" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20872" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20876" href="../Decidable/#plfa_plfa-part1-Decidable-20876" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20878" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20884" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-20890" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20892" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20896" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20897" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20902" href="../Decidable/#plfa_plfa-part1-Decidable-20876" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20903" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20905" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20906" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20911" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="CatchallClause Function Operator">⊎-dec</a><a id="plfa_plfa-part1-Decidable-20916" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20917" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="CatchallClause InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-20920" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20921" href="../Decidable/#plfa_plfa-part1-Decidable-20921" class="CatchallClause Bound">y</a> <a id="plfa_plfa-part1-Decidable-20923" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20925" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20929" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20930" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-20935" href="../Decidable/#plfa_plfa-part1-Decidable-20921" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-20936" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20938" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20941" href="../Decidable/#plfa_plfa-part1-Decidable-20941" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20944" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20950" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20953" href="../Decidable/#plfa_plfa-part1-Decidable-20953" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-20956" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20958" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20961" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-20964" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20965" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20970" href="../Decidable/#plfa_plfa-part1-Decidable-20970" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20971" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-20973" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20975" href="../Decidable/#plfa_plfa-part1-Decidable-20941" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20978" href="../Decidable/#plfa_plfa-part1-Decidable-20970" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20980" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-20982" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20983" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-20988" href="../Decidable/#plfa_plfa-part1-Decidable-20988" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-20989" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-20991" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20993" href="../Decidable/#plfa_plfa-part1-Decidable-20953" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-20996" href="../Decidable/#plfa_plfa-part1-Decidable-20988" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-20998" class="Symbol">}</a>
</pre><p>两个命题的析取当任意一者成立时成立，其否定则当两者的否定成立时成立。如果任意一者成立， 我们使用其证明来作为析取的证明。如果两个的否定都成立，假设任意一者都会引入一个矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都成立，我们选择第一个来构造析取， 但选择第二个也是同样正确的。</p><p>一个布尔值的否定当值为真时为假，反之亦然：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-not"></a><a id="plfa_plfa-part1-Decidable-21953" href="../Decidable/#plfa_plfa-part1-Decidable-21953" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21957" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21959" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-21964" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21966" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-21971" href="../Decidable/#plfa_plfa-part1-Decidable-21953" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21975" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-21981" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21983" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-21989" href="../Decidable/#plfa_plfa-part1-Decidable-21953" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21993" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-21999" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-22001" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
</pre><p>相应地，给定一个可判定的命题，我们可以判定它的否定：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬?"></a><a id="plfa_plfa-part1-Decidable-22133" href="../Decidable/#plfa_plfa-part1-Decidable-22133" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22136" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22138" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-22140" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-22141" href="../Decidable/#plfa_plfa-part1-Decidable-22141" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22143" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22145" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-22148" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-22150" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22152" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22156" href="../Decidable/#plfa_plfa-part1-Decidable-22141" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22158" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22160" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22164" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22165" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-22167" href="../Decidable/#plfa_plfa-part1-Decidable-22141" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-22168" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22170" href="../Decidable/#plfa_plfa-part1-Decidable-22133" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22173" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22174" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22178" href="../Decidable/#plfa_plfa-part1-Decidable-22178" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22179" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22182" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22185" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22188" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22189" href="../Decidable/#plfa_plfa-part1-Decidable-1132" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Decidable-22198" href="../Decidable/#plfa_plfa-part1-Decidable-22178" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22199" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22201" href="../Decidable/#plfa_plfa-part1-Decidable-22133" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22204" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22205" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22208" href="../Decidable/#plfa_plfa-part1-Decidable-22208" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-22210" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22213" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22216" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22220" href="../Decidable/#plfa_plfa-part1-Decidable-22208" class="Bound">¬x</a>
</pre><p>我们直接把 yes 和 no 交换。在第一个等式中，右手边断言了 <code>¬ A</code> 的否定成立，也就是说 <code>¬ ¬ A</code> 成立——这是一个 <code>A</code> 成立时可以简单得到的推论。</p><p>还有一个与蕴涵相对应，但是稍微不那么知名的运算符：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_⊃_"></a><a id="plfa_plfa-part1-Decidable-22656" href="../Decidable/#plfa_plfa-part1-Decidable-22656" class="Function Operator">_⊃_</a> <a id="plfa_plfa-part1-Decidable-22660" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22662" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22667" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22669" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22674" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22676" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-22681" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-22687" href="../Decidable/#plfa_plfa-part1-Decidable-22656" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22689" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-22696" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22699" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22704" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="CatchallClause InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-22709" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22710" href="../Decidable/#plfa_plfa-part1-Decidable-22656" class="CatchallClause Function Operator">⊃</a><a id="plfa_plfa-part1-Decidable-22711" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22712" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-22719" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22722" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22727" href="../Decidable/#plfa_plfa-part1-Decidable-2504" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-22733" href="../Decidable/#plfa_plfa-part1-Decidable-22656" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22735" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-22742" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22745" href="../Decidable/#plfa_plfa-part1-Decidable-2519" class="InductiveConstructor">false</a>
</pre><p>当任何一个布尔值为真的时候，另一个布尔值恒为真，我们成为第一个布尔值蕴涵第二个布尔值。 因此，两者的蕴涵在第二个为真或者第一个为假时为真，在第一个为真而第二个为假时为假。 在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_→-dec_"></a><a id="plfa_plfa-part1-Decidable-23537" href="../Decidable/#plfa_plfa-part1-Decidable-23537" class="Function Operator">_→-dec_</a> <a id="plfa_plfa-part1-Decidable-23545" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23547" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-23549" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-23550" href="../Decidable/#plfa_plfa-part1-Decidable-23550" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23552" href="../Decidable/#plfa_plfa-part1-Decidable-23552" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23554" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23556" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-23559" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-23561" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23563" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23567" href="../Decidable/#plfa_plfa-part1-Decidable-23550" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23569" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23571" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23575" href="../Decidable/#plfa_plfa-part1-Decidable-23552" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23577" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23579" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23583" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23584" href="../Decidable/#plfa_plfa-part1-Decidable-23550" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23586" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23588" href="../Decidable/#plfa_plfa-part1-Decidable-23552" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-23589" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23591" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-23597" href="../Decidable/#plfa_plfa-part1-Decidable-23537" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23603" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23607" href="../Decidable/#plfa_plfa-part1-Decidable-23607" class="Bound">y</a>  <a id="plfa_plfa-part1-Decidable-23610" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23613" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23617" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23620" href="../Decidable/#plfa_plfa-part1-Decidable-23620" class="Bound">_</a> <a id="plfa_plfa-part1-Decidable-23622" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23624" href="../Decidable/#plfa_plfa-part1-Decidable-23607" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-23625" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23627" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-23629" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23630" href="../Decidable/#plfa_plfa-part1-Decidable-23630" class="CatchallClause Bound">¬x</a><a id="plfa_plfa-part1-Decidable-23632" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23633" href="../Decidable/#plfa_plfa-part1-Decidable-23537" class="CatchallClause Function Operator">→-dec</a><a id="plfa_plfa-part1-Decidable-23638" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23639" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-23646" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23649" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23653" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23656" href="../Decidable/#plfa_plfa-part1-Decidable-23656" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23658" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23660" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Decidable-23667" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23668" href="../Decidable/#plfa_plfa-part1-Decidable-23630" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-23671" href="../Decidable/#plfa_plfa-part1-Decidable-23656" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-23672" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-23675" href="../Decidable/#plfa_plfa-part1-Decidable-9877" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23679" href="../Decidable/#plfa_plfa-part1-Decidable-23679" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23681" href="../Decidable/#plfa_plfa-part1-Decidable-23537" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23687" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23690" href="../Decidable/#plfa_plfa-part1-Decidable-23690" class="Bound">¬y</a>  <a id="plfa_plfa-part1-Decidable-23694" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23697" href="../Decidable/#plfa_plfa-part1-Decidable-9897" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23700" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23703" href="../Decidable/#plfa_plfa-part1-Decidable-23703" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23705" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23707" href="../Decidable/#plfa_plfa-part1-Decidable-23690" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-23710" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23711" href="../Decidable/#plfa_plfa-part1-Decidable-23703" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23713" href="../Decidable/#plfa_plfa-part1-Decidable-23679" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-23714" class="Symbol">))</a>
</pre><p>两者的蕴涵在第二者成立或者第一者的否定成立时成立，其否定在第一者成立而第二者否定成立时成立。 蕴涵成立的证明是一个从第一者成立的证明到第二者成立的证明的函数。如果第二者成立，那么这个函数 直接返回第二者的证明。如果第一者的否定成立，那么使用第一者成立的证明，构造一个矛盾。 如果第一者成立，第二者不成立，给定蕴涵成立的证明，我们必须构造一个矛盾：我们将成立的证明 <code>f</code> 应用于第一者成立的证明 <code>x</code>，再加以第二者否定成立的证明 <code>¬y</code> 来构造矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是哪一条被匹配而不一样，但两者都是同样正确的。</p><h4 id="练习-erasure实践">练习 <code>erasure</code>（实践）</h4><p>证明擦除将对应的布尔值和可判定的值的操作联系了起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25233" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-∧-×"></a><a id="plfa_plfa-part1-Decidable-25245" href="../Decidable/#plfa_plfa-part1-Decidable-25245" class="Postulate">∧-×</a> <a id="plfa_plfa-part1-Decidable-25249" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25251" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25253" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25254" href="../Decidable/#plfa_plfa-part1-Decidable-25254" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25256" href="../Decidable/#plfa_plfa-part1-Decidable-25256" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25258" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25260" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25263" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25265" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25266" href="../Decidable/#plfa_plfa-part1-Decidable-25266" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25268" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25270" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25274" href="../Decidable/#plfa_plfa-part1-Decidable-25254" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25275" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25277" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25278" href="../Decidable/#plfa_plfa-part1-Decidable-25278" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25280" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25282" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25286" href="../Decidable/#plfa_plfa-part1-Decidable-25256" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25287" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25289" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25291" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25293" href="../Decidable/#plfa_plfa-part1-Decidable-25266" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25295" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25297" href="../Decidable/#plfa_plfa-part1-Decidable-18474" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-25299" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25301" href="../Decidable/#plfa_plfa-part1-Decidable-25278" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25303" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25305" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25307" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25309" href="../Decidable/#plfa_plfa-part1-Decidable-25266" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25311" href="../Decidable/#plfa_plfa-part1-Decidable-19036" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-25317" href="../Decidable/#plfa_plfa-part1-Decidable-25278" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25319" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-∨-⊎"></a><a id="plfa_plfa-part1-Decidable-25323" href="../Decidable/#plfa_plfa-part1-Decidable-25323" class="Postulate">∨-⊎</a> <a id="plfa_plfa-part1-Decidable-25327" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25329" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25331" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25332" href="../Decidable/#plfa_plfa-part1-Decidable-25332" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25334" href="../Decidable/#plfa_plfa-part1-Decidable-25334" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25336" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25338" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25341" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25343" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25344" href="../Decidable/#plfa_plfa-part1-Decidable-25344" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25346" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25348" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25352" href="../Decidable/#plfa_plfa-part1-Decidable-25332" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25353" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25355" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25356" href="../Decidable/#plfa_plfa-part1-Decidable-25356" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25358" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25360" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25364" href="../Decidable/#plfa_plfa-part1-Decidable-25334" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25365" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25367" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25369" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25371" href="../Decidable/#plfa_plfa-part1-Decidable-25344" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25373" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25375" href="../Decidable/#plfa_plfa-part1-Decidable-20253" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-25377" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25379" href="../Decidable/#plfa_plfa-part1-Decidable-25356" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25381" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25383" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25385" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25387" href="../Decidable/#plfa_plfa-part1-Decidable-25344" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25389" href="../Decidable/#plfa_plfa-part1-Decidable-20818" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-25395" href="../Decidable/#plfa_plfa-part1-Decidable-25356" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25397" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-not-¬"></a><a id="plfa_plfa-part1-Decidable-25401" href="../Decidable/#plfa_plfa-part1-Decidable-25401" class="Postulate">not-¬</a> <a id="plfa_plfa-part1-Decidable-25407" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25409" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25411" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25412" href="../Decidable/#plfa_plfa-part1-Decidable-25412" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25414" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25416" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25419" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25421" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25422" href="../Decidable/#plfa_plfa-part1-Decidable-25422" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25424" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25426" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25430" href="../Decidable/#plfa_plfa-part1-Decidable-25412" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25431" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25433" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25435" href="../Decidable/#plfa_plfa-part1-Decidable-21953" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-25439" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25441" href="../Decidable/#plfa_plfa-part1-Decidable-25422" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25443" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25445" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25447" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25449" href="../Decidable/#plfa_plfa-part1-Decidable-22133" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-25452" href="../Decidable/#plfa_plfa-part1-Decidable-25422" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25454" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
</pre><h4 id="练习-iff-erasure-推荐">练习 <code>iff-erasure</code> （推荐）</h4><p>给出与<a href="../Isomorphism/#iff">同构与嵌入</a>章节中 <code>_↔︎_</code> 相对应的布尔值与可判定的值的操作， 并证明其对应的擦除：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25792" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_iff_"></a><a id="plfa_plfa-part1-Decidable-25804" href="../Decidable/#plfa_plfa-part1-Decidable-25804" class="Postulate Operator">_iff_</a> <a id="plfa_plfa-part1-Decidable-25810" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25812" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25817" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25819" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25824" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25826" href="../Decidable/#plfa_plfa-part1-Decidable-2485" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-_⇔-dec_"></a><a id="plfa_plfa-part1-Decidable-25833" href="../Decidable/#plfa_plfa-part1-Decidable-25833" class="Postulate Operator">_⇔-dec_</a> <a id="plfa_plfa-part1-Decidable-25841" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25843" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25845" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25846" href="../Decidable/#plfa_plfa-part1-Decidable-25846" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25848" href="../Decidable/#plfa_plfa-part1-Decidable-25848" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25850" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25852" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25855" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25857" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25859" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25863" href="../Decidable/#plfa_plfa-part1-Decidable-25846" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25865" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25867" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25871" href="../Decidable/#plfa_plfa-part1-Decidable-25848" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25873" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25875" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25879" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25880" href="../Decidable/#plfa_plfa-part1-Decidable-25846" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25882" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14960" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Decidable-25884" href="../Decidable/#plfa_plfa-part1-Decidable-25848" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25885" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Decidable-iff-⇔"></a><a id="plfa_plfa-part1-Decidable-25889" href="../Decidable/#plfa_plfa-part1-Decidable-25889" class="Postulate">iff-⇔</a> <a id="plfa_plfa-part1-Decidable-25895" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25897" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25899" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25900" href="../Decidable/#plfa_plfa-part1-Decidable-25900" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25902" href="../Decidable/#plfa_plfa-part1-Decidable-25902" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25904" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25906" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25909" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25911" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25912" href="../Decidable/#plfa_plfa-part1-Decidable-25912" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25914" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25916" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25920" href="../Decidable/#plfa_plfa-part1-Decidable-25900" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25921" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25923" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25924" href="../Decidable/#plfa_plfa-part1-Decidable-25924" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25926" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25928" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25932" href="../Decidable/#plfa_plfa-part1-Decidable-25902" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25933" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25935" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25937" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25939" href="../Decidable/#plfa_plfa-part1-Decidable-25912" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25941" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25943" href="../Decidable/#plfa_plfa-part1-Decidable-25804" class="Postulate Operator">iff</a> <a id="plfa_plfa-part1-Decidable-25947" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25949" href="../Decidable/#plfa_plfa-part1-Decidable-25924" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25951" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25953" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25955" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25957" href="../Decidable/#plfa_plfa-part1-Decidable-25912" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25959" href="../Decidable/#plfa_plfa-part1-Decidable-25833" class="Postulate Operator">⇔-dec</a> <a id="plfa_plfa-part1-Decidable-25965" href="../Decidable/#plfa_plfa-part1-Decidable-25924" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25967" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25984" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="proof-by-reflection">互映证明</h2><p>让我们回顾一下章节<a href="../Naturals/">自然数</a>中 <code>monus</code> 的定义。 如果从一个较小的数中减去一个较大的数，结果为零。毕竟我们总是要得到一个结果。 我们可以用其他方式定义吗？可以定义一版带有<strong>守卫（guarded）</strong>的减法──只有当 <code>n ≤ m</code> 时才能从 <code>m</code> 中减去 <code>n</code> ：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-minus"></a><a id="plfa_plfa-part1-Decidable-26601" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26607" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26609" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26610" href="../Decidable/#plfa_plfa-part1-Decidable-26610" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26612" href="../Decidable/#plfa_plfa-part1-Decidable-26612" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26614" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26616" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-26617" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26619" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26620" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-26624" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26626" href="../Decidable/#plfa_plfa-part1-Decidable-26612" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26628" href="../Decidable/#plfa_plfa-part1-Decidable-1650" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-26630" href="../Decidable/#plfa_plfa-part1-Decidable-26610" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26631" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26633" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-26635" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-26637" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26643" href="../Decidable/#plfa_plfa-part1-Decidable-26643" class="Bound">m</a>       <a id="plfa_plfa-part1-Decidable-26651" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-26659" class="Symbol">_</a>         <a id="plfa_plfa-part1-Decidable-26669" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26671" href="../Decidable/#plfa_plfa-part1-Decidable-26643" class="Bound">m</a>
<a id="plfa_plfa-part1-Decidable-26673" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26679" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26684" href="../Decidable/#plfa_plfa-part1-Decidable-26684" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26685" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26687" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26688" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26692" href="../Decidable/#plfa_plfa-part1-Decidable-26692" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-26693" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26695" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26696" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26700" href="../Decidable/#plfa_plfa-part1-Decidable-26700" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-26703" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26705" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26707" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26713" href="../Decidable/#plfa_plfa-part1-Decidable-26684" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26715" href="../Decidable/#plfa_plfa-part1-Decidable-26692" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26717" href="../Decidable/#plfa_plfa-part1-Decidable-26700" class="Bound">n≤m</a>
</pre><p>然而这种定义难以使用，因为我们必须显式地为 <code>n ≤ m</code> 提供证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-26878" href="../Decidable/#plfa_plfa-part1-Decidable-26878" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-26880" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26882" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26888" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-26890" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-26892" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26893" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26897" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26898" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26902" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26903" href="../Decidable/#plfa_plfa-part1-Decidable-1726" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26907" href="../Decidable/#plfa_plfa-part1-Decidable-1677" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-26910" class="Symbol">)))</a> <a id="plfa_plfa-part1-Decidable-26914" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-26916" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-26918" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-26920" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26922" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>这个问题没有通用的解决方案，但是在上述的情景下，我们恰好<strong>静态地</strong>知道这两个数字。这种情况下，我们可以使用一种被称为<strong>互映证明（proof by reflection）</strong>的技术。 实质上，在类型检查的时候我们可以让 Agda 运行可判定的等式 <code>n ≤? m</code> 并且保证 <code>n ≤ m</code>！</p><p>我们使用「隐式参数」的一个特性来实现这个功能。如果 Agda 可以填充一个记录类型的所有字段，那么 Agda 就可以填充此记录类型的隐式参数。 由于空记录类型没有任何字段，Agda 总是会设法填充空记录类型的隐式参数。这就是 <code>⊤</code> 类型被定义成空记录的原因。</p><p>这里的技巧是设置一个类型为 <code>T ⌊ n ≤? m ⌋</code> 的隐式参数。让我们一步一步阐述这句话的含义。 首先，我们运行判定过程 <code>n ≤? m</code>。它向我们提供了 <code>n ≤ m</code> 是否成立的证据。我们擦除证据得到布尔值。 最后，我们应用 <code>T</code>。回想一下，<code>T</code> 将布尔值映射到证据的世界：<code>true</code> 变成了单位类型 <code>⊤</code>， <code>false</code> 变成了空类型 <code>⊥</code> 。在操作上，这个类型的隐式参数起到了守卫的作用。</p><ul><li>如果 <code>n ≤ m</code> 成立，隐式参数的类型归约为 <code>⊤</code>。 然后 Agda 会欣然地提供隐式参数。</li><li>否则，类型归约为 <code>⊥</code> ，Agda 无法为此类型提供对应的值，因此会报错。例如，如果我们调用 <code>3 - 5</code> 会得到 <code>_n≤m_254 : ⊥</code>。</li></ul><p>我们使用之前定义的 <code>toWitness</code> 获得了 <code>n ≤ m</code> 的证据：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_-_"></a><a id="plfa_plfa-part1-Decidable-29085" href="../Decidable/#plfa_plfa-part1-Decidable-29085" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29089" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29091" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29092" href="../Decidable/#plfa_plfa-part1-Decidable-29092" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29094" href="../Decidable/#plfa_plfa-part1-Decidable-29094" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29096" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29098" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-29099" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-29101" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29102" href="../Decidable/#plfa_plfa-part1-Decidable-29102" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-29106" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29108" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29110" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29112" href="../Decidable/#plfa_plfa-part1-Decidable-29094" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29114" href="../Decidable/#plfa_plfa-part1-Decidable-11700" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-29117" href="../Decidable/#plfa_plfa-part1-Decidable-29092" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29119" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a><a id="plfa_plfa-part1-Decidable-29120" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29122" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29124" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-29126" href="../Decidable/#plfa_plfa-part1-Decidable-29085" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29130" href="../Decidable/#plfa_plfa-part1-Decidable-29130" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29132" href="../Decidable/#plfa_plfa-part1-Decidable-29132" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29134" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29135" href="../Decidable/#plfa_plfa-part1-Decidable-29135" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29138" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29140" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29142" href="../Decidable/#plfa_plfa-part1-Decidable-26601" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-29148" href="../Decidable/#plfa_plfa-part1-Decidable-29130" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29150" href="../Decidable/#plfa_plfa-part1-Decidable-29132" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29152" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29153" href="../Decidable/#plfa_plfa-part1-Decidable-17307" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-29163" href="../Decidable/#plfa_plfa-part1-Decidable-29135" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29166" class="Symbol">)</a>
</pre><p>我们现在只要能静态地知道这两个数就可以安全地使用 <code>_-_</code> 了：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-29297" href="../Decidable/#plfa_plfa-part1-Decidable-29297" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-29299" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29301" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-29303" href="../Decidable/#plfa_plfa-part1-Decidable-29085" class="Function Operator">-</a> <a id="plfa_plfa-part1-Decidable-29305" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-29307" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-29309" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-29311" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-29313" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29315" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>事实上，这种惯用语法非常普遍。标准库为 <code>T ⌊ ? ⌋</code> 定义了叫做 <code>True</code> 的同义词：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-True"></a><a id="plfa_plfa-part1-Decidable-29506" href="../Decidable/#plfa_plfa-part1-Decidable-29506" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29511" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29513" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-29515" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29516" href="../Decidable/#plfa_plfa-part1-Decidable-29516" class="Bound">Q</a><a id="plfa_plfa-part1-Decidable-29517" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29519" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29521" href="../Decidable/#plfa_plfa-part1-Decidable-9849" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-29525" href="../Decidable/#plfa_plfa-part1-Decidable-29516" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29527" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29529" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-29533" href="../Decidable/#plfa_plfa-part1-Decidable-29506" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29538" href="../Decidable/#plfa_plfa-part1-Decidable-29538" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29540" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29542" href="../Decidable/#plfa_plfa-part1-Decidable-4496" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29544" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29546" href="../Decidable/#plfa_plfa-part1-Decidable-29538" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29548" href="../Decidable/#plfa_plfa-part1-Decidable-16890" class="Function Operator">⌋</a>
</pre><h4 id="练习-false-实践">练习 <code>False</code> （实践）</h4><p>给出 <code>True</code>，<code>toWitness</code> 和 <code>fromWitness</code> 的<strong>相反</strong>定义。分别称为 <code>False</code>，<code>toWitnessFalse</code> 和 <code>fromWitnessFalse</code>。</p><h4 id="练习-bin-decidable延伸">练习 <code>Bin-decidable</code>（延伸）</h4><p>回想练习 <a href="../Naturals/#Bin">Bin</a>、 <a href="../Induction/#Bin-laws">Bin-laws</a> 和 <a href="../Relations/#Bin-predicates">Bin-predicates</a>，定义一个用比特串表示自然数的数据类型 <code>Bin</code>，并定义以下谓词：</p><pre><code>One  : Bin → Set
Can  : Bin → Set</code></pre><p>证明以上二者是可判定的。</p><pre><code>One? : ∀ (b : Bin) → Dec (One b)
Can? : ∀ (b : Bin) → Dec (Can b)</code></pre><h2 id="标准库">标准库</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-30596" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30603" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Decidable-30618" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30624" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-30629" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Decidable-30635" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30637" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-30642" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30644" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Decidable-30645" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30647" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Decidable-30650" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30652" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Decidable-30655" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30657" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Decidable-30660" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30662" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30669" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-30678" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30684" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30685" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#5518" class="Function Operator">_≤?_</a><a id="plfa_plfa-part1-Decidable-30689" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30691" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30698" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-30715" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30721" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30722" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Decidable-30725" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30727" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-30730" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30732" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-30734" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30736" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30743" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="plfa_plfa-part1-Decidable-30770" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30776" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30777" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊_⌋</a><a id="plfa_plfa-part1-Decidable-30780" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30782" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="plfa_plfa-part1-Decidable-30786" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30788" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1484" class="Function">toWitness</a><a id="plfa_plfa-part1-Decidable-30797" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30799" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1653" class="Function">fromWitness</a><a id="plfa_plfa-part1-Decidable-30810" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30812" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30819" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-30845" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30851" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30852" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#1355" class="Function">¬?</a><a id="plfa_plfa-part1-Decidable-30854" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30856" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30863" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html" class="Module">Relation.Nullary.Product</a> <a id="plfa_plfa-part1-Decidable-30888" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30894" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30895" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html#921" class="Function Operator">_×-dec_</a><a id="plfa_plfa-part1-Decidable-30902" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30904" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30911" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html" class="Module">Relation.Nullary.Sum</a> <a id="plfa_plfa-part1-Decidable-30932" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30938" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30939" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html#946" class="Function Operator">_⊎-dec_</a><a id="plfa_plfa-part1-Decidable-30946" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30948" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30955" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Decidable-30971" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30977" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30978" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Decidable-30987" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><pre><code>∧  U+2227  逻辑和 (\and, \wedge)
∨  U+2228  逻辑或 (\or, \vee)
⊃  U+2283  超集 (\sup)
ᵇ  U+1D47  修饰符小写 B  (\^b)
⌊  U+230A  左向下取整 (\clL)
⌋  U+230B  右向下取整 (\clR)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Fangyi Zhou、Oshmkufa2010<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>