<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Decidable</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Decidable: 布尔值与判定过程</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Decidable-138" class="Keyword">module</a> <a id="plfa_plfa-part1-Decidable-145" href="../Decidable/#" class="Module">plfa.part1.Decidable</a> <a id="plfa_plfa-part1-Decidable-166" class="Keyword">where</a>
</pre><p>我们有两种不同的方式来表示关系：一是表示为由关系成立的<strong>证明（Evidence）</strong>所构成的数据类型； 二是表示为一个<strong>计算（Compute）</strong>关系是否成立的函数。在本章中，我们将探讨这两种方式之间的关系。 我们首先研究大家熟悉的<strong>布尔值（Boolean）</strong>记法，但是之后我们会发现，相较布尔值记法， 使用一种新的<strong>可判定性（Decidable）</strong>记法将会是更好的选择。</p><h2 id="导入">导入</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-787" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-794" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Decidable-832" class="Symbol">as</a> <a id="plfa_plfa-part1-Decidable-835" class="Module">Eq</a>
<a id="plfa_plfa-part1-Decidable-838" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-843" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Decidable-846" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-852" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-853" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Decidable-856" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-858" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Decidable-862" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-864" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-869" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Decidable-884" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-889" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-896" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-905" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-911" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-912" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-913" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-915" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-919" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-921" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Decidable-924" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-926" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-931" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-938" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Decidable-951" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-957" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-958" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Decidable-961" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-963" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-972" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-973" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Decidable-977" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Decidable-985" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-987" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-992" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-999" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Decidable-1008" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1014" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1015" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Decidable-1018" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1020" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Decidable-1024" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1026" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Decidable-1030" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1032" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1037" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1044" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-1061" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1067" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1068" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Decidable-1070" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1072" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1077" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1084" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-1110" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1116" class="Symbol">()</a>
  <a id="plfa_plfa-part1-Decidable-1121" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-1130" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1131" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="plfa_plfa-part1-Decidable-1145" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-1148" class="Function">¬¬-intro</a><a id="plfa_plfa-part1-Decidable-1156" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1158" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1163" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1170" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Decidable-1180" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1186" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="plfa_plfa-part1-Decidable-1188" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1190" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-1192" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1194" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1199" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1206" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Decidable-1217" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1223" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1224" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Decidable-1225" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1227" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Decidable-1233" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1235" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1240" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1247" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Decidable-1268" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1274" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1275" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">_&lt;_</a><a id="plfa_plfa-part1-Decidable-1278" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1280" href="../Relations/#plfa_plfa-part1-Relations-26408" class="InductiveConstructor">z&lt;s</a><a id="plfa_plfa-part1-Decidable-1283" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1285" href="../Relations/#plfa_plfa-part1-Relations-26465" class="InductiveConstructor">s&lt;s</a><a id="plfa_plfa-part1-Decidable-1288" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1290" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1295" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1302" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Decidable-1325" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1331" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1332" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Decidable-1335" class="Symbol">)</a>
</pre><h2 id="证据-vs-计算">证据 vs 计算</h2><p>回忆我们在 <a href="../Relations/">Relations</a> 章节中将比较定义为一个归纳数据类型，其提供了一个数小于或等于另外一个数的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-1648" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-1654" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1656" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">_≤_</a>

<a id="plfa_plfa-part1-Decidable-1661" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-_≤_"></a><a id="plfa_plfa-part1-Decidable-1666" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Decidable-1670" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1672" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1674" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1676" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1678" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1680" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-1684" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.z≤n"></a><a id="plfa_plfa-part1-Decidable-1693" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Decidable-1697" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1699" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1701" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1702" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1704" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1706" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1707" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Decidable-1715" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Decidable-1728" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1730" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-1735" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1737" href="../Decidable/#plfa_plfa-part1-Decidable-1702" class="Bound">n</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.s≤s"></a><a id="plfa_plfa-part1-Decidable-1742" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1746" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1748" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1750" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1751" href="../Decidable/#plfa_plfa-part1-Decidable-1751" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1753" href="../Decidable/#plfa_plfa-part1-Decidable-1753" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1755" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1757" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1758" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Decidable-1764" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1766" href="../Decidable/#plfa_plfa-part1-Decidable-1751" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1768" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1770" href="../Decidable/#plfa_plfa-part1-Decidable-1753" class="Bound">n</a>
      <a id="plfa_plfa-part1-Decidable-1778" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Decidable-1796" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1798" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1802" href="../Decidable/#plfa_plfa-part1-Decidable-1751" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1804" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1806" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1810" href="../Decidable/#plfa_plfa-part1-Decidable-1753" class="Bound">n</a>
</pre><p>举例来说，我们提供 <code>2 ≤ 4</code> 成立的证明，也可以证明没有 <code>4 ≤ 2</code> 成立的证明。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2≤4"></a><a id="plfa_plfa-part1-Decidable-1987" href="../Decidable/#plfa_plfa-part1-Decidable-1987" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1991" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1993" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-1995" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1997" class="Number">4</a>
<a id="plfa_plfa-part1-Decidable-1999" href="../Decidable/#plfa_plfa-part1-Decidable-1987" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-2003" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-2005" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2009" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2010" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2014" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-2017" class="Symbol">)</a>

<a id="plfa_plfa-part1-Decidable-¬4≤2"></a><a id="plfa_plfa-part1-Decidable-2020" href="../Decidable/#plfa_plfa-part1-Decidable-2020" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-2025" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2027" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-2029" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2030" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2032" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-2034" class="Number">2</a><a id="plfa_plfa-part1-Decidable-2035" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-2037" href="../Decidable/#plfa_plfa-part1-Decidable-2020" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-2042" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2043" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2047" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2048" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-2052" class="Symbol">()))</a>
</pre><p><code>()</code> 的出现表明了没有 <code>2 ≤ 0</code> 成立的证明：<code>z≤n</code> 不能匹配（因为 <code>2</code> 不是 <code>zero</code>），<code>s≤s</code> 也不能匹配（因为 <code>0</code> 不能匹配 <code>suc n</code>）。</p><p>作为替代的定义，我们可以定义一个大家可能比较熟悉的布尔类型：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2496" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Bool"></a><a id="plfa_plfa-part1-Decidable-2501" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-2506" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2508" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-2512" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Bool.true"></a><a id="plfa_plfa-part1-Decidable-2520" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-2526" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2528" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-Bool.false"></a><a id="plfa_plfa-part1-Decidable-2535" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-2541" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2543" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
</pre><p>给定了布尔类型，我们可以定义一个两个数的函数在比较关系成立时来<strong>计算</strong>出 <code>true</code>， 否则计算出 <code>false</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-2766" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-2772" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2774" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">_≤ᵇ_</a>

<a id="plfa_plfa-part1-Decidable-_≤ᵇ_"></a><a id="plfa_plfa-part1-Decidable-2780" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">_≤ᵇ_</a> <a id="plfa_plfa-part1-Decidable-2785" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2787" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2789" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2791" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2793" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2795" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-2800" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-2805" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2808" href="../Decidable/#plfa_plfa-part1-Decidable-2808" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-2816" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2819" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-2824" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2828" href="../Decidable/#plfa_plfa-part1-Decidable-2828" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2830" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2833" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>   <a id="plfa_plfa-part1-Decidable-2840" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2843" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-2849" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2853" href="../Decidable/#plfa_plfa-part1-Decidable-2853" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2855" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2858" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2862" href="../Decidable/#plfa_plfa-part1-Decidable-2862" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-2865" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2868" href="../Decidable/#plfa_plfa-part1-Decidable-2853" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2870" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2873" href="../Decidable/#plfa_plfa-part1-Decidable-2862" class="Bound">n</a>
</pre><p>定义中的第一条与最后一条与归纳数据类型中的两个构造子相对应。因为对于任意的 <code>m</code>，不可能出现 <code>suc m ≤ zero</code> 的证明，我们使用中间一条定义来表示。 举个例子，我们可以计算 <code>2 ≤ᵇ 4</code> 成立，也可以计算 <code>4 ≤ᵇ 2</code> 不成立：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-3341" href="../Decidable/#plfa_plfa-part1-Decidable-3341" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3343" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3345" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3346" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3348" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3351" class="Number">4</a><a id="plfa_plfa-part1-Decidable-3352" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3356" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-3361" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3363" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3367" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3377" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3379" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3382" class="Number">4</a>
  <a id="plfa_plfa-part1-Decidable-3386" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3394" class="Number">1</a> <a id="plfa_plfa-part1-Decidable-3396" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3399" class="Number">3</a>
  <a id="plfa_plfa-part1-Decidable-3403" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3411" class="Number">0</a> <a id="plfa_plfa-part1-Decidable-3413" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3416" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3420" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3428" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
  <a id="plfa_plfa-part1-Decidable-3435" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Decidable-3438" href="../Decidable/#plfa_plfa-part1-Decidable-3438" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-3440" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3442" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-3443" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3445" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3448" class="Number">2</a><a id="plfa_plfa-part1-Decidable-3449" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-3451" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-3453" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-3459" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-3461" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-3465" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-3475" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-3477" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3480" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-3484" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3492" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-3494" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3497" class="Number">1</a>
  <a id="plfa_plfa-part1-Decidable-3501" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3509" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-3511" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-3514" class="Number">0</a>
  <a id="plfa_plfa-part1-Decidable-3518" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-3526" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
  <a id="plfa_plfa-part1-Decidable-3534" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>在第一种情况中，我们需要两步来将第一个参数降低到 0，再用一步来计算出真，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>z≤n</code> 来证明 <code>2 ≤ 4</code>。 在第二种情况中，我们需要两步来将第二个参数降低到 0，再用一步来计算出假，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>()</code> 来说明没有 <code>4 ≤ 2</code> 的证明。</p><h2 id="relating-evidence-and-computation">将证明与计算相联系</h2><p>我们希望能够证明这两种方法是有联系的，而我们的确可以。 首先，我们定义一个函数来把计算世界映射到证明世界：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T"></a><a id="plfa_plfa-part1-Decidable-4512" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4514" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4516" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-4521" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4523" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-4527" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4529" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-4536" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4539" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="plfa_plfa-part1-Decidable-4541" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4543" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-4550" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4553" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>回忆到 <code>⊤</code> 是只有一个元素 <code>tt</code> 的单元类型，<code>⊥</code> 是没有值的空类型。（注意 <code>T</code> 是大写字母 <code>t</code>， 与 <code>⊤</code> 不同。）如果 <code>b</code> 是 <code>Bool</code> 类型的，那么如果 <code>b</code> 为真，<code>tt</code> 可以提供 <code>T b</code> 成立的证明； 如果 <code>b</code> 为假，则不可能有 <code>T b</code> 成立的证明。</p><p>换句话说，<code>T b</code> 当且仅当 <code>b ≡ true</code> 成立时成立。在向前的方向，我们需要针对 <code>b</code> 进行情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-T→≡"></a><a id="plfa_plfa-part1-Decidable-5322" href="../Decidable/#plfa_plfa-part1-Decidable-5322" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5326" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5328" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5330" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-5331" href="../Decidable/#plfa_plfa-part1-Decidable-5331" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5333" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5335" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5339" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-5341" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5343" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5345" href="../Decidable/#plfa_plfa-part1-Decidable-5331" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5347" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5349" href="../Decidable/#plfa_plfa-part1-Decidable-5331" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5353" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-5358" href="../Decidable/#plfa_plfa-part1-Decidable-5322" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5362" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5367" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>   <a id="plfa_plfa-part1-Decidable-5372" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5375" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Decidable-5380" href="../Decidable/#plfa_plfa-part1-Decidable-5322" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-5384" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-5390" class="Symbol">()</a>
</pre><p>如果 <code>b</code> 为真，那么 <code>T b</code> 由 <code>tt</code> 证明，<code>b ≡ true</code> 由 <code>refl</code> 证明。 当 <code>b</code> 为假，那么 <code>T b</code> 无法证明。</p><p>在向后的方向，不需要针对布尔值 <code>b</code> 的情况分析：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≡→T"></a><a id="plfa_plfa-part1-Decidable-5750" href="../Decidable/#plfa_plfa-part1-Decidable-5750" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5754" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5756" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5758" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-5759" href="../Decidable/#plfa_plfa-part1-Decidable-5759" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5761" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5763" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-5767" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-5769" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5771" href="../Decidable/#plfa_plfa-part1-Decidable-5759" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-5773" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-5775" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-5780" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5782" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5784" href="../Decidable/#plfa_plfa-part1-Decidable-5759" class="Bound">b</a>
<a id="plfa_plfa-part1-Decidable-5786" href="../Decidable/#plfa_plfa-part1-Decidable-5750" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-5790" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>  <a id="plfa_plfa-part1-Decidable-5796" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5799" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre><p>如果 <code>b ≡ true</code> 由 <code>refl</code> 证明，我们知道 <code>b</code> 是 <code>true</code>，因此 <code>T b</code> 由 <code>tt</code> 证明。</p><p>现在我们可以证明 <code>T (m ≤ᵇ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><p>在向前的方向，我们考虑 <code>_≤ᵇ_</code> 定义中的三条语句：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ→≤"></a><a id="plfa_plfa-part1-Decidable-6252" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6257" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6259" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-6261" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6262" href="../Decidable/#plfa_plfa-part1-Decidable-6262" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6264" href="../Decidable/#plfa_plfa-part1-Decidable-6264" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6266" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-6268" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-6269" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6271" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6273" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-6275" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6276" href="../Decidable/#plfa_plfa-part1-Decidable-6262" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6278" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-6281" href="../Decidable/#plfa_plfa-part1-Decidable-6264" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6282" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6284" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-6286" href="../Decidable/#plfa_plfa-part1-Decidable-6262" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6288" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-6290" href="../Decidable/#plfa_plfa-part1-Decidable-6264" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-6292" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6297" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6305" href="../Decidable/#plfa_plfa-part1-Decidable-6305" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-6313" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-6317" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6320" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-6324" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6329" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6330" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6334" href="../Decidable/#plfa_plfa-part1-Decidable-6334" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6335" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-6345" class="Symbol">()</a>
<a id="plfa_plfa-part1-Decidable-6348" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6353" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6358" href="../Decidable/#plfa_plfa-part1-Decidable-6358" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-6359" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6361" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6362" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-6366" href="../Decidable/#plfa_plfa-part1-Decidable-6366" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-6367" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-6369" href="../Decidable/#plfa_plfa-part1-Decidable-6369" class="Bound">t</a>   <a id="plfa_plfa-part1-Decidable-6373" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-6376" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-6380" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-6381" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-6386" href="../Decidable/#plfa_plfa-part1-Decidable-6358" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-6388" href="../Decidable/#plfa_plfa-part1-Decidable-6366" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-6390" href="../Decidable/#plfa_plfa-part1-Decidable-6369" class="Bound">t</a><a id="plfa_plfa-part1-Decidable-6391" class="Symbol">)</a>
</pre><p>第一条语句中，我们立即可以得出 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 而得， 相对应地 <code>m ≤ n</code> 由 <code>z≤n</code> 而证明。在中间的语句中，我们立刻得出 <code>suc m ≤ᵇ zero</code> 为假，则 <code>T (m ≤ᵇ n)</code> 为空，因此我们无需证明 <code>m ≤ n</code>，同时也不存在这样的证明。在最后的语句中，我们对于 <code>suc m ≤ᵇ suc n</code> 递归至 <code>m ≤ᵇ n</code>。令 <code>t</code> 为 <code>T (suc m ≤ᵇ suc n)</code> 的证明，如果其存在。 根据 <code>_≤ᵇ_</code> 的定义，这也是 <code>T (m ≤ᵇ n)</code> 的证明。我们递归地应用函数来获得 <code>m ≤ n</code> 的证明，再使用 <code>s≤s</code> 将其转换成为 <code>suc m ≤ suc n</code> 的证明。</p><p>在向后的方向，我们考虑 <code>m ≤ n</code> 成立证明的可能形式：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤→≤ᵇ"></a><a id="plfa_plfa-part1-Decidable-7580" href="../Decidable/#plfa_plfa-part1-Decidable-7580" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7585" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7587" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-7589" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-7590" href="../Decidable/#plfa_plfa-part1-Decidable-7590" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7592" href="../Decidable/#plfa_plfa-part1-Decidable-7592" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7594" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-7597" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-7599" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7601" href="../Decidable/#plfa_plfa-part1-Decidable-7590" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7603" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7605" href="../Decidable/#plfa_plfa-part1-Decidable-7592" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7607" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7609" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-7611" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7612" href="../Decidable/#plfa_plfa-part1-Decidable-7590" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7614" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7617" href="../Decidable/#plfa_plfa-part1-Decidable-7592" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-7618" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-7620" href="../Decidable/#plfa_plfa-part1-Decidable-7580" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7625" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Decidable-7636" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-7642" href="../Decidable/#plfa_plfa-part1-Decidable-7580" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7647" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7648" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-7652" href="../Decidable/#plfa_plfa-part1-Decidable-7652" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-7655" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-7658" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-7661" href="../Decidable/#plfa_plfa-part1-Decidable-7580" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-7666" href="../Decidable/#plfa_plfa-part1-Decidable-7652" class="Bound">m≤n</a>
</pre><p>如果证明是 <code>z≤n</code>，我们立即可以得到 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 证明。 如果证明是 <code>s≤s</code> 作用于 <code>m≤n</code>，那么 <code>suc m ≤ᵇ suc n</code> 规约到 <code>m ≤ᵇ n</code>，我们可以递归地使用函数 来获得 <code>T (m ≤ᵇ n)</code> 的证明。</p><p>向前方向的证明比向后方向的证明多一条语句，因为在向前方向的证明中我们需要考虑比较结果为真和假 的语句，而向后方向的证明只需要考虑比较成立的语句。这也是为什么我们比起计算的形式，更加偏爱证明的形式， 因为这样让我们做更少的工作：我们只需要考虑关系成立时的情况，而可以忽略不成立的情况。</p><p>从另一个角度来说，有时计算的性质可能正是我们所需要的。面对一个大数值上的非显然关系， 使用电脑来计算出答案可能会更加方便。幸运的是，比起在<strong>证明</strong>或<strong>计算</strong>之中犹豫， 我们有一种更好的方法来兼取其优。</p><h2 id="the-best-of-both-worlds">取二者之精华</h2><p>一个返回布尔值的函数提供恰好一比特的信息：这个关系成立或是不成立。相反地，证明的形式告诉我们 为什么这个关系成立，但却需要我们自行完成这个证明。不过，我们其实可以简单地定义一个类型来取二者之精华。 我们把它叫做：<code>Dec A</code>，其中 <code>Dec</code> 是<strong>可判定的（Decidable）</strong>的意思。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-9860" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Dec"></a><a id="plfa_plfa-part1-Decidable-9865" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9869" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9870" href="../Decidable/#plfa_plfa-part1-Decidable-9870" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9872" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9874" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-9877" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-9879" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9881" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-9885" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Dec.yes"></a><a id="plfa_plfa-part1-Decidable-9893" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-9897" class="Symbol">:</a>   <a id="plfa_plfa-part1-Decidable-9901" href="../Decidable/#plfa_plfa-part1-Decidable-9870" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9903" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9905" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9909" href="../Decidable/#plfa_plfa-part1-Decidable-9870" class="Bound">A</a>
  <a id="plfa_plfa-part1-Decidable-Dec.no"></a><a id="plfa_plfa-part1-Decidable-9913" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a>  <a id="plfa_plfa-part1-Decidable-9917" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9919" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-9921" href="../Decidable/#plfa_plfa-part1-Decidable-9870" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-9923" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-9925" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-9929" href="../Decidable/#plfa_plfa-part1-Decidable-9870" class="Bound">A</a>
</pre><p>正如布尔值，这个类型有两个构造子。一个 <code>Dec A</code> 类型的值要么是以 <code>yes x</code> 的形式，其中 <code>x</code> 提供 <code>A</code> 成立的证明，或者是以 <code>no ¬x</code> 的形式，其中 <code>x</code> 提供了 <code>A</code> 无法成立的证明。（也就是说，<code>¬x</code> 是一个给定 <code>A</code> 成立的证据，返回矛盾的函数）</p><p>比如说，我们定义一个函数 <code>_≤?_</code>，给定两个数，判定是否一个数小于等于另一个，并提供证明来说明结论。</p><p>首先，我们使用两个有用的函数，用于构造不等式不成立的证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬s≤z"></a><a id="plfa_plfa-part1-Decidable-10778" href="../Decidable/#plfa_plfa-part1-Decidable-10778" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10783" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10785" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10787" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10788" href="../Decidable/#plfa_plfa-part1-Decidable-10788" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10790" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10792" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10793" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10795" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10797" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10799" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10800" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10804" href="../Decidable/#plfa_plfa-part1-Decidable-10788" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10806" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10808" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-10812" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10814" href="../Decidable/#plfa_plfa-part1-Decidable-10778" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-10819" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-¬s≤s"></a><a id="plfa_plfa-part1-Decidable-10823" href="../Decidable/#plfa_plfa-part1-Decidable-10823" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10828" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10830" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10832" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-10833" href="../Decidable/#plfa_plfa-part1-Decidable-10833" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10835" href="../Decidable/#plfa_plfa-part1-Decidable-10835" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-10837" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10839" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10840" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-10842" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10844" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10846" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10847" href="../Decidable/#plfa_plfa-part1-Decidable-10833" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10849" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10851" href="../Decidable/#plfa_plfa-part1-Decidable-10835" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10852" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10854" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10856" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-10858" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10859" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10863" href="../Decidable/#plfa_plfa-part1-Decidable-10833" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10865" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-10867" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-10871" href="../Decidable/#plfa_plfa-part1-Decidable-10835" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10872" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-10874" href="../Decidable/#plfa_plfa-part1-Decidable-10823" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-10879" href="../Decidable/#plfa_plfa-part1-Decidable-10879" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10884" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10885" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-10889" href="../Decidable/#plfa_plfa-part1-Decidable-10889" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-10892" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10894" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-10896" href="../Decidable/#plfa_plfa-part1-Decidable-10879" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-10901" href="../Decidable/#plfa_plfa-part1-Decidable-10889" class="Bound">m≤n</a>
</pre><p>第一个函数断言了 <code>¬ (suc m ≤ zero)</code>，由荒谬可得。因为每个不等式的成立证明必须是 <code>zero ≤ n</code> 或者 <code>suc m ≤ suc n</code> 的形式，两者都无法匹配 <code>suc m ≤ zero</code>。 第二个函数取 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，返回 <code>¬ (suc m ≤ suc n)</code> 的证明。 所有形如 <code>suc m ≤ suc n</code> 的证明必须是以 <code>s≤s m≤n</code> 的形式给出。因此我们可以构造一个 矛盾，以 <code>¬m≤n m≤n</code> 来证明。</p><p>使用这些，我们可以直接的判定不等关系：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?_"></a><a id="plfa_plfa-part1-Decidable-11716" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">_≤?_</a> <a id="plfa_plfa-part1-Decidable-11721" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11723" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-11725" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11726" href="../Decidable/#plfa_plfa-part1-Decidable-11726" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11728" href="../Decidable/#plfa_plfa-part1-Decidable-11728" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11730" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11732" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-11733" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-11735" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-11737" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-11741" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11742" href="../Decidable/#plfa_plfa-part1-Decidable-11726" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11744" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-11746" href="../Decidable/#plfa_plfa-part1-Decidable-11728" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-11747" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11749" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="plfa_plfa-part1-Decidable-11755" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11758" href="../Decidable/#plfa_plfa-part1-Decidable-11758" class="Bound">n</a>                   <a id="plfa_plfa-part1-Decidable-11778" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11781" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11785" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-11789" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11793" href="../Decidable/#plfa_plfa-part1-Decidable-11793" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11795" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11798" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                <a id="plfa_plfa-part1-Decidable-11818" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11821" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11824" href="../Decidable/#plfa_plfa-part1-Decidable-10778" class="Function">¬s≤z</a>
<a id="plfa_plfa-part1-Decidable-11829" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11833" href="../Decidable/#plfa_plfa-part1-Decidable-11833" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11835" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11838" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-11842" href="../Decidable/#plfa_plfa-part1-Decidable-11842" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11844" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-11849" href="../Decidable/#plfa_plfa-part1-Decidable-11833" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11851" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-11854" href="../Decidable/#plfa_plfa-part1-Decidable-11842" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-11856" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11874" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11876" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11880" href="../Decidable/#plfa_plfa-part1-Decidable-11880" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Decidable-11885" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11888" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11892" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11893" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-11897" href="../Decidable/#plfa_plfa-part1-Decidable-11880" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-11900" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11902" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-11920" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11922" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11925" href="../Decidable/#plfa_plfa-part1-Decidable-11925" class="Bound">¬m≤n</a>  <a id="plfa_plfa-part1-Decidable-11931" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-11934" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11937" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11938" href="../Decidable/#plfa_plfa-part1-Decidable-10823" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-11943" href="../Decidable/#plfa_plfa-part1-Decidable-11925" class="Bound">¬m≤n</a><a id="plfa_plfa-part1-Decidable-11947" class="Symbol">)</a>
</pre><p>与 <code>_≤ᵇ_</code> 一样，定义有三条语句。第一条语句中，<code>zero ≤ n</code> 立即成立，由 <code>z≤n</code> 证明。 第二条语句中，<code>suc m ≤ zero</code> 立即不成立，由 <code>¬s≤z</code> 证明。 第三条语句中，我们需要递归地应用 <code>m ≤? n</code>。有两种可能性，在 <code>yes</code> 的情况中，它会返回 <code>m ≤ n</code> 的证明 <code>m≤n</code>，所以 <code>s≤s m≤n</code> 即可作为 <code>suc m ≤ suc n</code> 的证明；在 <code>no</code> 的情况中， 它会返回 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，所以 <code>¬s≤s ¬m≤n</code> 即可作为 <code>¬ (suc m ≤ suc n)</code> 的证明。</p><p>当我们写 <code>_≤ᵇ_</code> 时，我们必须写两个其他的函数 <code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 来证明其正确性。 作为对比，<code>_≤?_</code> 的定义自身就证明了其正确性，由类型即可得知。<code>_≤?_</code> 的代码也比 <code>_≤ᵇ_</code>、<code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 加起来要简洁的多。我们稍后将会证明，如果我们需要后三者， 我们亦可简单地从 <code>_≤?_</code> 中派生出来。</p><p>我们可以使用我们新的函数来<strong>计算</strong>出我们之前需要自己想出来的<strong>证明</strong>。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-13602" href="../Decidable/#plfa_plfa-part1-Decidable-13602" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13604" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13606" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13608" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13611" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13613" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13615" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13619" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13620" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13624" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13625" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-13629" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-13632" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13635" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13637" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Decidable-13645" href="../Decidable/#plfa_plfa-part1-Decidable-13645" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-13647" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13649" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-13651" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-13654" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-13656" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-13658" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-13661" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13662" href="../Decidable/#plfa_plfa-part1-Decidable-10823" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13667" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13668" href="../Decidable/#plfa_plfa-part1-Decidable-10823" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-13673" href="../Decidable/#plfa_plfa-part1-Decidable-10778" class="Function">¬s≤z</a><a id="plfa_plfa-part1-Decidable-13677" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-13680" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-13682" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>你可以验证 Agda 的确计算出了这些值。输入 <code>C-c C-n</code> 并给出 <code>2 ≤? 4</code> 或者 <code>4 ≤? 2</code> 作为 需要的表达式，Agda 会输出如上的值。</p><p>（小细节：如果我们不把 <code>¬s≤z</code> 和 <code>¬s≤s</code> 作为顶层函数来定义，而是使用内嵌的匿名函数， Agda 可能会在规范化否定的证明中出现问题。）</p><h4 id="练习-__-推荐">练习 <code>_&lt;?_</code> （推荐）</h4><p>与上面的函数相似，定义一个判定严格不等性的函数：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14430" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_&lt;?_"></a><a id="plfa_plfa-part1-Decidable-14442" href="../Decidable/#plfa_plfa-part1-Decidable-14442" class="Postulate Operator">_&lt;?_</a> <a id="plfa_plfa-part1-Decidable-14447" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14449" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14451" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14452" href="../Decidable/#plfa_plfa-part1-Decidable-14452" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14454" href="../Decidable/#plfa_plfa-part1-Decidable-14454" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14456" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14458" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14459" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14461" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14463" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14467" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14468" href="../Decidable/#plfa_plfa-part1-Decidable-14452" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14470" href="../Relations/#plfa_plfa-part1-Relations-26381" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Decidable-14472" href="../Decidable/#plfa_plfa-part1-Decidable-14454" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14473" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14490" class="Comment">-- 请将代码写在此处。</a>
</pre><h4 id="练习-_ℕ_实践">练习 <code>_≡ℕ?_</code>（实践）</h4><p>定义一个函数来判定两个自然数是否相等。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14671" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_≡ℕ?_"></a><a id="plfa_plfa-part1-Decidable-14683" href="../Decidable/#plfa_plfa-part1-Decidable-14683" class="Postulate Operator">_≡ℕ?_</a> <a id="plfa_plfa-part1-Decidable-14689" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14691" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-14693" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14694" href="../Decidable/#plfa_plfa-part1-Decidable-14694" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14696" href="../Decidable/#plfa_plfa-part1-Decidable-14696" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-14698" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14700" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-14701" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-14703" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14705" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-14709" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-14710" href="../Decidable/#plfa_plfa-part1-Decidable-14694" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-14712" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-14714" href="../Decidable/#plfa_plfa-part1-Decidable-14696" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-14715" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-14732" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="decidables-from-booleans-and-booleans-from-decidables">从可判定的值到布尔值，从布尔值到可判定的值</h2><p>好奇的读者可能会思考能不能重用 <code>m ≤ᵇ n</code> 的定义，加上它与 <code>m ≤ n</code> 等价的证明， 来证明可判定性。的确，我们是可以做到的：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?′_"></a><a id="plfa_plfa-part1-Decidable-15181" href="../Decidable/#plfa_plfa-part1-Decidable-15181" class="Function Operator">_≤?′_</a> <a id="plfa_plfa-part1-Decidable-15187" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15189" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-15191" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15192" href="../Decidable/#plfa_plfa-part1-Decidable-15192" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15194" href="../Decidable/#plfa_plfa-part1-Decidable-15194" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15196" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15198" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-15199" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-15201" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15203" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15207" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15208" href="../Decidable/#plfa_plfa-part1-Decidable-15192" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15210" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-15212" href="../Decidable/#plfa_plfa-part1-Decidable-15194" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15213" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15215" href="../Decidable/#plfa_plfa-part1-Decidable-15215" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15217" href="../Decidable/#plfa_plfa-part1-Decidable-15181" class="Function Operator">≤?′</a> <a id="plfa_plfa-part1-Decidable-15221" href="../Decidable/#plfa_plfa-part1-Decidable-15221" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15223" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-15228" href="../Decidable/#plfa_plfa-part1-Decidable-15215" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15230" href="../Decidable/#plfa_plfa-part1-Decidable-2780" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15233" href="../Decidable/#plfa_plfa-part1-Decidable-15221" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15235" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15237" href="../Decidable/#plfa_plfa-part1-Decidable-6252" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-15242" href="../Decidable/#plfa_plfa-part1-Decidable-15215" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-15244" href="../Decidable/#plfa_plfa-part1-Decidable-15221" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-15246" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15248" href="../Decidable/#plfa_plfa-part1-Decidable-7580" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-15253" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15254" href="../Decidable/#plfa_plfa-part1-Decidable-15215" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-15255" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-15257" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15258" href="../Decidable/#plfa_plfa-part1-Decidable-15221" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-15259" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-15261" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15272" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15274" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-15281" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15283" href="../Decidable/#plfa_plfa-part1-Decidable-15283" class="Bound">p</a>        <a id="plfa_plfa-part1-Decidable-15292" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15294" class="Symbol">_</a>            <a id="plfa_plfa-part1-Decidable-15307" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15309" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15313" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15314" href="../Decidable/#plfa_plfa-part1-Decidable-15283" class="Bound">p</a> <a id="plfa_plfa-part1-Decidable-15316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-15318" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15320" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-15331" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15333" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-15340" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15342" class="Symbol">_</a>        <a id="plfa_plfa-part1-Decidable-15351" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-15353" href="../Decidable/#plfa_plfa-part1-Decidable-15353" class="Bound">¬p</a>           <a id="plfa_plfa-part1-Decidable-15366" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15368" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15371" href="../Decidable/#plfa_plfa-part1-Decidable-15353" class="Bound">¬p</a>
</pre><p>如果 <code>m ≤ᵇ n</code> 为真，那么 <code>≤ᵇ→≤</code> 会返回一个 <code>m ≤ n</code> 成立的证明。 如果 <code>m ≤ᵇ n</code> 为假，那么 <code>≤→≤ᵇ</code> 会取一个 <code>m ≤ n</code> 成立的证明，将其转换为一个矛盾。</p><p>在这个证明中，<code>with</code> 语句的三重约束是必须的。如果我们取而代之的写：</p><pre><code>_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})</code></pre><p>那么 Agda 对于每条语句会有一个抱怨：</p><pre><code>⊤ !=&lt; (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=&lt; ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n</code></pre><p>将表达式放在 <code>with</code> 语句中能让 Agda 利用下列事实：当 <code>m ≤ᵇ n</code> 为真时，<code>T (m ≤ᵇ n)</code> 是 <code>⊤</code>；当 <code>m ≤ᵇ n</code> 为假时，<code>T (m ≤ᵇ n)</code> 是 <code>⊥</code>。</p><p>然而，总体来说还是直接定义 <code>_≤?_</code> 比较方便，正如之前部分中那样。如果有人真的很需要 <code>_≤ᵇ_</code>， 那么它和它的性质可以简单地从 <code>_≤?_</code> 中派生出来，正如我们接下来要展示的一样。</p><p>擦除（Erasure）将一个可判定的值转换为一个布尔值：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-⌊_⌋"></a><a id="plfa_plfa-part1-Decidable-16908" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊_⌋</a> <a id="plfa_plfa-part1-Decidable-16912" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16914" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-16916" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-16917" href="../Decidable/#plfa_plfa-part1-Decidable-16917" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16919" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16921" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-16924" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-16926" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16928" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-16932" href="../Decidable/#plfa_plfa-part1-Decidable-16917" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16934" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16936" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-16941" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16943" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-16947" href="../Decidable/#plfa_plfa-part1-Decidable-16947" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-16949" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16952" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16955" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-16960" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-16962" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-16965" href="../Decidable/#plfa_plfa-part1-Decidable-16965" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-16968" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-16971" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16974" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
</pre><p>使用擦除，我们可以简单地从 <code>_≤?_</code> 中派生出 <code>_≤ᵇ_</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤ᵇ′_"></a><a id="plfa_plfa-part1-Decidable-17094" href="../Decidable/#plfa_plfa-part1-Decidable-17094" class="Function Operator">_≤ᵇ′_</a> <a id="plfa_plfa-part1-Decidable-17100" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17102" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17104" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17106" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-17108" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17110" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-17115" href="../Decidable/#plfa_plfa-part1-Decidable-17115" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17117" href="../Decidable/#plfa_plfa-part1-Decidable-17094" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17121" href="../Decidable/#plfa_plfa-part1-Decidable-17121" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-17124" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17127" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17129" href="../Decidable/#plfa_plfa-part1-Decidable-17115" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17131" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-17134" href="../Decidable/#plfa_plfa-part1-Decidable-17121" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17136" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
</pre>更进一步来说，如果 <code>D</code> 是一个类型为 <code>Dec A</code> 的值，那么 <code>T ⌊ D ⌋</code> 当且仅当 <code>A</code> 成立时成立：<pre class="Agda"><a id="plfa_plfa-part1-Decidable-toWitness"></a><a id="plfa_plfa-part1-Decidable-17325" href="../Decidable/#plfa_plfa-part1-Decidable-17325" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17335" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17337" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17339" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17340" href="../Decidable/#plfa_plfa-part1-Decidable-17340" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17342" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17344" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17347" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17349" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17350" href="../Decidable/#plfa_plfa-part1-Decidable-17350" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17352" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17354" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17358" href="../Decidable/#plfa_plfa-part1-Decidable-17340" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17359" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17361" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17363" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17365" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17367" href="../Decidable/#plfa_plfa-part1-Decidable-17350" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17369" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-17371" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17373" href="../Decidable/#plfa_plfa-part1-Decidable-17340" class="Bound">A</a>
<a id="plfa_plfa-part1-Decidable-17375" href="../Decidable/#plfa_plfa-part1-Decidable-17325" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17385" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17386" href="../Decidable/#plfa_plfa-part1-Decidable-17386" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17387" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17389" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17390" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17394" href="../Decidable/#plfa_plfa-part1-Decidable-17394" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17395" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17397" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-17401" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17404" href="../Decidable/#plfa_plfa-part1-Decidable-17394" class="Bound">x</a>
<a id="plfa_plfa-part1-Decidable-17406" href="../Decidable/#plfa_plfa-part1-Decidable-17325" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-17416" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17417" href="../Decidable/#plfa_plfa-part1-Decidable-17417" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17418" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17420" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17421" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17424" href="../Decidable/#plfa_plfa-part1-Decidable-17424" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17426" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17428" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-fromWitness"></a><a id="plfa_plfa-part1-Decidable-17432" href="../Decidable/#plfa_plfa-part1-Decidable-17432" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17444" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17446" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17448" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17449" href="../Decidable/#plfa_plfa-part1-Decidable-17449" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17451" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17453" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17456" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17458" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17459" href="../Decidable/#plfa_plfa-part1-Decidable-17459" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17461" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17463" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17467" href="../Decidable/#plfa_plfa-part1-Decidable-17449" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17468" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17470" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17472" href="../Decidable/#plfa_plfa-part1-Decidable-17449" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17474" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17476" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17478" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-17480" href="../Decidable/#plfa_plfa-part1-Decidable-17459" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-17482" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
<a id="plfa_plfa-part1-Decidable-17484" href="../Decidable/#plfa_plfa-part1-Decidable-17432" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17496" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17497" href="../Decidable/#plfa_plfa-part1-Decidable-17497" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17498" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17500" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17501" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17505" href="../Decidable/#plfa_plfa-part1-Decidable-17505" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17506" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17508" class="Symbol">_</a>  <a id="plfa_plfa-part1-Decidable-17511" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17514" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-17517" href="../Decidable/#plfa_plfa-part1-Decidable-17432" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-17529" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17530" href="../Decidable/#plfa_plfa-part1-Decidable-17530" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-17531" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17533" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17534" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17537" href="../Decidable/#plfa_plfa-part1-Decidable-17537" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17539" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17541" href="../Decidable/#plfa_plfa-part1-Decidable-17541" class="Bound">x</a>  <a id="plfa_plfa-part1-Decidable-17544" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17547" href="../Decidable/#plfa_plfa-part1-Decidable-17537" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-17550" href="../Decidable/#plfa_plfa-part1-Decidable-17541" class="Bound">x</a>
</pre><p>使用这些，我们可以简单地派生出 <code>T (m ≤ᵇ′ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ′→≤"></a><a id="plfa_plfa-part1-Decidable-17727" href="../Decidable/#plfa_plfa-part1-Decidable-17727" class="Function">≤ᵇ′→≤</a> <a id="plfa_plfa-part1-Decidable-17733" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17735" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17737" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17738" href="../Decidable/#plfa_plfa-part1-Decidable-17738" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17740" href="../Decidable/#plfa_plfa-part1-Decidable-17740" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17742" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17744" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17745" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17747" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17749" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17751" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17752" href="../Decidable/#plfa_plfa-part1-Decidable-17738" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17754" href="../Decidable/#plfa_plfa-part1-Decidable-17094" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17758" href="../Decidable/#plfa_plfa-part1-Decidable-17740" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17759" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-17761" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17763" href="../Decidable/#plfa_plfa-part1-Decidable-17738" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17765" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17767" href="../Decidable/#plfa_plfa-part1-Decidable-17740" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-17769" href="../Decidable/#plfa_plfa-part1-Decidable-17727" class="Function">≤ᵇ′→≤</a>  <a id="plfa_plfa-part1-Decidable-17776" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17779" href="../Decidable/#plfa_plfa-part1-Decidable-17325" class="Function">toWitness</a>

<a id="plfa_plfa-part1-Decidable-≤→≤ᵇ′"></a><a id="plfa_plfa-part1-Decidable-17790" href="../Decidable/#plfa_plfa-part1-Decidable-17790" class="Function">≤→≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17796" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17798" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17800" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17801" href="../Decidable/#plfa_plfa-part1-Decidable-17801" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17803" href="../Decidable/#plfa_plfa-part1-Decidable-17803" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17805" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17807" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-17808" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17810" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17812" href="../Decidable/#plfa_plfa-part1-Decidable-17801" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17814" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-17816" href="../Decidable/#plfa_plfa-part1-Decidable-17803" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-17818" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17820" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-17822" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17823" href="../Decidable/#plfa_plfa-part1-Decidable-17801" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-17825" href="../Decidable/#plfa_plfa-part1-Decidable-17094" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-17829" href="../Decidable/#plfa_plfa-part1-Decidable-17803" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-17830" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-17832" href="../Decidable/#plfa_plfa-part1-Decidable-17790" class="Function">≤→≤ᵇ′</a>  <a id="plfa_plfa-part1-Decidable-17839" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17842" href="../Decidable/#plfa_plfa-part1-Decidable-17432" class="Function">fromWitness</a>
</pre><p>总结来说，最好避免直接使用布尔值，而使用可判定的值。如果有需要布尔值的时候，它们和它们的性质 可以简单地从对应的可判定的值中派生而来。</p><h2 id="logical-connectives">逻辑连接符</h2><p>大多数读者对于布尔值的逻辑运算符很熟悉了。每个逻辑运算符都可以被延伸至可判定的值。</p><p>两个布尔值的合取当两者都为真时为真，当任一为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-18478" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-18485" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-18487" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="Function Operator">_∧_</a>

<a id="plfa_plfa-part1-Decidable-_∧_"></a><a id="plfa_plfa-part1-Decidable-18492" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Decidable-18496" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18498" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18503" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18505" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-18510" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18512" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-18517" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18523" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18525" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-18531" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18533" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-18538" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18544" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18546" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-18552" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18554" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-18560" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-18561" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-18566" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="CatchallClause Function Operator">∧</a><a id="plfa_plfa-part1-Decidable-18567" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-18568" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="CatchallClause InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-18574" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-18576" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第三个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第二条还是第三条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的合取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-19036" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-19043" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-19045" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="Function Operator">_×-dec_</a>

<a id="plfa_plfa-part1-Decidable-_×-dec_"></a><a id="plfa_plfa-part1-Decidable-19054" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="Function Operator">_×-dec_</a> <a id="plfa_plfa-part1-Decidable-19062" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19064" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-19066" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-19067" href="../Decidable/#plfa_plfa-part1-Decidable-19067" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19069" href="../Decidable/#plfa_plfa-part1-Decidable-19069" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19071" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19073" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-19076" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-19078" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19080" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19084" href="../Decidable/#plfa_plfa-part1-Decidable-19067" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19086" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19088" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19092" href="../Decidable/#plfa_plfa-part1-Decidable-19069" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19094" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19096" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19100" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19101" href="../Decidable/#plfa_plfa-part1-Decidable-19067" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19103" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Decidable-19105" href="../Decidable/#plfa_plfa-part1-Decidable-19069" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-19106" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-19108" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19112" href="../Decidable/#plfa_plfa-part1-Decidable-19112" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19114" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19120" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19124" href="../Decidable/#plfa_plfa-part1-Decidable-19124" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19126" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19128" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-19132" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19134" href="../Decidable/#plfa_plfa-part1-Decidable-19112" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19136" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19138" href="../Decidable/#plfa_plfa-part1-Decidable-19124" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19140" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Decidable-19142" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19145" href="../Decidable/#plfa_plfa-part1-Decidable-19145" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19148" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-19154" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-19160" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19162" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19165" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19168" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19170" href="../Decidable/#plfa_plfa-part1-Decidable-19170" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19172" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19174" href="../Decidable/#plfa_plfa-part1-Decidable-19174" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19176" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19178" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19180" href="../Decidable/#plfa_plfa-part1-Decidable-19145" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-19183" href="../Decidable/#plfa_plfa-part1-Decidable-19170" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19185" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-19187" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-19188" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-19193" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="CatchallClause Function Operator">×-dec</a><a id="plfa_plfa-part1-Decidable-19198" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19199" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-19201" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-19202" href="../Decidable/#plfa_plfa-part1-Decidable-19202" class="CatchallClause Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19205" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19207" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-19210" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-19213" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-19215" href="../Decidable/#plfa_plfa-part1-Decidable-19215" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19217" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-19219" href="../Decidable/#plfa_plfa-part1-Decidable-19219" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19221" href="../Decidable/#plfa_plfa-part1-Decidable-980" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-19223" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19225" href="../Decidable/#plfa_plfa-part1-Decidable-19202" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-19228" href="../Decidable/#plfa_plfa-part1-Decidable-19219" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19230" class="Symbol">}</a>
</pre><p>两个命题的合取当两者都成立时成立，其否定则当任意一者否定成立时成立。如果两个都成立， 我们将每一证明放入数据对中，作为合取的证明。如果任意一者的否定成立，假设整个合取将会引入一个矛盾。</p><p>同样地，在 Emacs 中，第三条等式在左手边以灰色显示，说明等式的顺序决定了第二条还是第三条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都不成立，我们选择第一个来构造矛盾， 但选择第二个也是同样正确的。</p><p>两个布尔值的析取当任意为真时为真，当两者为假时为假：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20257" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20264" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20266" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="Function Operator">_∨_</a>

<a id="plfa_plfa-part1-Decidable-_∨_"></a><a id="plfa_plfa-part1-Decidable-20271" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="Function Operator">_∨_</a> <a id="plfa_plfa-part1-Decidable-20275" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20277" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20282" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20284" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-20289" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20291" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-20296" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-20302" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20304" class="Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-20311" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20313" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20318" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20319" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20324" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="CatchallClause Function Operator">∨</a><a id="plfa_plfa-part1-Decidable-20325" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20326" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="CatchallClause InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-20333" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20335" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-20340" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-20346" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-20348" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-20355" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20357" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
</pre><p>在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-20818" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-20825" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-20827" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="Function Operator">_⊎-dec_</a>

<a id="plfa_plfa-part1-Decidable-_⊎-dec_"></a><a id="plfa_plfa-part1-Decidable-20836" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="Function Operator">_⊎-dec_</a> <a id="plfa_plfa-part1-Decidable-20844" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20846" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-20848" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-20849" href="../Decidable/#plfa_plfa-part1-Decidable-20849" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20851" href="../Decidable/#plfa_plfa-part1-Decidable-20851" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20853" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-20855" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-20858" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-20860" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20862" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20866" href="../Decidable/#plfa_plfa-part1-Decidable-20849" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20868" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20870" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20874" href="../Decidable/#plfa_plfa-part1-Decidable-20851" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-20876" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20878" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-20882" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20883" href="../Decidable/#plfa_plfa-part1-Decidable-20849" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-20885" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Decidable-20887" href="../Decidable/#plfa_plfa-part1-Decidable-20851" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-20888" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20890" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20894" href="../Decidable/#plfa_plfa-part1-Decidable-20894" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20896" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20902" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-20908" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20910" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20914" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20915" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20920" href="../Decidable/#plfa_plfa-part1-Decidable-20894" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20921" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20923" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-20924" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-20929" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="CatchallClause Function Operator">⊎-dec</a><a id="plfa_plfa-part1-Decidable-20934" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20935" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="CatchallClause InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-20938" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-20939" href="../Decidable/#plfa_plfa-part1-Decidable-20939" class="CatchallClause Bound">y</a> <a id="plfa_plfa-part1-Decidable-20941" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20943" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-20947" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20948" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-20953" href="../Decidable/#plfa_plfa-part1-Decidable-20939" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-20954" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-20956" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20959" href="../Decidable/#plfa_plfa-part1-Decidable-20959" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20962" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-20968" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20971" href="../Decidable/#plfa_plfa-part1-Decidable-20971" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-20974" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-20976" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-20979" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-20982" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-20983" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-20988" href="../Decidable/#plfa_plfa-part1-Decidable-20988" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-20989" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-20991" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-20993" href="../Decidable/#plfa_plfa-part1-Decidable-20959" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-20996" href="../Decidable/#plfa_plfa-part1-Decidable-20988" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-20998" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-21000" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-21001" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-21006" href="../Decidable/#plfa_plfa-part1-Decidable-21006" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-21007" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-21009" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21011" href="../Decidable/#plfa_plfa-part1-Decidable-20971" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-21014" href="../Decidable/#plfa_plfa-part1-Decidable-21006" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-21016" class="Symbol">}</a>
</pre><p>两个命题的析取当任意一者成立时成立，其否定则当两者的否定成立时成立。如果任意一者成立， 我们使用其证明来作为析取的证明。如果两个的否定都成立，假设任意一者都会引入一个矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都成立，我们选择第一个来构造析取， 但选择第二个也是同样正确的。</p><p>一个布尔值的否定当值为真时为假，反之亦然：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-not"></a><a id="plfa_plfa-part1-Decidable-21971" href="../Decidable/#plfa_plfa-part1-Decidable-21971" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21975" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21977" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-21982" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21984" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-21989" href="../Decidable/#plfa_plfa-part1-Decidable-21971" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-21993" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-21999" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-22001" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-22007" href="../Decidable/#plfa_plfa-part1-Decidable-21971" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-22011" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-22017" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-22019" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
</pre><p>相应地，给定一个可判定的命题，我们可以判定它的否定：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬?"></a><a id="plfa_plfa-part1-Decidable-22151" href="../Decidable/#plfa_plfa-part1-Decidable-22151" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22154" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22156" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-22158" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-22159" href="../Decidable/#plfa_plfa-part1-Decidable-22159" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22161" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22163" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-22166" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-22168" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22170" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22174" href="../Decidable/#plfa_plfa-part1-Decidable-22159" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-22176" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22178" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-22182" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22183" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-22185" href="../Decidable/#plfa_plfa-part1-Decidable-22159" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-22186" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22188" href="../Decidable/#plfa_plfa-part1-Decidable-22151" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22191" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22192" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22196" href="../Decidable/#plfa_plfa-part1-Decidable-22196" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22197" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22200" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22203" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22206" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22207" href="../Decidable/#plfa_plfa-part1-Decidable-1148" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Decidable-22216" href="../Decidable/#plfa_plfa-part1-Decidable-22196" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-22217" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22219" href="../Decidable/#plfa_plfa-part1-Decidable-22151" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-22222" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22223" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-22226" href="../Decidable/#plfa_plfa-part1-Decidable-22226" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-22228" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-22231" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22234" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-22238" href="../Decidable/#plfa_plfa-part1-Decidable-22226" class="Bound">¬x</a>
</pre><p>我们直接把 yes 和 no 交换。在第一个等式中，右手边断言了 <code>¬ A</code> 的否定成立，也就是说 <code>¬ ¬ A</code> 成立——这是一个 <code>A</code> 成立时可以简单得到的推论。</p><p>还有一个与蕴涵相对应，但是稍微不那么知名的运算符：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_⊃_"></a><a id="plfa_plfa-part1-Decidable-22674" href="../Decidable/#plfa_plfa-part1-Decidable-22674" class="Function Operator">_⊃_</a> <a id="plfa_plfa-part1-Decidable-22678" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-22680" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22685" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22687" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-22692" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-22694" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-22699" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-22705" href="../Decidable/#plfa_plfa-part1-Decidable-22674" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22707" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-22714" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22717" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22722" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="CatchallClause InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-22727" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22728" href="../Decidable/#plfa_plfa-part1-Decidable-22674" class="CatchallClause Function Operator">⊃</a><a id="plfa_plfa-part1-Decidable-22729" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-22730" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-22737" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22740" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-22745" href="../Decidable/#plfa_plfa-part1-Decidable-2520" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-22751" href="../Decidable/#plfa_plfa-part1-Decidable-22674" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-22753" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-22760" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-22763" href="../Decidable/#plfa_plfa-part1-Decidable-2535" class="InductiveConstructor">false</a>
</pre><p>当任何一个布尔值为真的时候，另一个布尔值恒为真，我们成为第一个布尔值蕴涵第二个布尔值。 因此，两者的蕴涵在第二个为真或者第一个为假时为真，在第一个为真而第二个为假时为假。 在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p><p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_→-dec_"></a><a id="plfa_plfa-part1-Decidable-23555" href="../Decidable/#plfa_plfa-part1-Decidable-23555" class="Function Operator">_→-dec_</a> <a id="plfa_plfa-part1-Decidable-23563" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23565" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-23567" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-23568" href="../Decidable/#plfa_plfa-part1-Decidable-23568" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23570" href="../Decidable/#plfa_plfa-part1-Decidable-23570" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23572" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-23574" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-23577" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-23579" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23581" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23585" href="../Decidable/#plfa_plfa-part1-Decidable-23568" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23587" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23589" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23593" href="../Decidable/#plfa_plfa-part1-Decidable-23570" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-23595" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23597" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-23601" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23602" href="../Decidable/#plfa_plfa-part1-Decidable-23568" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-23604" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23606" href="../Decidable/#plfa_plfa-part1-Decidable-23570" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-23607" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23609" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-23615" href="../Decidable/#plfa_plfa-part1-Decidable-23555" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23621" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23625" href="../Decidable/#plfa_plfa-part1-Decidable-23625" class="Bound">y</a>  <a id="plfa_plfa-part1-Decidable-23628" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23631" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23635" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23638" href="../Decidable/#plfa_plfa-part1-Decidable-23638" class="Bound">_</a> <a id="plfa_plfa-part1-Decidable-23640" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23642" href="../Decidable/#plfa_plfa-part1-Decidable-23625" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-23643" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-23645" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-23647" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23648" href="../Decidable/#plfa_plfa-part1-Decidable-23648" class="CatchallClause Bound">¬x</a><a id="plfa_plfa-part1-Decidable-23650" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23651" href="../Decidable/#plfa_plfa-part1-Decidable-23555" class="CatchallClause Function Operator">→-dec</a><a id="plfa_plfa-part1-Decidable-23656" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-23657" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-23664" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23667" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23671" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23674" href="../Decidable/#plfa_plfa-part1-Decidable-23674" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23676" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23678" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Decidable-23685" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23686" href="../Decidable/#plfa_plfa-part1-Decidable-23648" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-23689" href="../Decidable/#plfa_plfa-part1-Decidable-23674" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-23690" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-23693" href="../Decidable/#plfa_plfa-part1-Decidable-9893" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-23697" href="../Decidable/#plfa_plfa-part1-Decidable-23697" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-23699" href="../Decidable/#plfa_plfa-part1-Decidable-23555" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-23705" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23708" href="../Decidable/#plfa_plfa-part1-Decidable-23708" class="Bound">¬y</a>  <a id="plfa_plfa-part1-Decidable-23712" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-23715" href="../Decidable/#plfa_plfa-part1-Decidable-9913" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-23718" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-23721" href="../Decidable/#plfa_plfa-part1-Decidable-23721" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23723" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-23725" href="../Decidable/#plfa_plfa-part1-Decidable-23708" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-23728" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-23729" href="../Decidable/#plfa_plfa-part1-Decidable-23721" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-23731" href="../Decidable/#plfa_plfa-part1-Decidable-23697" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-23732" class="Symbol">))</a>
</pre><p>两者的蕴涵在第二者成立或者第一者的否定成立时成立，其否定在第一者成立而第二者否定成立时成立。 蕴涵成立的证明是一个从第一者成立的证明到第二者成立的证明的函数。如果第二者成立，那么这个函数 直接返回第二者的证明。如果第一者的否定成立，那么使用第一者成立的证明，构造一个矛盾。 如果第一者成立，第二者不成立，给定蕴涵成立的证明，我们必须构造一个矛盾：我们将成立的证明 <code>f</code> 应用于第一者成立的证明 <code>x</code>，再加以第二者否定成立的证明 <code>¬y</code> 来构造矛盾。</p><p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是哪一条被匹配而不一样，但两者都是同样正确的。</p><h4 id="练习-erasure实践">练习 <code>erasure</code>（实践）</h4><p>证明擦除将对应的布尔值和可判定的值的操作联系了起来：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25251" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-∧-×"></a><a id="plfa_plfa-part1-Decidable-25263" href="../Decidable/#plfa_plfa-part1-Decidable-25263" class="Postulate">∧-×</a> <a id="plfa_plfa-part1-Decidable-25267" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25269" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25271" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25272" href="../Decidable/#plfa_plfa-part1-Decidable-25272" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25274" href="../Decidable/#plfa_plfa-part1-Decidable-25274" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25276" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25278" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25281" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25283" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25284" href="../Decidable/#plfa_plfa-part1-Decidable-25284" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25286" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25288" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25292" href="../Decidable/#plfa_plfa-part1-Decidable-25272" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25293" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25295" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25296" href="../Decidable/#plfa_plfa-part1-Decidable-25296" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25298" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25300" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25304" href="../Decidable/#plfa_plfa-part1-Decidable-25274" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25305" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25307" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25309" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25311" href="../Decidable/#plfa_plfa-part1-Decidable-25284" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25313" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25315" href="../Decidable/#plfa_plfa-part1-Decidable-18492" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-25317" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25319" href="../Decidable/#plfa_plfa-part1-Decidable-25296" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25321" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25323" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25325" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25327" href="../Decidable/#plfa_plfa-part1-Decidable-25284" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25329" href="../Decidable/#plfa_plfa-part1-Decidable-19054" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-25335" href="../Decidable/#plfa_plfa-part1-Decidable-25296" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25337" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-∨-⊎"></a><a id="plfa_plfa-part1-Decidable-25341" href="../Decidable/#plfa_plfa-part1-Decidable-25341" class="Postulate">∨-⊎</a> <a id="plfa_plfa-part1-Decidable-25345" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25347" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25349" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25350" href="../Decidable/#plfa_plfa-part1-Decidable-25350" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25352" href="../Decidable/#plfa_plfa-part1-Decidable-25352" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25354" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25356" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25359" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25361" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25362" href="../Decidable/#plfa_plfa-part1-Decidable-25362" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25364" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25366" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25370" href="../Decidable/#plfa_plfa-part1-Decidable-25350" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25371" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25373" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25374" href="../Decidable/#plfa_plfa-part1-Decidable-25374" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25376" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25378" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25382" href="../Decidable/#plfa_plfa-part1-Decidable-25352" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25383" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25385" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25387" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25389" href="../Decidable/#plfa_plfa-part1-Decidable-25362" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25391" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25393" href="../Decidable/#plfa_plfa-part1-Decidable-20271" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-25395" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25397" href="../Decidable/#plfa_plfa-part1-Decidable-25374" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25399" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25401" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25403" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25405" href="../Decidable/#plfa_plfa-part1-Decidable-25362" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25407" href="../Decidable/#plfa_plfa-part1-Decidable-20836" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-25413" href="../Decidable/#plfa_plfa-part1-Decidable-25374" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25415" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-not-¬"></a><a id="plfa_plfa-part1-Decidable-25419" href="../Decidable/#plfa_plfa-part1-Decidable-25419" class="Postulate">not-¬</a> <a id="plfa_plfa-part1-Decidable-25425" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25427" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25429" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25430" href="../Decidable/#plfa_plfa-part1-Decidable-25430" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25432" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25434" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25437" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25439" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25440" href="../Decidable/#plfa_plfa-part1-Decidable-25440" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25442" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25444" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25448" href="../Decidable/#plfa_plfa-part1-Decidable-25430" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25449" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25451" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25453" href="../Decidable/#plfa_plfa-part1-Decidable-21971" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-25457" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25459" href="../Decidable/#plfa_plfa-part1-Decidable-25440" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25461" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25465" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25467" href="../Decidable/#plfa_plfa-part1-Decidable-22151" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-25470" href="../Decidable/#plfa_plfa-part1-Decidable-25440" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25472" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
</pre><h4 id="练习-iff-erasure-推荐">练习 <code>iff-erasure</code> （推荐）</h4><p>给出与<a href="../Isomorphism/#iff">同构与嵌入</a>章节中 <code>_↔︎_</code> 相对应的布尔值与可判定的值的操作， 并证明其对应的擦除：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-25810" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_iff_"></a><a id="plfa_plfa-part1-Decidable-25822" href="../Decidable/#plfa_plfa-part1-Decidable-25822" class="Postulate Operator">_iff_</a> <a id="plfa_plfa-part1-Decidable-25828" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25830" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25835" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25837" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-25842" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25844" href="../Decidable/#plfa_plfa-part1-Decidable-2501" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-_⇔-dec_"></a><a id="plfa_plfa-part1-Decidable-25851" href="../Decidable/#plfa_plfa-part1-Decidable-25851" class="Postulate Operator">_⇔-dec_</a> <a id="plfa_plfa-part1-Decidable-25859" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25861" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25863" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25864" href="../Decidable/#plfa_plfa-part1-Decidable-25864" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25866" href="../Decidable/#plfa_plfa-part1-Decidable-25866" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25868" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25870" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25873" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25875" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25877" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25881" href="../Decidable/#plfa_plfa-part1-Decidable-25864" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25883" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25885" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25889" href="../Decidable/#plfa_plfa-part1-Decidable-25866" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25891" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25893" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25897" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25898" href="../Decidable/#plfa_plfa-part1-Decidable-25864" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25900" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-14976" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Decidable-25902" href="../Decidable/#plfa_plfa-part1-Decidable-25866" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25903" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Decidable-iff-⇔"></a><a id="plfa_plfa-part1-Decidable-25907" href="../Decidable/#plfa_plfa-part1-Decidable-25907" class="Postulate">iff-⇔</a> <a id="plfa_plfa-part1-Decidable-25913" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25915" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-25917" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-25918" href="../Decidable/#plfa_plfa-part1-Decidable-25918" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-25920" href="../Decidable/#plfa_plfa-part1-Decidable-25920" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-25922" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25924" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-25927" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-25929" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25930" href="../Decidable/#plfa_plfa-part1-Decidable-25930" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25932" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25934" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25938" href="../Decidable/#plfa_plfa-part1-Decidable-25918" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-25939" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25941" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-25942" href="../Decidable/#plfa_plfa-part1-Decidable-25942" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25944" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-25946" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-25950" href="../Decidable/#plfa_plfa-part1-Decidable-25920" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-25951" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-25953" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-25955" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25957" href="../Decidable/#plfa_plfa-part1-Decidable-25930" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25959" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25961" href="../Decidable/#plfa_plfa-part1-Decidable-25822" class="Postulate Operator">iff</a> <a id="plfa_plfa-part1-Decidable-25965" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25967" href="../Decidable/#plfa_plfa-part1-Decidable-25942" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25969" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-25971" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-25973" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-25975" href="../Decidable/#plfa_plfa-part1-Decidable-25930" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-25977" href="../Decidable/#plfa_plfa-part1-Decidable-25851" class="Postulate Operator">⇔-dec</a> <a id="plfa_plfa-part1-Decidable-25983" href="../Decidable/#plfa_plfa-part1-Decidable-25942" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-25985" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-26002" class="Comment">-- 请将代码写在此处。</a>
</pre><h2 id="proof-by-reflection">互映证明</h2><p>让我们回顾一下章节<a href="../Naturals/">自然数</a>中 <code>monus</code> 的定义。 如果从一个较小的数中减去一个较大的数，结果为零。毕竟我们总是要得到一个结果。 我们可以用其他方式定义吗？可以定义一版带有<strong>守卫（guarded）</strong>的减法──只有当 <code>n ≤ m</code> 时才能从 <code>m</code> 中减去 <code>n</code> ：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-minus"></a><a id="plfa_plfa-part1-Decidable-26620" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26626" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26628" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26629" href="../Decidable/#plfa_plfa-part1-Decidable-26629" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26631" href="../Decidable/#plfa_plfa-part1-Decidable-26631" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26633" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26635" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-26636" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26638" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26639" href="../Decidable/#plfa_plfa-part1-Decidable-26639" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-26643" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26645" href="../Decidable/#plfa_plfa-part1-Decidable-26631" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26647" href="../Decidable/#plfa_plfa-part1-Decidable-1666" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-26649" href="../Decidable/#plfa_plfa-part1-Decidable-26629" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26650" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26652" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-26654" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-26656" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26662" href="../Decidable/#plfa_plfa-part1-Decidable-26662" class="Bound">m</a>       <a id="plfa_plfa-part1-Decidable-26670" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-26678" class="Symbol">_</a>         <a id="plfa_plfa-part1-Decidable-26688" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26690" href="../Decidable/#plfa_plfa-part1-Decidable-26662" class="Bound">m</a>
<a id="plfa_plfa-part1-Decidable-26692" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26698" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26699" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26703" href="../Decidable/#plfa_plfa-part1-Decidable-26703" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-26704" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26706" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26707" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-26711" href="../Decidable/#plfa_plfa-part1-Decidable-26711" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-26712" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26714" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26715" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26719" href="../Decidable/#plfa_plfa-part1-Decidable-26719" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-26722" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-26724" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26726" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26732" href="../Decidable/#plfa_plfa-part1-Decidable-26703" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-26734" href="../Decidable/#plfa_plfa-part1-Decidable-26711" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-26736" href="../Decidable/#plfa_plfa-part1-Decidable-26719" class="Bound">n≤m</a>
</pre><p>然而这种定义难以使用，因为我们必须显式地为 <code>n ≤ m</code> 提供证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-26897" href="../Decidable/#plfa_plfa-part1-Decidable-26897" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-26899" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-26901" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-26907" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-26909" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-26911" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26912" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26916" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26917" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26921" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-26922" href="../Decidable/#plfa_plfa-part1-Decidable-1742" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-26926" href="../Decidable/#plfa_plfa-part1-Decidable-1693" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-26929" class="Symbol">)))</a> <a id="plfa_plfa-part1-Decidable-26933" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-26935" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-26937" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-26939" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-26941" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>这个问题没有通用的解决方案，但是在上述的情景下，我们恰好<strong>静态地</strong>知道这两个数字。这种情况下，我们可以使用一种被称为<strong>互映证明（proof by reflection）</strong>的技术。 实质上，在类型检查的时候我们可以让 Agda 运行可判定的等式 <code>n ≤? m</code> 并且保证 <code>n ≤ m</code>！</p><p>我们使用「隐式参数」的一个特性来实现这个功能。如果 Agda 可以填充一个记录类型的所有字段，那么 Agda 就可以填充此记录类型的隐式参数。 由于空记录类型没有任何字段，Agda 总是会设法填充空记录类型的隐式参数。这就是 <code>⊤</code> 类型被定义成空记录的原因。</p><p>这里的技巧是设置一个类型为 <code>T ⌊ n ≤? m ⌋</code> 的隐式参数。让我们一步一步阐述这句话的含义。 首先，我们运行判定过程 <code>n ≤? m</code>。它向我们提供了 <code>n ≤ m</code> 是否成立的证据。我们擦除证据得到布尔值。 最后，我们应用 <code>T</code>。回想一下，<code>T</code> 将布尔值映射到证据的世界：<code>true</code> 变成了单位类型 <code>⊤</code>， <code>false</code> 变成了空类型 <code>⊥</code> 。在操作上，这个类型的隐式参数起到了守卫的作用。</p><ul><li>如果 <code>n ≤ m</code> 成立，隐式参数的类型规约为 <code>⊤</code>。 然后 Agda 会欣然地提供隐式参数。</li><li>否则，类型规约为 <code>⊥</code> ，Agda 无法为此类型提供对应的值，因此会报错。例如，如果我们调用 <code>3 - 5</code> 会得到 <code>_n≤m_254 : ⊥</code>。</li></ul><p>我们使用之前定义的 <code>toWitness</code> 获得了 <code>n ≤ m</code> 的证据：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_-_"></a><a id="plfa_plfa-part1-Decidable-29104" href="../Decidable/#plfa_plfa-part1-Decidable-29104" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29108" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29110" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29111" href="../Decidable/#plfa_plfa-part1-Decidable-29111" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29113" href="../Decidable/#plfa_plfa-part1-Decidable-29113" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29115" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29117" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-29118" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-29120" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29121" href="../Decidable/#plfa_plfa-part1-Decidable-29121" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-29125" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29127" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29129" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29131" href="../Decidable/#plfa_plfa-part1-Decidable-29113" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29133" href="../Decidable/#plfa_plfa-part1-Decidable-11716" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-29136" href="../Decidable/#plfa_plfa-part1-Decidable-29111" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29138" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a><a id="plfa_plfa-part1-Decidable-29139" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29141" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29143" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-29145" href="../Decidable/#plfa_plfa-part1-Decidable-29104" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-29149" href="../Decidable/#plfa_plfa-part1-Decidable-29149" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29151" href="../Decidable/#plfa_plfa-part1-Decidable-29151" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29153" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29154" href="../Decidable/#plfa_plfa-part1-Decidable-29154" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29157" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29159" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29161" href="../Decidable/#plfa_plfa-part1-Decidable-26620" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-29167" href="../Decidable/#plfa_plfa-part1-Decidable-29149" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-29169" href="../Decidable/#plfa_plfa-part1-Decidable-29151" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-29171" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29172" href="../Decidable/#plfa_plfa-part1-Decidable-17325" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-29182" href="../Decidable/#plfa_plfa-part1-Decidable-29154" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-29185" class="Symbol">)</a>
</pre><p>我们现在只要能静态地知道这两个数就可以安全地使用 <code>_-_</code> 了：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-29316" href="../Decidable/#plfa_plfa-part1-Decidable-29316" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-29318" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29320" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-29322" href="../Decidable/#plfa_plfa-part1-Decidable-29104" class="Function Operator">-</a> <a id="plfa_plfa-part1-Decidable-29324" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-29326" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-29328" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-29330" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-29332" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29334" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>事实上，这种惯用语法非常普遍。标准库为 <code>T ⌊ ? ⌋</code> 定义了叫做 <code>True</code> 的同义词：</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-True"></a><a id="plfa_plfa-part1-Decidable-29525" href="../Decidable/#plfa_plfa-part1-Decidable-29525" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29530" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-29532" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-29534" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-29535" href="../Decidable/#plfa_plfa-part1-Decidable-29535" class="Bound">Q</a><a id="plfa_plfa-part1-Decidable-29536" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-29538" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29540" href="../Decidable/#plfa_plfa-part1-Decidable-9865" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-29544" href="../Decidable/#plfa_plfa-part1-Decidable-29535" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29546" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-29548" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-29552" href="../Decidable/#plfa_plfa-part1-Decidable-29525" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-29557" href="../Decidable/#plfa_plfa-part1-Decidable-29557" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29559" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-29561" href="../Decidable/#plfa_plfa-part1-Decidable-4512" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-29563" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-29565" href="../Decidable/#plfa_plfa-part1-Decidable-29557" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-29567" href="../Decidable/#plfa_plfa-part1-Decidable-16908" class="Function Operator">⌋</a>
</pre><h4 id="练习-false-实践">练习 <code>False</code> （实践）</h4><p>给出 <code>True</code>，<code>toWitness</code> 和 <code>fromWitness</code> 的<strong>相反</strong>定义。分别称为 <code>False</code>，<code>toWitnessFalse</code> 和 <code>fromWitnessFalse</code>。</p><h2 id="标准库">标准库</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-29952" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-29959" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Decidable-29974" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-29980" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-29981" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-29985" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-29987" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Decidable-29991" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-29993" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-29998" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30000" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Decidable-30001" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30003" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Decidable-30006" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30008" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Decidable-30011" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30013" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Decidable-30016" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30018" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30025" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-30034" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30040" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30041" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#5518" class="Function Operator">_≤?_</a><a id="plfa_plfa-part1-Decidable-30045" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30047" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30054" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-30071" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30077" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30078" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Decidable-30081" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30083" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-30086" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30088" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-30090" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30092" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30099" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="plfa_plfa-part1-Decidable-30126" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30132" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30133" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊_⌋</a><a id="plfa_plfa-part1-Decidable-30136" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30138" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="plfa_plfa-part1-Decidable-30142" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30144" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1484" class="Function">toWitness</a><a id="plfa_plfa-part1-Decidable-30153" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-30155" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1653" class="Function">fromWitness</a><a id="plfa_plfa-part1-Decidable-30166" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30168" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30175" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-30201" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30207" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30208" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#1355" class="Function">¬?</a><a id="plfa_plfa-part1-Decidable-30210" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30212" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30219" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html" class="Module">Relation.Nullary.Product</a> <a id="plfa_plfa-part1-Decidable-30244" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30250" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30251" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html#921" class="Function Operator">_×-dec_</a><a id="plfa_plfa-part1-Decidable-30258" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30260" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30267" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html" class="Module">Relation.Nullary.Sum</a> <a id="plfa_plfa-part1-Decidable-30288" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30294" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30295" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html#946" class="Function Operator">_⊎-dec_</a><a id="plfa_plfa-part1-Decidable-30302" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-30304" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-30311" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Decidable-30327" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-30333" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-30334" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Decidable-30343" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><pre><code>∧  U+2227  逻辑和 (\and, \wedge)
∨  U+2228  逻辑或 (\or, \vee)
⊃  U+2283  超集 (\sup)
ᵇ  U+1D47  修饰符小写 B  (\^b)
⌊  U+230A  左向下取整 (\clL)
⌋  U+230B  右向下取整 (\clR)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Fangyi Zhou、Oshmkufa2010</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>