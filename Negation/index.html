<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Negation</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Negation: 直觉逻辑与命题逻辑中的否定</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Negation-123" class="Keyword">module</a> <a id="plfa_plfa-part1-Negation-130" href="../Negation/#" class="Module">plfa.part1.Negation</a> <a id="plfa_plfa-part1-Negation-150" class="Keyword">where</a>
</pre><p>本章介绍了否定的性质，讨论了直觉逻辑和经典逻辑。</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Negation-301" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-306" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-313" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Negation-351" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-357" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-358" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Negation-361" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-363" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Negation-367" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-369" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-374" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-381" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Negation-390" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-396" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-397" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-398" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-400" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Negation-404" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-406" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Negation-409" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-411" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-416" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-423" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Negation-434" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-440" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-441" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Negation-442" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-444" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Negation-450" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-452" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-457" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-464" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Negation-473" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-479" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-480" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Negation-483" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-485" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Negation-489" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-491" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Negation-495" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-497" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-502" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-509" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Negation-522" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-528" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-529" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Negation-532" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-534" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-539" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-546" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Negation-569" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-575" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-576" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5575" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Negation-579" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-581" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Negation-595" class="Symbol">)</a>
</pre><h2 id="否定">否定</h2><p>给定命题 <code>A</code>，当 <code>A</code> 不成立时，它的否定形式 <code>¬ A</code> 成立。 我们将否定阐述为「蕴涵假」来形式化此概念。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬_"></a><a id="plfa_plfa-part1-Negation-865" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬_</a> <a id="plfa_plfa-part1-Negation-868" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-870" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-874" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-876" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-880" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-882" href="../Negation/#plfa_plfa-part1-Negation-882" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-884" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-886" href="../Negation/#plfa_plfa-part1-Negation-882" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-888" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-890" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>这是<strong>归谬法（Reductio ad Absurdum）</strong>的一种形式：若从 <code>A</code> 可得出结论 <code>⊥</code>（即喵呜）， 则 <code>¬ A</code> 必定成立。</p><p><code>¬ A</code> 成立的证据的形式为：</p><pre><code>λ{ x → N }</code></pre><p>其中 <code>N</code> 是类型为 <code>⊥</code> 的项，它包含类型为 <code>A</code> 的自由变量 <code>x</code>。换言之，<code>¬ A</code> 成立 的证据是一个函数，该函数将 <code>A</code> 成立的证据转换为 <code>⊥</code> 成立的证据。</p><p>给定 <code>¬ A</code> 和 <code>A</code> 均成立的证据，我们可以得出 <code>⊥</code> 成立。换言之，若 <code>¬ A</code> 和 <code>A</code> 均成立， 那么我们就得到了矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬-elim"></a><a id="plfa_plfa-part1-Negation-1740" href="../Negation/#plfa_plfa-part1-Negation-1740" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1747" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1749" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-1751" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-1752" href="../Negation/#plfa_plfa-part1-Negation-1752" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-1754" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1756" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-1759" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-1763" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1765" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-1767" href="../Negation/#plfa_plfa-part1-Negation-1752" class="Bound">A</a>
  <a id="plfa_plfa-part1-Negation-1771" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1773" href="../Negation/#plfa_plfa-part1-Negation-1752" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-1779" class="Comment">---</a>
  <a id="plfa_plfa-part1-Negation-1785" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1787" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-1789" href="../Negation/#plfa_plfa-part1-Negation-1740" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1796" href="../Negation/#plfa_plfa-part1-Negation-1796" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1799" href="../Negation/#plfa_plfa-part1-Negation-1799" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-1801" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-1803" href="../Negation/#plfa_plfa-part1-Negation-1796" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1806" href="../Negation/#plfa_plfa-part1-Negation-1799" class="Bound">x</a>
</pre><p>在这里，我们将 <code>¬ A</code> 的证据写作 <code>¬x</code>，将 <code>A</code> 的证据写作 <code>x</code>。这表示 <code>¬x</code> 必须是类型为 <code>A → ⊥</code> 的函数，因此应用 <code>¬x x</code> 得到的类型必为 <code>⊥</code>。注意此规则只是 <code>→-elim</code> 的一个特例。</p><p>我们将否定的优先级设定为高于析取和合取，但低于其它运算：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-2363" class="Keyword">infix</a> <a id="plfa_plfa-part1-Negation-2369" class="Number">3</a> <a id="plfa_plfa-part1-Negation-2371" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬_</a>
</pre><p>因此，<code>¬ A × ¬ B</code> 会解析为 <code>(¬ A) × (¬ B)</code>，而 <code>¬ m ≡ n</code> 会解析为 <code>¬ (m ≡ n)</code>。</p><p>在<strong>经典逻辑</strong>中，<code>A</code> 等价于 <code>¬ ¬ A</code>。而如前文所述，Agda 中使用了<strong>直觉逻辑</strong>， 因此我们只有该等价关系的一半，即 <code>A</code> 蕴涵 <code>¬ ¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro"></a><a id="plfa_plfa-part1-Negation-2838" href="../Negation/#plfa_plfa-part1-Negation-2838" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2847" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2849" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2851" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2852" href="../Negation/#plfa_plfa-part1-Negation-2852" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2854" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2856" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2859" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2863" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2865" href="../Negation/#plfa_plfa-part1-Negation-2852" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2871" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-2879" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2881" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2883" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2885" href="../Negation/#plfa_plfa-part1-Negation-2852" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2887" href="../Negation/#plfa_plfa-part1-Negation-2838" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2896" href="../Negation/#plfa_plfa-part1-Negation-2896" class="Bound">x</a>  <a id="plfa_plfa-part1-Negation-2899" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-2902" class="Symbol">λ{</a><a id="plfa_plfa-part1-Negation-2904" href="../Negation/#plfa_plfa-part1-Negation-2904" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2907" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2909" href="../Negation/#plfa_plfa-part1-Negation-2904" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2912" href="../Negation/#plfa_plfa-part1-Negation-2896" class="Bound">x</a><a id="plfa_plfa-part1-Negation-2913" class="Symbol">}</a>
</pre><p>令 <code>x</code> 为 <code>A</code> 的证据。我们要证明若假定 <code>¬ A</code> 成立，则会导出矛盾，因此 <code>¬ ¬ A</code> 必定成立。令 <code>¬x</code> 为 <code>¬ A</code> 的证据。那么以 <code>¬x x</code> 为证据，从 <code>A</code> 和 <code>¬ A</code> 可以导出矛盾。 这样我们就证明了 <code>¬ ¬ A</code>。</p><p>以上描述的等价写法如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro′"></a><a id="plfa_plfa-part1-Negation-3390" href="../Negation/#plfa_plfa-part1-Negation-3390" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3400" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3402" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3404" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3405" href="../Negation/#plfa_plfa-part1-Negation-3405" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3407" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3409" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3412" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3416" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3418" href="../Negation/#plfa_plfa-part1-Negation-3405" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3424" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-3432" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3434" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3436" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3438" href="../Negation/#plfa_plfa-part1-Negation-3405" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3440" href="../Negation/#plfa_plfa-part1-Negation-3390" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3450" href="../Negation/#plfa_plfa-part1-Negation-3450" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3452" href="../Negation/#plfa_plfa-part1-Negation-3452" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3455" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-3457" href="../Negation/#plfa_plfa-part1-Negation-3452" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3460" href="../Negation/#plfa_plfa-part1-Negation-3450" class="Bound">x</a>
</pre><p>在这里我们简单地将 λ-项的参数转换成了该函数的额外参数。 我们通常会使用后面这种形式，因为它更加紧凑。</p><p>我们无法证明 <code>¬ ¬ A</code> 蕴涵 <code>A</code>，但可以证明 <code>¬ ¬ ¬ A</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬¬-elim"></a><a id="plfa_plfa-part1-Negation-3853" href="../Negation/#plfa_plfa-part1-Negation-3853" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3862" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3864" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3866" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3867" href="../Negation/#plfa_plfa-part1-Negation-3867" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3869" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3871" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3874" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3878" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3880" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3882" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3884" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3886" href="../Negation/#plfa_plfa-part1-Negation-3867" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3892" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Negation-3902" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3904" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3906" href="../Negation/#plfa_plfa-part1-Negation-3867" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3908" href="../Negation/#plfa_plfa-part1-Negation-3853" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3917" href="../Negation/#plfa_plfa-part1-Negation-3917" class="Bound">¬¬¬x</a>  <a id="plfa_plfa-part1-Negation-3923" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-3926" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-3928" href="../Negation/#plfa_plfa-part1-Negation-3928" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3930" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3932" href="../Negation/#plfa_plfa-part1-Negation-3917" class="Bound">¬¬¬x</a> <a id="plfa_plfa-part1-Negation-3937" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3938" href="../Negation/#plfa_plfa-part1-Negation-2838" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-3947" href="../Negation/#plfa_plfa-part1-Negation-3928" class="Bound">x</a><a id="plfa_plfa-part1-Negation-3948" class="Symbol">)</a>
</pre><p>令 <code>¬¬¬x</code> 为 <code>¬ ¬ ¬ A</code> 的证据。我们要证明若假定 <code>A</code> 成立就会导出矛盾， 因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据前面的结果，以 <code>¬¬-intro x</code> 为证据可得出结论 <code>¬ ¬ A</code>。根据 <code>¬¬¬x (¬¬-intro x)</code>，我们可从 <code>¬ ¬ ¬ A</code> 和 <code>¬ ¬ A</code> 导出矛盾。这样我们就证明了 <code>¬ A</code>。</p><p>另一个逻辑规则是<strong>换质换位律（contraposition）</strong>，它陈述了若 <code>A</code> 蕴涵 <code>B</code>， 则 <code>¬ B</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-contraposition"></a><a id="plfa_plfa-part1-Negation-4693" href="../Negation/#plfa_plfa-part1-Negation-4693" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4708" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4710" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-4712" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-4713" href="../Negation/#plfa_plfa-part1-Negation-4713" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4715" href="../Negation/#plfa_plfa-part1-Negation-4715" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4717" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4719" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-4722" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-4726" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4728" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4729" href="../Negation/#plfa_plfa-part1-Negation-4713" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4731" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4733" href="../Negation/#plfa_plfa-part1-Negation-4715" class="Bound">B</a><a id="plfa_plfa-part1-Negation-4734" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Negation-4740" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Negation-4754" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4756" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4757" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4759" href="../Negation/#plfa_plfa-part1-Negation-4715" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4761" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4763" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4765" href="../Negation/#plfa_plfa-part1-Negation-4713" class="Bound">A</a><a id="plfa_plfa-part1-Negation-4766" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-4768" href="../Negation/#plfa_plfa-part1-Negation-4693" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4783" href="../Negation/#plfa_plfa-part1-Negation-4783" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4785" href="../Negation/#plfa_plfa-part1-Negation-4785" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4788" href="../Negation/#plfa_plfa-part1-Negation-4788" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-4790" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4792" href="../Negation/#plfa_plfa-part1-Negation-4785" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4795" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4796" href="../Negation/#plfa_plfa-part1-Negation-4783" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4798" href="../Negation/#plfa_plfa-part1-Negation-4788" class="Bound">x</a><a id="plfa_plfa-part1-Negation-4799" class="Symbol">)</a>
</pre><p>令 <code>f</code> 为 <code>A → B</code> 的证据，<code>¬y</code> 为 <code>¬ B</code> 的证据。我们要证明，若假定 <code>A</code> 成立就会导出矛盾，因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据 <code>f x</code>， 我们可从 <code>A → B</code> 和 <code>A</code> 我们可得出结论 <code>B</code>。而根据 <code>¬y (f x)</code>，可从 <code>B</code> 和 <code>¬ B</code> 得出结论 <code>⊥</code>。这样，我们就证明了 <code>¬ A</code>。</p><p>利用否定可直接定义不等性：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-_≢_"></a><a id="plfa_plfa-part1-Negation-5443" href="../Negation/#plfa_plfa-part1-Negation-5443" class="Function Operator">_≢_</a> <a id="plfa_plfa-part1-Negation-5447" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5449" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-5451" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-5452" href="../Negation/#plfa_plfa-part1-Negation-5452" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5454" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5456" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-5459" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-5461" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5463" href="../Negation/#plfa_plfa-part1-Negation-5452" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5465" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5467" href="../Negation/#plfa_plfa-part1-Negation-5452" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5469" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5471" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-5475" href="../Negation/#plfa_plfa-part1-Negation-5475" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5477" href="../Negation/#plfa_plfa-part1-Negation-5443" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5479" href="../Negation/#plfa_plfa-part1-Negation-5479" class="Bound">y</a>  <a id="plfa_plfa-part1-Negation-5482" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-5485" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-5487" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-5488" href="../Negation/#plfa_plfa-part1-Negation-5475" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5490" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-5492" href="../Negation/#plfa_plfa-part1-Negation-5479" class="Bound">y</a><a id="plfa_plfa-part1-Negation-5493" class="Symbol">)</a>
</pre><p>要证明不同的数不相等很简单：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-5588" href="../Negation/#plfa_plfa-part1-Negation-5588" class="Function">_</a> <a id="plfa_plfa-part1-Negation-5590" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5592" class="Number">1</a> <a id="plfa_plfa-part1-Negation-5594" href="../Negation/#plfa_plfa-part1-Negation-5443" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5596" class="Number">2</a>
<a id="plfa_plfa-part1-Negation-5598" class="Symbol">_</a> <a id="plfa_plfa-part1-Negation-5600" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-5602" class="Symbol">λ()</a>
</pre><p>这是我们第一次在 λ-表达式中使用谬模式（Absurd Pattern）。类型 <code>M ≡ N</code> 只有在 <code>M</code> 和 <code>N</code> 可被化简为相同的项时才能居留。由于 <code>1</code> 和 <code>2</code> 会化简为不同的正规形式，因此 Agda 判定没有证据可证明 <code>1 ≡ 2</code>。 第二个例子是，很容易验证皮亚诺公理中「零不是任何数的后继数」的假设：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-peano"></a><a id="plfa_plfa-part1-Negation-6175" href="../Negation/#plfa_plfa-part1-Negation-6175" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6181" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6183" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-6185" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-6186" href="../Negation/#plfa_plfa-part1-Negation-6186" class="Bound">m</a> <a id="plfa_plfa-part1-Negation-6188" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6190" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-6191" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-6193" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6195" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Negation-6200" href="../Negation/#plfa_plfa-part1-Negation-5443" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-6202" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Negation-6206" href="../Negation/#plfa_plfa-part1-Negation-6186" class="Bound">m</a>
<a id="plfa_plfa-part1-Negation-6208" href="../Negation/#plfa_plfa-part1-Negation-6175" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6214" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6216" class="Symbol">λ()</a>
</pre><p>它们的证明基本上相同，因为谬模式会匹配所有类型为 <code>zero ≡ suc m</code> 的可能的证据。</p><p>鉴于蕴涵和幂运算之间的对应关系，以及没有成员的类型为假， 我们可以将否定看作零的幂。它确实对应于我们所知的算术运算，即</p><pre><code>0 ^ n  ≡  1,  if n ≡ 0
       ≡  0,  if n ≢ 0</code></pre><p>确实，只有一个 <code>⊥ → ⊥</code> 的证明。我们可以用两种方式写出此证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id"></a><a id="plfa_plfa-part1-Negation-6882" href="../Negation/#plfa_plfa-part1-Negation-6882" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6885" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6887" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-6889" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6891" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-6893" href="../Negation/#plfa_plfa-part1-Negation-6882" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6896" href="../Negation/#plfa_plfa-part1-Negation-6896" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-6898" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6900" href="../Negation/#plfa_plfa-part1-Negation-6896" class="Bound">x</a>

<a id="plfa_plfa-part1-Negation-id′"></a><a id="plfa_plfa-part1-Negation-6903" href="../Negation/#plfa_plfa-part1-Negation-6903" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6907" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6909" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-6911" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6913" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-6915" href="../Negation/#plfa_plfa-part1-Negation-6903" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6919" class="Symbol">()</a>
</pre><p>不过使用外延性，我们可以证明二者相等：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id≡id′"></a><a id="plfa_plfa-part1-Negation-7019" href="../Negation/#plfa_plfa-part1-Negation-7019" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7026" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7028" href="../Negation/#plfa_plfa-part1-Negation-6882" class="Function">id</a> <a id="plfa_plfa-part1-Negation-7031" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7033" href="../Negation/#plfa_plfa-part1-Negation-6903" class="Function">id′</a>
<a id="plfa_plfa-part1-Negation-7037" href="../Negation/#plfa_plfa-part1-Negation-7019" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7044" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7046" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7061" class="Symbol">(λ())</a>
</pre><p>根据外延性，对于任何在二者定义域中的 <code>x</code>，都有 <code>id x ≡ id′ x</code>， 则 <code>id ≡ id′</code> 成立。不过没有 <code>x</code> 在它们的定义域中，因此其相等性平凡成立。</p><p>实际上，我们可以证明任意两个否定的证明都是相等的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-assimilation"></a><a id="plfa_plfa-part1-Negation-7439" href="../Negation/#plfa_plfa-part1-Negation-7439" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7452" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7454" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-7456" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-7457" href="../Negation/#plfa_plfa-part1-Negation-7457" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-7459" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7461" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-7464" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-7466" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-7467" href="../Negation/#plfa_plfa-part1-Negation-7467" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7470" href="../Negation/#plfa_plfa-part1-Negation-7470" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7474" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7476" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-7478" href="../Negation/#plfa_plfa-part1-Negation-7457" class="Bound">A</a><a id="plfa_plfa-part1-Negation-7479" class="Symbol">)</a> <a id="plfa_plfa-part1-Negation-7481" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7483" href="../Negation/#plfa_plfa-part1-Negation-7467" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7486" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7488" href="../Negation/#plfa_plfa-part1-Negation-7470" class="Bound">¬x′</a>
<a id="plfa_plfa-part1-Negation-7492" href="../Negation/#plfa_plfa-part1-Negation-7439" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7505" href="../Negation/#plfa_plfa-part1-Negation-7505" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7508" href="../Negation/#plfa_plfa-part1-Negation-7508" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7512" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7514" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3547" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7529" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-7532" href="../Negation/#plfa_plfa-part1-Negation-7532" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-7534" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7536" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Negation-7543" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-7544" href="../Negation/#plfa_plfa-part1-Negation-7505" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7547" href="../Negation/#plfa_plfa-part1-Negation-7532" class="Bound">x</a><a id="plfa_plfa-part1-Negation-7548" class="Symbol">))</a>
</pre><p><code>¬ A</code> 的证据蕴涵任何 <code>A</code> 的证据都可直接得出矛盾。但由于外延性全称量化了使 <code>A</code> 成立的 <code>x</code>，因此任何这样的 <code>x</code> 都会直接导出矛盾，同样其相等性平凡成立。</p><h4 id="练习--irreflexive推荐">练习 <code>&lt;-irreflexive</code>（推荐）</h4><p>利用否定证明<a href="../Relations/#strict-inequality">严格不等性</a>满足非自反性， 即 <code>n &lt; n</code> 对于任何 <code>n</code> 都不成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8223" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-trichotomy实践">练习 <code>trichotomy</code>（实践）</h4><p>请证明严格不等性满足<a href="../Relations/#trichotomy">三分律</a>， 即对于任何自然数 <code>m</code> 和 <code>n</code>，以下三条刚好只有一条成立：</p><ul><li><code>m &lt; n</code></li><li><code>m ≡ n</code></li><li><code>m &gt; n</code></li></ul><p>「刚好只有一条」的意思是，三者中不仅有一条成立，而且当其中一条成立时， 其它二者的否定也必定成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8788" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--dual-推荐">练习 <code>⊎-dual-×</code>（推荐）</h4><p>请证明合取、析取和否定可通过以下版本的德摩根定律（De Morgan’s Law）关联在一起。</p><pre><code>¬ (A ⊎ B) ≃ (¬ A) × (¬ B)</code></pre><p>此结果是我们之前证明的定理的简单推论。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-9176" class="Comment">-- 请将代码写在此处</a>
</pre><p>以下命题也成立吗？</p><pre><code>¬ (A × B) ≃ (¬ A) ⊎ (¬ B)</code></pre><p>若成立，请证明；若不成立，你能给出一个比同构更弱的关系将两边关联起来吗？</p><h2 id="直觉逻辑与经典逻辑">直觉逻辑与经典逻辑</h2><p>在 Gilbert 和 Sullivan 的电影《船夫》（<em>The Gondoliers</em>）中， Casilda 被告知她还是个婴儿时，就被许配给了巴塔维亚国王的继承人。 但由于一场动乱，没人知道她被许配给了两位继承人 Marco 和 Giuseppe 中的哪一位。她惊慌地哀嚎道：「那么你的意思是说我嫁给了两位船夫中的一位， 但却无法确定是谁？」对此的回答是：「虽然不知道是谁，但这件事却是毫无疑问的。」</p><p>逻辑学有很多变种，而<strong>经典逻辑</strong>和<strong>直觉逻辑</strong>之间有一个区别。 直觉主义者关注于某些逻辑学家对无限性本质的假设，坚持真理的构造主义的概念。 具体来说，它们坚持认为 <code>A ⊎ B</code> 的证明必须确定 <code>A</code> 或 <code>B</code> 中的<strong>哪一个</strong>成立， 因此它们会解决宣称 Casilda 嫁给了 Marco 或者 Giuseppe，直到其中一个被确定为 她的丈夫为止。或许 Gilbert 和 Sullivan 期待直觉主义，因为在故事的结局中， 继承人是第三个人 Luiz，他和 Casilda 已经顺利地相爱了。</p><p>直觉主义者也拒绝排中律（Law of the Excluded Middle）————该定律断言，对于所有的 <code>A</code>，<code>A ⊎ ¬ A</code> 必定成立————因为该定律没有给出 <code>A</code> 和 <code>¬ A</code> 中的哪一个成立。 海廷（Heyting）形式化了希尔伯特（Hilbert）经典逻辑的一个变种，抓住了直觉主义中可证明性的概念。 具体来说，排中律在希尔伯特逻辑中是可证明的，但在海廷逻辑中却不可证明。 进一步来说，如果排中律作为一条公理添加到海廷逻辑中，那么它会等价于希尔伯特逻辑。 柯尔莫哥洛夫（Kolmogorov）证明了两种逻辑紧密相关：他给出了双重否定翻译，即一个式子在经典逻辑中 可证，当且仅当它的双重否定式在直觉逻辑中可证。</p><p>「命题即类型」最初是为直觉逻辑而制定的。这是一种完美的契合，因为在直觉主义的 解释中，式子 <code>A ⊎ B</code> 刚好可以在给出 <code>A</code> 或 <code>B</code> 之一的证明时得证，因此对应于析取 的类型是一个不交和（Disjoint Sum）。</p><p>（以上内容部分取自 “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>，2015 年 12 月。）</p><h2 id="排中律是不可辩驳的">排中律是不可辩驳的</h2><p>排中律可形式化如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-12874" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Negation-em"></a><a id="plfa_plfa-part1-Negation-12886" href="../Negation/#plfa_plfa-part1-Negation-12886" class="Postulate">em</a> <a id="plfa_plfa-part1-Negation-12889" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12891" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-12893" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-12894" href="../Negation/#plfa_plfa-part1-Negation-12894" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12896" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12898" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-12901" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-12903" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-12905" href="../Negation/#plfa_plfa-part1-Negation-12894" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12907" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-12909" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-12911" href="../Negation/#plfa_plfa-part1-Negation-12894" class="Bound">A</a>
</pre><p>如之前所言，排中律在直觉逻辑中并不成立。然而，我们可以证明它是 <strong>不可辩驳（Irrefutable）</strong>的，即其否定的否定是可证明的（因而其否定式不可证明）：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-em-irrefutable"></a><a id="plfa_plfa-part1-Negation-13252" href="../Negation/#plfa_plfa-part1-Negation-13252" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13267" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13269" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-13271" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-13272" href="../Negation/#plfa_plfa-part1-Negation-13272" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13274" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13276" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-13279" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-13281" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13283" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13285" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13287" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13288" href="../Negation/#plfa_plfa-part1-Negation-13272" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13290" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-13292" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13294" href="../Negation/#plfa_plfa-part1-Negation-13272" class="Bound">A</a><a id="plfa_plfa-part1-Negation-13295" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-13297" href="../Negation/#plfa_plfa-part1-Negation-13252" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13312" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-13314" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-13316" href="../Negation/#plfa_plfa-part1-Negation-13316" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13318" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13320" href="../Negation/#plfa_plfa-part1-Negation-13316" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13322" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13323" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Negation-13328" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-13331" href="../Negation/#plfa_plfa-part1-Negation-13331" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-13333" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13335" href="../Negation/#plfa_plfa-part1-Negation-13316" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13337" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13338" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Negation-13343" href="../Negation/#plfa_plfa-part1-Negation-13331" class="Bound">x</a><a id="plfa_plfa-part1-Negation-13344" class="Symbol">)))</a>
</pre><p>解释此代码的最佳方式是交互式地推导它：</p><pre><code>em-irrefutable k = ?</code></pre><p>给定 <code>¬ (A ⊎ ¬ A)</code> 的证据 <code>k</code>，即一个函数，它接受一个类型为 <code>A ⊎ ¬ A</code> 的值， 返回一个空类型的值，我们必须在 <code>?</code> 处填上一个返回空类型的项。得到空类型值 的唯一方式就是应用 <code>k</code> 本身，于是我们据此展开此洞：</p><pre><code>em-irrefutable k = k ?</code></pre><p>我们需要用类型为 <code>A ⊎ ¬ A</code> 的值填上这个新的洞。由于目前我们并没有类型为 <code>A</code> 的值， 因此先处理第二个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → ? })</code></pre><p>第二个析取接受 <code>¬ A</code> 的证据，即一个函数，它接受类型为 <code>A</code> 的值，返回空类型的值。 我们将 <code>x</code> 绑定到类型为 <code>A</code> 的值，现在我们需要在洞中填入空类型的值。同样， 得到空类型的值的唯一方法就是将 <code>k</code> 应用到其自身，于是我们展开此洞：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k ? })</code></pre><p>这次我们就有一个类型为 <code>A</code> 的值了，其名为 <code>x</code>，于是我们可以处理第一个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k (inj₁ x) })</code></pre><p>现在没有洞了！这样就完成了证明。</p><p>下面的故事说明了我们创建的项的行为。 （向 Peter Selinger 道歉，他讲的是个关于国王，巫师和贤者之石的类似的故事。）</p><p>曾经有一个恶魔向一个男人提议：「要么 (a) 我给你 10 亿美元，要么 (b) 如果你付给我 10 亿美元，我可以实现你的任何一个愿望。当然，得是我决定提供 (a) 还是 (b)。」</p><p>男人很谨慎。他需要付出他的灵魂吗？ 恶魔说不用，他只要接受这个提议就行。</p><p>于是男人思索着，如果恶魔向他提供 (b)，那么他不太可能付得起这个愿望。 不过倘若真是如此的话，能有什么坏处吗？</p><p>「我接受」，男人回答道，「我能得到 (a) 还是 (b)？」</p><p>恶魔顿了顿。「我提供 (b)。」</p><p>男人很失望，但并不惊讶。「果然是这样」，他想。 但是这个提议折磨着他。想想他都能用这个愿望做些什么！ 多年以后，男人开始积累钱财。为了得到这笔钱，他有时会做坏事， 而且他隐约意识到这一定是魔鬼所想到的。最后他攒够了 10 亿美元，恶魔再次出现了。</p><p>「这是 10 亿美元」，男人说着，交出一个手提箱。「实现我的愿望吧！」</p><p>恶魔接过了手提箱。然后他说道，「哦？我之前说的是 (b) 吗？抱歉，我说的是 (a)。 很高兴能给你 10 亿美元。」</p><p>于是恶魔将那个手提箱又还给了他。</p><p>（以上内容部分取自 “Call-by-Value is Dual to Call-by-Name”, Philip Wadler, <em>International Conference on Functional Programming</em>, 2003 年。）</p><h4 id="练习-classical延伸">练习 <code>Classical</code>（延伸）</h4><p>考虑以下定律：</p><ul><li>排中律：对于所有 <code>A</code>，<code>A ⊎ ¬ A</code>。</li><li>双重否定消去：对于所有的 <code>A</code>，<code>¬ ¬ A → A</code>。</li><li>皮尔士定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>((A → B) → A) → A</code>。</li><li>蕴涵表示为析取：对于所有的 <code>A</code> 和 <code>B</code>，<code>(A → B) → ¬ A ⊎ B</code>。</li><li>德摩根定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>¬ (¬ A × ¬ B) → A ⊎ B</code>。</li></ul><p>请证明其中任意一条定律都蕴涵其它所有定律。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18254" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="联系-stable延伸">联系 <code>Stable</code>（延伸）</h4><p>若双重否定消去对某个式子成立，我们就说它是<strong>稳定（Stable）</strong>的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-Stable"></a><a id="plfa_plfa-part1-Negation-18470" href="../Negation/#plfa_plfa-part1-Negation-18470" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18477" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-18479" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-18483" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18485" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-18489" href="../Negation/#plfa_plfa-part1-Negation-18470" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18496" href="../Negation/#plfa_plfa-part1-Negation-18496" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18498" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-18500" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18502" href="../Negation/#plfa_plfa-part1-Negation-865" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18504" href="../Negation/#plfa_plfa-part1-Negation-18496" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18506" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18508" href="../Negation/#plfa_plfa-part1-Negation-18496" class="Bound">A</a>
</pre><p>请证明任何否定式都是稳定的，并且两个稳定式的合取也是稳定的。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18667" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>本章中的类似定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18842" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18849" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Negation-18866" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18872" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18873" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Negation-18875" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-18877" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18884" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Negation-18910" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18916" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18917" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#998" class="Function">contraposition</a><a id="plfa_plfa-part1-Negation-18931" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章使用了以下 Unicode：</p><pre><code>¬  U+00AC  否定符号 (\neg)
≢  U+2262  不等价于 (\==n)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div><h3 class="footer-heading">本章翻译进度：100% ，译者：Oling Cat</h3>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>