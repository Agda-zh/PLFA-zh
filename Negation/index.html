<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Negation</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Negation: 直觉逻辑与命题逻辑中的否定</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Negation-107" class="Keyword">module</a> <a id="plfa_plfa-part1-Negation-114" href="../Negation/#" class="Module">plfa.part1.Negation</a> <a id="plfa_plfa-part1-Negation-134" class="Keyword">where</a>
</pre><p>本章介绍了否定的性质，讨论了直觉逻辑和经典逻辑。</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Negation-285" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-290" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-297" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Negation-335" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-341" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-342" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Negation-345" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-347" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Negation-351" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-353" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-358" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-365" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Negation-379" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-385" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-386" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-387" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-389" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Negation-393" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-395" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Negation-398" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-400" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-405" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-412" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Negation-423" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-429" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-430" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a><a id="plfa_plfa-part1-Negation-431" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-433" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-438" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-445" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="plfa_plfa-part1-Negation-459" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-465" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-466" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Negation-469" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-471" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Negation-475" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-477" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Negation-481" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-483" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-488" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-495" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="plfa_plfa-part1-Negation-513" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-519" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-520" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Negation-523" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-525" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-530" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-537" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Negation-563" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-569" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-570" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1270" class="Function">contradiction</a><a id="plfa_plfa-part1-Negation-583" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-585" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-590" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-597" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Negation-620" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-626" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-627" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5565" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Negation-630" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-632" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Negation-646" class="Symbol">)</a>
</pre><h2 id="否定">否定</h2><p>给定命题 <code>A</code>，当 <code>A</code> 不成立时，它的否定形式 <code>¬ A</code> 成立。 我们将否定阐述为「蕴涵假」来形式化此概念。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬_"></a><a id="plfa_plfa-part1-Negation-916" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬_</a> <a id="plfa_plfa-part1-Negation-919" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-921" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-925" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-927" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-931" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-933" href="../Negation/#plfa_plfa-part1-Negation-933" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-935" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-937" href="../Negation/#plfa_plfa-part1-Negation-933" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-939" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-941" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a>
</pre><p>这是<strong>归谬法（Reductio ad Absurdum）</strong>的一种形式：若从 <code>A</code> 可得出结论 <code>⊥</code>（即谬误）， 则 <code>¬ A</code> 必定成立。</p><p><code>¬ A</code> 成立的证据的形式为：</p><pre><code>λ{ x → N }</code></pre><p>其中 <code>N</code> 是类型为 <code>⊥</code> 的项，它包含类型为 <code>A</code> 的自由变量 <code>x</code>。换言之，<code>¬ A</code> 成立 的证据是一个函数，该函数将 <code>A</code> 成立的证据转换为 <code>⊥</code> 成立的证据。</p><p>给定 <code>¬ A</code> 和 <code>A</code> 均成立的证据，我们可以得出 <code>⊥</code> 成立。换言之，若 <code>¬ A</code> 和 <code>A</code> 均成立， 那么我们就得到了矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬-elim"></a><a id="plfa_plfa-part1-Negation-1791" href="../Negation/#plfa_plfa-part1-Negation-1791" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1798" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1800" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-1802" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-1803" href="../Negation/#plfa_plfa-part1-Negation-1803" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-1805" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1807" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-1810" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-1814" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1816" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-1818" href="../Negation/#plfa_plfa-part1-Negation-1803" class="Bound">A</a>
  <a id="plfa_plfa-part1-Negation-1822" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1824" href="../Negation/#plfa_plfa-part1-Negation-1803" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-1830" class="Comment">---</a>
  <a id="plfa_plfa-part1-Negation-1836" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1838" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a>
<a id="plfa_plfa-part1-Negation-1840" href="../Negation/#plfa_plfa-part1-Negation-1791" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1847" href="../Negation/#plfa_plfa-part1-Negation-1847" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1850" href="../Negation/#plfa_plfa-part1-Negation-1850" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-1852" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-1854" href="../Negation/#plfa_plfa-part1-Negation-1847" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1857" href="../Negation/#plfa_plfa-part1-Negation-1850" class="Bound">x</a>
</pre><p>在这里，我们将 <code>¬ A</code> 的证据写作 <code>¬x</code>，将 <code>A</code> 的证据写作 <code>x</code>。这表示 <code>¬x</code> 必须是类型为 <code>A → ⊥</code> 的函数，因此应用 <code>¬x x</code> 得到的类型必为 <code>⊥</code>。注意此规则只是 <code>→-elim</code> 的一个特例。</p><p>我们将否定的优先级设定为高于析取和合取，但低于其它运算：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-2414" class="Keyword">infix</a> <a id="plfa_plfa-part1-Negation-2420" class="Number">3</a> <a id="plfa_plfa-part1-Negation-2422" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬_</a>
</pre><p>因此，<code>¬ A × ¬ B</code> 会解析为 <code>(¬ A) × (¬ B)</code>，而 <code>¬ m ≡ n</code> 会解析为 <code>¬ (m ≡ n)</code>。</p><p>在<strong>经典逻辑</strong>中，<code>A</code> 等价于 <code>¬ ¬ A</code>。而如前文所述，Agda 中使用了<strong>直觉逻辑</strong>， 因此我们只有该等价关系的一半，即 <code>A</code> 蕴涵 <code>¬ ¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro"></a><a id="plfa_plfa-part1-Negation-2889" href="../Negation/#plfa_plfa-part1-Negation-2889" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2898" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2900" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2902" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2903" href="../Negation/#plfa_plfa-part1-Negation-2903" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2905" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2907" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2910" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2914" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2916" href="../Negation/#plfa_plfa-part1-Negation-2903" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2922" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-2930" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2932" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2934" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2936" href="../Negation/#plfa_plfa-part1-Negation-2903" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2938" href="../Negation/#plfa_plfa-part1-Negation-2889" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2947" href="../Negation/#plfa_plfa-part1-Negation-2947" class="Bound">x</a>  <a id="plfa_plfa-part1-Negation-2950" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-2953" class="Symbol">λ{</a><a id="plfa_plfa-part1-Negation-2955" href="../Negation/#plfa_plfa-part1-Negation-2955" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2958" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2960" href="../Negation/#plfa_plfa-part1-Negation-2955" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2963" href="../Negation/#plfa_plfa-part1-Negation-2947" class="Bound">x</a><a id="plfa_plfa-part1-Negation-2964" class="Symbol">}</a>
</pre><p>令 <code>x</code> 为 <code>A</code> 的证据。我们要证明若假定 <code>¬ A</code> 成立，则会导出矛盾，因此 <code>¬ ¬ A</code> 必定成立。令 <code>¬x</code> 为 <code>¬ A</code> 的证据。那么以 <code>¬x x</code> 为证据，从 <code>A</code> 和 <code>¬ A</code> 可以导出矛盾。 这样我们就证明了 <code>¬ ¬ A</code>。</p><p>以上描述的等价写法如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro′"></a><a id="plfa_plfa-part1-Negation-3441" href="../Negation/#plfa_plfa-part1-Negation-3441" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3451" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3453" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3455" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3456" href="../Negation/#plfa_plfa-part1-Negation-3456" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3458" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3460" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3463" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3467" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3469" href="../Negation/#plfa_plfa-part1-Negation-3456" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3475" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-3483" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3485" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3487" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3489" href="../Negation/#plfa_plfa-part1-Negation-3456" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3491" href="../Negation/#plfa_plfa-part1-Negation-3441" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3501" href="../Negation/#plfa_plfa-part1-Negation-3501" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3503" href="../Negation/#plfa_plfa-part1-Negation-3503" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3506" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-3508" href="../Negation/#plfa_plfa-part1-Negation-3503" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3511" href="../Negation/#plfa_plfa-part1-Negation-3501" class="Bound">x</a>
</pre><p>在这里我们简单地将 λ-项的参数转换成了该函数的额外参数。 我们通常会使用后面这种形式，因为它更加紧凑。</p><p>我们无法证明 <code>¬ ¬ A</code> 蕴涵 <code>A</code>，但可以证明 <code>¬ ¬ ¬ A</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬¬-elim"></a><a id="plfa_plfa-part1-Negation-3904" href="../Negation/#plfa_plfa-part1-Negation-3904" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3913" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3915" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3917" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3918" href="../Negation/#plfa_plfa-part1-Negation-3918" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3920" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3922" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3925" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3929" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3931" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3933" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3935" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3937" href="../Negation/#plfa_plfa-part1-Negation-3918" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3943" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Negation-3953" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3955" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3957" href="../Negation/#plfa_plfa-part1-Negation-3918" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3959" href="../Negation/#plfa_plfa-part1-Negation-3904" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3968" href="../Negation/#plfa_plfa-part1-Negation-3968" class="Bound">¬¬¬x</a>  <a id="plfa_plfa-part1-Negation-3974" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-3977" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-3979" href="../Negation/#plfa_plfa-part1-Negation-3979" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3981" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3983" href="../Negation/#plfa_plfa-part1-Negation-3968" class="Bound">¬¬¬x</a> <a id="plfa_plfa-part1-Negation-3988" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3989" href="../Negation/#plfa_plfa-part1-Negation-2889" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-3998" href="../Negation/#plfa_plfa-part1-Negation-3979" class="Bound">x</a><a id="plfa_plfa-part1-Negation-3999" class="Symbol">)</a>
</pre><p>令 <code>¬¬¬x</code> 为 <code>¬ ¬ ¬ A</code> 的证据。我们要证明若假定 <code>A</code> 成立就会导出矛盾， 因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据前面的结果，以 <code>¬¬-intro x</code> 为证据可得出结论 <code>¬ ¬ A</code>。根据 <code>¬¬¬x (¬¬-intro x)</code>，我们可从 <code>¬ ¬ ¬ A</code> 和 <code>¬ ¬ A</code> 导出矛盾。这样我们就证明了 <code>¬ A</code>。</p><p>另一个逻辑规则是<strong>换质换位律（contraposition）</strong>，它陈述了若 <code>A</code> 蕴涵 <code>B</code>， 则 <code>¬ B</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-contraposition"></a><a id="plfa_plfa-part1-Negation-4744" href="../Negation/#plfa_plfa-part1-Negation-4744" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4759" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4761" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-4763" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-4764" href="../Negation/#plfa_plfa-part1-Negation-4764" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4766" href="../Negation/#plfa_plfa-part1-Negation-4766" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4768" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4770" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-4773" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-4777" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4779" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4780" href="../Negation/#plfa_plfa-part1-Negation-4764" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4782" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4784" href="../Negation/#plfa_plfa-part1-Negation-4766" class="Bound">B</a><a id="plfa_plfa-part1-Negation-4785" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Negation-4791" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Negation-4805" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4807" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4808" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4810" href="../Negation/#plfa_plfa-part1-Negation-4766" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4812" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4814" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4816" href="../Negation/#plfa_plfa-part1-Negation-4764" class="Bound">A</a><a id="plfa_plfa-part1-Negation-4817" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-4819" href="../Negation/#plfa_plfa-part1-Negation-4744" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4834" href="../Negation/#plfa_plfa-part1-Negation-4834" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4836" href="../Negation/#plfa_plfa-part1-Negation-4836" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4839" href="../Negation/#plfa_plfa-part1-Negation-4839" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-4841" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4843" href="../Negation/#plfa_plfa-part1-Negation-4836" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4846" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4847" href="../Negation/#plfa_plfa-part1-Negation-4834" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4849" href="../Negation/#plfa_plfa-part1-Negation-4839" class="Bound">x</a><a id="plfa_plfa-part1-Negation-4850" class="Symbol">)</a>
</pre><p>令 <code>f</code> 为 <code>A → B</code> 的证据，<code>¬y</code> 为 <code>¬ B</code> 的证据。我们要证明，若假定 <code>A</code> 成立就会导出矛盾，因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据 <code>f x</code>， 我们可从 <code>A → B</code> 和 <code>A</code> 我们可得出结论 <code>B</code>。而根据 <code>¬y (f x)</code>，可从 <code>B</code> 和 <code>¬ B</code> 得出结论 <code>⊥</code>。这样，我们就证明了 <code>¬ A</code>。</p><p>利用否定可直接定义不等性：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-_≢_"></a><a id="plfa_plfa-part1-Negation-5494" href="../Negation/#plfa_plfa-part1-Negation-5494" class="Function Operator">_≢_</a> <a id="plfa_plfa-part1-Negation-5498" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5500" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-5502" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-5503" href="../Negation/#plfa_plfa-part1-Negation-5503" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5505" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5507" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-5510" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-5512" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5514" href="../Negation/#plfa_plfa-part1-Negation-5503" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5516" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5518" href="../Negation/#plfa_plfa-part1-Negation-5503" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5520" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5522" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-5526" href="../Negation/#plfa_plfa-part1-Negation-5526" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5528" href="../Negation/#plfa_plfa-part1-Negation-5494" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5530" href="../Negation/#plfa_plfa-part1-Negation-5530" class="Bound">y</a>  <a id="plfa_plfa-part1-Negation-5533" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-5536" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-5538" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-5539" href="../Negation/#plfa_plfa-part1-Negation-5526" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5541" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-5543" href="../Negation/#plfa_plfa-part1-Negation-5530" class="Bound">y</a><a id="plfa_plfa-part1-Negation-5544" class="Symbol">)</a>
</pre><p>要证明不同的数不相等很简单：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-5639" href="../Negation/#plfa_plfa-part1-Negation-5639" class="Function">_</a> <a id="plfa_plfa-part1-Negation-5641" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5643" class="Number">1</a> <a id="plfa_plfa-part1-Negation-5645" href="../Negation/#plfa_plfa-part1-Negation-5494" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5647" class="Number">2</a>
<a id="plfa_plfa-part1-Negation-5649" class="Symbol">_</a> <a id="plfa_plfa-part1-Negation-5651" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-5653" class="Symbol">λ()</a>
</pre><p>这是我们第一次在 λ-表达式中使用谬模式（Absurd Pattern）。类型 <code>M ≡ N</code> 只有在 <code>M</code> 和 <code>N</code> 可被化简为相同的项时才能居留。由于 <code>1</code> 和 <code>2</code> 会化简为不同的正规形式，因此 Agda 判定没有证据可证明 <code>1 ≡ 2</code>。 第二个例子是，很容易验证皮亚诺公理中「零不是任何数的后继数」的假设：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-peano"></a><a id="plfa_plfa-part1-Negation-6226" href="../Negation/#plfa_plfa-part1-Negation-6226" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6232" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6234" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-6236" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-6237" href="../Negation/#plfa_plfa-part1-Negation-6237" class="Bound">m</a> <a id="plfa_plfa-part1-Negation-6239" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6241" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-6242" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-6244" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6246" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Negation-6251" href="../Negation/#plfa_plfa-part1-Negation-5494" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-6253" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Negation-6257" href="../Negation/#plfa_plfa-part1-Negation-6237" class="Bound">m</a>
<a id="plfa_plfa-part1-Negation-6259" href="../Negation/#plfa_plfa-part1-Negation-6226" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6265" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6267" class="Symbol">λ()</a>
</pre><p>它们的证明基本上相同，因为谬模式会匹配所有类型为 <code>zero ≡ suc m</code> 的可能的证据。</p><p>鉴于蕴涵和幂运算之间的对应关系，以及没有成员的类型为假， 我们可以将否定看作零的幂。它确实对应于我们所知的算术运算，即</p><pre><code>0 ^ n  ≡  1,  if n ≡ 0
       ≡  0,  if n ≢ 0</code></pre><p>确实，只有一个 <code>⊥ → ⊥</code> 的证明。我们可以用两种方式写出此证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id"></a><a id="plfa_plfa-part1-Negation-6933" href="../Negation/#plfa_plfa-part1-Negation-6933" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6936" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6938" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a> <a id="plfa_plfa-part1-Negation-6940" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6942" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a>
<a id="plfa_plfa-part1-Negation-6944" href="../Negation/#plfa_plfa-part1-Negation-6933" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6947" href="../Negation/#plfa_plfa-part1-Negation-6947" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-6949" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6951" href="../Negation/#plfa_plfa-part1-Negation-6947" class="Bound">x</a>

<a id="plfa_plfa-part1-Negation-id′"></a><a id="plfa_plfa-part1-Negation-6954" href="../Negation/#plfa_plfa-part1-Negation-6954" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6958" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6960" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a> <a id="plfa_plfa-part1-Negation-6962" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6964" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Empty.html#914" class="Function">⊥</a>
<a id="plfa_plfa-part1-Negation-6966" href="../Negation/#plfa_plfa-part1-Negation-6954" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6970" class="Symbol">()</a>
</pre><p>不过使用外延性，我们可以证明二者相等：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id≡id′"></a><a id="plfa_plfa-part1-Negation-7070" href="../Negation/#plfa_plfa-part1-Negation-7070" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7077" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7079" href="../Negation/#plfa_plfa-part1-Negation-6933" class="Function">id</a> <a id="plfa_plfa-part1-Negation-7082" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7084" href="../Negation/#plfa_plfa-part1-Negation-6954" class="Function">id′</a>
<a id="plfa_plfa-part1-Negation-7088" href="../Negation/#plfa_plfa-part1-Negation-7070" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7095" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7097" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7112" class="Symbol">(λ())</a>
</pre><p>根据外延性，对于任何在二者定义域中的 <code>x</code>，都有 <code>id x ≡ id′ x</code>， 则 <code>id ≡ id′</code> 成立。不过没有 <code>x</code> 在它们的定义域中，因此其相等性平凡成立。</p><p>实际上，我们可以证明任意两个否定的证明都是相等的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-assimilation"></a><a id="plfa_plfa-part1-Negation-7490" href="../Negation/#plfa_plfa-part1-Negation-7490" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7503" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7505" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-7507" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-7508" href="../Negation/#plfa_plfa-part1-Negation-7508" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-7510" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7512" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-7515" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-7517" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-7518" href="../Negation/#plfa_plfa-part1-Negation-7518" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7521" href="../Negation/#plfa_plfa-part1-Negation-7521" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7525" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7527" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-7529" href="../Negation/#plfa_plfa-part1-Negation-7508" class="Bound">A</a><a id="plfa_plfa-part1-Negation-7530" class="Symbol">)</a> <a id="plfa_plfa-part1-Negation-7532" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7534" href="../Negation/#plfa_plfa-part1-Negation-7518" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7537" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7539" href="../Negation/#plfa_plfa-part1-Negation-7521" class="Bound">¬x′</a>
<a id="plfa_plfa-part1-Negation-7543" href="../Negation/#plfa_plfa-part1-Negation-7490" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7556" href="../Negation/#plfa_plfa-part1-Negation-7556" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7559" href="../Negation/#plfa_plfa-part1-Negation-7559" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7563" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7565" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3537" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7580" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-7583" href="../Negation/#plfa_plfa-part1-Negation-7583" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-7585" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7587" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1270" class="Function">contradiction</a> <a id="plfa_plfa-part1-Negation-7601" href="../Negation/#plfa_plfa-part1-Negation-7583" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-7603" href="../Negation/#plfa_plfa-part1-Negation-7556" class="Bound">¬x</a><a id="plfa_plfa-part1-Negation-7605" class="Symbol">)</a>
</pre><p><code>¬ A</code> 的证据蕴涵任何 <code>A</code> 的证据都可直接得出矛盾。但由于外延性全称量化了使 <code>A</code> 成立的 <code>x</code>，因此任何这样的 <code>x</code> 都会直接导出矛盾，同样其相等性平凡成立。</p><h4 id="练习--irreflexive推荐">练习 <code>&lt;-irreflexive</code>（推荐）</h4><p>利用否定证明<a href="../Relations/#strict-inequality">严格不等性</a>满足非自反性， 即 <code>n &lt; n</code> 对于任何 <code>n</code> 都不成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8279" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-trichotomy实践">练习 <code>trichotomy</code>（实践）</h4><p>请证明严格不等性满足<a href="../Relations/#trichotomy">三分律</a>， 即对于任何自然数 <code>m</code> 和 <code>n</code>，以下三条刚好只有一条成立：</p><ul><li><code>m &lt; n</code></li><li><code>m ≡ n</code></li><li><code>m &gt; n</code></li></ul><p>「刚好只有一条」的意思是，三者中不仅有一条成立，而且当其中一条成立时， 其它二者的否定也必定成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8844" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--dual-推荐">练习 <code>⊎-dual-×</code>（推荐）</h4><p>请证明合取、析取和否定可通过以下版本的德摩根定律（De Morgan’s Law）关联在一起。</p><pre><code>¬ (A ⊎ B) ≃ (¬ A) × (¬ B)</code></pre><p>此结果是我们之前证明的定理的简单推论。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-9232" class="Comment">-- 请将代码写在此处</a>
</pre><p>以下命题也成立吗？</p><pre><code>¬ (A × B) ≃ (¬ A) ⊎ (¬ B)</code></pre><p>若成立，请证明；若不成立，你能给出一个比同构更弱的关系将两边关联起来吗？</p><h2 id="直觉逻辑与经典逻辑">直觉逻辑与经典逻辑</h2><p>在 Gilbert 和 Sullivan 的电影《船夫》（<em>The Gondoliers</em>）中， Casilda 被告知她还是个婴儿时，就被许配给了巴塔维亚国王的继承人。 但由于一场动乱，没人知道她被许配给了两位继承人 Marco 和 Giuseppe 中的哪一位。她惊慌地哀嚎道：「那么你的意思是说我嫁给了两位船夫中的一位， 但却无法确定是谁？」对此的回答是：「虽然不知道是谁，但这件事却是毫无疑问的。」</p><p>逻辑学有很多变种，而<strong>经典逻辑</strong>和<strong>直觉逻辑</strong>之间有一个区别。 直觉主义者关注于某些逻辑学家对无限性本质的假设，坚持真理的构造主义的概念。 具体来说，它们坚持认为 <code>A ⊎ B</code> 的证明必须确定 <code>A</code> 或 <code>B</code> 中的<strong>哪一个</strong>成立， 因此它们会解决宣称 Casilda 嫁给了 Marco 或者 Giuseppe，直到其中一个被确定为 她的丈夫为止。或许 Gilbert 和 Sullivan 期待直觉主义，因为在故事的结局中， 继承人是第三个人 Luiz，他和 Casilda 已经顺利地相爱了。</p><p>直觉主义者也拒绝排中律（Law of the Excluded Middle）————该定律断言，对于所有的 <code>A</code>，<code>A ⊎ ¬ A</code> 必定成立————因为该定律没有给出 <code>A</code> 和 <code>¬ A</code> 中的哪一个成立。 海廷（Heyting）形式化了希尔伯特（Hilbert）经典逻辑的一个变种，抓住了直觉主义中可证明性的概念。 具体来说，排中律在希尔伯特逻辑中是可证明的，但在海廷逻辑中却不可证明。 进一步来说，如果排中律作为一条公理添加到海廷逻辑中，那么它会等价于希尔伯特逻辑。 柯尔莫哥洛夫（Kolmogorov）证明了两种逻辑紧密相关：他给出了双重否定翻译，即一个式子在经典逻辑中 可证，当且仅当它的双重否定式在直觉逻辑中可证。</p><p>「命题即类型」最初是为直觉逻辑而制定的。这是一种完美的契合，因为在直觉主义的 解释中，式子 <code>A ⊎ B</code> 刚好可以在给出 <code>A</code> 或 <code>B</code> 之一的证明时得证，因此对应于析取 的类型是一个不交和（Disjoint Sum）。</p><p>（以上内容部分取自 “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>，2015 年 12 月。）</p><h2 id="排中律是不可辩驳的">排中律是不可辩驳的</h2><p>排中律可形式化如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-12930" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Negation-em"></a><a id="plfa_plfa-part1-Negation-12942" href="../Negation/#plfa_plfa-part1-Negation-12942" class="Postulate">em</a> <a id="plfa_plfa-part1-Negation-12945" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12947" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-12949" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-12950" href="../Negation/#plfa_plfa-part1-Negation-12950" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12952" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12954" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-12957" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-12959" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-12961" href="../Negation/#plfa_plfa-part1-Negation-12950" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12963" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-12965" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-12967" href="../Negation/#plfa_plfa-part1-Negation-12950" class="Bound">A</a>
</pre><p>如之前所言，排中律在直觉逻辑中并不成立。然而，我们可以证明它是 <strong>不可辩驳（Irrefutable）</strong>的，即其否定的否定是可证明的（因而其否定式不可证明）：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-em-irrefutable"></a><a id="plfa_plfa-part1-Negation-13308" href="../Negation/#plfa_plfa-part1-Negation-13308" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13323" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13325" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-13327" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-13328" href="../Negation/#plfa_plfa-part1-Negation-13328" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13330" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13332" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-13335" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-13337" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13339" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13341" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13343" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13344" href="../Negation/#plfa_plfa-part1-Negation-13328" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13346" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-13348" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13350" href="../Negation/#plfa_plfa-part1-Negation-13328" class="Bound">A</a><a id="plfa_plfa-part1-Negation-13351" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-13353" href="../Negation/#plfa_plfa-part1-Negation-13308" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13368" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-13370" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-13372" href="../Negation/#plfa_plfa-part1-Negation-13372" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13374" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13376" href="../Negation/#plfa_plfa-part1-Negation-13372" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13378" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13379" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Negation-13384" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-13387" href="../Negation/#plfa_plfa-part1-Negation-13387" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-13389" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13391" href="../Negation/#plfa_plfa-part1-Negation-13372" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13393" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13394" href="https://agda.github.io/agda-stdlib/v2.2-dev/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Negation-13399" href="../Negation/#plfa_plfa-part1-Negation-13387" class="Bound">x</a><a id="plfa_plfa-part1-Negation-13400" class="Symbol">)))</a>
</pre><p>解释此代码的最佳方式是交互式地推导它：</p><pre><code>em-irrefutable k = ?</code></pre><p>给定 <code>¬ (A ⊎ ¬ A)</code> 的证据 <code>k</code>，即一个函数，它接受一个类型为 <code>A ⊎ ¬ A</code> 的值， 返回一个空类型的值，我们必须在 <code>?</code> 处填上一个返回空类型的项。得到空类型值 的唯一方式就是应用 <code>k</code> 本身，于是我们据此展开此洞：</p><pre><code>em-irrefutable k = k ?</code></pre><p>我们需要用类型为 <code>A ⊎ ¬ A</code> 的值填上这个新的洞。由于目前我们并没有类型为 <code>A</code> 的值， 因此先处理第二个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → ? })</code></pre><p>第二个析取接受 <code>¬ A</code> 的证据，即一个函数，它接受类型为 <code>A</code> 的值，返回空类型的值。 我们将 <code>x</code> 绑定到类型为 <code>A</code> 的值，现在我们需要在洞中填入空类型的值。同样， 得到空类型的值的唯一方法就是将 <code>k</code> 应用到其自身，于是我们展开此洞：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k ? })</code></pre><p>这次我们就有一个类型为 <code>A</code> 的值了，其名为 <code>x</code>，于是我们可以处理第一个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k (inj₁ x) })</code></pre><p>现在没有洞了！这样就完成了证明。</p><p>下面的故事说明了我们创建的项的行为。 （向 Peter Selinger 道歉，他讲的是个关于国王，巫师和贤者之石的类似的故事。）</p><p>曾经有一个恶魔向一个男人提议：「要么 (a) 我给你 10 亿美元，要么 (b) 如果你付给我 10 亿美元，我可以实现你的任何一个愿望。当然，得是我决定提供 (a) 还是 (b)。」</p><p>男人很谨慎。他需要付出他的灵魂吗？ 恶魔说不用，他只要接受这个提议就行。</p><p>于是男人思索着，如果恶魔向他提供 (b)，那么他不太可能付得起这个愿望。 不过倘若真是如此的话，能有什么坏处吗？</p><p>「我接受」，男人回答道，「我能得到 (a) 还是 (b)？」</p><p>恶魔顿了顿。「我提供 (b)。」</p><p>男人很失望，但并不惊讶。「果然是这样」，他想。 但是这个提议折磨着他。想想他都能用这个愿望做些什么！ 多年以后，男人开始积累钱财。为了得到这笔钱，他有时会做坏事， 而且他隐约意识到这一定是魔鬼所想到的。最后他攒够了 10 亿美元，恶魔再次出现了。</p><p>「这是 10 亿美元」，男人说着，交出一个手提箱。「实现我的愿望吧！」</p><p>恶魔接过了手提箱。然后他说道，「哦？我之前说的是 (b) 吗？抱歉，我说的是 (a)。 很高兴能给你 10 亿美元。」</p><p>于是恶魔将那个手提箱又还给了他。</p><p>（以上内容部分取自 “Call-by-Value is Dual to Call-by-Name”, Philip Wadler, <em>International Conference on Functional Programming</em>, 2003 年。）</p><h4 id="练习-classical延伸">练习 <code>Classical</code>（延伸）</h4><p>考虑以下定律：</p><ul><li>排中律：对于所有 <code>A</code>，<code>A ⊎ ¬ A</code>。</li><li>双重否定消去：对于所有的 <code>A</code>，<code>¬ ¬ A → A</code>。</li><li>皮尔士定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>((A → B) → A) → A</code>。</li><li>蕴涵表示为析取：对于所有的 <code>A</code> 和 <code>B</code>，<code>(A → B) → ¬ A ⊎ B</code>。</li><li>德摩根定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>¬ (¬ A × ¬ B) → A ⊎ B</code>。</li></ul><p>请证明其中任意一条定律都蕴涵其它所有定律。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18310" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="联系-stable延伸">联系 <code>Stable</code>（延伸）</h4><p>若双重否定消去对某个式子成立，我们就说它是<strong>稳定（Stable）</strong>的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-Stable"></a><a id="plfa_plfa-part1-Negation-18526" href="../Negation/#plfa_plfa-part1-Negation-18526" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18533" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-18535" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-18539" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18541" href="https://agda.github.io/agda-stdlib/v2.2-dev/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-18545" href="../Negation/#plfa_plfa-part1-Negation-18526" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18552" href="../Negation/#plfa_plfa-part1-Negation-18552" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18554" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-18556" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18558" href="../Negation/#plfa_plfa-part1-Negation-916" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18560" href="../Negation/#plfa_plfa-part1-Negation-18552" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18562" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18564" href="../Negation/#plfa_plfa-part1-Negation-18552" class="Bound">A</a>
</pre><p>请证明任何否定式都是稳定的，并且两个稳定式的合取也是稳定的。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18723" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>本章中的类似定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18898" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18905" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Negation-18922" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18928" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18929" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Negation-18931" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-18933" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18940" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Negation-18966" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18972" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18973" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1270" class="Function">contradiction</a><a id="plfa_plfa-part1-Negation-18986" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-18988" href="https://agda.github.io/agda-stdlib/v2.2-dev/Relation.Nullary.Negation.Core.html#1493" class="Function">contraposition</a><a id="plfa_plfa-part1-Negation-19002" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章使用了以下 Unicode：</p><pre><code>¬  U+00AC  否定符号 (\neg)
≢  U+2262  不等价于 (\==n)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Oling Cat<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>