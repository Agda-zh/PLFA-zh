<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Negation</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Negation: 直觉逻辑与命题逻辑中的否定</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Negation-107" class="Keyword">module</a> <a id="plfa_plfa-part1-Negation-114" href="../Negation/#" class="Module">plfa.part1.Negation</a> <a id="plfa_plfa-part1-Negation-134" class="Keyword">where</a>
</pre><p>本章介绍了否定的性质，讨论了直觉逻辑和经典逻辑。</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Negation-285" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-290" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-297" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Negation-335" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-341" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-342" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Negation-345" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-347" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Negation-351" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-353" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-358" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-365" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Negation-374" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-380" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-381" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-382" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-384" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Negation-388" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Negation-393" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-395" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-400" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-407" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Negation-418" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-424" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-425" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Negation-426" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-428" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Negation-434" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-436" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-441" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-448" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Negation-457" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-463" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-464" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Negation-467" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-469" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Negation-473" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-475" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Negation-479" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-481" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-486" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-493" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Negation-506" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-512" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-513" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Negation-516" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-518" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-523" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-530" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Negation-553" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-559" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-560" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-5560" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Negation-563" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-565" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Negation-579" class="Symbol">)</a>
</pre><h2 id="否定">否定</h2><p>给定命题 <code>A</code>，当 <code>A</code> 不成立时，它的否定形式 <code>¬ A</code> 成立。 我们将否定阐述为「蕴涵假」来形式化此概念。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬_"></a><a id="plfa_plfa-part1-Negation-849" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬_</a> <a id="plfa_plfa-part1-Negation-852" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-854" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-858" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-860" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-864" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-866" href="../Negation/#plfa_plfa-part1-Negation-866" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-868" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-870" href="../Negation/#plfa_plfa-part1-Negation-866" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-872" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-874" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>这是<strong>归谬法（Reductio ad Absurdum）</strong>的一种形式：若从 <code>A</code> 可得出结论 <code>⊥</code>（即谬误）， 则 <code>¬ A</code> 必定成立。</p><p><code>¬ A</code> 成立的证据的形式为：</p><pre><code>λ{ x → N }</code></pre><p>其中 <code>N</code> 是类型为 <code>⊥</code> 的项，它包含类型为 <code>A</code> 的自由变量 <code>x</code>。换言之，<code>¬ A</code> 成立 的证据是一个函数，该函数将 <code>A</code> 成立的证据转换为 <code>⊥</code> 成立的证据。</p><p>给定 <code>¬ A</code> 和 <code>A</code> 均成立的证据，我们可以得出 <code>⊥</code> 成立。换言之，若 <code>¬ A</code> 和 <code>A</code> 均成立， 那么我们就得到了矛盾：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬-elim"></a><a id="plfa_plfa-part1-Negation-1724" href="../Negation/#plfa_plfa-part1-Negation-1724" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1731" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1733" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-1735" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-1736" href="../Negation/#plfa_plfa-part1-Negation-1736" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-1738" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1740" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-1743" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-1747" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1749" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-1751" href="../Negation/#plfa_plfa-part1-Negation-1736" class="Bound">A</a>
  <a id="plfa_plfa-part1-Negation-1755" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1757" href="../Negation/#plfa_plfa-part1-Negation-1736" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-1763" class="Comment">---</a>
  <a id="plfa_plfa-part1-Negation-1769" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1771" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-1773" href="../Negation/#plfa_plfa-part1-Negation-1724" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1780" href="../Negation/#plfa_plfa-part1-Negation-1780" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1783" href="../Negation/#plfa_plfa-part1-Negation-1783" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-1785" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-1787" href="../Negation/#plfa_plfa-part1-Negation-1780" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1790" href="../Negation/#plfa_plfa-part1-Negation-1783" class="Bound">x</a>
</pre><p>在这里，我们将 <code>¬ A</code> 的证据写作 <code>¬x</code>，将 <code>A</code> 的证据写作 <code>x</code>。这表示 <code>¬x</code> 必须是类型为 <code>A → ⊥</code> 的函数，因此应用 <code>¬x x</code> 得到的类型必为 <code>⊥</code>。注意此规则只是 <code>→-elim</code> 的一个特例。</p><p>我们将否定的优先级设定为高于析取和合取，但低于其它运算：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-2347" class="Keyword">infix</a> <a id="plfa_plfa-part1-Negation-2353" class="Number">3</a> <a id="plfa_plfa-part1-Negation-2355" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬_</a>
</pre><p>因此，<code>¬ A × ¬ B</code> 会解析为 <code>(¬ A) × (¬ B)</code>，而 <code>¬ m ≡ n</code> 会解析为 <code>¬ (m ≡ n)</code>。</p><p>在<strong>经典逻辑</strong>中，<code>A</code> 等价于 <code>¬ ¬ A</code>。而如前文所述，Agda 中使用了<strong>直觉逻辑</strong>， 因此我们只有该等价关系的一半，即 <code>A</code> 蕴涵 <code>¬ ¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro"></a><a id="plfa_plfa-part1-Negation-2822" href="../Negation/#plfa_plfa-part1-Negation-2822" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2831" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2833" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2835" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2836" href="../Negation/#plfa_plfa-part1-Negation-2836" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2838" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2840" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2843" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2847" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2849" href="../Negation/#plfa_plfa-part1-Negation-2836" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2855" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-2863" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2865" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2867" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2869" href="../Negation/#plfa_plfa-part1-Negation-2836" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2871" href="../Negation/#plfa_plfa-part1-Negation-2822" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2880" href="../Negation/#plfa_plfa-part1-Negation-2880" class="Bound">x</a>  <a id="plfa_plfa-part1-Negation-2883" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-2886" class="Symbol">λ{</a><a id="plfa_plfa-part1-Negation-2888" href="../Negation/#plfa_plfa-part1-Negation-2888" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2891" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2893" href="../Negation/#plfa_plfa-part1-Negation-2888" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2896" href="../Negation/#plfa_plfa-part1-Negation-2880" class="Bound">x</a><a id="plfa_plfa-part1-Negation-2897" class="Symbol">}</a>
</pre><p>令 <code>x</code> 为 <code>A</code> 的证据。我们要证明若假定 <code>¬ A</code> 成立，则会导出矛盾，因此 <code>¬ ¬ A</code> 必定成立。令 <code>¬x</code> 为 <code>¬ A</code> 的证据。那么以 <code>¬x x</code> 为证据，从 <code>A</code> 和 <code>¬ A</code> 可以导出矛盾。 这样我们就证明了 <code>¬ ¬ A</code>。</p><p>以上描述的等价写法如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro′"></a><a id="plfa_plfa-part1-Negation-3374" href="../Negation/#plfa_plfa-part1-Negation-3374" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3384" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3386" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3388" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3389" href="../Negation/#plfa_plfa-part1-Negation-3389" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3391" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3393" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3396" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3400" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3402" href="../Negation/#plfa_plfa-part1-Negation-3389" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3408" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-3416" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3418" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3420" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3422" href="../Negation/#plfa_plfa-part1-Negation-3389" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3424" href="../Negation/#plfa_plfa-part1-Negation-3374" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-3434" href="../Negation/#plfa_plfa-part1-Negation-3434" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3436" href="../Negation/#plfa_plfa-part1-Negation-3436" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3439" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-3441" href="../Negation/#plfa_plfa-part1-Negation-3436" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-3444" href="../Negation/#plfa_plfa-part1-Negation-3434" class="Bound">x</a>
</pre><p>在这里我们简单地将 λ-项的参数转换成了该函数的额外参数。 我们通常会使用后面这种形式，因为它更加紧凑。</p><p>我们无法证明 <code>¬ ¬ A</code> 蕴涵 <code>A</code>，但可以证明 <code>¬ ¬ ¬ A</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬¬-elim"></a><a id="plfa_plfa-part1-Negation-3837" href="../Negation/#plfa_plfa-part1-Negation-3837" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3846" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3848" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3850" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3851" href="../Negation/#plfa_plfa-part1-Negation-3851" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3853" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3855" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3858" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3862" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3864" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3866" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3868" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3870" href="../Negation/#plfa_plfa-part1-Negation-3851" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-3876" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Negation-3886" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3888" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3890" href="../Negation/#plfa_plfa-part1-Negation-3851" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-3892" href="../Negation/#plfa_plfa-part1-Negation-3837" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-3901" href="../Negation/#plfa_plfa-part1-Negation-3901" class="Bound">¬¬¬x</a>  <a id="plfa_plfa-part1-Negation-3907" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-3910" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-3912" href="../Negation/#plfa_plfa-part1-Negation-3912" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3914" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3916" href="../Negation/#plfa_plfa-part1-Negation-3901" class="Bound">¬¬¬x</a> <a id="plfa_plfa-part1-Negation-3921" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3922" href="../Negation/#plfa_plfa-part1-Negation-2822" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-3931" href="../Negation/#plfa_plfa-part1-Negation-3912" class="Bound">x</a><a id="plfa_plfa-part1-Negation-3932" class="Symbol">)</a>
</pre><p>令 <code>¬¬¬x</code> 为 <code>¬ ¬ ¬ A</code> 的证据。我们要证明若假定 <code>A</code> 成立就会导出矛盾， 因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据前面的结果，以 <code>¬¬-intro x</code> 为证据可得出结论 <code>¬ ¬ A</code>。根据 <code>¬¬¬x (¬¬-intro x)</code>，我们可从 <code>¬ ¬ ¬ A</code> 和 <code>¬ ¬ A</code> 导出矛盾。这样我们就证明了 <code>¬ A</code>。</p><p>另一个逻辑规则是<strong>换质换位律（contraposition）</strong>，它陈述了若 <code>A</code> 蕴涵 <code>B</code>， 则 <code>¬ B</code> 蕴涵 <code>¬ A</code>：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-contraposition"></a><a id="plfa_plfa-part1-Negation-4677" href="../Negation/#plfa_plfa-part1-Negation-4677" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4692" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4694" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-4696" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-4697" href="../Negation/#plfa_plfa-part1-Negation-4697" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4699" href="../Negation/#plfa_plfa-part1-Negation-4699" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4701" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4703" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-4706" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-4710" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4712" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4713" href="../Negation/#plfa_plfa-part1-Negation-4697" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-4715" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4717" href="../Negation/#plfa_plfa-part1-Negation-4699" class="Bound">B</a><a id="plfa_plfa-part1-Negation-4718" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Negation-4724" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Negation-4738" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4740" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4741" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4743" href="../Negation/#plfa_plfa-part1-Negation-4699" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-4745" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4747" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-4749" href="../Negation/#plfa_plfa-part1-Negation-4697" class="Bound">A</a><a id="plfa_plfa-part1-Negation-4750" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-4752" href="../Negation/#plfa_plfa-part1-Negation-4677" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-4767" href="../Negation/#plfa_plfa-part1-Negation-4767" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4769" href="../Negation/#plfa_plfa-part1-Negation-4769" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4772" href="../Negation/#plfa_plfa-part1-Negation-4772" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-4774" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4776" href="../Negation/#plfa_plfa-part1-Negation-4769" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-4779" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-4780" href="../Negation/#plfa_plfa-part1-Negation-4767" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-4782" href="../Negation/#plfa_plfa-part1-Negation-4772" class="Bound">x</a><a id="plfa_plfa-part1-Negation-4783" class="Symbol">)</a>
</pre><p>令 <code>f</code> 为 <code>A → B</code> 的证据，<code>¬y</code> 为 <code>¬ B</code> 的证据。我们要证明，若假定 <code>A</code> 成立就会导出矛盾，因此 <code>¬ A</code> 必定成立。令 <code>x</code> 为 <code>A</code> 的证据。根据 <code>f x</code>， 我们可从 <code>A → B</code> 和 <code>A</code> 我们可得出结论 <code>B</code>。而根据 <code>¬y (f x)</code>，可从 <code>B</code> 和 <code>¬ B</code> 得出结论 <code>⊥</code>。这样，我们就证明了 <code>¬ A</code>。</p><p>利用否定可直接定义不等性：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-_≢_"></a><a id="plfa_plfa-part1-Negation-5427" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Function Operator">_≢_</a> <a id="plfa_plfa-part1-Negation-5431" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5433" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-5435" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-5436" href="../Negation/#plfa_plfa-part1-Negation-5436" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5438" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5440" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-5443" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-5445" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5447" href="../Negation/#plfa_plfa-part1-Negation-5436" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5449" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5451" href="../Negation/#plfa_plfa-part1-Negation-5436" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5453" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5455" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-5459" href="../Negation/#plfa_plfa-part1-Negation-5459" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5461" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5463" href="../Negation/#plfa_plfa-part1-Negation-5463" class="Bound">y</a>  <a id="plfa_plfa-part1-Negation-5466" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-5469" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-5471" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-5472" href="../Negation/#plfa_plfa-part1-Negation-5459" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5474" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-5476" href="../Negation/#plfa_plfa-part1-Negation-5463" class="Bound">y</a><a id="plfa_plfa-part1-Negation-5477" class="Symbol">)</a>
</pre><p>要证明不同的数不相等很简单：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-5572" href="../Negation/#plfa_plfa-part1-Negation-5572" class="Function">_</a> <a id="plfa_plfa-part1-Negation-5574" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5576" class="Number">1</a> <a id="plfa_plfa-part1-Negation-5578" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-5580" class="Number">2</a>
<a id="plfa_plfa-part1-Negation-5582" class="Symbol">_</a> <a id="plfa_plfa-part1-Negation-5584" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-5586" class="Symbol">λ()</a>
</pre><p>这是我们第一次在 λ-表达式中使用谬模式（Absurd Pattern）。类型 <code>M ≡ N</code> 只有在 <code>M</code> 和 <code>N</code> 可被化简为相同的项时才能居留。由于 <code>1</code> 和 <code>2</code> 会化简为不同的正规形式，因此 Agda 判定没有证据可证明 <code>1 ≡ 2</code>。 第二个例子是，很容易验证皮亚诺公理中「零不是任何数的后继数」的假设：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-peano"></a><a id="plfa_plfa-part1-Negation-6159" href="../Negation/#plfa_plfa-part1-Negation-6159" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6165" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6167" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-6169" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-6170" href="../Negation/#plfa_plfa-part1-Negation-6170" class="Bound">m</a> <a id="plfa_plfa-part1-Negation-6172" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6174" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-6175" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-6177" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6179" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Negation-6184" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-6186" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Negation-6190" href="../Negation/#plfa_plfa-part1-Negation-6170" class="Bound">m</a>
<a id="plfa_plfa-part1-Negation-6192" href="../Negation/#plfa_plfa-part1-Negation-6159" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-6198" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6200" class="Symbol">λ()</a>
</pre><p>它们的证明基本上相同，因为谬模式会匹配所有类型为 <code>zero ≡ suc m</code> 的可能的证据。</p><p>鉴于蕴涵和幂运算之间的对应关系，以及没有成员的类型为假， 我们可以将否定看作零的幂。它确实对应于我们所知的算术运算，即</p><pre><code>0 ^ n  ≡  1,  if n ≡ 0
       ≡  0,  if n ≢ 0</code></pre><p>确实，只有一个 <code>⊥ → ⊥</code> 的证明。我们可以用两种方式写出此证明：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id"></a><a id="plfa_plfa-part1-Negation-6866" href="../Negation/#plfa_plfa-part1-Negation-6866" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6869" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6871" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-6873" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6875" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-6877" href="../Negation/#plfa_plfa-part1-Negation-6866" class="Function">id</a> <a id="plfa_plfa-part1-Negation-6880" href="../Negation/#plfa_plfa-part1-Negation-6880" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-6882" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-6884" href="../Negation/#plfa_plfa-part1-Negation-6880" class="Bound">x</a>

<a id="plfa_plfa-part1-Negation-id′"></a><a id="plfa_plfa-part1-Negation-6887" href="../Negation/#plfa_plfa-part1-Negation-6887" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6891" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-6893" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-6895" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-6897" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-6899" href="../Negation/#plfa_plfa-part1-Negation-6887" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-6903" class="Symbol">()</a>
</pre><p>不过使用外延性，我们可以证明二者相等：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-id≡id′"></a><a id="plfa_plfa-part1-Negation-7003" href="../Negation/#plfa_plfa-part1-Negation-7003" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7010" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7012" href="../Negation/#plfa_plfa-part1-Negation-6866" class="Function">id</a> <a id="plfa_plfa-part1-Negation-7015" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7017" href="../Negation/#plfa_plfa-part1-Negation-6887" class="Function">id′</a>
<a id="plfa_plfa-part1-Negation-7021" href="../Negation/#plfa_plfa-part1-Negation-7003" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-7028" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7030" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7045" class="Symbol">(λ())</a>
</pre><p>根据外延性，对于任何在二者定义域中的 <code>x</code>，都有 <code>id x ≡ id′ x</code>， 则 <code>id ≡ id′</code> 成立。不过没有 <code>x</code> 在它们的定义域中，因此其相等性平凡成立。</p><p>实际上，我们可以证明任意两个否定的证明都是相等的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-assimilation"></a><a id="plfa_plfa-part1-Negation-7423" href="../Negation/#plfa_plfa-part1-Negation-7423" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7436" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7438" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-7440" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-7441" href="../Negation/#plfa_plfa-part1-Negation-7441" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-7443" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7445" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-7448" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-7450" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-7451" href="../Negation/#plfa_plfa-part1-Negation-7451" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7454" href="../Negation/#plfa_plfa-part1-Negation-7454" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7458" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-7460" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-7462" href="../Negation/#plfa_plfa-part1-Negation-7441" class="Bound">A</a><a id="plfa_plfa-part1-Negation-7463" class="Symbol">)</a> <a id="plfa_plfa-part1-Negation-7465" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7467" href="../Negation/#plfa_plfa-part1-Negation-7451" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7470" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-7472" href="../Negation/#plfa_plfa-part1-Negation-7454" class="Bound">¬x′</a>
<a id="plfa_plfa-part1-Negation-7476" href="../Negation/#plfa_plfa-part1-Negation-7423" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-7489" href="../Negation/#plfa_plfa-part1-Negation-7489" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7492" href="../Negation/#plfa_plfa-part1-Negation-7492" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-7496" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-7498" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3532" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-7513" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-7516" href="../Negation/#plfa_plfa-part1-Negation-7516" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-7518" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-7520" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Negation-7527" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-7528" href="../Negation/#plfa_plfa-part1-Negation-7489" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-7531" href="../Negation/#plfa_plfa-part1-Negation-7516" class="Bound">x</a><a id="plfa_plfa-part1-Negation-7532" class="Symbol">))</a>
</pre><p><code>¬ A</code> 的证据蕴涵任何 <code>A</code> 的证据都可直接得出矛盾。但由于外延性全称量化了使 <code>A</code> 成立的 <code>x</code>，因此任何这样的 <code>x</code> 都会直接导出矛盾，同样其相等性平凡成立。</p><h4 id="练习--irreflexive推荐">练习 <code>&lt;-irreflexive</code>（推荐）</h4><p>利用否定证明<a href="../Relations/#strict-inequality">严格不等性</a>满足非自反性， 即 <code>n &lt; n</code> 对于任何 <code>n</code> 都不成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8207" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习-trichotomy实践">练习 <code>trichotomy</code>（实践）</h4><p>请证明严格不等性满足<a href="../Relations/#trichotomy">三分律</a>， 即对于任何自然数 <code>m</code> 和 <code>n</code>，以下三条刚好只有一条成立：</p><ul><li><code>m &lt; n</code></li><li><code>m ≡ n</code></li><li><code>m &gt; n</code></li></ul><p>「刚好只有一条」的意思是，三者中不仅有一条成立，而且当其中一条成立时， 其它二者的否定也必定成立。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-8772" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="练习--dual-推荐">练习 <code>⊎-dual-×</code>（推荐）</h4><p>请证明合取、析取和否定可通过以下版本的德摩根定律（De Morgan’s Law）关联在一起。</p><pre><code>¬ (A ⊎ B) ≃ (¬ A) × (¬ B)</code></pre><p>此结果是我们之前证明的定理的简单推论。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-9160" class="Comment">-- 请将代码写在此处</a>
</pre><p>以下命题也成立吗？</p><pre><code>¬ (A × B) ≃ (¬ A) ⊎ (¬ B)</code></pre><p>若成立，请证明；若不成立，你能给出一个比同构更弱的关系将两边关联起来吗？</p><h2 id="直觉逻辑与经典逻辑">直觉逻辑与经典逻辑</h2><p>在 Gilbert 和 Sullivan 的电影《船夫》（<em>The Gondoliers</em>）中， Casilda 被告知她还是个婴儿时，就被许配给了巴塔维亚国王的继承人。 但由于一场动乱，没人知道她被许配给了两位继承人 Marco 和 Giuseppe 中的哪一位。她惊慌地哀嚎道：「那么你的意思是说我嫁给了两位船夫中的一位， 但却无法确定是谁？」对此的回答是：「虽然不知道是谁，但这件事却是毫无疑问的。」</p><p>逻辑学有很多变种，而<strong>经典逻辑</strong>和<strong>直觉逻辑</strong>之间有一个区别。 直觉主义者关注于某些逻辑学家对无限性本质的假设，坚持真理的构造主义的概念。 具体来说，它们坚持认为 <code>A ⊎ B</code> 的证明必须确定 <code>A</code> 或 <code>B</code> 中的<strong>哪一个</strong>成立， 因此它们会解决宣称 Casilda 嫁给了 Marco 或者 Giuseppe，直到其中一个被确定为 她的丈夫为止。或许 Gilbert 和 Sullivan 期待直觉主义，因为在故事的结局中， 继承人是第三个人 Luiz，他和 Casilda 已经顺利地相爱了。</p><p>直觉主义者也拒绝排中律（Law of the Excluded Middle）————该定律断言，对于所有的 <code>A</code>，<code>A ⊎ ¬ A</code> 必定成立————因为该定律没有给出 <code>A</code> 和 <code>¬ A</code> 中的哪一个成立。 海廷（Heyting）形式化了希尔伯特（Hilbert）经典逻辑的一个变种，抓住了直觉主义中可证明性的概念。 具体来说，排中律在希尔伯特逻辑中是可证明的，但在海廷逻辑中却不可证明。 进一步来说，如果排中律作为一条公理添加到海廷逻辑中，那么它会等价于希尔伯特逻辑。 柯尔莫哥洛夫（Kolmogorov）证明了两种逻辑紧密相关：他给出了双重否定翻译，即一个式子在经典逻辑中 可证，当且仅当它的双重否定式在直觉逻辑中可证。</p><p>「命题即类型」最初是为直觉逻辑而制定的。这是一种完美的契合，因为在直觉主义的 解释中，式子 <code>A ⊎ B</code> 刚好可以在给出 <code>A</code> 或 <code>B</code> 之一的证明时得证，因此对应于析取 的类型是一个不交和（Disjoint Sum）。</p><p>（以上内容部分取自 “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>，2015 年 12 月。）</p><h2 id="排中律是不可辩驳的">排中律是不可辩驳的</h2><p>排中律可形式化如下：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-12858" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Negation-em"></a><a id="plfa_plfa-part1-Negation-12870" href="../Negation/#plfa_plfa-part1-Negation-12870" class="Postulate">em</a> <a id="plfa_plfa-part1-Negation-12873" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12875" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-12877" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-12878" href="../Negation/#plfa_plfa-part1-Negation-12878" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12880" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-12882" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-12885" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-12887" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-12889" href="../Negation/#plfa_plfa-part1-Negation-12878" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-12891" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-12893" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-12895" href="../Negation/#plfa_plfa-part1-Negation-12878" class="Bound">A</a>
</pre><p>如之前所言，排中律在直觉逻辑中并不成立。然而，我们可以证明它是 <strong>不可辩驳（Irrefutable）</strong>的，即其否定的否定是可证明的（因而其否定式不可证明）：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-em-irrefutable"></a><a id="plfa_plfa-part1-Negation-13236" href="../Negation/#plfa_plfa-part1-Negation-13236" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13251" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13253" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-13255" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-13256" href="../Negation/#plfa_plfa-part1-Negation-13256" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13258" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13260" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-13263" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-13265" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13267" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13269" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13271" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13272" href="../Negation/#plfa_plfa-part1-Negation-13256" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13274" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-13276" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13278" href="../Negation/#plfa_plfa-part1-Negation-13256" class="Bound">A</a><a id="plfa_plfa-part1-Negation-13279" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-13281" href="../Negation/#plfa_plfa-part1-Negation-13236" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-13296" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-13298" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-13300" href="../Negation/#plfa_plfa-part1-Negation-13300" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13302" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13304" href="../Negation/#plfa_plfa-part1-Negation-13300" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13306" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13307" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Negation-13312" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-13315" href="../Negation/#plfa_plfa-part1-Negation-13315" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-13317" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13319" href="../Negation/#plfa_plfa-part1-Negation-13300" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-13321" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13322" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Negation-13327" href="../Negation/#plfa_plfa-part1-Negation-13315" class="Bound">x</a><a id="plfa_plfa-part1-Negation-13328" class="Symbol">)))</a>
</pre><p>解释此代码的最佳方式是交互式地推导它：</p><pre><code>em-irrefutable k = ?</code></pre><p>给定 <code>¬ (A ⊎ ¬ A)</code> 的证据 <code>k</code>，即一个函数，它接受一个类型为 <code>A ⊎ ¬ A</code> 的值， 返回一个空类型的值，我们必须在 <code>?</code> 处填上一个返回空类型的项。得到空类型值 的唯一方式就是应用 <code>k</code> 本身，于是我们据此展开此洞：</p><pre><code>em-irrefutable k = k ?</code></pre><p>我们需要用类型为 <code>A ⊎ ¬ A</code> 的值填上这个新的洞。由于目前我们并没有类型为 <code>A</code> 的值， 因此先处理第二个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → ? })</code></pre><p>第二个析取接受 <code>¬ A</code> 的证据，即一个函数，它接受类型为 <code>A</code> 的值，返回空类型的值。 我们将 <code>x</code> 绑定到类型为 <code>A</code> 的值，现在我们需要在洞中填入空类型的值。同样， 得到空类型的值的唯一方法就是将 <code>k</code> 应用到其自身，于是我们展开此洞：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k ? })</code></pre><p>这次我们就有一个类型为 <code>A</code> 的值了，其名为 <code>x</code>，于是我们可以处理第一个析取：</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k (inj₁ x) })</code></pre><p>现在没有洞了！这样就完成了证明。</p><p>下面的故事说明了我们创建的项的行为。 （向 Peter Selinger 道歉，他讲的是个关于国王，巫师和贤者之石的类似的故事。）</p><p>曾经有一个恶魔向一个男人提议：「要么 (a) 我给你 10 亿美元，要么 (b) 如果你付给我 10 亿美元，我可以实现你的任何一个愿望。当然，得是我决定提供 (a) 还是 (b)。」</p><p>男人很谨慎。他需要付出他的灵魂吗？ 恶魔说不用，他只要接受这个提议就行。</p><p>于是男人思索着，如果恶魔向他提供 (b)，那么他不太可能付得起这个愿望。 不过倘若真是如此的话，能有什么坏处吗？</p><p>「我接受」，男人回答道，「我能得到 (a) 还是 (b)？」</p><p>恶魔顿了顿。「我提供 (b)。」</p><p>男人很失望，但并不惊讶。「果然是这样」，他想。 但是这个提议折磨着他。想想他都能用这个愿望做些什么！ 多年以后，男人开始积累钱财。为了得到这笔钱，他有时会做坏事， 而且他隐约意识到这一定是魔鬼所想到的。最后他攒够了 10 亿美元，恶魔再次出现了。</p><p>「这是 10 亿美元」，男人说着，交出一个手提箱。「实现我的愿望吧！」</p><p>恶魔接过了手提箱。然后他说道，「哦？我之前说的是 (b) 吗？抱歉，我说的是 (a)。 很高兴能给你 10 亿美元。」</p><p>于是恶魔将那个手提箱又还给了他。</p><p>（以上内容部分取自 “Call-by-Value is Dual to Call-by-Name”, Philip Wadler, <em>International Conference on Functional Programming</em>, 2003 年。）</p><h4 id="练习-classical延伸">练习 <code>Classical</code>（延伸）</h4><p>考虑以下定律：</p><ul><li>排中律：对于所有 <code>A</code>，<code>A ⊎ ¬ A</code>。</li><li>双重否定消去：对于所有的 <code>A</code>，<code>¬ ¬ A → A</code>。</li><li>皮尔士定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>((A → B) → A) → A</code>。</li><li>蕴涵表示为析取：对于所有的 <code>A</code> 和 <code>B</code>，<code>(A → B) → ¬ A ⊎ B</code>。</li><li>德摩根定律：对于所有的 <code>A</code> 和 <code>B</code>，<code>¬ (¬ A × ¬ B) → A ⊎ B</code>。</li></ul><p>请证明其中任意一条定律都蕴涵其它所有定律。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18238" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="联系-stable延伸">联系 <code>Stable</code>（延伸）</h4><p>若双重否定消去对某个式子成立，我们就说它是<strong>稳定（Stable）</strong>的：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-Stable"></a><a id="plfa_plfa-part1-Negation-18454" href="../Negation/#plfa_plfa-part1-Negation-18454" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18461" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-18463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-18467" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18469" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-18473" href="../Negation/#plfa_plfa-part1-Negation-18454" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-18480" href="../Negation/#plfa_plfa-part1-Negation-18480" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18482" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-18484" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18486" href="../Negation/#plfa_plfa-part1-Negation-849" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-18488" href="../Negation/#plfa_plfa-part1-Negation-18480" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-18490" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-18492" href="../Negation/#plfa_plfa-part1-Negation-18480" class="Bound">A</a>
</pre><p>请证明任何否定式都是稳定的，并且两个稳定式的合取也是稳定的。</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18651" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>本章中的类似定义可在标准库中找到：</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-18826" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18833" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Negation-18850" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18856" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18857" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Negation-18859" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-18861" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-18868" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Negation-18894" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-18900" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-18901" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#998" class="Function">contraposition</a><a id="plfa_plfa-part1-Negation-18915" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>本章使用了以下 Unicode：</p><pre><code>¬  U+00AC  否定符号 (\neg)
≢  U+2262  不等价于 (\==n)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Negation.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Oling Cat<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>