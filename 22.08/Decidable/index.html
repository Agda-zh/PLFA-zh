<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Decidable</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Decidable.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Decidable: Booleans and decision procedures</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Decidable-100" class="Keyword">module</a> <a id="plfa_plfa-part1-Decidable-107" href="../Decidable/#" class="Module">plfa.part1.Decidable</a> <a id="plfa_plfa-part1-Decidable-128" class="Keyword">where</a>
</pre><p>We have a choice as to how to represent relations: as an inductive data type of <em>evidence</em> that the relation holds, or as a function that <em>computes</em> whether the relation holds. Here we explore the relation between these choices. We first explore the familiar notion of <em>booleans</em>, but later discover that these are best avoided in favour of a new notion of <em>decidable</em>.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-531" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-538" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Decidable-576" class="Symbol">as</a> <a id="plfa_plfa-part1-Decidable-579" class="Module">Eq</a>
<a id="plfa_plfa-part1-Decidable-582" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-587" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Decidable-590" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-596" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-597" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Decidable-600" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-602" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Decidable-606" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-608" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-613" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Decidable-628" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-633" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-640" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-649" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-655" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-656" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-657" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-659" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-663" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Decidable-668" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-670" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-675" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-682" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Decidable-695" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-701" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-702" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Decidable-705" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-707" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-716" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-717" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Decidable-721" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Decidable-729" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-731" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-736" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-743" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Decidable-752" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-758" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-759" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Decidable-762" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-764" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Decidable-768" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-770" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Decidable-774" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-776" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-781" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-788" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-805" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-811" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-812" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Decidable-814" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-816" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-821" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-828" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-854" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-860" class="Symbol">()</a>
  <a id="plfa_plfa-part1-Decidable-865" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Decidable-874" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-875" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="plfa_plfa-part1-Decidable-889" class="Symbol">to</a> <a id="plfa_plfa-part1-Decidable-892" class="Function">¬¬-intro</a><a id="plfa_plfa-part1-Decidable-900" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-902" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-907" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-914" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="plfa_plfa-part1-Decidable-924" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-930" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-931" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="plfa_plfa-part1-Decidable-932" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-934" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-936" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-938" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-943" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-950" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Decidable-961" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-967" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-968" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Decidable-969" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-971" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Decidable-977" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-979" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-984" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-991" href="../Relations/#" class="Module">plfa.part1.Relations</a> <a id="plfa_plfa-part1-Decidable-1012" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1018" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1019" href="../Relations/#plfa_plfa-part1-Relations-18917" class="Datatype Operator">_&lt;_</a><a id="plfa_plfa-part1-Decidable-1022" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1024" href="../Relations/#plfa_plfa-part1-Relations-18944" class="InductiveConstructor">z&lt;s</a><a id="plfa_plfa-part1-Decidable-1027" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-1029" href="../Relations/#plfa_plfa-part1-Relations-19001" class="InductiveConstructor">s&lt;s</a><a id="plfa_plfa-part1-Decidable-1032" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1034" class="Keyword">open</a> <a id="plfa_plfa-part1-Decidable-1039" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-1046" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Decidable-1069" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-1075" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1076" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Decidable-1079" class="Symbol">)</a>
</pre><h2 id="evidence-vs-computation">Evidence vs Computation</h2>Recall that Chapter <a href="../Relations/">Relations</a> defined comparison as an inductive datatype, which provides <em>evidence</em> that one number is less than or equal to another:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-1288" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-1294" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1296" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">_≤_</a>

<a id="plfa_plfa-part1-Decidable-1301" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-_≤_"></a><a id="plfa_plfa-part1-Decidable-1306" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">_≤_</a> <a id="plfa_plfa-part1-Decidable-1310" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1312" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1314" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-1318" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1320" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-1324" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.z≤n"></a><a id="plfa_plfa-part1-Decidable-1333" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Decidable-1337" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1339" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1341" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1342" href="../Decidable/#plfa_plfa-part1-Decidable-1342" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1344" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1346" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1347" class="Symbol">}</a>
      <a id="plfa_plfa-part1-Decidable-1355" class="Comment">--------</a>
    <a id="plfa_plfa-part1-Decidable-1368" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1370" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-1375" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1377" href="../Decidable/#plfa_plfa-part1-Decidable-1342" class="Bound">n</a>

  <a id="plfa_plfa-part1-Decidable-_≤_.s≤s"></a><a id="plfa_plfa-part1-Decidable-1382" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1386" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1388" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-1390" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-1391" href="../Decidable/#plfa_plfa-part1-Decidable-1391" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1393" href="../Decidable/#plfa_plfa-part1-Decidable-1393" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-1395" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1397" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-1398" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Decidable-1404" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1406" href="../Decidable/#plfa_plfa-part1-Decidable-1391" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1408" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1410" href="../Decidable/#plfa_plfa-part1-Decidable-1393" class="Bound">n</a>
      <a id="plfa_plfa-part1-Decidable-1418" class="Comment">-------------</a>
    <a id="plfa_plfa-part1-Decidable-1436" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-1438" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1442" href="../Decidable/#plfa_plfa-part1-Decidable-1391" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-1444" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1446" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-1450" href="../Decidable/#plfa_plfa-part1-Decidable-1393" class="Bound">n</a>
</pre>For example, we can provide evidence that <code>2 ≤ 4</code>, and show there is no possible evidence that <code>4 ≤ 2</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-2≤4"></a><a id="plfa_plfa-part1-Decidable-1568" href="../Decidable/#plfa_plfa-part1-Decidable-1568" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1572" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1574" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-1576" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1578" class="Number">4</a>
<a id="plfa_plfa-part1-Decidable-1580" href="../Decidable/#plfa_plfa-part1-Decidable-1568" class="Function">2≤4</a> <a id="plfa_plfa-part1-Decidable-1584" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-1586" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1590" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1591" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1595" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-1598" class="Symbol">)</a>

<a id="plfa_plfa-part1-Decidable-¬4≤2"></a><a id="plfa_plfa-part1-Decidable-1601" href="../Decidable/#plfa_plfa-part1-Decidable-1601" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-1606" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1608" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-1610" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1611" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-1613" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-1615" class="Number">2</a><a id="plfa_plfa-part1-Decidable-1616" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-1618" href="../Decidable/#plfa_plfa-part1-Decidable-1601" class="Function">¬4≤2</a> <a id="plfa_plfa-part1-Decidable-1623" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1624" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1628" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-1629" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-1633" class="Symbol">()))</a>
</pre><p>The occurrence of <code>()</code> attests to the fact that there is no possible evidence for <code>2 ≤ 0</code>, which <code>z≤n</code> cannot match (because <code>2</code> is not <code>zero</code>) and <code>s≤s</code> cannot match (because <code>0</code> cannot match <code>suc n</code>).</p>An alternative, which may seem more familiar, is to define a type of booleans:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-1933" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Bool"></a><a id="plfa_plfa-part1-Decidable-1938" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-1943" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1945" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-1949" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Bool.true"></a><a id="plfa_plfa-part1-Decidable-1957" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-1963" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1965" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-Bool.false"></a><a id="plfa_plfa-part1-Decidable-1972" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-1978" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-1980" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
</pre>Given booleans, we can define a function of two numbers that <em>computes</em> to <code>true</code> if the comparison holds and to <code>false</code> otherwise:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-2129" class="Keyword">infix</a> <a id="plfa_plfa-part1-Decidable-2135" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2137" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">_≤ᵇ_</a>

<a id="plfa_plfa-part1-Decidable-_≤ᵇ_"></a><a id="plfa_plfa-part1-Decidable-2143" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">_≤ᵇ_</a> <a id="plfa_plfa-part1-Decidable-2148" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2150" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2152" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2154" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-2156" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-2158" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-2163" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Decidable-2168" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2171" href="../Decidable/#plfa_plfa-part1-Decidable-2171" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-2179" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2182" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-2187" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2191" href="../Decidable/#plfa_plfa-part1-Decidable-2191" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2193" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2196" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>   <a id="plfa_plfa-part1-Decidable-2203" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2206" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-2212" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2216" href="../Decidable/#plfa_plfa-part1-Decidable-2216" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2218" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2221" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-2225" href="../Decidable/#plfa_plfa-part1-Decidable-2225" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-2228" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-2231" href="../Decidable/#plfa_plfa-part1-Decidable-2216" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-2233" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2236" href="../Decidable/#plfa_plfa-part1-Decidable-2225" class="Bound">n</a>
</pre>The first and last clauses of this definition resemble the two constructors of the corresponding inductive datatype, while the middle clause arises because there is no possible evidence that <code>suc m ≤ zero</code> for any <code>m</code>. For example, we can compute that <code>2 ≤ᵇ 4</code> holds, and we can compute that <code>4 ≤ᵇ 2</code> does not hold:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-2566" href="../Decidable/#plfa_plfa-part1-Decidable-2566" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-2568" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2570" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2571" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-2573" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2576" class="Number">4</a><a id="plfa_plfa-part1-Decidable-2577" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-2579" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-2581" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-2586" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-2588" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-2592" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-2602" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-2604" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2607" class="Number">4</a>
  <a id="plfa_plfa-part1-Decidable-2611" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2619" class="Number">1</a> <a id="plfa_plfa-part1-Decidable-2621" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2624" class="Number">3</a>
  <a id="plfa_plfa-part1-Decidable-2628" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2636" class="Number">0</a> <a id="plfa_plfa-part1-Decidable-2638" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2641" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-2645" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2653" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
  <a id="plfa_plfa-part1-Decidable-2660" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Decidable-2663" href="../Decidable/#plfa_plfa-part1-Decidable-2663" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-2665" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-2667" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-2668" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2670" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2673" class="Number">2</a><a id="plfa_plfa-part1-Decidable-2674" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-2676" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-2678" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-2684" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-2686" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Decidable-2690" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Decidable-2700" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-2702" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2705" class="Number">2</a>
  <a id="plfa_plfa-part1-Decidable-2709" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2717" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-2719" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2722" class="Number">1</a>
  <a id="plfa_plfa-part1-Decidable-2726" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2734" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-2736" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-2739" class="Number">0</a>
  <a id="plfa_plfa-part1-Decidable-2743" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Decidable-2751" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
  <a id="plfa_plfa-part1-Decidable-2759" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>In the first case, it takes two steps to reduce the first argument to zero, and one more step to compute true, corresponding to the two uses of <code>s≤s</code> and the one use of <code>z≤n</code> when providing evidence that <code>2 ≤ 4</code>. In the second case, it takes two steps to reduce the second argument to zero, and one more step to compute false, corresponding to the two uses of <code>s≤s</code> and the one use of <code>()</code> when showing there can be no evidence that <code>4 ≤ 2</code>.</p><h2 id="relating-evidence-and-computation">Relating evidence and computation</h2>We would hope to be able to show these two approaches are related, and indeed we can. First, we define a function that lets us map from the computation world to the evidence world:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-T"></a><a id="plfa_plfa-part1-Decidable-3436" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-3438" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-3440" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-3445" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-3447" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-3451" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-3453" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-3460" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-3463" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="plfa_plfa-part1-Decidable-3465" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-3467" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-3474" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-3477" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>Recall that <code>⊤</code> is the unit type which contains the single element <code>tt</code>, and the <code>⊥</code> is the empty type which contains no values. (Also note that <code>T</code> is a capital letter t, and distinct from <code>⊤</code>.) If <code>b</code> is of type <code>Bool</code>, then <code>tt</code> provides evidence that <code>T b</code> holds if <code>b</code> is true, while there is no possible evidence that <code>T b</code> holds if <code>b</code> is false.</p>Another way to put this is that <code>T b</code> is inhabited exactly when <code>b ≡ true</code> is inhabited. In the forward direction, we need to do a case analysis on the boolean <code>b</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-T→≡"></a><a id="plfa_plfa-part1-Decidable-4012" href="../Decidable/#plfa_plfa-part1-Decidable-4012" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-4016" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4018" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-4020" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4021" href="../Decidable/#plfa_plfa-part1-Decidable-4021" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-4023" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4025" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-4029" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4031" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4033" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4035" href="../Decidable/#plfa_plfa-part1-Decidable-4021" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-4037" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4039" href="../Decidable/#plfa_plfa-part1-Decidable-4021" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-4041" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-4043" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-4048" href="../Decidable/#plfa_plfa-part1-Decidable-4012" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-4052" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-4057" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>   <a id="plfa_plfa-part1-Decidable-4062" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4065" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Decidable-4070" href="../Decidable/#plfa_plfa-part1-Decidable-4012" class="Function">T→≡</a> <a id="plfa_plfa-part1-Decidable-4074" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-4080" class="Symbol">()</a>
</pre><p>If <code>b</code> is true then <code>T b</code> is inhabited by <code>tt</code> and <code>b ≡ true</code> is inhabited by <code>refl</code>, while if <code>b</code> is false then <code>T b</code> in uninhabited.</p>In the reverse direction, there is no need for a case analysis on the boolean <code>b</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-≡→T"></a><a id="plfa_plfa-part1-Decidable-4314" href="../Decidable/#plfa_plfa-part1-Decidable-4314" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-4318" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4320" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-4322" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-4323" href="../Decidable/#plfa_plfa-part1-Decidable-4323" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-4325" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4327" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-4331" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-4333" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4335" href="../Decidable/#plfa_plfa-part1-Decidable-4323" class="Bound">b</a> <a id="plfa_plfa-part1-Decidable-4337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-4339" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Decidable-4344" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4346" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4348" href="../Decidable/#plfa_plfa-part1-Decidable-4323" class="Bound">b</a>
<a id="plfa_plfa-part1-Decidable-4350" href="../Decidable/#plfa_plfa-part1-Decidable-4314" class="Function">≡→T</a> <a id="plfa_plfa-part1-Decidable-4354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>  <a id="plfa_plfa-part1-Decidable-4360" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4363" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre><p>If <code>b ≡ true</code> is inhabited by <code>refl</code> we know that <code>b</code> is <code>true</code> and hence <code>T b</code> is inhabited by <code>tt</code>.</p><p>Now we can show that <code>T (m ≤ᵇ n)</code> is inhabited exactly when <code>m ≤ n</code> is inhabited.</p>In the forward direction, we consider the three clauses in the definition of <code>_≤ᵇ_</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ→≤"></a><a id="plfa_plfa-part1-Decidable-4649" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-4654" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4656" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-4658" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4659" href="../Decidable/#plfa_plfa-part1-Decidable-4659" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-4661" href="../Decidable/#plfa_plfa-part1-Decidable-4661" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-4663" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-4665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-4666" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4668" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4670" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-4672" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4673" href="../Decidable/#plfa_plfa-part1-Decidable-4659" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-4675" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-4678" href="../Decidable/#plfa_plfa-part1-Decidable-4661" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-4679" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4681" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-4683" href="../Decidable/#plfa_plfa-part1-Decidable-4659" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-4685" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-4687" href="../Decidable/#plfa_plfa-part1-Decidable-4661" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-4689" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-4694" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-4702" href="../Decidable/#plfa_plfa-part1-Decidable-4702" class="Bound">n</a>       <a id="plfa_plfa-part1-Decidable-4710" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-4714" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4717" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-4721" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-4726" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4727" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-4731" href="../Decidable/#plfa_plfa-part1-Decidable-4731" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-4732" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4734" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-4742" class="Symbol">()</a>
<a id="plfa_plfa-part1-Decidable-4745" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-4750" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4751" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-4755" href="../Decidable/#plfa_plfa-part1-Decidable-4755" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-4756" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4758" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4759" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-4763" href="../Decidable/#plfa_plfa-part1-Decidable-4763" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-4764" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-4766" href="../Decidable/#plfa_plfa-part1-Decidable-4766" class="Bound">t</a>   <a id="plfa_plfa-part1-Decidable-4770" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-4773" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-4777" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-4778" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-4783" href="../Decidable/#plfa_plfa-part1-Decidable-4755" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-4785" href="../Decidable/#plfa_plfa-part1-Decidable-4763" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-4787" href="../Decidable/#plfa_plfa-part1-Decidable-4766" class="Bound">t</a><a id="plfa_plfa-part1-Decidable-4788" class="Symbol">)</a>
</pre><p>In the first clause, we immediately have that <code>zero ≤ᵇ n</code> is true, so <code>T (m ≤ᵇ n)</code> is evidenced by <code>tt</code>, and correspondingly <code>m ≤ n</code> is evidenced by <code>z≤n</code>. In the middle clause, we immediately have that <code>suc m ≤ᵇ zero</code> is false, and hence <code>T (m ≤ᵇ n)</code> is empty, so we need not provide evidence that <code>m ≤ n</code>, which is just as well since there is no such evidence. In the last clause, we have that <code>suc m ≤ᵇ suc n</code> recurses to <code>m ≤ᵇ n</code>. We let <code>t</code> be the evidence of <code>T (suc m ≤ᵇ suc n)</code> if it exists, which, by definition of <code>_≤ᵇ_</code>, will also be evidence of <code>T (m ≤ᵇ n)</code>. We recursively invoke the function to get evidence that <code>m ≤ n</code>, which <code>s≤s</code> converts to evidence that <code>suc m ≤ suc n</code>.</p>In the reverse direction, we consider the possible forms of evidence that <code>m ≤ n</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤→≤ᵇ"></a><a id="plfa_plfa-part1-Decidable-5579" href="../Decidable/#plfa_plfa-part1-Decidable-5579" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-5584" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5586" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-5588" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-5589" href="../Decidable/#plfa_plfa-part1-Decidable-5589" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-5591" href="../Decidable/#plfa_plfa-part1-Decidable-5591" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-5593" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-5595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-5596" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-5598" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5600" href="../Decidable/#plfa_plfa-part1-Decidable-5589" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-5602" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-5604" href="../Decidable/#plfa_plfa-part1-Decidable-5591" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-5606" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-5608" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-5610" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-5611" href="../Decidable/#plfa_plfa-part1-Decidable-5589" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-5613" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-5616" href="../Decidable/#plfa_plfa-part1-Decidable-5591" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-5617" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-5619" href="../Decidable/#plfa_plfa-part1-Decidable-5579" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-5624" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a>        <a id="plfa_plfa-part1-Decidable-5635" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5638" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-5641" href="../Decidable/#plfa_plfa-part1-Decidable-5579" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-5646" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-5647" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-5651" href="../Decidable/#plfa_plfa-part1-Decidable-5651" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-5654" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-5657" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-5660" href="../Decidable/#plfa_plfa-part1-Decidable-5579" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-5665" href="../Decidable/#plfa_plfa-part1-Decidable-5651" class="Bound">m≤n</a>
</pre><p>If the evidence is <code>z≤n</code> then we immediately have that <code>zero ≤ᵇ n</code> is true, so <code>T (m ≤ᵇ n)</code> is evidenced by <code>tt</code>. If the evidence is <code>s≤s</code> applied to <code>m≤n</code>, then <code>suc m ≤ᵇ suc n</code> reduces to <code>m ≤ᵇ n</code>, and we may recursively invoke the function to produce evidence that <code>T (m ≤ᵇ n)</code>.</p><p>The forward proof has one more clause than the reverse proof, precisely because in the forward proof we need clauses corresponding to the comparison yielding both true and false, while in the reverse proof we only need clauses corresponding to the case where there is evidence that the comparison holds. This is exactly why we tend to prefer the evidence formulation to the computation formulation, because it allows us to do less work: we consider only cases where the relation holds, and can ignore those where it does not.</p><p>On the other hand, sometimes the computation formulation may be just what we want. Given a non-obvious relation over large values, it might be handy to have the computer work out the answer for us. Fortunately, rather than choosing between <em>evidence</em> and <em>computation</em>, there is a way to get the benefits of both.</p><h2 id="the-best-of-both-worlds">The best of both worlds</h2>A function that returns a boolean returns exactly a single bit of information: does the relation hold or does it not? Conversely, the evidence approach tells us exactly why the relation holds, but we are responsible for generating the evidence. But it is easy to define a type that combines the benefits of both approaches. It is called <code>Dec A</code>, where <code>Dec</code> is short for <em>decidable</em>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-7223" class="Keyword">data</a> <a id="plfa_plfa-part1-Decidable-Dec"></a><a id="plfa_plfa-part1-Decidable-7228" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-7232" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7233" href="../Decidable/#plfa_plfa-part1-Decidable-7233" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-7235" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7237" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-7240" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-7242" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7244" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Decidable-7248" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Decidable-Dec.yes"></a><a id="plfa_plfa-part1-Decidable-7256" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-7260" class="Symbol">:</a>   <a id="plfa_plfa-part1-Decidable-7264" href="../Decidable/#plfa_plfa-part1-Decidable-7233" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-7266" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7268" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-7272" href="../Decidable/#plfa_plfa-part1-Decidable-7233" class="Bound">A</a>
  <a id="plfa_plfa-part1-Decidable-Dec.no"></a><a id="plfa_plfa-part1-Decidable-7276" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a>  <a id="plfa_plfa-part1-Decidable-7280" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7282" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-7284" href="../Decidable/#plfa_plfa-part1-Decidable-7233" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-7286" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7288" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-7292" href="../Decidable/#plfa_plfa-part1-Decidable-7233" class="Bound">A</a>
</pre><p>Like booleans, the type has two constructors. A value of type <code>Dec A</code> is either of the form <code>yes x</code>, where <code>x</code> provides evidence that <code>A</code> holds, or of the form <code>no ¬x</code>, where <code>¬x</code> provides evidence that <code>A</code> cannot hold (that is, <code>¬x</code> is a function which given evidence of <code>A</code> yields a contradiction).</p><p>For example, we define a function <code>_≤?_</code> which given two numbers decides whether one is less than or equal to the other, and provides evidence to justify its conclusion.</p>First, we introduce two functions useful for constructing evidence that an inequality does not hold:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬s≤z"></a><a id="plfa_plfa-part1-Decidable-7881" href="../Decidable/#plfa_plfa-part1-Decidable-7881" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-7886" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7888" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-7890" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-7891" href="../Decidable/#plfa_plfa-part1-Decidable-7891" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7893" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7895" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-7896" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-7898" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7900" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-7902" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7903" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-7907" href="../Decidable/#plfa_plfa-part1-Decidable-7891" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7909" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7911" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Decidable-7915" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-7917" href="../Decidable/#plfa_plfa-part1-Decidable-7881" class="Function">¬s≤z</a> <a id="plfa_plfa-part1-Decidable-7922" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-¬s≤s"></a><a id="plfa_plfa-part1-Decidable-7926" href="../Decidable/#plfa_plfa-part1-Decidable-7926" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-7931" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7933" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-7935" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-7936" href="../Decidable/#plfa_plfa-part1-Decidable-7936" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7938" href="../Decidable/#plfa_plfa-part1-Decidable-7938" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-7940" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-7942" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-7943" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-7945" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7947" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-7949" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7950" href="../Decidable/#plfa_plfa-part1-Decidable-7936" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7952" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7954" href="../Decidable/#plfa_plfa-part1-Decidable-7938" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-7955" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-7957" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-7959" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-7961" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7962" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-7966" href="../Decidable/#plfa_plfa-part1-Decidable-7936" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-7968" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-7970" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-7974" href="../Decidable/#plfa_plfa-part1-Decidable-7938" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-7975" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-7977" href="../Decidable/#plfa_plfa-part1-Decidable-7926" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-7982" href="../Decidable/#plfa_plfa-part1-Decidable-7982" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-7987" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-7988" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-7992" href="../Decidable/#plfa_plfa-part1-Decidable-7992" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-7995" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-7997" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-7999" href="../Decidable/#plfa_plfa-part1-Decidable-7982" class="Bound">¬m≤n</a> <a id="plfa_plfa-part1-Decidable-8004" href="../Decidable/#plfa_plfa-part1-Decidable-7992" class="Bound">m≤n</a>
</pre><p>The first of these asserts that <code>¬ (suc m ≤ zero)</code>, and follows by absurdity, since any evidence of inequality has the form <code>zero ≤ n</code> or <code>suc m ≤ suc n</code>, neither of which match <code>suc m ≤ zero</code>. The second of these takes evidence <code>¬m≤n</code> of <code>¬ (m ≤ n)</code> and returns a proof of <code>¬ (suc m ≤ suc n)</code>. Any evidence of <code>suc m ≤ suc n</code> must have the form <code>s≤s m≤n</code> where <code>m≤n</code> is evidence that <code>m ≤ n</code>. Hence, we have a contradiction, evidenced by <code>¬m≤n m≤n</code>.</p>Using these, it is straightforward to decide an inequality:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?_"></a><a id="plfa_plfa-part1-Decidable-8534" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">_≤?_</a> <a id="plfa_plfa-part1-Decidable-8539" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-8541" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-8543" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-8544" href="../Decidable/#plfa_plfa-part1-Decidable-8544" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-8546" href="../Decidable/#plfa_plfa-part1-Decidable-8546" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-8548" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-8550" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-8551" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-8553" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-8555" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-8559" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-8560" href="../Decidable/#plfa_plfa-part1-Decidable-8544" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-8562" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-8564" href="../Decidable/#plfa_plfa-part1-Decidable-8546" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-8565" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-8567" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="plfa_plfa-part1-Decidable-8573" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-8576" href="../Decidable/#plfa_plfa-part1-Decidable-8576" class="Bound">n</a>                   <a id="plfa_plfa-part1-Decidable-8596" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-8599" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-8603" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a>
<a id="plfa_plfa-part1-Decidable-8607" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-8611" href="../Decidable/#plfa_plfa-part1-Decidable-8611" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-8613" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-8616" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                <a id="plfa_plfa-part1-Decidable-8636" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-8639" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-8642" href="../Decidable/#plfa_plfa-part1-Decidable-7881" class="Function">¬s≤z</a>
<a id="plfa_plfa-part1-Decidable-8647" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-8651" href="../Decidable/#plfa_plfa-part1-Decidable-8651" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-8653" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-8656" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-8660" href="../Decidable/#plfa_plfa-part1-Decidable-8660" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-8662" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-8667" href="../Decidable/#plfa_plfa-part1-Decidable-8651" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-8669" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-8672" href="../Decidable/#plfa_plfa-part1-Decidable-8660" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-8674" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-8692" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-8694" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-8698" href="../Decidable/#plfa_plfa-part1-Decidable-8698" class="Bound">m≤n</a>  <a id="plfa_plfa-part1-Decidable-8703" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-8706" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-8710" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-8711" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-8715" href="../Decidable/#plfa_plfa-part1-Decidable-8698" class="Bound">m≤n</a><a id="plfa_plfa-part1-Decidable-8718" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-8720" class="Symbol">...</a>               <a id="plfa_plfa-part1-Decidable-8738" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-8740" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-8743" href="../Decidable/#plfa_plfa-part1-Decidable-8743" class="Bound">¬m≤n</a>  <a id="plfa_plfa-part1-Decidable-8749" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-8752" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-8755" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-8756" href="../Decidable/#plfa_plfa-part1-Decidable-7926" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-8761" href="../Decidable/#plfa_plfa-part1-Decidable-8743" class="Bound">¬m≤n</a><a id="plfa_plfa-part1-Decidable-8765" class="Symbol">)</a>
</pre><p>As with <code>_≤ᵇ_</code>, the definition has three clauses. In the first clause, it is immediate that <code>zero ≤ n</code> holds, and it is evidenced by <code>z≤n</code>. In the second clause, it is immediate that <code>suc m ≤ zero</code> does not hold, and it is evidenced by <code>¬s≤z</code>. In the third clause, to decide whether <code>suc m ≤ suc n</code> holds we recursively invoke <code>m ≤? n</code>. There are two possibilities. In the <code>yes</code> case it returns evidence <code>m≤n</code> that <code>m ≤ n</code>, and <code>s≤s m≤n</code> provides evidence that <code>suc m ≤ suc n</code>. In the <code>no</code> case it returns evidence <code>¬m≤n</code> that <code>¬ (m ≤ n)</code>, and <code>¬s≤s ¬m≤n</code> provides evidence that <code>¬ (suc m ≤ suc n)</code>.</p><p>When we wrote <code>_≤ᵇ_</code>, we had to write two other functions, <code>≤ᵇ→≤</code> and <code>≤→≤ᵇ</code>, in order to show that it was correct. In contrast, the definition of <code>_≤?_</code> proves itself correct, as attested to by its type. The code of <code>_≤?_</code> is far more compact than the combined code of <code>_≤ᵇ_</code>, <code>≤ᵇ→≤</code>, and <code>≤→≤ᵇ</code>. As we will later show, if you really want the latter three, it is easy to derive them from <code>_≤?_</code>.</p>We can use our new function to <em>compute</em> the <em>evidence</em> that earlier we had to think up on our own:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-9885" href="../Decidable/#plfa_plfa-part1-Decidable-9885" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-9887" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9889" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-9891" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-9894" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-9896" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-9898" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-9902" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9903" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-9907" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9908" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-9912" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-9915" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-9918" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-9920" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-9922" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Decidable-9928" href="../Decidable/#plfa_plfa-part1-Decidable-9928" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-9930" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-9932" class="Number">4</a> <a id="plfa_plfa-part1-Decidable-9934" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-9937" class="Number">2</a> <a id="plfa_plfa-part1-Decidable-9939" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-9941" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-9944" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9945" href="../Decidable/#plfa_plfa-part1-Decidable-7926" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-9950" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-9951" href="../Decidable/#plfa_plfa-part1-Decidable-7926" class="Function">¬s≤s</a> <a id="plfa_plfa-part1-Decidable-9956" href="../Decidable/#plfa_plfa-part1-Decidable-7881" class="Function">¬s≤z</a><a id="plfa_plfa-part1-Decidable-9960" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-9963" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-9965" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-9967" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>You can check that Agda will indeed compute these values. Typing <code>C-c C-n</code> and providing <code>2 ≤? 4</code> or <code>4 ≤? 2</code> as the requested expression causes Agda to print the values given above.</p><p>(A subtlety: if we do not define <code>¬s≤z</code> and <code>¬s≤s</code> as top-level functions, but instead use inline anonymous functions then Agda may have trouble normalising evidence of negation.)</p><h4 id="exercise-__-recommended">Exercise <code>_&lt;?_</code> (recommended)</h4>Analogous to the function above, define a function to decide strict inequality:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-10467" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_&lt;?_"></a><a id="plfa_plfa-part1-Decidable-10479" href="../Decidable/#plfa_plfa-part1-Decidable-10479" class="Postulate Operator">_&lt;?_</a> <a id="plfa_plfa-part1-Decidable-10484" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10486" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10488" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10489" href="../Decidable/#plfa_plfa-part1-Decidable-10489" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10491" href="../Decidable/#plfa_plfa-part1-Decidable-10491" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-10493" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10495" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10496" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10498" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10500" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-10504" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10505" href="../Decidable/#plfa_plfa-part1-Decidable-10489" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10507" href="../Relations/#plfa_plfa-part1-Relations-18917" class="Datatype Operator">&lt;</a> <a id="plfa_plfa-part1-Decidable-10509" href="../Decidable/#plfa_plfa-part1-Decidable-10491" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10510" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-10525" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-_ℕ_-practice">Exercise <code>_≡ℕ?_</code> (practice)</h4>Define a function to decide whether two naturals are equal:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-10655" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_≡ℕ?_"></a><a id="plfa_plfa-part1-Decidable-10667" href="../Decidable/#plfa_plfa-part1-Decidable-10667" class="Postulate Operator">_≡ℕ?_</a> <a id="plfa_plfa-part1-Decidable-10673" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10675" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-10677" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10678" href="../Decidable/#plfa_plfa-part1-Decidable-10678" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10680" href="../Decidable/#plfa_plfa-part1-Decidable-10680" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-10682" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-10684" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-10685" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-10687" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-10689" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-10693" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-10694" href="../Decidable/#plfa_plfa-part1-Decidable-10678" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-10696" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-10698" href="../Decidable/#plfa_plfa-part1-Decidable-10680" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-10699" class="Symbol">)</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-10714" class="Comment">-- Your code goes here</a>
</pre><h2 id="decidables-from-booleans-and-booleans-from-decidables">Decidables from booleans, and booleans from decidables</h2>Curious readers might wonder if we could reuse the definition of <code>m ≤ᵇ n</code>, together with the proofs that it is equivalent to <code>m ≤ n</code>, to show decidability. Indeed, we can do so as follows:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤?′_"></a><a id="plfa_plfa-part1-Decidable-11000" href="../Decidable/#plfa_plfa-part1-Decidable-11000" class="Function Operator">_≤?′_</a> <a id="plfa_plfa-part1-Decidable-11006" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11008" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-11010" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11011" href="../Decidable/#plfa_plfa-part1-Decidable-11011" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11013" href="../Decidable/#plfa_plfa-part1-Decidable-11013" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11015" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-11017" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-11018" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-11020" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-11022" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-11026" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11027" href="../Decidable/#plfa_plfa-part1-Decidable-11011" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11029" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-11031" href="../Decidable/#plfa_plfa-part1-Decidable-11013" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-11032" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11034" href="../Decidable/#plfa_plfa-part1-Decidable-11034" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11036" href="../Decidable/#plfa_plfa-part1-Decidable-11000" class="Function Operator">≤?′</a> <a id="plfa_plfa-part1-Decidable-11040" href="../Decidable/#plfa_plfa-part1-Decidable-11040" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11042" class="Keyword">with</a> <a id="plfa_plfa-part1-Decidable-11047" href="../Decidable/#plfa_plfa-part1-Decidable-11034" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11049" href="../Decidable/#plfa_plfa-part1-Decidable-2143" class="Function Operator">≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-11052" href="../Decidable/#plfa_plfa-part1-Decidable-11040" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11054" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11056" href="../Decidable/#plfa_plfa-part1-Decidable-4649" class="Function">≤ᵇ→≤</a> <a id="plfa_plfa-part1-Decidable-11061" href="../Decidable/#plfa_plfa-part1-Decidable-11034" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-11063" href="../Decidable/#plfa_plfa-part1-Decidable-11040" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-11065" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11067" href="../Decidable/#plfa_plfa-part1-Decidable-5579" class="Function">≤→≤ᵇ</a> <a id="plfa_plfa-part1-Decidable-11072" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-11073" href="../Decidable/#plfa_plfa-part1-Decidable-11034" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-11074" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-11076" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-11077" href="../Decidable/#plfa_plfa-part1-Decidable-11040" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-11078" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-11080" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-11091" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11093" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-11100" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11102" href="../Decidable/#plfa_plfa-part1-Decidable-11102" class="Bound">p</a>        <a id="plfa_plfa-part1-Decidable-11111" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11113" class="Symbol">_</a>            <a id="plfa_plfa-part1-Decidable-11126" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-11128" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-11132" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-11133" href="../Decidable/#plfa_plfa-part1-Decidable-11102" class="Bound">p</a> <a id="plfa_plfa-part1-Decidable-11135" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="plfa_plfa-part1-Decidable-11137" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-11139" class="Symbol">...</a>        <a id="plfa_plfa-part1-Decidable-11150" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11152" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-11159" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11161" class="Symbol">_</a>        <a id="plfa_plfa-part1-Decidable-11170" class="Symbol">|</a> <a id="plfa_plfa-part1-Decidable-11172" href="../Decidable/#plfa_plfa-part1-Decidable-11172" class="Bound">¬p</a>           <a id="plfa_plfa-part1-Decidable-11185" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-11187" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-11190" href="../Decidable/#plfa_plfa-part1-Decidable-11172" class="Bound">¬p</a>
</pre><p>If <code>m ≤ᵇ n</code> is true then <code>≤ᵇ→≤</code> yields a proof that <code>m ≤ n</code> holds, while if it is false then <code>≤→≤ᵇ</code> takes a proof that <code>m ≤ n</code> holds into a contradiction.</p><p>The triple binding of the <code>with</code> clause in this proof is essential. If instead we wrote:</p><pre><code>_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})</code></pre><p>then Agda would make two complaints, one for each clause:</p><pre><code>⊤ !=&lt; (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=&lt; ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n</code></pre><p>Putting the expressions into the <code>with</code> clause permits Agda to exploit the fact that <code>T (m ≤ᵇ n)</code> is <code>⊤</code> when <code>m ≤ᵇ n</code> is true, and that <code>T (m ≤ᵇ n)</code> is <code>⊥</code> when <code>m ≤ᵇ n</code> is false.</p><p>However, overall it is simpler to just define <code>_≤?_</code> directly, as in the previous section. If one really wants <code>_≤ᵇ_</code>, then it and its properties are easily derived from <code>_≤?_</code>, as we will now show.</p>Erasure takes a decidable value to a boolean:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-⌊_⌋"></a><a id="plfa_plfa-part1-Decidable-12277" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊_⌋</a> <a id="plfa_plfa-part1-Decidable-12281" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12283" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-12285" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12286" href="../Decidable/#plfa_plfa-part1-Decidable-12286" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-12288" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12290" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-12293" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12295" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12297" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-12301" href="../Decidable/#plfa_plfa-part1-Decidable-12286" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-12303" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12305" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-12310" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-12312" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-12316" href="../Decidable/#plfa_plfa-part1-Decidable-12316" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-12318" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-12321" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12324" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-12329" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-12331" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-12334" href="../Decidable/#plfa_plfa-part1-Decidable-12334" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-12337" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>  <a id="plfa_plfa-part1-Decidable-12340" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12343" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
</pre>Using erasure, we can easily derive <code>_≤ᵇ_</code> from <code>_≤?_</code>:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-_≤ᵇ′_"></a><a id="plfa_plfa-part1-Decidable-12417" href="../Decidable/#plfa_plfa-part1-Decidable-12417" class="Function Operator">_≤ᵇ′_</a> <a id="plfa_plfa-part1-Decidable-12423" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12425" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-12427" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12429" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Decidable-12431" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12433" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-12438" href="../Decidable/#plfa_plfa-part1-Decidable-12438" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12440" href="../Decidable/#plfa_plfa-part1-Decidable-12417" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-12444" href="../Decidable/#plfa_plfa-part1-Decidable-12444" class="Bound">n</a>  <a id="plfa_plfa-part1-Decidable-12447" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12450" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-12452" href="../Decidable/#plfa_plfa-part1-Decidable-12438" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12454" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-12457" href="../Decidable/#plfa_plfa-part1-Decidable-12444" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-12459" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
</pre>Further, if <code>D</code> is a value of type <code>Dec A</code>, then <code>T ⌊ D ⌋</code> is inhabited exactly when <code>A</code> is inhabited:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-toWitness"></a><a id="plfa_plfa-part1-Decidable-12577" href="../Decidable/#plfa_plfa-part1-Decidable-12577" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-12587" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12589" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-12591" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12592" href="../Decidable/#plfa_plfa-part1-Decidable-12592" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-12594" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12596" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-12599" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12601" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12602" href="../Decidable/#plfa_plfa-part1-Decidable-12602" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-12604" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12606" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-12610" href="../Decidable/#plfa_plfa-part1-Decidable-12592" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12611" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12613" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12615" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-12617" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-12619" href="../Decidable/#plfa_plfa-part1-Decidable-12602" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-12621" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-12623" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12625" href="../Decidable/#plfa_plfa-part1-Decidable-12592" class="Bound">A</a>
<a id="plfa_plfa-part1-Decidable-12627" href="../Decidable/#plfa_plfa-part1-Decidable-12577" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-12637" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12638" href="../Decidable/#plfa_plfa-part1-Decidable-12638" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12639" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12641" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12642" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-12646" href="../Decidable/#plfa_plfa-part1-Decidable-12646" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-12647" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12649" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="plfa_plfa-part1-Decidable-12653" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12656" href="../Decidable/#plfa_plfa-part1-Decidable-12646" class="Bound">x</a>
<a id="plfa_plfa-part1-Decidable-12658" href="../Decidable/#plfa_plfa-part1-Decidable-12577" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-12668" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12669" href="../Decidable/#plfa_plfa-part1-Decidable-12669" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12670" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12672" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12673" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-12676" href="../Decidable/#plfa_plfa-part1-Decidable-12676" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-12678" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12680" class="Symbol">()</a>

<a id="plfa_plfa-part1-Decidable-fromWitness"></a><a id="plfa_plfa-part1-Decidable-12684" href="../Decidable/#plfa_plfa-part1-Decidable-12684" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-12696" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12698" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-12700" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12701" href="../Decidable/#plfa_plfa-part1-Decidable-12701" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-12703" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-12708" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12710" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12711" href="../Decidable/#plfa_plfa-part1-Decidable-12711" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-12713" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12715" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-12719" href="../Decidable/#plfa_plfa-part1-Decidable-12701" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12720" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12722" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12724" href="../Decidable/#plfa_plfa-part1-Decidable-12701" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-12726" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12728" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-12730" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-12732" href="../Decidable/#plfa_plfa-part1-Decidable-12711" class="Bound">D</a> <a id="plfa_plfa-part1-Decidable-12734" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
<a id="plfa_plfa-part1-Decidable-12736" href="../Decidable/#plfa_plfa-part1-Decidable-12684" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-12748" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12749" href="../Decidable/#plfa_plfa-part1-Decidable-12749" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12750" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12752" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12753" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-12757" href="../Decidable/#plfa_plfa-part1-Decidable-12757" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-12758" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12760" class="Symbol">_</a>  <a id="plfa_plfa-part1-Decidable-12763" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12766" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="plfa_plfa-part1-Decidable-12769" href="../Decidable/#plfa_plfa-part1-Decidable-12684" class="Function">fromWitness</a> <a id="plfa_plfa-part1-Decidable-12781" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12782" href="../Decidable/#plfa_plfa-part1-Decidable-12782" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-12783" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12785" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12786" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-12789" href="../Decidable/#plfa_plfa-part1-Decidable-12789" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-12791" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12793" href="../Decidable/#plfa_plfa-part1-Decidable-12793" class="Bound">x</a>  <a id="plfa_plfa-part1-Decidable-12796" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12799" href="../Decidable/#plfa_plfa-part1-Decidable-12789" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-12802" href="../Decidable/#plfa_plfa-part1-Decidable-12793" class="Bound">x</a>
</pre>Using these, we can easily derive that <code>T (m ≤ᵇ′ n)</code> is inhabited exactly when <code>m ≤ n</code> is inhabited:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-≤ᵇ′→≤"></a><a id="plfa_plfa-part1-Decidable-12917" href="../Decidable/#plfa_plfa-part1-Decidable-12917" class="Function">≤ᵇ′→≤</a> <a id="plfa_plfa-part1-Decidable-12923" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12925" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-12927" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12928" href="../Decidable/#plfa_plfa-part1-Decidable-12928" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12930" href="../Decidable/#plfa_plfa-part1-Decidable-12930" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-12932" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12934" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-12935" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-12937" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12939" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-12941" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-12942" href="../Decidable/#plfa_plfa-part1-Decidable-12928" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12944" href="../Decidable/#plfa_plfa-part1-Decidable-12417" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-12948" href="../Decidable/#plfa_plfa-part1-Decidable-12930" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-12949" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-12951" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-12953" href="../Decidable/#plfa_plfa-part1-Decidable-12928" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12955" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-12957" href="../Decidable/#plfa_plfa-part1-Decidable-12930" class="Bound">n</a>
<a id="plfa_plfa-part1-Decidable-12959" href="../Decidable/#plfa_plfa-part1-Decidable-12917" class="Function">≤ᵇ′→≤</a>  <a id="plfa_plfa-part1-Decidable-12966" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-12969" href="../Decidable/#plfa_plfa-part1-Decidable-12577" class="Function">toWitness</a>

<a id="plfa_plfa-part1-Decidable-≤→≤ᵇ′"></a><a id="plfa_plfa-part1-Decidable-12980" href="../Decidable/#plfa_plfa-part1-Decidable-12980" class="Function">≤→≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-12986" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12988" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-12990" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-12991" href="../Decidable/#plfa_plfa-part1-Decidable-12991" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-12993" href="../Decidable/#plfa_plfa-part1-Decidable-12993" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-12995" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-12997" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-12998" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-13000" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13002" href="../Decidable/#plfa_plfa-part1-Decidable-12991" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-13004" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-13006" href="../Decidable/#plfa_plfa-part1-Decidable-12993" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-13008" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13010" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-13012" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13013" href="../Decidable/#plfa_plfa-part1-Decidable-12991" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-13015" href="../Decidable/#plfa_plfa-part1-Decidable-12417" class="Function Operator">≤ᵇ′</a> <a id="plfa_plfa-part1-Decidable-13019" href="../Decidable/#plfa_plfa-part1-Decidable-12993" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-13020" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-13022" href="../Decidable/#plfa_plfa-part1-Decidable-12980" class="Function">≤→≤ᵇ′</a>  <a id="plfa_plfa-part1-Decidable-13029" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-13032" href="../Decidable/#plfa_plfa-part1-Decidable-12684" class="Function">fromWitness</a>
</pre><p>In summary, it is usually best to eschew booleans and rely on decidables. If you need booleans, they and their properties are easily derived from the corresponding decidables.</p><h2 id="logical-connectives">Logical connectives</h2><p>Most readers will be familiar with the logical connectives for booleans. Each of these extends to decidables.</p>The conjunction of two booleans is true if both are true, and false if either is false:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-13458" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-13465" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-13467" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="Function Operator">_∧_</a>

<a id="plfa_plfa-part1-Decidable-_∧_"></a><a id="plfa_plfa-part1-Decidable-13472" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Decidable-13476" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13478" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-13483" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13485" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-13490" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13492" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-13497" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-13503" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-13505" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-13511" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13513" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-13518" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-13524" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-13526" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-13532" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13534" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-13540" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-13541" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-13546" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="CatchallClause Function Operator">∧</a><a id="plfa_plfa-part1-Decidable-13547" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-13548" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="CatchallClause InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-13554" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13556" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
</pre><p>In Emacs, the left-hand side of the third equation displays in grey, indicating that the order of the equations determines which of the second or the third can match. However, regardless of which matches the answer is the same.</p>Correspondingly, given two decidable propositions, we can decide their conjunction:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-13888" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-13895" class="Number">6</a> <a id="plfa_plfa-part1-Decidable-13897" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="Function Operator">_×-dec_</a>

<a id="plfa_plfa-part1-Decidable-_×-dec_"></a><a id="plfa_plfa-part1-Decidable-13906" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="Function Operator">_×-dec_</a> <a id="plfa_plfa-part1-Decidable-13914" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13916" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-13918" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-13919" href="../Decidable/#plfa_plfa-part1-Decidable-13919" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-13921" href="../Decidable/#plfa_plfa-part1-Decidable-13921" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-13923" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-13925" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-13928" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-13930" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13932" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-13936" href="../Decidable/#plfa_plfa-part1-Decidable-13919" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-13938" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13940" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-13944" href="../Decidable/#plfa_plfa-part1-Decidable-13921" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-13946" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-13948" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-13952" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-13953" href="../Decidable/#plfa_plfa-part1-Decidable-13919" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-13955" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Decidable-13957" href="../Decidable/#plfa_plfa-part1-Decidable-13921" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-13958" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-13960" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13964" href="../Decidable/#plfa_plfa-part1-Decidable-13964" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-13966" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-13972" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13976" href="../Decidable/#plfa_plfa-part1-Decidable-13976" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-13978" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-13980" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-13984" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-13986" href="../Decidable/#plfa_plfa-part1-Decidable-13964" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-13988" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-13990" href="../Decidable/#plfa_plfa-part1-Decidable-13976" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-13992" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Decidable-13994" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-13997" href="../Decidable/#plfa_plfa-part1-Decidable-13997" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-14000" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-14006" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-14012" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-14014" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-14017" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-14020" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-14022" href="../Decidable/#plfa_plfa-part1-Decidable-14022" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-14024" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-14026" href="../Decidable/#plfa_plfa-part1-Decidable-14026" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-14028" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-14030" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14032" href="../Decidable/#plfa_plfa-part1-Decidable-13997" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-14035" href="../Decidable/#plfa_plfa-part1-Decidable-14022" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-14037" class="Symbol">}</a>
<a id="plfa_plfa-part1-Decidable-14039" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-14040" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-14045" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="CatchallClause Function Operator">×-dec</a><a id="plfa_plfa-part1-Decidable-14050" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-14051" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-14053" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-14054" href="../Decidable/#plfa_plfa-part1-Decidable-14054" class="CatchallClause Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-14057" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-14059" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-14062" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-14065" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Decidable-14067" href="../Decidable/#plfa_plfa-part1-Decidable-14067" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-14069" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Decidable-14071" href="../Decidable/#plfa_plfa-part1-Decidable-14071" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-14073" href="../Decidable/#plfa_plfa-part1-Decidable-724" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Decidable-14075" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14077" href="../Decidable/#plfa_plfa-part1-Decidable-14054" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-14080" href="../Decidable/#plfa_plfa-part1-Decidable-14071" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-14082" class="Symbol">}</a>
</pre><p>The conjunction of two propositions holds if they both hold, and its negation holds if the negation of either holds. If both hold, then we pair the evidence for each to yield evidence of the conjunct. If the negation of either holds, assuming the conjunct will lead to a contradiction.</p><p>Again in Emacs, the left-hand side of the third equation displays in grey, indicating that the order of the equations determines which of the second or the third can match. This time the answer is different depending on which matches; if both conjuncts fail to hold we pick the first to yield the contradiction, but it would be equally valid to pick the second.</p>The disjunction of two booleans is true if either is true, and false if both are false:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-14836" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-14843" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-14845" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="Function Operator">_∨_</a>

<a id="plfa_plfa-part1-Decidable-_∨_"></a><a id="plfa_plfa-part1-Decidable-14850" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="Function Operator">_∨_</a> <a id="plfa_plfa-part1-Decidable-14854" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-14856" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-14861" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14863" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-14868" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-14870" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-14875" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-14881" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-14883" class="Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-14890" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-14892" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-14897" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-14898" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-14903" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="CatchallClause Function Operator">∨</a><a id="plfa_plfa-part1-Decidable-14904" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-14905" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="CatchallClause InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-14912" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-14914" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-14919" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-14925" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-14927" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-14934" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-14936" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
</pre><p>In Emacs, the left-hand side of the second equation displays in grey, indicating that the order of the equations determines which of the first or the second can match. However, regardless of which matches the answer is the same.</p>Correspondingly, given two decidable propositions, we can decide their disjunction:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-15269" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Decidable-15276" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-15278" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="Function Operator">_⊎-dec_</a>

<a id="plfa_plfa-part1-Decidable-_⊎-dec_"></a><a id="plfa_plfa-part1-Decidable-15287" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="Function Operator">_⊎-dec_</a> <a id="plfa_plfa-part1-Decidable-15295" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15297" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-15299" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-15300" href="../Decidable/#plfa_plfa-part1-Decidable-15300" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-15302" href="../Decidable/#plfa_plfa-part1-Decidable-15302" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-15304" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-15306" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-15309" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-15311" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15313" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15317" href="../Decidable/#plfa_plfa-part1-Decidable-15300" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-15319" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15321" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15325" href="../Decidable/#plfa_plfa-part1-Decidable-15302" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-15327" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15329" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-15333" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15334" href="../Decidable/#plfa_plfa-part1-Decidable-15300" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-15336" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Decidable-15338" href="../Decidable/#plfa_plfa-part1-Decidable-15302" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-15339" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15341" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15345" href="../Decidable/#plfa_plfa-part1-Decidable-15345" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-15347" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-15353" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-15359" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15361" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15365" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15366" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-15371" href="../Decidable/#plfa_plfa-part1-Decidable-15345" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-15372" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15374" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Decidable-15375" class="CatchallClause">     </a><a id="plfa_plfa-part1-Decidable-15380" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="CatchallClause Function Operator">⊎-dec</a><a id="plfa_plfa-part1-Decidable-15385" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-15386" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="CatchallClause InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-15389" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-15390" href="../Decidable/#plfa_plfa-part1-Decidable-15390" class="CatchallClause Bound">y</a> <a id="plfa_plfa-part1-Decidable-15392" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15394" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-15398" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15399" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-15404" href="../Decidable/#plfa_plfa-part1-Decidable-15390" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-15405" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-15407" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15410" href="../Decidable/#plfa_plfa-part1-Decidable-15410" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-15413" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-15419" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15422" href="../Decidable/#plfa_plfa-part1-Decidable-15422" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-15425" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-15427" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-15430" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Decidable-15433" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15434" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Decidable-15439" href="../Decidable/#plfa_plfa-part1-Decidable-15439" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-15440" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-15442" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15444" href="../Decidable/#plfa_plfa-part1-Decidable-15410" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-15447" href="../Decidable/#plfa_plfa-part1-Decidable-15439" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-15449" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-15451" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-15452" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Decidable-15457" href="../Decidable/#plfa_plfa-part1-Decidable-15457" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-15458" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-15460" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-15462" href="../Decidable/#plfa_plfa-part1-Decidable-15422" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-15465" href="../Decidable/#plfa_plfa-part1-Decidable-15457" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-15467" class="Symbol">}</a>
</pre><p>The disjunction of two propositions holds if either holds, and its negation holds if the negation of both hold. If either holds, we inject the evidence to yield evidence of the disjunct. If the negation of both hold, assuming either disjunct will lead to a contradiction.</p><p>Again in Emacs, the left-hand side of the second equation displays in grey, indicating that the order of the equations determines which of the first or the second can match. This time the answer is different depending on which matches; if both disjuncts hold we pick the first, but it would be equally valid to pick the second.</p>The negation of a boolean is false if its argument is true, and vice versa:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-not"></a><a id="plfa_plfa-part1-Decidable-16161" href="../Decidable/#plfa_plfa-part1-Decidable-16161" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-16165" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16167" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-16172" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16174" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-16179" href="../Decidable/#plfa_plfa-part1-Decidable-16161" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-16183" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-16189" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-16191" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
<a id="plfa_plfa-part1-Decidable-16197" href="../Decidable/#plfa_plfa-part1-Decidable-16161" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-16201" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a> <a id="plfa_plfa-part1-Decidable-16207" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-16209" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
</pre>Correspondingly, given a decidable proposition, we can decide its negation:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-¬?"></a><a id="plfa_plfa-part1-Decidable-16302" href="../Decidable/#plfa_plfa-part1-Decidable-16302" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-16305" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16307" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-16309" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-16310" href="../Decidable/#plfa_plfa-part1-Decidable-16310" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16312" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16314" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-16317" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-16319" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16321" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-16325" href="../Decidable/#plfa_plfa-part1-Decidable-16310" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-16327" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16329" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-16333" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-16334" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Decidable-16336" href="../Decidable/#plfa_plfa-part1-Decidable-16310" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-16337" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-16339" href="../Decidable/#plfa_plfa-part1-Decidable-16302" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-16342" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-16343" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-16347" href="../Decidable/#plfa_plfa-part1-Decidable-16347" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-16348" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-16351" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16354" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-16357" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-16358" href="../Decidable/#plfa_plfa-part1-Decidable-892" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Decidable-16367" href="../Decidable/#plfa_plfa-part1-Decidable-16347" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-16368" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-16370" href="../Decidable/#plfa_plfa-part1-Decidable-16302" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-16373" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-16374" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-16377" href="../Decidable/#plfa_plfa-part1-Decidable-16377" class="Bound">¬x</a><a id="plfa_plfa-part1-Decidable-16379" class="Symbol">)</a>  <a id="plfa_plfa-part1-Decidable-16382" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16385" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-16389" href="../Decidable/#plfa_plfa-part1-Decidable-16377" class="Bound">¬x</a>
</pre><p>We simply swap yes and no. In the first equation, the right-hand side asserts that the negation of <code>¬ A</code> holds, in other words, that <code>¬ ¬ A</code> holds, which is an easy consequence of the fact that <code>A</code> holds.</p>There is also a slightly less familiar connective, corresponding to implication:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-_⊃_"></a><a id="plfa_plfa-part1-Decidable-16692" href="../Decidable/#plfa_plfa-part1-Decidable-16692" class="Function Operator">_⊃_</a> <a id="plfa_plfa-part1-Decidable-16696" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-16698" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-16703" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16705" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-16710" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-16712" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Decidable-16717" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-16723" href="../Decidable/#plfa_plfa-part1-Decidable-16692" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-16725" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>   <a id="plfa_plfa-part1-Decidable-16732" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16735" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-16740" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="CatchallClause InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-16745" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-16746" href="../Decidable/#plfa_plfa-part1-Decidable-16692" class="CatchallClause Function Operator">⊃</a><a id="plfa_plfa-part1-Decidable-16747" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-16748" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-16755" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16758" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>
<a id="plfa_plfa-part1-Decidable-16763" href="../Decidable/#plfa_plfa-part1-Decidable-1957" class="InductiveConstructor">true</a>  <a id="plfa_plfa-part1-Decidable-16769" href="../Decidable/#plfa_plfa-part1-Decidable-16692" class="Function Operator">⊃</a> <a id="plfa_plfa-part1-Decidable-16771" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>  <a id="plfa_plfa-part1-Decidable-16778" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-16781" href="../Decidable/#plfa_plfa-part1-Decidable-1972" class="InductiveConstructor">false</a>
</pre><p>One boolean implies another if whenever the first is true then the second is true. Hence, the implication of two booleans is true if the second is true or the first is false, and false if the first is true and the second is false. In Emacs, the left-hand side of the second equation displays in grey, indicating that the order of the equations determines which of the first or the second can match. However, regardless of which matches the answer is the same.</p>Correspondingly, given two decidable propositions, we can decide if the first implies the second:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-_→-dec_"></a><a id="plfa_plfa-part1-Decidable-17359" href="../Decidable/#plfa_plfa-part1-Decidable-17359" class="Function Operator">_→-dec_</a> <a id="plfa_plfa-part1-Decidable-17367" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17369" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-17371" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-17372" href="../Decidable/#plfa_plfa-part1-Decidable-17372" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17374" href="../Decidable/#plfa_plfa-part1-Decidable-17374" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-17376" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-17378" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-17381" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-17383" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17385" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17389" href="../Decidable/#plfa_plfa-part1-Decidable-17372" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17391" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17393" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17397" href="../Decidable/#plfa_plfa-part1-Decidable-17374" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-17399" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17401" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-17405" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17406" href="../Decidable/#plfa_plfa-part1-Decidable-17372" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-17408" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17410" href="../Decidable/#plfa_plfa-part1-Decidable-17374" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-17411" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-17413" class="Symbol">_</a>     <a id="plfa_plfa-part1-Decidable-17419" href="../Decidable/#plfa_plfa-part1-Decidable-17359" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-17425" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17429" href="../Decidable/#plfa_plfa-part1-Decidable-17429" class="Bound">y</a>  <a id="plfa_plfa-part1-Decidable-17432" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17435" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17439" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-17442" href="../Decidable/#plfa_plfa-part1-Decidable-17442" class="Bound">_</a> <a id="plfa_plfa-part1-Decidable-17444" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17446" href="../Decidable/#plfa_plfa-part1-Decidable-17429" class="Bound">y</a><a id="plfa_plfa-part1-Decidable-17447" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-17449" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-17451" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-17452" href="../Decidable/#plfa_plfa-part1-Decidable-17452" class="CatchallClause Bound">¬x</a><a id="plfa_plfa-part1-Decidable-17454" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-17455" href="../Decidable/#plfa_plfa-part1-Decidable-17359" class="CatchallClause Function Operator">→-dec</a><a id="plfa_plfa-part1-Decidable-17460" class="CatchallClause"> </a><a id="plfa_plfa-part1-Decidable-17461" class="CatchallClause Symbol">_</a>      <a id="plfa_plfa-part1-Decidable-17468" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17471" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17475" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-17478" href="../Decidable/#plfa_plfa-part1-Decidable-17478" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-17480" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17482" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Decidable-17489" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17490" href="../Decidable/#plfa_plfa-part1-Decidable-17452" class="Bound">¬x</a> <a id="plfa_plfa-part1-Decidable-17493" href="../Decidable/#plfa_plfa-part1-Decidable-17478" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17494" class="Symbol">))</a>
<a id="plfa_plfa-part1-Decidable-17497" href="../Decidable/#plfa_plfa-part1-Decidable-7256" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Decidable-17501" href="../Decidable/#plfa_plfa-part1-Decidable-17501" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-17503" href="../Decidable/#plfa_plfa-part1-Decidable-17359" class="Function Operator">→-dec</a> <a id="plfa_plfa-part1-Decidable-17509" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17512" href="../Decidable/#plfa_plfa-part1-Decidable-17512" class="Bound">¬y</a>  <a id="plfa_plfa-part1-Decidable-17516" class="Symbol">=</a>  <a id="plfa_plfa-part1-Decidable-17519" href="../Decidable/#plfa_plfa-part1-Decidable-7276" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Decidable-17522" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Decidable-17525" href="../Decidable/#plfa_plfa-part1-Decidable-17525" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-17527" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-17529" href="../Decidable/#plfa_plfa-part1-Decidable-17512" class="Bound">¬y</a> <a id="plfa_plfa-part1-Decidable-17532" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-17533" href="../Decidable/#plfa_plfa-part1-Decidable-17525" class="Bound">f</a> <a id="plfa_plfa-part1-Decidable-17535" href="../Decidable/#plfa_plfa-part1-Decidable-17501" class="Bound">x</a><a id="plfa_plfa-part1-Decidable-17536" class="Symbol">))</a>
</pre><p>The implication holds if either the second holds or the negation of the first holds, and its negation holds if the first holds and the negation of the second holds. Evidence for the implication is a function from evidence of the first to evidence of the second. If the second holds, the function returns the evidence for it. If the negation of the first holds, the function takes the evidence of the first and derives a contradiction. If the first holds and the negation of the second holds, given evidence of the implication we must derive a contradiction; we apply the evidence of the implication <code>f</code> to the evidence of the first <code>x</code>, yielding a contradiction with the evidence <code>¬y</code> of the negation of the second.</p><p>Again in Emacs, the left-hand side of the second equation displays in grey, indicating that the order of the equations determines which of the first or the second can match. This time the answer is different depending on which matches; but either is equally valid.</p><h4 id="exercise-erasure-practice">Exercise <code>erasure</code> (practice)</h4>Show that erasure relates corresponding boolean and decidable operations:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-18645" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-∧-×"></a><a id="plfa_plfa-part1-Decidable-18657" href="../Decidable/#plfa_plfa-part1-Decidable-18657" class="Postulate">∧-×</a> <a id="plfa_plfa-part1-Decidable-18661" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18663" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-18665" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-18666" href="../Decidable/#plfa_plfa-part1-Decidable-18666" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-18668" href="../Decidable/#plfa_plfa-part1-Decidable-18668" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-18670" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18672" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-18675" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-18677" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-18678" href="../Decidable/#plfa_plfa-part1-Decidable-18678" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18680" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18682" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-18686" href="../Decidable/#plfa_plfa-part1-Decidable-18666" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-18687" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-18689" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-18690" href="../Decidable/#plfa_plfa-part1-Decidable-18690" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18692" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18694" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-18698" href="../Decidable/#plfa_plfa-part1-Decidable-18668" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-18699" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-18701" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18703" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18705" href="../Decidable/#plfa_plfa-part1-Decidable-18678" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18707" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-18709" href="../Decidable/#plfa_plfa-part1-Decidable-13472" class="Function Operator">∧</a> <a id="plfa_plfa-part1-Decidable-18711" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18713" href="../Decidable/#plfa_plfa-part1-Decidable-18690" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18715" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-18717" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-18719" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18721" href="../Decidable/#plfa_plfa-part1-Decidable-18678" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18723" href="../Decidable/#plfa_plfa-part1-Decidable-13906" class="Function Operator">×-dec</a> <a id="plfa_plfa-part1-Decidable-18729" href="../Decidable/#plfa_plfa-part1-Decidable-18690" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18731" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-∨-⊎"></a><a id="plfa_plfa-part1-Decidable-18735" href="../Decidable/#plfa_plfa-part1-Decidable-18735" class="Postulate">∨-⊎</a> <a id="plfa_plfa-part1-Decidable-18739" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18741" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-18743" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-18744" href="../Decidable/#plfa_plfa-part1-Decidable-18744" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-18746" href="../Decidable/#plfa_plfa-part1-Decidable-18746" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-18748" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18750" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-18753" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-18755" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-18756" href="../Decidable/#plfa_plfa-part1-Decidable-18756" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18758" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18760" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-18764" href="../Decidable/#plfa_plfa-part1-Decidable-18744" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-18765" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-18767" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-18768" href="../Decidable/#plfa_plfa-part1-Decidable-18768" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18770" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18772" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-18776" href="../Decidable/#plfa_plfa-part1-Decidable-18746" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-18777" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-18779" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18781" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18783" href="../Decidable/#plfa_plfa-part1-Decidable-18756" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18785" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-18787" href="../Decidable/#plfa_plfa-part1-Decidable-14850" class="Function Operator">∨</a> <a id="plfa_plfa-part1-Decidable-18789" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18791" href="../Decidable/#plfa_plfa-part1-Decidable-18768" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18793" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-18795" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-18797" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18799" href="../Decidable/#plfa_plfa-part1-Decidable-18756" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18801" href="../Decidable/#plfa_plfa-part1-Decidable-15287" class="Function Operator">⊎-dec</a> <a id="plfa_plfa-part1-Decidable-18807" href="../Decidable/#plfa_plfa-part1-Decidable-18768" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-18809" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
  <a id="plfa_plfa-part1-Decidable-not-¬"></a><a id="plfa_plfa-part1-Decidable-18813" href="../Decidable/#plfa_plfa-part1-Decidable-18813" class="Postulate">not-¬</a> <a id="plfa_plfa-part1-Decidable-18819" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18821" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-18823" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-18824" href="../Decidable/#plfa_plfa-part1-Decidable-18824" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-18826" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18828" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-18831" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-18833" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-18834" href="../Decidable/#plfa_plfa-part1-Decidable-18834" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18836" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-18838" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-18842" href="../Decidable/#plfa_plfa-part1-Decidable-18824" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-18843" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-18845" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-18847" href="../Decidable/#plfa_plfa-part1-Decidable-16161" class="Function">not</a> <a id="plfa_plfa-part1-Decidable-18851" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18853" href="../Decidable/#plfa_plfa-part1-Decidable-18834" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18855" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-18857" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-18859" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-18861" href="../Decidable/#plfa_plfa-part1-Decidable-16302" class="Function">¬?</a> <a id="plfa_plfa-part1-Decidable-18864" href="../Decidable/#plfa_plfa-part1-Decidable-18834" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-18866" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
</pre><h4 id="exercise-iff-erasure-recommended">Exercise <code>iff-erasure</code> (recommended)</h4>Give analogues of the <code>_⇔_</code> operation from Chapter <a href="../Isomorphism/#iff">Isomorphism</a>, operation on booleans and decidables, and also show the corresponding erasure:<pre class="Agda"><a id="plfa_plfa-part1-Decidable-19088" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Decidable-_iff_"></a><a id="plfa_plfa-part1-Decidable-19100" href="../Decidable/#plfa_plfa-part1-Decidable-19100" class="Postulate Operator">_iff_</a> <a id="plfa_plfa-part1-Decidable-19106" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19108" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-19113" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19115" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a> <a id="plfa_plfa-part1-Decidable-19120" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19122" href="../Decidable/#plfa_plfa-part1-Decidable-1938" class="Datatype">Bool</a>
  <a id="plfa_plfa-part1-Decidable-_⇔-dec_"></a><a id="plfa_plfa-part1-Decidable-19129" href="../Decidable/#plfa_plfa-part1-Decidable-19129" class="Postulate Operator">_⇔-dec_</a> <a id="plfa_plfa-part1-Decidable-19137" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19139" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-19141" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-19142" href="../Decidable/#plfa_plfa-part1-Decidable-19142" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19144" href="../Decidable/#plfa_plfa-part1-Decidable-19144" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19146" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19148" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-19151" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-19153" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19155" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19159" href="../Decidable/#plfa_plfa-part1-Decidable-19142" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19161" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19163" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19167" href="../Decidable/#plfa_plfa-part1-Decidable-19144" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19169" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19171" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19175" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19176" href="../Decidable/#plfa_plfa-part1-Decidable-19142" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19178" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Decidable-19180" href="../Decidable/#plfa_plfa-part1-Decidable-19144" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-19181" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Decidable-iff-⇔"></a><a id="plfa_plfa-part1-Decidable-19185" href="../Decidable/#plfa_plfa-part1-Decidable-19185" class="Postulate">iff-⇔</a> <a id="plfa_plfa-part1-Decidable-19191" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19193" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-19195" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-19196" href="../Decidable/#plfa_plfa-part1-Decidable-19196" class="Bound">A</a> <a id="plfa_plfa-part1-Decidable-19198" href="../Decidable/#plfa_plfa-part1-Decidable-19198" class="Bound">B</a> <a id="plfa_plfa-part1-Decidable-19200" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19202" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Decidable-19205" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-19207" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19208" href="../Decidable/#plfa_plfa-part1-Decidable-19208" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19210" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19212" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19216" href="../Decidable/#plfa_plfa-part1-Decidable-19196" class="Bound">A</a><a id="plfa_plfa-part1-Decidable-19217" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19219" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19220" href="../Decidable/#plfa_plfa-part1-Decidable-19220" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19222" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19224" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-19228" href="../Decidable/#plfa_plfa-part1-Decidable-19198" class="Bound">B</a><a id="plfa_plfa-part1-Decidable-19229" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19231" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19233" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-19235" href="../Decidable/#plfa_plfa-part1-Decidable-19208" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19237" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-19239" href="../Decidable/#plfa_plfa-part1-Decidable-19100" class="Postulate Operator">iff</a> <a id="plfa_plfa-part1-Decidable-19243" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-19245" href="../Decidable/#plfa_plfa-part1-Decidable-19220" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19247" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a> <a id="plfa_plfa-part1-Decidable-19249" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-19251" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-19253" href="../Decidable/#plfa_plfa-part1-Decidable-19208" class="Bound">x</a> <a id="plfa_plfa-part1-Decidable-19255" href="../Decidable/#plfa_plfa-part1-Decidable-19129" class="Postulate Operator">⇔-dec</a> <a id="plfa_plfa-part1-Decidable-19261" href="../Decidable/#plfa_plfa-part1-Decidable-19220" class="Bound">y</a> <a id="plfa_plfa-part1-Decidable-19263" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Decidable-19278" class="Comment">-- Your code goes here</a>
</pre><h2 id="proof-by-reflection">Proof by reflection</h2><p>Let’s revisit our definition of monus from Chapter <a href="../Naturals/">Naturals</a>. If we subtract a larger number from a smaller number, we take the result to be zero. We had to do something, after all. What could we have done differently? We could have defined a <em>guarded</em> version of minus, a function which subtracts <code>n</code> from <code>m</code> only if <code>n ≤ m</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-minus"></a><a id="plfa_plfa-part1-Decidable-19703" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-19709" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19711" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19712" href="../Decidable/#plfa_plfa-part1-Decidable-19712" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-19714" href="../Decidable/#plfa_plfa-part1-Decidable-19714" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-19716" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19718" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-19719" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19721" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19722" href="../Decidable/#plfa_plfa-part1-Decidable-19722" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-19726" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19728" href="../Decidable/#plfa_plfa-part1-Decidable-19714" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-19730" href="../Decidable/#plfa_plfa-part1-Decidable-1306" class="Datatype Operator">≤</a> <a id="plfa_plfa-part1-Decidable-19732" href="../Decidable/#plfa_plfa-part1-Decidable-19712" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-19733" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19735" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-19737" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-19739" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-19745" href="../Decidable/#plfa_plfa-part1-Decidable-19745" class="Bound">m</a>       <a id="plfa_plfa-part1-Decidable-19753" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Decidable-19761" class="Symbol">_</a>         <a id="plfa_plfa-part1-Decidable-19771" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19773" href="../Decidable/#plfa_plfa-part1-Decidable-19745" class="Bound">m</a>
<a id="plfa_plfa-part1-Decidable-19775" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-19781" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-19786" href="../Decidable/#plfa_plfa-part1-Decidable-19786" class="Bound">m</a><a id="plfa_plfa-part1-Decidable-19787" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19789" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19790" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Decidable-19794" href="../Decidable/#plfa_plfa-part1-Decidable-19794" class="Bound">n</a><a id="plfa_plfa-part1-Decidable-19795" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19797" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19798" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-19802" href="../Decidable/#plfa_plfa-part1-Decidable-19802" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-19805" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-19807" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19809" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-19815" href="../Decidable/#plfa_plfa-part1-Decidable-19786" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-19817" href="../Decidable/#plfa_plfa-part1-Decidable-19794" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-19819" href="../Decidable/#plfa_plfa-part1-Decidable-19802" class="Bound">n≤m</a>
</pre><p>Unfortunately, it is painful to use, since we have to explicitly provide the proof that <code>n ≤ m</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-19934" href="../Decidable/#plfa_plfa-part1-Decidable-19934" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-19936" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-19938" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-19944" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-19946" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-19948" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19949" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-19953" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19954" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-19958" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-19959" href="../Decidable/#plfa_plfa-part1-Decidable-1382" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Decidable-19963" href="../Decidable/#plfa_plfa-part1-Decidable-1333" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Decidable-19966" class="Symbol">)))</a> <a id="plfa_plfa-part1-Decidable-19970" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-19972" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-19974" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-19976" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-19978" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>We cannot solve this problem in general, but in the scenario above, we happen to know the two numbers <em>statically</em>. In that case, we can use a technique called <em>proof by reflection</em>. Essentially, we can ask Agda to run the decidable equality <code>n ≤? m</code> while type checking, and make sure that <code>n ≤ m</code>!</p><p>We do this by using a feature of implicits. Agda will fill in an implicit of a record type if it can fill in all its fields. So Agda will <em>always</em> manage to fill in an implicit of an <em>empty</em> record type, since there aren’t any fields after all. This is why <code>⊤</code> is defined as an empty record.</p><p>The trick is to have an implicit argument of the type <code>T ⌊ n ≤? m ⌋</code>. Let’s go through what this means step-by-step. First, we run the decision procedure, <code>n ≤? m</code>. This provides us with evidence whether <code>n ≤ m</code> holds or not. We erase the evidence to a boolean. Finally, we apply <code>T</code>. Recall that <code>T</code> maps booleans into the world of evidence: <code>true</code> becomes the unit type <code>⊤</code>, and <code>false</code> becomes the empty type <code>⊥</code>. Operationally, an implicit argument of this type works as a guard.</p><ul><li>If <code>n ≤ m</code> holds, the type of the implicit value reduces to <code>⊤</code>. Agda then happily provides the implicit value.</li><li>Otherwise, the type reduces to <code>⊥</code>, which Agda has no chance of providing, so it will throw an error. For instance, if we call <code>3 - 5</code> we get <code>_n≤m_254 : ⊥</code>.</li></ul><p>We obtain the witness for <code>n ≤ m</code> using <code>toWitness</code>, which we defined earlier:</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-_-_"></a><a id="plfa_plfa-part1-Decidable-21434" href="../Decidable/#plfa_plfa-part1-Decidable-21434" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-21438" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21440" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-21441" href="../Decidable/#plfa_plfa-part1-Decidable-21441" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-21443" href="../Decidable/#plfa_plfa-part1-Decidable-21443" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-21445" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21447" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Decidable-21448" class="Symbol">)</a> <a id="plfa_plfa-part1-Decidable-21450" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-21451" href="../Decidable/#plfa_plfa-part1-Decidable-21451" class="Bound">n≤m</a> <a id="plfa_plfa-part1-Decidable-21455" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21457" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-21459" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-21461" href="../Decidable/#plfa_plfa-part1-Decidable-21443" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-21463" href="../Decidable/#plfa_plfa-part1-Decidable-8534" class="Function Operator">≤?</a> <a id="plfa_plfa-part1-Decidable-21466" href="../Decidable/#plfa_plfa-part1-Decidable-21441" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-21468" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a><a id="plfa_plfa-part1-Decidable-21469" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-21471" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21473" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Decidable-21475" href="../Decidable/#plfa_plfa-part1-Decidable-21434" class="Function Operator">_-_</a> <a id="plfa_plfa-part1-Decidable-21479" href="../Decidable/#plfa_plfa-part1-Decidable-21479" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-21481" href="../Decidable/#plfa_plfa-part1-Decidable-21481" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-21483" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-21484" href="../Decidable/#plfa_plfa-part1-Decidable-21484" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-21487" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-21489" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21491" href="../Decidable/#plfa_plfa-part1-Decidable-19703" class="Function">minus</a> <a id="plfa_plfa-part1-Decidable-21497" href="../Decidable/#plfa_plfa-part1-Decidable-21479" class="Bound">m</a> <a id="plfa_plfa-part1-Decidable-21499" href="../Decidable/#plfa_plfa-part1-Decidable-21481" class="Bound">n</a> <a id="plfa_plfa-part1-Decidable-21501" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-21502" href="../Decidable/#plfa_plfa-part1-Decidable-12577" class="Function">toWitness</a> <a id="plfa_plfa-part1-Decidable-21512" href="../Decidable/#plfa_plfa-part1-Decidable-21484" class="Bound">n≤m</a><a id="plfa_plfa-part1-Decidable-21515" class="Symbol">)</a>
</pre><p>We can safely use <code>_-_</code> as long as we statically know the two numbers:</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-21602" href="../Decidable/#plfa_plfa-part1-Decidable-21602" class="Function">_</a> <a id="plfa_plfa-part1-Decidable-21604" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21606" class="Number">5</a> <a id="plfa_plfa-part1-Decidable-21608" href="../Decidable/#plfa_plfa-part1-Decidable-21434" class="Function Operator">-</a> <a id="plfa_plfa-part1-Decidable-21610" class="Number">3</a> <a id="plfa_plfa-part1-Decidable-21612" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Decidable-21614" class="Number">2</a>
<a id="plfa_plfa-part1-Decidable-21616" class="Symbol">_</a> <a id="plfa_plfa-part1-Decidable-21618" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21620" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>It turns out that this idiom is very common. The standard library defines a synonym for <code>T ⌊ ? ⌋</code> called <code>True</code>:</p><pre class="Agda"><a id="plfa_plfa-part1-Decidable-True"></a><a id="plfa_plfa-part1-Decidable-21752" href="../Decidable/#plfa_plfa-part1-Decidable-21752" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-21757" class="Symbol">:</a> <a id="plfa_plfa-part1-Decidable-21759" class="Symbol">∀</a> <a id="plfa_plfa-part1-Decidable-21761" class="Symbol">{</a><a id="plfa_plfa-part1-Decidable-21762" href="../Decidable/#plfa_plfa-part1-Decidable-21762" class="Bound">Q</a><a id="plfa_plfa-part1-Decidable-21763" class="Symbol">}</a> <a id="plfa_plfa-part1-Decidable-21765" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21767" href="../Decidable/#plfa_plfa-part1-Decidable-7228" class="Datatype">Dec</a> <a id="plfa_plfa-part1-Decidable-21771" href="../Decidable/#plfa_plfa-part1-Decidable-21762" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-21773" class="Symbol">→</a> <a id="plfa_plfa-part1-Decidable-21775" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Decidable-21779" href="../Decidable/#plfa_plfa-part1-Decidable-21752" class="Function">True</a> <a id="plfa_plfa-part1-Decidable-21784" href="../Decidable/#plfa_plfa-part1-Decidable-21784" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-21786" class="Symbol">=</a> <a id="plfa_plfa-part1-Decidable-21788" href="../Decidable/#plfa_plfa-part1-Decidable-3436" class="Function">T</a> <a id="plfa_plfa-part1-Decidable-21790" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌊</a> <a id="plfa_plfa-part1-Decidable-21792" href="../Decidable/#plfa_plfa-part1-Decidable-21784" class="Bound">Q</a> <a id="plfa_plfa-part1-Decidable-21794" href="../Decidable/#plfa_plfa-part1-Decidable-12277" class="Function Operator">⌋</a>
</pre><h4 id="exercise-false">Exercise <code>False</code></h4><p>Give analogues of <code>True</code>, <code>toWitness</code>, and <code>fromWitness</code> which work with <em>negated</em> properties. Call these <code>False</code>, <code>toWitnessFalse</code>, and <code>fromWitnessFalse</code>.</p><h2 id="standard-library">Standard Library</h2><pre class="Agda"><a id="plfa_plfa-part1-Decidable-22012" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22019" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Decidable-22034" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22040" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22041" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Decidable-22045" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22047" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Decidable-22051" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22053" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Decidable-22058" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22060" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Decidable-22061" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22063" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Decidable-22066" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22068" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Decidable-22071" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22073" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Decidable-22076" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22078" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22085" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Decidable-22094" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22100" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22101" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#5518" class="Function Operator">_≤?_</a><a id="plfa_plfa-part1-Decidable-22105" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22107" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22114" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Decidable-22131" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22137" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22138" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Decidable-22141" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22143" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Decidable-22146" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22148" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Decidable-22150" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22152" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22159" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="plfa_plfa-part1-Decidable-22186" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22192" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22193" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊_⌋</a><a id="plfa_plfa-part1-Decidable-22196" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22198" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="plfa_plfa-part1-Decidable-22202" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22204" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1484" class="Function">toWitness</a><a id="plfa_plfa-part1-Decidable-22213" class="Symbol">;</a> <a id="plfa_plfa-part1-Decidable-22215" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Decidable.Core.html#1653" class="Function">fromWitness</a><a id="plfa_plfa-part1-Decidable-22226" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22228" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22235" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Decidable-22261" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22267" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22268" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#1355" class="Function">¬?</a><a id="plfa_plfa-part1-Decidable-22270" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22272" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22279" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html" class="Module">Relation.Nullary.Product</a> <a id="plfa_plfa-part1-Decidable-22304" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22310" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22311" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Product.html#921" class="Function Operator">_×-dec_</a><a id="plfa_plfa-part1-Decidable-22318" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22320" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22327" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html" class="Module">Relation.Nullary.Sum</a> <a id="plfa_plfa-part1-Decidable-22348" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22354" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22355" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Sum.html#946" class="Function Operator">_⊎-dec_</a><a id="plfa_plfa-part1-Decidable-22362" class="Symbol">)</a>
<a id="plfa_plfa-part1-Decidable-22364" class="Keyword">import</a> <a id="plfa_plfa-part1-Decidable-22371" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Decidable-22387" class="Keyword">using</a> <a id="plfa_plfa-part1-Decidable-22393" class="Symbol">(</a><a id="plfa_plfa-part1-Decidable-22394" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Decidable-22403" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><pre><code>∧  U+2227  LOGICAL AND (\and, \wedge)
∨  U+2228  LOGICAL OR (\or, \vee)
⊃  U+2283  SUPERSET OF (\sup)
ᵇ  U+1D47  MODIFIER LETTER SMALL B  (\^b)
⌊  U+230A  LEFT FLOOR (\clL)
⌋  U+230B  RIGHT FLOOR (\clR)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Quantifiers/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Decidable.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lists/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>