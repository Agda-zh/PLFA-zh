<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Lists: Lists and higher-order functions</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-92" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-99" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-116" class="Keyword">where</a>
</pre><p>This chapter discusses the list data type. It gives further examples of many of the techniques we have developed so far, and provides examples of polymorphic types and higher-order functions.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-341" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-348" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-386" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-389" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-392" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-397" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-400" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-407" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-410" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-412" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-416" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-418" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="plfa_plfa-part1-Lists-421" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-423" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a><a id="plfa_plfa-part1-Lists-428" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-430" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="plfa_plfa-part1-Lists-434" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-436" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-441" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-456" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-461" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-468" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-478" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-484" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-485" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-489" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-491" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-495" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-497" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-502" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1451" class="Function">T</a><a id="plfa_plfa-part1-Lists-505" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-507" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-512" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-515" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-517" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#932" class="Function">not</a><a id="plfa_plfa-part1-Lists-520" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-522" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-527" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-534" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-543" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-549" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-550" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-551" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-557" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-559" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-562" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-564" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-567" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-569" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-582" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-584" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-587" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-589" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-592" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-594" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-599" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-606" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-626" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-634" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-635" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-642" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-644" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-657" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-668" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-670" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-677" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-679" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-690" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-692" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-703" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-705" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-710" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-717" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-734" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-740" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-741" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-743" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-745" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-748" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-750" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-753" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-755" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-757" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-759" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-764" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-771" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-784" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-791" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-794" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-796" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1369" class="Function">∃</a><a id="plfa_plfa-part1-Lists-797" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-799" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1806" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-807" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-809" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-818" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-819" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-823" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-831" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-833" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-838" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-845" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-854" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-860" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-861" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-864" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-866" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-871" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-878" href="https://agda.github.io/agda-stdlib/v1.7.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-884" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-890" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-891" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#597" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-896" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-898" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-903" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-910" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-933" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-940" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-943" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-945" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-948" class="Symbol">)</a>
</pre><h2 id="lists">Lists</h2>Lists are defined in Agda as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-1012" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1017" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1022" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1023" href="../Lists/#plfa_plfa-part1-Lists-1023" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1025" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1027" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1030" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1032" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1034" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1038" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1046" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1050" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1052" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1057" href="../Lists/#plfa_plfa-part1-Lists-1023" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1061" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1065" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1067" href="../Lists/#plfa_plfa-part1-Lists-1023" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1069" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1071" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1076" href="../Lists/#plfa_plfa-part1-Lists-1023" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1078" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1080" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1085" href="../Lists/#plfa_plfa-part1-Lists-1023" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1088" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1095" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1097" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">_∷_</a>
</pre><p>Let’s unpack this definition. If <code>A</code> is a set, then <code>List A</code> is a set. The next two lines tell us that <code>[]</code> (pronounced <em>nil</em>) is a list of type <code>A</code> (often called the <em>empty</em> list), and that <code>_∷_</code> (pronounced <em>cons</em>, short for <em>constructor</em>) takes a value of type <code>A</code> and a value of type <code>List A</code> and returns a value of type <code>List A</code>. Operator <code>_∷_</code> has precedence level 5 and associates to the right.</p>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-1530" href="../Lists/#plfa_plfa-part1-Lists-1530" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1532" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1534" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1539" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1541" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1543" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1545" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1547" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1549" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1551" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1553" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1555" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1557" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
</pre><p>denotes the list of the first three natural numbers. Since <code>_∷_</code> associates to the right, the term parses as <code>0 ∷ (1 ∷ (2 ∷ []))</code>. Here <code>0</code> is the first element of the list, called the <em>head</em>, and <code>1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the <em>tail</em>. A list is a strange beast: it has a head and a tail, nothing in between, and the tail is itself another list!</p>As we’ve seen, parameterised types can be translated to indexed types. The definition above is equivalent to the following:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2076" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2081" href="../Lists/#plfa_plfa-part1-Lists-2081" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2087" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2089" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2093" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2095" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2099" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2107" href="../Lists/#plfa_plfa-part1-Lists-2107" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2112" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2114" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2116" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2117" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2119" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2121" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2124" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2126" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2128" href="../Lists/#plfa_plfa-part1-Lists-2081" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2134" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2138" href="../Lists/#plfa_plfa-part1-Lists-2138" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2143" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2145" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2147" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2148" href="../Lists/#plfa_plfa-part1-Lists-2148" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2150" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2152" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2155" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2157" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2159" href="../Lists/#plfa_plfa-part1-Lists-2148" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2161" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2163" href="../Lists/#plfa_plfa-part1-Lists-2081" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2169" href="../Lists/#plfa_plfa-part1-Lists-2148" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2171" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2173" href="../Lists/#plfa_plfa-part1-Lists-2081" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2179" href="../Lists/#plfa_plfa-part1-Lists-2148" class="Bound">A</a>
</pre>Each constructor takes the parameter as an implicit argument. Thus, our example list could also be written:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2301" href="../Lists/#plfa_plfa-part1-Lists-2301" class="Function">_</a> <a id="plfa_plfa-part1-Lists-2303" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2305" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-2310" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-2312" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-2314" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2316" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2320" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2321" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2322" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2324" class="Number">0</a> <a id="plfa_plfa-part1-Lists-2326" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2327" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2331" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2333" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2335" class="Number">1</a> <a id="plfa_plfa-part1-Lists-2337" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2338" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2342" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2343" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2344" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2346" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2348" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2349" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-2352" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2353" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2354" class="Symbol">})))</a>
</pre><p>where here we have provided the implicit parameters explicitly.</p><p>Including the pragma:</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>tells Agda that the type <code>List</code> corresponds to the Haskell type list, and the constructors <code>[]</code> and <code>_∷_</code> correspond to nil and cons respectively, allowing a more efficient representation of lists.</p><h2 id="list-syntax">List syntax</h2>We can write lists more conveniently by introducing the following definitions:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2785" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-2793" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-2797" href="../Lists/#plfa_plfa-part1-Lists-2801" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2799" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2801" href="../Lists/#plfa_plfa-part1-Lists-2801" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2803" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2805" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2808" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-2816" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-2822" href="../Lists/#plfa_plfa-part1-Lists-2828" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2824" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2826" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2828" href="../Lists/#plfa_plfa-part1-Lists-2828" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2830" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2832" href="../Lists/#plfa_plfa-part1-Lists-2832" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2834" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2836" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2839" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-2847" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-2855" href="../Lists/#plfa_plfa-part1-Lists-2863" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2857" href="../Lists/#plfa_plfa-part1-Lists-2867" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2859" href="../Lists/#plfa_plfa-part1-Lists-2871" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2861" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2863" href="../Lists/#plfa_plfa-part1-Lists-2863" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2865" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2867" href="../Lists/#plfa_plfa-part1-Lists-2867" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2869" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2871" href="../Lists/#plfa_plfa-part1-Lists-2871" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2873" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2875" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2878" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-2886" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-2896" href="../Lists/#plfa_plfa-part1-Lists-2906" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2898" href="../Lists/#plfa_plfa-part1-Lists-2910" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2900" href="../Lists/#plfa_plfa-part1-Lists-2914" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2902" href="../Lists/#plfa_plfa-part1-Lists-2918" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2904" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2906" href="../Lists/#plfa_plfa-part1-Lists-2906" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2908" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2910" href="../Lists/#plfa_plfa-part1-Lists-2910" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2912" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2914" href="../Lists/#plfa_plfa-part1-Lists-2914" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2916" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2918" href="../Lists/#plfa_plfa-part1-Lists-2918" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2920" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2922" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2925" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-2933" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-2945" href="../Lists/#plfa_plfa-part1-Lists-2957" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-2947" href="../Lists/#plfa_plfa-part1-Lists-2961" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2949" href="../Lists/#plfa_plfa-part1-Lists-2965" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2951" href="../Lists/#plfa_plfa-part1-Lists-2969" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2953" href="../Lists/#plfa_plfa-part1-Lists-2973" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2955" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2957" href="../Lists/#plfa_plfa-part1-Lists-2957" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-2959" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2961" href="../Lists/#plfa_plfa-part1-Lists-2961" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2963" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2965" href="../Lists/#plfa_plfa-part1-Lists-2965" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2967" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2969" href="../Lists/#plfa_plfa-part1-Lists-2969" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2971" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2973" href="../Lists/#plfa_plfa-part1-Lists-2973" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2975" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2977" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2980" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-2988" href="../Lists/#plfa_plfa-part1-Lists-2988" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3002" href="../Lists/#plfa_plfa-part1-Lists-3016" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3004" href="../Lists/#plfa_plfa-part1-Lists-3020" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3006" href="../Lists/#plfa_plfa-part1-Lists-3024" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3008" href="../Lists/#plfa_plfa-part1-Lists-3028" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3010" href="../Lists/#plfa_plfa-part1-Lists-3032" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3012" href="../Lists/#plfa_plfa-part1-Lists-3036" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3014" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3016" href="../Lists/#plfa_plfa-part1-Lists-3016" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3018" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3020" href="../Lists/#plfa_plfa-part1-Lists-3020" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3022" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3024" href="../Lists/#plfa_plfa-part1-Lists-3024" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3026" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3028" href="../Lists/#plfa_plfa-part1-Lists-3028" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3030" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3032" href="../Lists/#plfa_plfa-part1-Lists-3032" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3034" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3036" href="../Lists/#plfa_plfa-part1-Lists-3036" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3038" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3040" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
</pre><p>This is our first use of pattern declarations. For instance, the third line tells us that <code>[ x , y , z ]</code> is equivalent to <code>x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in a pattern on the left-hand side of an equation, or a term on the right-hand side of an equation.</p><h2 id="append">Append</h2><p>Our first function on lists is written <code>_++_</code> and pronounced <em>append</em>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3422" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-3429" class="Number">5</a> <a id="plfa_plfa-part1-Lists-3431" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-3437" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-3442" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3444" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-3446" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3447" href="../Lists/#plfa_plfa-part1-Lists-3447" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3449" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3451" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-3454" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3456" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3458" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3463" href="../Lists/#plfa_plfa-part1-Lists-3447" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3465" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3467" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3472" href="../Lists/#plfa_plfa-part1-Lists-3447" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3474" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3476" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3481" href="../Lists/#plfa_plfa-part1-Lists-3447" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-3483" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-3492" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3495" href="../Lists/#plfa_plfa-part1-Lists-3495" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3499" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3502" href="../Lists/#plfa_plfa-part1-Lists-3495" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-3505" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3506" href="../Lists/#plfa_plfa-part1-Lists-3506" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3508" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3510" href="../Lists/#plfa_plfa-part1-Lists-3510" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-3512" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-3514" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3517" href="../Lists/#plfa_plfa-part1-Lists-3517" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3521" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3524" href="../Lists/#plfa_plfa-part1-Lists-3506" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3526" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3528" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3529" href="../Lists/#plfa_plfa-part1-Lists-3510" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-3532" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3535" href="../Lists/#plfa_plfa-part1-Lists-3517" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-3537" class="Symbol">)</a>
</pre><p>The type <code>A</code> is an implicit argument to append, making it a <em>polymorphic</em> function (one that can be used at many types). A list appended to the empty list yields the list itself. A list appended to a non-empty list yields a list with the head the same as the head of the non-empty list, and a tail the same as the other list appended to tail of the non-empty list.</p>Here is an example, showing how to compute the result of appending two lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-3995" href="../Lists/#plfa_plfa-part1-Lists-3995" class="Function">_</a> <a id="plfa_plfa-part1-Lists-3997" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3999" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4001" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4003" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4005" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4007" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4009" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4011" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4013" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4016" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4018" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4020" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4022" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4024" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4026" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4028" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4030" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4032" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4034" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4036" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4038" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4040" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4042" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4044" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4046" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4048" href="../Lists/#plfa_plfa-part1-Lists-2933" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-4050" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-4052" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4056" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4066" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4068" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4070" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4072" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4074" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4076" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4078" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4081" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4084" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4086" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4088" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4090" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4092" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4097" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4105" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4107" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4109" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4110" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4112" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4114" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4116" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4118" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4121" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4124" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4126" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4128" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4130" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4132" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4134" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4138" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4146" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4148" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4150" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4152" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4154" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4155" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4157" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4159" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4162" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4165" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4167" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4169" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4171" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4173" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4175" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4179" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4187" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4189" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4191" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4193" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4195" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4197" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4199" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4200" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4203" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4206" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4208" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4210" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4212" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4214" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4216" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4220" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4228" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4230" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4232" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4234" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4236" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4238" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4240" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4242" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4244" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4246" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4248" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4253" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Appending two lists requires time linear in the number of elements in the first list.</p><h2 id="reasoning-about-append">Reasoning about append</h2>We can reason about lists in much the same way that we reason about numbers. Here is the proof that append is associative:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-4506" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4515" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4517" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4519" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4520" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4522" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4524" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4527" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4529" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4530" href="../Lists/#plfa_plfa-part1-Lists-4530" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4533" href="../Lists/#plfa_plfa-part1-Lists-4533" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4536" href="../Lists/#plfa_plfa-part1-Lists-4536" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4539" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4541" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4546" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Bound">A</a><a id="plfa_plfa-part1-Lists-4547" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4551" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4553" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4554" href="../Lists/#plfa_plfa-part1-Lists-4530" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4557" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4560" href="../Lists/#plfa_plfa-part1-Lists-4533" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4562" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4564" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4567" href="../Lists/#plfa_plfa-part1-Lists-4536" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4570" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4572" href="../Lists/#plfa_plfa-part1-Lists-4530" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4575" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4578" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4579" href="../Lists/#plfa_plfa-part1-Lists-4533" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4582" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4585" href="../Lists/#plfa_plfa-part1-Lists-4536" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4587" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-4589" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4598" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4601" href="../Lists/#plfa_plfa-part1-Lists-4601" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4604" href="../Lists/#plfa_plfa-part1-Lists-4604" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4607" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4611" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4621" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4622" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4625" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4628" href="../Lists/#plfa_plfa-part1-Lists-4601" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4630" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4632" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4635" href="../Lists/#plfa_plfa-part1-Lists-4604" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4640" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4648" href="../Lists/#plfa_plfa-part1-Lists-4601" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4651" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4654" href="../Lists/#plfa_plfa-part1-Lists-4604" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4659" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4667" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4670" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4673" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4674" href="../Lists/#plfa_plfa-part1-Lists-4601" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4677" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4680" href="../Lists/#plfa_plfa-part1-Lists-4604" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4682" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4686" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-4688" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4697" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4698" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4700" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4702" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4704" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4706" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4709" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4712" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4716" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4726" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4727" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4729" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4731" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4734" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4737" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4739" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4741" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4744" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4749" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4757" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4759" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4761" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4762" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4765" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4768" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4770" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4772" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4775" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4780" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4788" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4790" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4792" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-4794" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4797" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4800" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4802" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4804" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4807" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4809" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4813" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-4816" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-4821" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4822" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4824" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-4826" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4828" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4829" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4838" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4841" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4844" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4846" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4848" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-4854" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4856" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4858" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4859" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4862" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4865" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4866" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4869" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4872" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4874" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-4879" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4887" href="../Lists/#plfa_plfa-part1-Lists-4698" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4889" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4891" href="../Lists/#plfa_plfa-part1-Lists-4702" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4894" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4897" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4898" href="../Lists/#plfa_plfa-part1-Lists-4706" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4901" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4904" href="../Lists/#plfa_plfa-part1-Lists-4709" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4906" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4910" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>++-assoc xs ys zs</code>.</p><p>Recall that Agda supports <a href="../Induction/#sections">sections</a>. Applying <code>cong (x ∷_)</code> promotes the inductive hypothesis:</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>to the equality:</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>which is needed in the proof.</p>It is also easy to show that <code>[]</code> is a left and right identity for <code>_++_</code>. That it is a left identity is immediate from the definition:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-5703" href="../Lists/#plfa_plfa-part1-Lists-5703" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5716" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5718" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5720" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5721" href="../Lists/#plfa_plfa-part1-Lists-5721" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5723" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5725" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5728" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5730" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5731" href="../Lists/#plfa_plfa-part1-Lists-5731" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5734" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5736" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5741" href="../Lists/#plfa_plfa-part1-Lists-5721" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5742" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5744" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5746" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5749" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5752" href="../Lists/#plfa_plfa-part1-Lists-5731" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5755" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5757" href="../Lists/#plfa_plfa-part1-Lists-5731" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5760" href="../Lists/#plfa_plfa-part1-Lists-5703" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5773" href="../Lists/#plfa_plfa-part1-Lists-5773" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5776" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5780" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5790" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5793" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5796" href="../Lists/#plfa_plfa-part1-Lists-5773" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-5801" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5809" href="../Lists/#plfa_plfa-part1-Lists-5773" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-5814" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>That it is a right identity follows by simple induction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-5885" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-5898" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5900" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5902" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5903" href="../Lists/#plfa_plfa-part1-Lists-5903" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5905" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5907" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5910" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5912" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5913" href="../Lists/#plfa_plfa-part1-Lists-5913" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5916" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5918" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5923" href="../Lists/#plfa_plfa-part1-Lists-5903" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5924" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5926" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5928" href="../Lists/#plfa_plfa-part1-Lists-5913" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5931" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5934" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5937" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5939" href="../Lists/#plfa_plfa-part1-Lists-5913" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5942" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-5955" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5958" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5962" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5972" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5975" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5978" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5983" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5991" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5996" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-5998" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6011" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6012" href="../Lists/#plfa_plfa-part1-Lists-6012" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6014" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6016" href="../Lists/#plfa_plfa-part1-Lists-6016" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6018" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6020" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6024" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6034" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6035" href="../Lists/#plfa_plfa-part1-Lists-6012" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6037" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6039" href="../Lists/#plfa_plfa-part1-Lists-6016" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6041" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6043" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6046" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6051" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6059" href="../Lists/#plfa_plfa-part1-Lists-6012" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6061" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6063" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6064" href="../Lists/#plfa_plfa-part1-Lists-6016" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6067" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6070" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6072" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6076" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6079" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6084" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6085" href="../Lists/#plfa_plfa-part1-Lists-6012" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6087" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6089" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6091" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6092" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6105" href="../Lists/#plfa_plfa-part1-Lists-6016" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6107" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6109" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6115" href="../Lists/#plfa_plfa-part1-Lists-6012" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6117" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6119" href="../Lists/#plfa_plfa-part1-Lists-6016" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6124" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>As we will see later, these three properties establish that <code>_++_</code> and <code>[]</code> form a <em>monoid</em> over lists.</p><h2 id="length">Length</h2>Our next function finds the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-6300" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6307" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6309" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6311" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6312" href="../Lists/#plfa_plfa-part1-Lists-6312" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6314" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6319" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6321" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6323" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6328" href="../Lists/#plfa_plfa-part1-Lists-6312" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6330" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-6334" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6341" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-6351" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-6359" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6366" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6367" href="../Lists/#plfa_plfa-part1-Lists-6367" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6369" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6371" href="../Lists/#plfa_plfa-part1-Lists-6371" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6373" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-6376" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6379" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6383" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6384" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6391" href="../Lists/#plfa_plfa-part1-Lists-6371" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6393" class="Symbol">)</a>
</pre><p>Again, it takes an implicit parameter <code>A</code>. The length of the empty list is zero. The length of a non-empty list is one greater than the length of the tail of the list.</p>Here is an example showing how to compute the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-6640" href="../Lists/#plfa_plfa-part1-Lists-6640" class="Function">_</a> <a id="plfa_plfa-part1-Lists-6642" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6644" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6651" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-6653" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6655" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6657" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6659" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6661" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6663" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-6665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6667" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-6669" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-6671" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6675" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6685" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6692" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6693" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6695" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6697" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6699" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6701" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6703" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6705" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6707" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6711" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6719" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6723" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6724" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6731" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6732" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6734" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6736" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6738" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6740" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6742" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6755" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6759" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6760" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6764" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6765" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6772" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6773" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6775" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6777" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6779" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6785" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6793" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6797" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6798" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6802" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6803" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6807" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6808" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6815" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6816" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-6817" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6819" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6821" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6827" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6835" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6839" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6840" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6844" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6845" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6849" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-6853" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6858" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Computing the length of a list requires time linear in the number of elements in the list.</p><p>In the second-to-last line, we cannot write simply <code>length []</code> but must instead write <code>length {ℕ} []</code>. Since <code>[]</code> has no elements, Agda has insufficient information to infer the implicit parameter.</p><h2 id="reasoning-about-length">Reasoning about length</h2>The length of one list appended to another is the sum of the lengths of the lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-7275" href="../Lists/#plfa_plfa-part1-Lists-7275" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7285" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7287" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7289" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7290" href="../Lists/#plfa_plfa-part1-Lists-7290" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7292" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7294" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7297" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7299" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7300" href="../Lists/#plfa_plfa-part1-Lists-7300" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7303" href="../Lists/#plfa_plfa-part1-Lists-7303" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7306" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7308" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7313" href="../Lists/#plfa_plfa-part1-Lists-7290" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7314" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7318" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7320" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7327" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7328" href="../Lists/#plfa_plfa-part1-Lists-7300" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7331" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7334" href="../Lists/#plfa_plfa-part1-Lists-7303" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7336" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7338" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7340" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7347" href="../Lists/#plfa_plfa-part1-Lists-7300" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7350" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7352" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7359" href="../Lists/#plfa_plfa-part1-Lists-7303" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-7362" href="../Lists/#plfa_plfa-part1-Lists-7275" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7372" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7373" href="../Lists/#plfa_plfa-part1-Lists-7373" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7374" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7376" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7379" href="../Lists/#plfa_plfa-part1-Lists-7379" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7382" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7386" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7396" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7403" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7404" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7407" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7410" href="../Lists/#plfa_plfa-part1-Lists-7379" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7412" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7416" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7424" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7431" href="../Lists/#plfa_plfa-part1-Lists-7379" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7436" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7444" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7451" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7452" href="../Lists/#plfa_plfa-part1-Lists-7373" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7453" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7455" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7458" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7460" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7467" href="../Lists/#plfa_plfa-part1-Lists-7379" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7472" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7474" href="../Lists/#plfa_plfa-part1-Lists-7275" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7484" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7485" href="../Lists/#plfa_plfa-part1-Lists-7485" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7487" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7489" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7491" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7493" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7496" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7500" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7510" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7517" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-7519" href="../Lists/#plfa_plfa-part1-Lists-7485" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7521" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7523" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7525" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7527" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7530" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7532" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7536" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7544" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7548" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7549" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7556" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7557" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7560" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7563" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7565" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7570" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7573" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7578" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7582" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7583" href="../Lists/#plfa_plfa-part1-Lists-7275" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7593" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7596" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7598" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7600" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7606" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7610" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7611" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7618" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7621" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7623" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7630" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7632" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7636" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7644" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7651" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7652" href="../Lists/#plfa_plfa-part1-Lists-7485" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7654" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7656" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7658" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7660" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7662" href="../Lists/#plfa_plfa-part1-Lists-6300" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7669" href="../Lists/#plfa_plfa-part1-Lists-7493" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7674" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. As before, Agda cannot infer the implicit type parameter to <code>length</code>, and it must be given explicitly. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>length-++ xs ys</code>, and it is promoted by the congruence <code>cong suc</code>.</p><h2 id="reverse">Reverse</h2>Using append, it is easy to formulate a function to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-8302" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8310" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8312" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8314" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8315" href="../Lists/#plfa_plfa-part1-Lists-8315" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8317" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8319" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8322" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8324" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8326" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8331" href="../Lists/#plfa_plfa-part1-Lists-8315" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8333" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8335" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8340" href="../Lists/#plfa_plfa-part1-Lists-8315" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-8342" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8350" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8360" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8363" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-8366" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8374" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8375" href="../Lists/#plfa_plfa-part1-Lists-8375" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8377" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8379" href="../Lists/#plfa_plfa-part1-Lists-8379" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8381" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8384" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8387" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8395" href="../Lists/#plfa_plfa-part1-Lists-8379" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-8398" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8401" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8403" href="../Lists/#plfa_plfa-part1-Lists-8375" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8405" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a>
</pre><p>The reverse of the empty list is the empty list. The reverse of a non-empty list is the reverse of its tail appended to a unit list containing its head.</p>Here is an example showing how to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-8623" href="../Lists/#plfa_plfa-part1-Lists-8623" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8625" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8627" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8635" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8637" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8639" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8641" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8643" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8645" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8647" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8649" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8651" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8653" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8655" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8657" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8659" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8661" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8663" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-8665" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8667" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8671" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8681" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8689" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8690" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8692" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8694" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8696" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8698" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8700" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8702" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8704" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8708" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8716" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8725" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8727" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8729" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8731" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8733" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8735" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8737" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8740" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8742" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8744" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8748" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8756" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8757" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8765" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8766" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8768" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8770" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8772" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8774" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8777" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8779" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8781" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8782" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8784" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8787" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8789" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8791" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8795" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8803" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8805" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8813" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8816" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8819" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8821" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8823" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8824" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8826" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8829" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8831" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8833" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8834" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8836" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8839" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8841" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8843" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8847" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8855" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8857" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8860" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8863" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8865" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8867" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8868" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8870" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8873" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8875" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8877" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8878" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8880" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8883" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8885" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8887" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8891" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8899" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8901" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8904" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8907" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8909" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8911" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8913" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8915" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8918" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8920" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8922" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8924" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8926" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8929" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8931" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8933" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-8938" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8947" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8949" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8951" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8954" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8957" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8959" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8961" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8963" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8965" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8968" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8970" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8972" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-8977" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8985" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8987" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8989" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8990" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8993" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8996" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8998" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9000" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9002" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9004" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9007" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9009" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9011" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9016" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9024" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9025" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9027" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9029" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9031" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9033" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9035" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9037" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9040" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9042" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9044" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9049" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9057" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9059" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9061" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9062" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9064" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9066" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9069" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9072" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9074" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9076" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9078" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9082" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9090" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9092" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9094" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9096" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9099" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9102" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9105" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9107" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9109" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9111" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9115" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9123" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9125" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9127" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9129" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9131" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9133" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9135" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9140" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9148" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9150" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9152" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9154" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9156" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9158" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9160" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9164" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Reversing a list in this way takes time <em>quadratic</em> in the length of the list. This is because reverse ends up appending lists of lengths <code>1</code>, <code>2</code>, up to <code>n - 1</code>, where <code>n</code> is the length of the list being reversed, append takes time linear in the length of the first list, and the sum of the numbers up to <code>n - 1</code> is <code>n * (n - 1) / 2</code>. (We will validate that last fact in an exercise later in this chapter.)</p><h4 id="exercise-reverse--distrib-recommended">Exercise <code>reverse-++-distrib</code> (recommended)</h4><p>Show that the reverse of one list appended to another is the reverse of the second appended to the reverse of the first:</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><h4 id="exercise-reverse-involutive-recommended">Exercise <code>reverse-involutive</code> (recommended)</h4><p>A function is an <em>involution</em> if when applied twice it acts as the identity function. Show that reverse is an involution:</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><h2 id="faster-reverse">Faster reverse</h2>The definition above, while easy to reason about, is less efficient than one might expect since it takes time quadratic in the length of the list. The idea is that we generalise reverse to take an additional argument:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-10254" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10260" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10262" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10264" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10265" href="../Lists/#plfa_plfa-part1-Lists-10265" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10267" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10269" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10272" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10274" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10276" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10281" href="../Lists/#plfa_plfa-part1-Lists-10265" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10283" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10285" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10290" href="../Lists/#plfa_plfa-part1-Lists-10265" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10292" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10294" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10299" href="../Lists/#plfa_plfa-part1-Lists-10265" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10301" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10307" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-10316" href="../Lists/#plfa_plfa-part1-Lists-10316" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10320" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10323" href="../Lists/#plfa_plfa-part1-Lists-10316" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10326" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10332" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10333" href="../Lists/#plfa_plfa-part1-Lists-10333" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10335" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10337" href="../Lists/#plfa_plfa-part1-Lists-10337" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10339" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10341" href="../Lists/#plfa_plfa-part1-Lists-10341" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10345" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10348" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10354" href="../Lists/#plfa_plfa-part1-Lists-10337" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10357" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10358" href="../Lists/#plfa_plfa-part1-Lists-10333" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10360" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10362" href="../Lists/#plfa_plfa-part1-Lists-10341" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10364" class="Symbol">)</a>
</pre><p>The definition is by recursion on the first argument. The second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we recurse becomes <em>smaller</em>.</p>Shunt is related to reverse as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-10606" href="../Lists/#plfa_plfa-part1-Lists-10606" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10620" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10622" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10624" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10625" href="../Lists/#plfa_plfa-part1-Lists-10625" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10627" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10629" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10632" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10634" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10635" href="../Lists/#plfa_plfa-part1-Lists-10635" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10638" href="../Lists/#plfa_plfa-part1-Lists-10638" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10641" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10643" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10648" href="../Lists/#plfa_plfa-part1-Lists-10625" class="Bound">A</a><a id="plfa_plfa-part1-Lists-10649" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10653" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10655" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10661" href="../Lists/#plfa_plfa-part1-Lists-10635" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10664" href="../Lists/#plfa_plfa-part1-Lists-10638" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10667" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-10669" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10677" href="../Lists/#plfa_plfa-part1-Lists-10635" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10680" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10683" href="../Lists/#plfa_plfa-part1-Lists-10638" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10686" href="../Lists/#plfa_plfa-part1-Lists-10606" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10700" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10703" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10706" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10710" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-10720" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10726" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10729" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10734" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10742" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10747" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10755" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10763" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10766" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10769" href="../Lists/#plfa_plfa-part1-Lists-10703" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10774" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-10776" href="../Lists/#plfa_plfa-part1-Lists-10606" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10790" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10791" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10793" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10795" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10797" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10799" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10802" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10806" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-10816" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10822" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10823" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10825" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10827" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10829" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10831" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10836" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10844" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10850" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10853" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10854" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10856" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10858" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10860" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10864" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-10867" href="../Lists/#plfa_plfa-part1-Lists-10606" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10881" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10884" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10885" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10887" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10889" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10891" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10893" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-10899" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10907" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10910" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10913" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10914" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10916" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10918" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10920" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10924" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10932" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10940" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10943" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10946" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10947" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10949" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10951" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-10953" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10956" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10958" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10962" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-10965" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-10969" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10970" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-10979" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10980" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10988" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10990" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10992" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-10994" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10996" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-10998" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11000" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11002" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11008" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11009" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11017" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11020" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11023" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11025" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11027" href="../Lists/#plfa_plfa-part1-Lists-2793" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11028" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11030" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11033" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11038" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11046" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11054" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11055" href="../Lists/#plfa_plfa-part1-Lists-10791" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11057" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11059" href="../Lists/#plfa_plfa-part1-Lists-10795" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11061" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11063" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11066" href="../Lists/#plfa_plfa-part1-Lists-10799" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11071" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code> and follows by the inductive hypothesis and associativity of append. When we invoke the inductive hypothesis, the second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we induct becomes <em>smaller</em>.</p><p>Generalising on an auxiliary argument, which becomes larger as the argument on which we recurse or induct becomes smaller, is a common trick. It belongs in your quiver of arrows, ready to slay the right problem.</p>Having defined shunt be generalisation, it is now easy to respecialise to give a more efficient definition of reverse:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-11834" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-11843" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11845" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-11847" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-11848" href="../Lists/#plfa_plfa-part1-Lists-11848" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-11850" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11852" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-11855" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-11857" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-11859" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-11864" href="../Lists/#plfa_plfa-part1-Lists-11848" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-11866" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-11868" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-11873" href="../Lists/#plfa_plfa-part1-Lists-11848" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-11875" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-11884" href="../Lists/#plfa_plfa-part1-Lists-11884" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11887" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-11889" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11895" href="../Lists/#plfa_plfa-part1-Lists-11884" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11898" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
</pre>Given our previous lemma, it is straightforward to show the two definitions equivalent:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-12002" href="../Lists/#plfa_plfa-part1-Lists-12002" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12011" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12013" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12015" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12016" href="../Lists/#plfa_plfa-part1-Lists-12016" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12018" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12020" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12023" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12025" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12026" href="../Lists/#plfa_plfa-part1-Lists-12026" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12029" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12031" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12036" href="../Lists/#plfa_plfa-part1-Lists-12016" class="Bound">A</a><a id="plfa_plfa-part1-Lists-12037" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12041" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12043" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12052" href="../Lists/#plfa_plfa-part1-Lists-12026" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12055" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12057" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12065" href="../Lists/#plfa_plfa-part1-Lists-12026" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-12068" href="../Lists/#plfa_plfa-part1-Lists-12002" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12077" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12080" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12084" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12094" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12103" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12108" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12116" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12122" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12125" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12130" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12133" href="../Lists/#plfa_plfa-part1-Lists-10606" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-12147" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12150" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12153" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12159" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12167" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12170" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-12173" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12178" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12181" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-12194" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12195" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12203" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-12205" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12207" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12213" href="../Lists/#plfa_plfa-part1-Lists-8302" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12221" href="../Lists/#plfa_plfa-part1-Lists-12077" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12226" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>Here is an example showing fast reverse of the list <code>[ 0 , 1 , 2 ]</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-12310" href="../Lists/#plfa_plfa-part1-Lists-12310" class="Function">_</a> <a id="plfa_plfa-part1-Lists-12312" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12314" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12323" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12325" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12327" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12329" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12331" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12333" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12335" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-12337" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12339" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12341" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12343" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12345" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12347" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12349" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12351" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-12353" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-12355" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12359" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12369" href="../Lists/#plfa_plfa-part1-Lists-11834" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12378" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12379" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12381" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12383" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12385" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12387" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12389" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12391" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12393" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12397" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12405" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12411" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12412" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12414" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12416" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12418" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12420" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12422" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12424" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12426" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12428" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12433" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12441" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12447" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12448" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12450" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12452" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12454" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12456" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12458" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12460" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12461" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12463" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12465" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12467" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12471" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12479" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12485" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12486" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12488" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12490" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12492" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12494" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12495" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12497" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12499" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12501" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12503" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12505" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12509" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12517" href="../Lists/#plfa_plfa-part1-Lists-10254" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12523" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12526" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12527" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12529" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12531" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12533" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12535" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12537" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12539" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12541" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12545" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12553" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12555" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12557" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12559" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12561" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12563" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12565" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12570" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Now the time to reverse a list is linear in the length of the list.</p><h2 id="Map">Map</h2>Map applies a function to every element of a list to generate a corresponding list. Map is an example of a <em>higher-order function</em>, one which takes a function as an argument or returns a function as a result:<pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-12877" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-12881" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12883" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12885" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12886" href="../Lists/#plfa_plfa-part1-Lists-12886" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12888" href="../Lists/#plfa_plfa-part1-Lists-12888" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-12890" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12892" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12895" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12897" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12899" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12900" href="../Lists/#plfa_plfa-part1-Lists-12886" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12902" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12904" href="../Lists/#plfa_plfa-part1-Lists-12888" class="Bound">B</a><a id="plfa_plfa-part1-Lists-12905" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12907" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12909" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12914" href="../Lists/#plfa_plfa-part1-Lists-12886" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12916" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12918" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12923" href="../Lists/#plfa_plfa-part1-Lists-12888" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-12925" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-12929" href="../Lists/#plfa_plfa-part1-Lists-12929" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-12931" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-12941" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-12944" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-12947" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-12951" href="../Lists/#plfa_plfa-part1-Lists-12951" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-12953" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12954" href="../Lists/#plfa_plfa-part1-Lists-12954" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-12956" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12958" href="../Lists/#plfa_plfa-part1-Lists-12958" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-12960" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-12963" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-12966" href="../Lists/#plfa_plfa-part1-Lists-12951" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-12968" href="../Lists/#plfa_plfa-part1-Lists-12954" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-12970" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12972" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-12976" href="../Lists/#plfa_plfa-part1-Lists-12951" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-12978" href="../Lists/#plfa_plfa-part1-Lists-12958" class="Bound">xs</a>
</pre><p>Map of the empty list is the empty list. Map of a non-empty list yields a list with head the same as the function applied to the head of the given list, and tail the same as map of the function applied to the tail of the given list.</p>Here is an example showing how to use map to increment every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-13307" href="../Lists/#plfa_plfa-part1-Lists-13307" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13309" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13311" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13315" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13319" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13321" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13323" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13325" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13327" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13329" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13331" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13333" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13335" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13337" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13339" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13341" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13343" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13345" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13347" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13349" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13351" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13355" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13365" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13369" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13373" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13374" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13376" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13378" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13380" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13382" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13384" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13386" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13388" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13392" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13400" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13404" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13406" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13408" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13412" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13416" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13417" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13419" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13421" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13423" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13425" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13427" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13431" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13439" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13443" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13445" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13447" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13451" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13453" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13455" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13459" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13463" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13464" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13466" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13468" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13470" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13474" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13482" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13486" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13488" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13490" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13494" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13496" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13498" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13502" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13504" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13506" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13510" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13514" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13519" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13527" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13531" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13533" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13535" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13539" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13541" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13543" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13547" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13549" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13551" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13556" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13564" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13566" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13568" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13570" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13572" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13574" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13576" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13581" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Map requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying map to a function to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-13800" href="../Lists/#plfa_plfa-part1-Lists-13800" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13805" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13807" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13812" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-13814" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13816" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13821" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-13823" href="../Lists/#plfa_plfa-part1-Lists-13800" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13828" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-13830" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13834" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-13839" href="../Lists/#plfa_plfa-part1-Lists-13839" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13841" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13843" href="../Lists/#plfa_plfa-part1-Lists-13800" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13848" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13850" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13852" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13854" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13856" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13858" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13860" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13862" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13864" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13866" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13868" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13870" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13872" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13874" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13876" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13878" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13880" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13884" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13894" href="../Lists/#plfa_plfa-part1-Lists-13800" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13899" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13901" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13903" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13905" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13907" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13909" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13911" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-13915" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13923" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13927" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13931" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13933" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13935" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13937" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13939" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13941" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13943" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-13947" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13955" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13957" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13959" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13961" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13963" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13965" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13967" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-13971" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>A type that is parameterised on another type, such as list, often has a corresponding map, which accepts a function and returns a function from the type parameterised on the domain of the function to the type parameterised on the range of the function. Further, a type that is parameterised on <em>n</em> types often has a map that is parameterised on <em>n</em> functions.</p><h4 id="exercise-map-compose-practice">Exercise <code>map-compose</code> (practice)</h4><p>Prove that the map of a composition is equal to the composition of two maps:</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>The last step of the proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-14552" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map--distribute-practice">Exercise <code>map-++-distribute</code> (practice)</h4><p>Prove the following relationship between map and append:</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-14737" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-tree-practice">Exercise <code>map-Tree</code> (practice)</h4>Define a type of trees with leaves of type <code>A</code> and internal nodes of type <code>B</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-14889" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-14894" href="../Lists/#plfa_plfa-part1-Lists-14894" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14899" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14900" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14902" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-14904" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14906" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-14909" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14911" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14913" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-14917" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-14925" href="../Lists/#plfa_plfa-part1-Lists-14925" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-14930" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14932" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14934" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14936" href="../Lists/#plfa_plfa-part1-Lists-14894" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14941" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14943" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-14947" href="../Lists/#plfa_plfa-part1-Lists-14947" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-14952" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14954" href="../Lists/#plfa_plfa-part1-Lists-14894" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14959" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14961" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-14963" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14965" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-14967" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14969" href="../Lists/#plfa_plfa-part1-Lists-14894" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14974" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14976" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-14978" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14980" href="../Lists/#plfa_plfa-part1-Lists-14894" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14985" href="../Lists/#plfa_plfa-part1-Lists-14900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14987" href="../Lists/#plfa_plfa-part1-Lists-14902" class="Bound">B</a>
</pre><p>Define a suitable map operator over trees:</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15121" class="Comment">-- Your code goes here</a>
</pre><h2 id="Fold">Fold</h2>Fold takes an operator and a value, and uses the operator to combine each of the elements of the list, taking the given value as the result for the empty list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-15334" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15340" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15342" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15344" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15345" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15347" href="../Lists/#plfa_plfa-part1-Lists-15347" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15349" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15351" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15354" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15356" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15358" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15359" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15361" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15363" href="../Lists/#plfa_plfa-part1-Lists-15347" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15365" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15367" href="../Lists/#plfa_plfa-part1-Lists-15347" class="Bound">B</a><a id="plfa_plfa-part1-Lists-15368" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15370" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15372" href="../Lists/#plfa_plfa-part1-Lists-15347" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15374" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15376" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15381" href="../Lists/#plfa_plfa-part1-Lists-15345" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15383" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15385" href="../Lists/#plfa_plfa-part1-Lists-15347" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-15387" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15393" href="../Lists/#plfa_plfa-part1-Lists-15393" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15397" href="../Lists/#plfa_plfa-part1-Lists-15397" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15399" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-15409" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15412" href="../Lists/#plfa_plfa-part1-Lists-15397" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-15414" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15420" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15424" href="../Lists/#plfa_plfa-part1-Lists-15424" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15426" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15427" href="../Lists/#plfa_plfa-part1-Lists-15427" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15429" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15431" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15433" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-15436" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15439" href="../Lists/#plfa_plfa-part1-Lists-15427" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15441" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-15443" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15449" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15453" href="../Lists/#plfa_plfa-part1-Lists-15424" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15455" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">xs</a>
</pre><p>Fold of the empty list is the given value. Fold of a non-empty list uses the operator to combine the head of the list and the fold of the tail of the list.</p>Here is an example showing how to use fold to find the sum of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15697" href="../Lists/#plfa_plfa-part1-Lists-15697" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15699" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15701" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15707" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15711" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15713" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15715" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15717" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15719" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15721" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15723" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15725" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15727" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15729" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15731" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15733" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-15736" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15738" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15742" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15752" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15758" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15762" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15764" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15765" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15767" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15769" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15771" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15773" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15775" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15777" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15779" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15781" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15783" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15787" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15795" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15797" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15799" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15805" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15809" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15811" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15812" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15814" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15816" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15818" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15820" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15822" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15824" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15826" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15830" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15838" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15840" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15842" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15843" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15845" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15847" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15853" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15857" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15859" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15860" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15862" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15864" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15866" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15868" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15870" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-15875" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15883" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15885" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15887" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15888" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15890" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15892" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15893" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15895" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15897" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15903" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15907" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15909" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15910" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15912" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15914" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15916" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-15922" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15930" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15932" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15934" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15935" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15937" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15940" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15942" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15944" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15945" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15947" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15949" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15955" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15959" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15961" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15963" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-15969" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15977" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15979" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15981" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15982" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15984" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15986" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15987" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15989" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15991" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15992" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15994" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15996" class="Number">0</a><a id="plfa_plfa-part1-Lists-15997" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16003" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Here we have an instance of <code>foldr</code> where <code>A</code> and <code>B</code> are both <code>ℕ</code>. Fold requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying fold to an operator and a value to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-16305" href="../Lists/#plfa_plfa-part1-Lists-16305" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16309" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16311" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16316" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-16318" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16320" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-16322" href="../Lists/#plfa_plfa-part1-Lists-16305" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16326" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-16328" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16334" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16338" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-16341" href="../Lists/#plfa_plfa-part1-Lists-16341" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16343" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16345" href="../Lists/#plfa_plfa-part1-Lists-16305" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16349" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16351" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16353" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16355" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16357" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16359" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16361" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16363" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16365" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16367" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16369" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16372" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16374" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16378" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16388" href="../Lists/#plfa_plfa-part1-Lists-16305" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16392" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16394" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16396" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16398" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16400" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16402" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16404" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16406" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16408" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16412" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16420" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16426" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16430" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16432" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16434" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16436" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16438" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16440" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16442" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16444" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16446" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16448" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16452" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16460" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-16465" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>Just as the list type has two constructors, <code>[]</code> and <code>_∷_</code>, so the fold function takes two arguments, <code>e</code> and <code>_⊗_</code> (in addition to the list argument). In general, a data type with <em>n</em> constructors will have a corresponding fold function that takes <em>n</em> arguments.</p><p>As another example, observe that</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Here, if <code>xs</code> is of type <code>List A</code>, then we see we have an instance of <code>foldr</code> where <code>A</code> is <code>A</code> and <code>B</code> is <code>List A</code>. It follows that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>Demonstrating both these equations is left as an exercise.</p><h4 id="exercise-product-recommended">Exercise <code>product</code> (recommended)</h4><p>Use fold to define a function to find the product of a list of numbers. For example:</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17193" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--recommended">Exercise <code>foldr-++</code> (recommended)</h4><p>Show that fold and append are related as follows:</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17380" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17565" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-foldr-practice">Exercise <code>map-is-foldr</code> (practice)</h4><p>Show that map can be defined using fold:</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>The proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-17762" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-fold-tree-practice">Exercise <code>fold-Tree</code> (practice)</h4><p>Define a suitable fold function for the type of trees given earlier:</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17983" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-fold-tree-practice">Exercise <code>map-is-fold-Tree</code> (practice)</h4><p>Demonstrate an analogue of <code>map-is-foldr</code> for the type of trees.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18130" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-sum-downfrom-stretch">Exercise <code>sum-downFrom</code> (stretch)</h4>Define a function that counts down as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-18253" href="../Lists/#plfa_plfa-part1-Lists-18253" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18262" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18264" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-18266" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18268" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-18273" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-18275" href="../Lists/#plfa_plfa-part1-Lists-18253" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18284" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-18293" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18296" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-18299" href="../Lists/#plfa_plfa-part1-Lists-18253" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18308" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18309" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-18313" href="../Lists/#plfa_plfa-part1-Lists-18313" class="Bound">n</a><a id="plfa_plfa-part1-Lists-18314" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-18317" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18320" href="../Lists/#plfa_plfa-part1-Lists-18313" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-18322" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-18324" href="../Lists/#plfa_plfa-part1-Lists-18253" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18333" href="../Lists/#plfa_plfa-part1-Lists-18313" class="Bound">n</a>
</pre>For example:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18360" href="../Lists/#plfa_plfa-part1-Lists-18360" class="Function">_</a> <a id="plfa_plfa-part1-Lists-18362" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18364" href="../Lists/#plfa_plfa-part1-Lists-18253" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18373" class="Number">3</a> <a id="plfa_plfa-part1-Lists-18375" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18377" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-18379" class="Number">2</a> <a id="plfa_plfa-part1-Lists-18381" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18383" class="Number">1</a> <a id="plfa_plfa-part1-Lists-18385" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18387" class="Number">0</a> <a id="plfa_plfa-part1-Lists-18389" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-18391" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-18393" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-18395" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre><p>Prove that the sum of the numbers <code>(n - 1) + ⋯ + 0</code> is equal to <code>n * (n ∸ 1) / 2</code>:</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><h2 id="monoids">Monoids</h2><p>Typically when we use a fold the operator is associative and the value is a left and right identity for the operator, meaning that the operator and the value form a <em>monoid</em>.</p>We can define a monoid as a suitable record type:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18775" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-18782" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-18791" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-18792" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18794" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18796" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-18799" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-18801" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18802" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-18806" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18808" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18810" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18812" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-18814" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18816" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a><a id="plfa_plfa-part1-Lists-18817" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18819" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18820" href="../Lists/#plfa_plfa-part1-Lists-18820" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-18822" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18824" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a><a id="plfa_plfa-part1-Lists-18825" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18827" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18829" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-18833" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-18841" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-18851" href="../Lists/#plfa_plfa-part1-Lists-18851" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-18857" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18859" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-18861" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18862" href="../Lists/#plfa_plfa-part1-Lists-18862" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18864" href="../Lists/#plfa_plfa-part1-Lists-18864" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-18866" href="../Lists/#plfa_plfa-part1-Lists-18866" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-18868" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18870" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a><a id="plfa_plfa-part1-Lists-18871" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18873" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18875" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18876" href="../Lists/#plfa_plfa-part1-Lists-18862" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18878" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18880" href="../Lists/#plfa_plfa-part1-Lists-18864" class="Bound">y</a><a id="plfa_plfa-part1-Lists-18881" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18883" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18885" href="../Lists/#plfa_plfa-part1-Lists-18866" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-18887" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18889" href="../Lists/#plfa_plfa-part1-Lists-18862" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18891" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18893" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18894" href="../Lists/#plfa_plfa-part1-Lists-18864" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-18896" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18898" href="../Lists/#plfa_plfa-part1-Lists-18866" class="Bound">z</a><a id="plfa_plfa-part1-Lists-18899" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-18905" href="../Lists/#plfa_plfa-part1-Lists-18905" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-18915" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18917" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-18919" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18920" href="../Lists/#plfa_plfa-part1-Lists-18920" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18922" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18924" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a><a id="plfa_plfa-part1-Lists-18925" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18927" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18929" href="../Lists/#plfa_plfa-part1-Lists-18820" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-18931" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18933" href="../Lists/#plfa_plfa-part1-Lists-18920" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18935" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18937" href="../Lists/#plfa_plfa-part1-Lists-18920" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-18943" href="../Lists/#plfa_plfa-part1-Lists-18943" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-18953" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18955" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-18957" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18958" href="../Lists/#plfa_plfa-part1-Lists-18958" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18960" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18962" href="../Lists/#plfa_plfa-part1-Lists-18792" class="Bound">A</a><a id="plfa_plfa-part1-Lists-18963" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-18965" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18967" href="../Lists/#plfa_plfa-part1-Lists-18958" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-18969" href="../Lists/#plfa_plfa-part1-Lists-18802" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-18971" href="../Lists/#plfa_plfa-part1-Lists-18820" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-18973" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18975" href="../Lists/#plfa_plfa-part1-Lists-18958" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-18978" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-18983" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Module">IsMonoid</a>
</pre>As examples, sum and zero, multiplication and one, and append and the empty list, are all examples of monoids:<pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-19116" href="../Lists/#plfa_plfa-part1-Lists-19116" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19125" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19127" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19136" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19140" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-19142" href="../Lists/#plfa_plfa-part1-Lists-19116" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19151" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19155" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19166" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19168" href="../Lists/#plfa_plfa-part1-Lists-18851" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19174" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19176" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13062" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-19188" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19190" href="../Lists/#plfa_plfa-part1-Lists-18905" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19200" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19202" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13163" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19218" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19220" href="../Lists/#plfa_plfa-part1-Lists-18943" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19230" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19232" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19248" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-19251" href="../Lists/#plfa_plfa-part1-Lists-19251" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19260" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19262" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19271" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-19275" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-19277" href="../Lists/#plfa_plfa-part1-Lists-19251" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19286" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19290" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19301" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19303" href="../Lists/#plfa_plfa-part1-Lists-18851" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19309" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19311" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#21046" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-19323" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19325" href="../Lists/#plfa_plfa-part1-Lists-18905" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19335" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19337" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#19946" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19353" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19355" href="../Lists/#plfa_plfa-part1-Lists-18943" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19365" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19367" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19383" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-19386" href="../Lists/#plfa_plfa-part1-Lists-19386" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19396" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19398" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19400" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19401" href="../Lists/#plfa_plfa-part1-Lists-19401" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19403" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19405" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19408" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19410" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19412" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19421" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19422" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19427" href="../Lists/#plfa_plfa-part1-Lists-19401" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19428" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19430" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-19435" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-19438" href="../Lists/#plfa_plfa-part1-Lists-19386" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19448" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19452" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19463" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19465" href="../Lists/#plfa_plfa-part1-Lists-18851" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19471" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19473" href="../Lists/#plfa_plfa-part1-Lists-4506" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-19486" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19488" href="../Lists/#plfa_plfa-part1-Lists-18905" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19498" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19500" href="../Lists/#plfa_plfa-part1-Lists-5703" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19517" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19519" href="../Lists/#plfa_plfa-part1-Lists-18943" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19529" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19531" href="../Lists/#plfa_plfa-part1-Lists-5885" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19548" class="Symbol">}</a>
</pre>If <code>_⊗_</code> and <code>e</code> form a monoid, then we can re-express fold on the same operator and an arbitrary value:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-19668" href="../Lists/#plfa_plfa-part1-Lists-19668" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-19681" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19683" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19685" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19686" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19688" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19690" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19693" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19695" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19696" href="../Lists/#plfa_plfa-part1-Lists-19696" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19700" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19702" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19704" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19706" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19708" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19710" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19711" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19713" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19714" href="../Lists/#plfa_plfa-part1-Lists-19714" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19716" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19718" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19719" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19721" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19723" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19732" href="../Lists/#plfa_plfa-part1-Lists-19696" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19736" href="../Lists/#plfa_plfa-part1-Lists-19714" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19738" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-19742" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19744" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19745" href="../Lists/#plfa_plfa-part1-Lists-19745" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-19748" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19750" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19755" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19756" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19759" href="../Lists/#plfa_plfa-part1-Lists-19759" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19761" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19763" href="../Lists/#plfa_plfa-part1-Lists-19686" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19764" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19766" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19768" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19774" href="../Lists/#plfa_plfa-part1-Lists-19696" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19778" href="../Lists/#plfa_plfa-part1-Lists-19759" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19780" href="../Lists/#plfa_plfa-part1-Lists-19745" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-19783" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19785" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19791" href="../Lists/#plfa_plfa-part1-Lists-19696" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19795" href="../Lists/#plfa_plfa-part1-Lists-19714" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19797" href="../Lists/#plfa_plfa-part1-Lists-19745" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-19800" href="../Lists/#plfa_plfa-part1-Lists-19696" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19802" href="../Lists/#plfa_plfa-part1-Lists-19759" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-19804" href="../Lists/#plfa_plfa-part1-Lists-19668" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-19817" href="../Lists/#plfa_plfa-part1-Lists-19817" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19821" href="../Lists/#plfa_plfa-part1-Lists-19821" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19823" href="../Lists/#plfa_plfa-part1-Lists-19823" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-19832" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-19835" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19837" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19841" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-19851" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19857" href="../Lists/#plfa_plfa-part1-Lists-19817" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19861" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19863" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-19868" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-19876" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-19880" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-19883" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-19887" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19888" href="../Lists/#plfa_plfa-part1-Lists-18905" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19898" href="../Lists/#plfa_plfa-part1-Lists-19823" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-19907" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a><a id="plfa_plfa-part1-Lists-19908" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19910" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-19916" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19917" href="../Lists/#plfa_plfa-part1-Lists-19821" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19919" href="../Lists/#plfa_plfa-part1-Lists-19817" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19921" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a><a id="plfa_plfa-part1-Lists-19922" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-19926" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-19934" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19940" href="../Lists/#plfa_plfa-part1-Lists-19817" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19944" href="../Lists/#plfa_plfa-part1-Lists-19821" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19946" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-19949" href="../Lists/#plfa_plfa-part1-Lists-19817" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19951" href="../Lists/#plfa_plfa-part1-Lists-19835" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-19955" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-19957" href="../Lists/#plfa_plfa-part1-Lists-19668" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-19970" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19974" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19976" href="../Lists/#plfa_plfa-part1-Lists-19976" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-19985" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19986" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19988" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-19990" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-19992" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19994" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19996" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20000" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20010" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20016" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20020" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20022" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20023" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20025" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20027" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20029" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20033" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20041" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20043" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20045" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20046" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20052" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20056" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20058" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20060" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20064" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20067" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-20072" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20073" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20075" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-20077" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20079" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20080" href="../Lists/#plfa_plfa-part1-Lists-19668" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20093" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20097" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20099" href="../Lists/#plfa_plfa-part1-Lists-19976" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20108" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20111" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20112" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20114" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20120" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20122" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20124" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20125" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20131" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20135" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20137" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20140" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20142" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20143" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20147" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20150" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20154" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20155" href="../Lists/#plfa_plfa-part1-Lists-18851" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-20161" href="../Lists/#plfa_plfa-part1-Lists-19976" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20170" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20172" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20173" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20179" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20183" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20185" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20187" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20189" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20190" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20192" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20198" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20199" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20201" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20203" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20209" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20213" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20215" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20217" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20219" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20221" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20225" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20233" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20239" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20243" href="../Lists/#plfa_plfa-part1-Lists-19974" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20245" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20246" href="../Lists/#plfa_plfa-part1-Lists-19986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20248" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20250" href="../Lists/#plfa_plfa-part1-Lists-19990" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20252" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20254" href="../Lists/#plfa_plfa-part1-Lists-19970" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20256" href="../Lists/#plfa_plfa-part1-Lists-19994" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20260" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre>In a previous exercise we showed the following.<pre class="Agda"><a id="plfa_plfa-part1-Lists-20323" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-20335" href="../Lists/#plfa_plfa-part1-Lists-20335" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-20344" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20346" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20348" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20349" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20351" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20353" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20356" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20358" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20359" href="../Lists/#plfa_plfa-part1-Lists-20359" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20363" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20365" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20367" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20369" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20371" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20373" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20374" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20376" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20377" href="../Lists/#plfa_plfa-part1-Lists-20377" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20379" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20381" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20382" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20384" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20385" href="../Lists/#plfa_plfa-part1-Lists-20385" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20388" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20391" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20393" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20398" href="../Lists/#plfa_plfa-part1-Lists-20349" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20399" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20401" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-20407" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20413" href="../Lists/#plfa_plfa-part1-Lists-20359" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20417" href="../Lists/#plfa_plfa-part1-Lists-20377" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20419" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20420" href="../Lists/#plfa_plfa-part1-Lists-20385" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20423" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20426" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20428" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20430" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20432" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20438" href="../Lists/#plfa_plfa-part1-Lists-20359" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20442" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20443" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20449" href="../Lists/#plfa_plfa-part1-Lists-20359" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20453" href="../Lists/#plfa_plfa-part1-Lists-20377" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20455" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20457" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20459" href="../Lists/#plfa_plfa-part1-Lists-20385" class="Bound">xs</a>
</pre>As a consequence we can decompose fold over append in a monoid into two folds as follows.<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-20565" href="../Lists/#plfa_plfa-part1-Lists-20565" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20581" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20583" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20585" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20586" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20588" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20590" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20593" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20595" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20596" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20600" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20602" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20604" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20606" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20608" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20610" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20611" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20613" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20614" href="../Lists/#plfa_plfa-part1-Lists-20614" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20616" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20618" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20619" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20621" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20623" href="../Lists/#plfa_plfa-part1-Lists-18782" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20632" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20636" href="../Lists/#plfa_plfa-part1-Lists-20614" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20638" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20642" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20644" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20645" href="../Lists/#plfa_plfa-part1-Lists-20645" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20648" href="../Lists/#plfa_plfa-part1-Lists-20648" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20651" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20653" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20658" href="../Lists/#plfa_plfa-part1-Lists-20586" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20659" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20661" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20663" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20669" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20673" href="../Lists/#plfa_plfa-part1-Lists-20614" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20675" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20676" href="../Lists/#plfa_plfa-part1-Lists-20645" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20679" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20682" href="../Lists/#plfa_plfa-part1-Lists-20648" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20684" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20686" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20688" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20694" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20698" href="../Lists/#plfa_plfa-part1-Lists-20614" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20700" href="../Lists/#plfa_plfa-part1-Lists-20645" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20703" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20705" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20711" href="../Lists/#plfa_plfa-part1-Lists-20596" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20715" href="../Lists/#plfa_plfa-part1-Lists-20614" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20717" href="../Lists/#plfa_plfa-part1-Lists-20648" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-20720" href="../Lists/#plfa_plfa-part1-Lists-20565" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20736" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20740" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20742" href="../Lists/#plfa_plfa-part1-Lists-20742" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-20751" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20754" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20757" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20761" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20771" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20777" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20781" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20783" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20784" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20787" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20790" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20792" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20796" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20799" href="../Lists/#plfa_plfa-part1-Lists-20335" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-20808" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20812" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20814" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20817" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20820" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20826" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20832" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20836" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20837" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20843" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20847" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20849" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20851" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20853" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-20858" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20861" href="../Lists/#plfa_plfa-part1-Lists-19668" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20874" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20878" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20880" href="../Lists/#plfa_plfa-part1-Lists-20742" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-20889" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20892" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20893" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20899" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20903" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20905" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20907" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20909" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20915" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20921" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20925" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20927" href="../Lists/#plfa_plfa-part1-Lists-20751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20930" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20932" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20938" href="../Lists/#plfa_plfa-part1-Lists-20736" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20942" href="../Lists/#plfa_plfa-part1-Lists-20740" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20944" href="../Lists/#plfa_plfa-part1-Lists-20754" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-20949" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><h4 id="exercise-foldl-practice">Exercise <code>foldl</code> (practice)</h4><p>Define a function <code>foldl</code> which is analogous to <code>foldr</code>, but where operations associate to the left rather than the right. For example:</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21241" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr-monoid-foldl-practice">Exercise <code>foldr-monoid-foldl</code> (practice)</h4><p>Show that if <code>_⊗_</code> and <code>e</code> form a monoid, then <code>foldr _⊗_ e</code> and <code>foldl _⊗_ e</code> always compute the same result.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-21437" class="Comment">-- Your code goes here</a>
</pre><h2 id="All">All</h2><p>We can also define predicates over lists. Two of the most important are <code>All</code> and <code>Any</code>.</p>Predicate <code>All P</code> holds if predicate <code>P</code> is satisfied by every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-21661" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-21666" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21670" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21671" href="../Lists/#plfa_plfa-part1-Lists-21671" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21673" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21675" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-21678" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21680" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21681" href="../Lists/#plfa_plfa-part1-Lists-21681" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21683" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21685" href="../Lists/#plfa_plfa-part1-Lists-21671" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21687" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21689" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-21692" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21694" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21696" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-21701" href="../Lists/#plfa_plfa-part1-Lists-21671" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21703" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21705" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-21709" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-21717" href="../Lists/#plfa_plfa-part1-Lists-21717" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-21721" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21723" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21727" href="../Lists/#plfa_plfa-part1-Lists-21681" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21729" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-21734" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-21738" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21740" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-21742" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21743" href="../Lists/#plfa_plfa-part1-Lists-21743" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21745" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21747" href="../Lists/#plfa_plfa-part1-Lists-21671" class="Bound">A</a><a id="plfa_plfa-part1-Lists-21748" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21750" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21751" href="../Lists/#plfa_plfa-part1-Lists-21751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21754" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21756" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-21761" href="../Lists/#plfa_plfa-part1-Lists-21671" class="Bound">A</a><a id="plfa_plfa-part1-Lists-21762" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21764" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21766" href="../Lists/#plfa_plfa-part1-Lists-21681" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21768" href="../Lists/#plfa_plfa-part1-Lists-21743" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21770" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21772" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21776" href="../Lists/#plfa_plfa-part1-Lists-21681" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21778" href="../Lists/#plfa_plfa-part1-Lists-21751" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21781" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21783" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21787" href="../Lists/#plfa_plfa-part1-Lists-21681" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21789" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21790" href="../Lists/#plfa_plfa-part1-Lists-21743" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21792" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-21794" href="../Lists/#plfa_plfa-part1-Lists-21751" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-21796" class="Symbol">)</a>
</pre><p>The type has two constructors, reusing the names of the same constructors for lists. The first asserts that <code>P</code> holds for every element of the empty list. The second asserts that if <code>P</code> holds of the head of a list and for every element of the tail of a list, then <code>P</code> holds for every element of the list. Agda uses types to disambiguate whether the constructor is building a list or evidence that <code>All P</code> holds.</p>For example, <code>All (_≤ 2)</code> holds of a list where every element is less than or equal to two. Recall that <code>z≤n</code> proves <code>zero ≤ n</code> for any <code>n</code>, and that if <code>m≤n</code> proves <code>m ≤ n</code> then <code>s≤s m≤n</code> proves <code>suc m ≤ suc n</code>, for any <code>m</code> and <code>n</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-22458" href="../Lists/#plfa_plfa-part1-Lists-22458" class="Function">_</a> <a id="plfa_plfa-part1-Lists-22460" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22462" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22466" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22467" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1535" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-22470" class="Number">2</a><a id="plfa_plfa-part1-Lists-22471" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22473" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-22475" class="Number">0</a> <a id="plfa_plfa-part1-Lists-22477" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22479" class="Number">1</a> <a id="plfa_plfa-part1-Lists-22481" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22483" class="Number">2</a> <a id="plfa_plfa-part1-Lists-22485" href="../Lists/#plfa_plfa-part1-Lists-2847" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-22487" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-22489" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-22491" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22495" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22497" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22501" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22505" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22507" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22511" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22512" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22516" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-22519" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22521" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22523" href="../Lists/#plfa_plfa-part1-Lists-21717" class="InductiveConstructor">[]</a>
</pre><p>Here <code>_∷_</code> and <code>[]</code> are the constructors of <code>All P</code> rather than of <code>List A</code>. The three items are proofs of <code>0 ≤ 2</code>, <code>1 ≤ 2</code>, and <code>2 ≤ 2</code>, respectively.</p><p>(One might wonder whether a pattern such as <code>[_,_,_]</code> can be used to construct values of type <code>All</code> as well as type <code>List</code>, since both use the same constructors. Indeed it can, so long as both types are in scope when the pattern is declared. That’s not the case here, since <code>List</code> is defined before <code>[_,_,_]</code>, but <code>All</code> is defined later.)</p><h2 id="any">Any</h2>Predicate <code>Any P</code> holds if predicate <code>P</code> is satisfied by some element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23122" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-23127" href="../Lists/#plfa_plfa-part1-Lists-23127" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23131" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23132" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23134" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23136" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23139" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23141" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23142" href="../Lists/#plfa_plfa-part1-Lists-23142" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23144" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23146" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23148" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23150" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23153" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23155" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23157" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23162" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23164" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23166" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-23170" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-23178" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-23184" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23186" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23188" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23189" href="../Lists/#plfa_plfa-part1-Lists-23189" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23193" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23194" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23196" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23197" href="../Lists/#plfa_plfa-part1-Lists-23197" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23200" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23202" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23207" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23208" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23210" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23212" href="../Lists/#plfa_plfa-part1-Lists-23142" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23214" href="../Lists/#plfa_plfa-part1-Lists-23189" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23216" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23218" href="../Lists/#plfa_plfa-part1-Lists-23127" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23222" href="../Lists/#plfa_plfa-part1-Lists-23142" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23224" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23225" href="../Lists/#plfa_plfa-part1-Lists-23189" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23227" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23229" href="../Lists/#plfa_plfa-part1-Lists-23197" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23231" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-23235" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-23241" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23243" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23245" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23246" href="../Lists/#plfa_plfa-part1-Lists-23246" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23248" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23250" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23251" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23253" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23254" href="../Lists/#plfa_plfa-part1-Lists-23254" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23257" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23259" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23264" href="../Lists/#plfa_plfa-part1-Lists-23132" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23265" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23267" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23269" href="../Lists/#plfa_plfa-part1-Lists-23127" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23273" href="../Lists/#plfa_plfa-part1-Lists-23142" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23275" href="../Lists/#plfa_plfa-part1-Lists-23254" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23278" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23280" href="../Lists/#plfa_plfa-part1-Lists-23127" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23284" href="../Lists/#plfa_plfa-part1-Lists-23142" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23286" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23287" href="../Lists/#plfa_plfa-part1-Lists-23246" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23289" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23291" href="../Lists/#plfa_plfa-part1-Lists-23254" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23293" class="Symbol">)</a>
</pre>The first constructor provides evidence that the head of the list satisfies <code>P</code>, while the second provides evidence that some element of the tail of the list satisfies <code>P</code>. For example, we can define list membership as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23536" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-23542" class="Number">4</a> <a id="plfa_plfa-part1-Lists-23544" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23548" href="../Lists/#plfa_plfa-part1-Lists-23623" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-23553" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23557" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23559" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23561" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23562" href="../Lists/#plfa_plfa-part1-Lists-23562" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23564" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23566" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23569" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23571" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23572" href="../Lists/#plfa_plfa-part1-Lists-23572" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23574" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23576" href="../Lists/#plfa_plfa-part1-Lists-23562" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23577" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23579" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23580" href="../Lists/#plfa_plfa-part1-Lists-23580" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23583" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23585" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23590" href="../Lists/#plfa_plfa-part1-Lists-23562" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23591" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23593" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23595" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23599" href="../Lists/#plfa_plfa-part1-Lists-23599" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23601" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23603" href="../Lists/#plfa_plfa-part1-Lists-23603" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23606" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23608" href="../Lists/#plfa_plfa-part1-Lists-23127" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23612" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23613" href="../Lists/#plfa_plfa-part1-Lists-23599" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23615" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-23617" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23619" href="../Lists/#plfa_plfa-part1-Lists-23603" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-23623" href="../Lists/#plfa_plfa-part1-Lists-23623" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-23627" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23629" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23631" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23632" href="../Lists/#plfa_plfa-part1-Lists-23632" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23634" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23636" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23639" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23641" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23642" href="../Lists/#plfa_plfa-part1-Lists-23642" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23644" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23646" href="../Lists/#plfa_plfa-part1-Lists-23632" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23647" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23649" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23650" href="../Lists/#plfa_plfa-part1-Lists-23650" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23653" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23655" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23660" href="../Lists/#plfa_plfa-part1-Lists-23632" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23661" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23663" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23665" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23669" href="../Lists/#plfa_plfa-part1-Lists-23669" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23671" href="../Lists/#plfa_plfa-part1-Lists-23623" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-23673" href="../Lists/#plfa_plfa-part1-Lists-23673" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23676" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23678" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-23680" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23681" href="../Lists/#plfa_plfa-part1-Lists-23669" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23683" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23685" href="../Lists/#plfa_plfa-part1-Lists-23673" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23687" class="Symbol">)</a>
</pre>For example, zero is an element of the list <code>[ 0 , 1 , 0 , 2 ]</code>. Indeed, we can demonstrate this fact in two different ways, corresponding to the two different occurrences of zero in the list, as the first element and as the third element:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23942" href="../Lists/#plfa_plfa-part1-Lists-23942" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23944" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23946" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23948" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23950" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23952" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23954" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23956" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23958" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23960" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23962" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23964" class="Number">2</a> <a id="plfa_plfa-part1-Lists-23966" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-23968" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-23970" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23972" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-23977" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-23983" href="../Lists/#plfa_plfa-part1-Lists-23983" class="Function">_</a> <a id="plfa_plfa-part1-Lists-23985" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23987" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23989" href="../Lists/#plfa_plfa-part1-Lists-23553" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23991" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-23993" class="Number">0</a> <a id="plfa_plfa-part1-Lists-23995" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-23997" class="Number">1</a> <a id="plfa_plfa-part1-Lists-23999" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24001" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24003" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24005" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24007" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24009" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24011" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24013" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24019" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24020" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24026" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24027" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24032" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-24036" class="Symbol">))</a>
</pre>Further, we can demonstrate that three is not in the list, because any possible proof that it is in the list leads to contradiction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-24184" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24193" class="Number">3</a> <a id="plfa_plfa-part1-Lists-24195" href="../Lists/#plfa_plfa-part1-Lists-23623" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-24197" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24199" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24201" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24203" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24205" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24207" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24209" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24211" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24213" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24215" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24222" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24223" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24228" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-24232" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24240" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24246" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24247" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24252" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-24257" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24264" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24265" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24271" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24272" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24279" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24284" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-24290" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24297" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24298" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24304" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24305" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24311" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24312" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24319" href="../Lists/#plfa_plfa-part1-Lists-23178" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24324" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-24331" href="../Lists/#plfa_plfa-part1-Lists-24184" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24338" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24339" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24345" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24346" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24352" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24353" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24359" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24360" href="../Lists/#plfa_plfa-part1-Lists-23235" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24366" class="Symbol">()))))</a>
</pre><p>The five occurrences of <code>()</code> attest to the fact that there is no possible evidence for <code>3 ≡ 0</code>, <code>3 ≡ 1</code>, <code>3 ≡ 0</code>, <code>3 ≡ 2</code>, and <code>3 ∈ []</code>, respectively.</p><h2 id="all-and-append">All and append</h2>A predicate holds for every element of one list appended to another if and only if it holds for every element of both lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-24681" href="../Lists/#plfa_plfa-part1-Lists-24681" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-24690" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24692" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24694" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24695" href="../Lists/#plfa_plfa-part1-Lists-24695" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24697" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24699" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24702" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24704" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24705" href="../Lists/#plfa_plfa-part1-Lists-24705" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24707" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24709" href="../Lists/#plfa_plfa-part1-Lists-24695" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24711" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24713" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24716" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24718" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24719" href="../Lists/#plfa_plfa-part1-Lists-24719" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24722" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24725" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24727" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24732" href="../Lists/#plfa_plfa-part1-Lists-24695" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24733" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24735" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-24739" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24743" href="../Lists/#plfa_plfa-part1-Lists-24705" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24745" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24746" href="../Lists/#plfa_plfa-part1-Lists-24719" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24749" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-24752" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24754" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24756" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-24758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24759" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24763" href="../Lists/#plfa_plfa-part1-Lists-24705" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24765" href="../Lists/#plfa_plfa-part1-Lists-24719" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24768" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-24770" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24774" href="../Lists/#plfa_plfa-part1-Lists-24705" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24776" href="../Lists/#plfa_plfa-part1-Lists-24722" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24778" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-24780" href="../Lists/#plfa_plfa-part1-Lists-24681" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-24789" href="../Lists/#plfa_plfa-part1-Lists-24789" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24792" href="../Lists/#plfa_plfa-part1-Lists-24792" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24795" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24799" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24810" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24812" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12063" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-24821" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-24824" href="../Lists/#plfa_plfa-part1-Lists-24879" class="Function">to</a> <a id="plfa_plfa-part1-Lists-24827" href="../Lists/#plfa_plfa-part1-Lists-24789" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24830" href="../Lists/#plfa_plfa-part1-Lists-24792" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-24837" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24839" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12080" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-24848" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-24851" href="../Lists/#plfa_plfa-part1-Lists-25104" class="Function">from</a> <a id="plfa_plfa-part1-Lists-24856" href="../Lists/#plfa_plfa-part1-Lists-24789" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24859" href="../Lists/#plfa_plfa-part1-Lists-24792" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-24866" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-24870" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-24879" href="../Lists/#plfa_plfa-part1-Lists-24879" class="Function">to</a> <a id="plfa_plfa-part1-Lists-24882" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24884" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24886" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24887" href="../Lists/#plfa_plfa-part1-Lists-24887" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24889" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24891" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24894" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24896" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24897" href="../Lists/#plfa_plfa-part1-Lists-24897" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24899" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24901" href="../Lists/#plfa_plfa-part1-Lists-24887" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24903" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24905" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24908" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24910" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24911" href="../Lists/#plfa_plfa-part1-Lists-24911" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24914" href="../Lists/#plfa_plfa-part1-Lists-24914" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24917" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24919" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24924" href="../Lists/#plfa_plfa-part1-Lists-24887" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24925" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24927" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-24933" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24937" href="../Lists/#plfa_plfa-part1-Lists-24897" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24940" href="../Lists/#plfa_plfa-part1-Lists-24911" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24943" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-24946" href="../Lists/#plfa_plfa-part1-Lists-24914" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24948" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24950" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24952" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24953" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24957" href="../Lists/#plfa_plfa-part1-Lists-24897" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24959" href="../Lists/#plfa_plfa-part1-Lists-24911" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24962" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-24964" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24968" href="../Lists/#plfa_plfa-part1-Lists-24897" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24970" href="../Lists/#plfa_plfa-part1-Lists-24914" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24972" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-24976" href="../Lists/#plfa_plfa-part1-Lists-24879" class="Function">to</a> <a id="plfa_plfa-part1-Lists-24979" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-24982" href="../Lists/#plfa_plfa-part1-Lists-24982" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24985" href="../Lists/#plfa_plfa-part1-Lists-24985" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-24989" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24991" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-24993" href="../Lists/#plfa_plfa-part1-Lists-21717" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-24996" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24998" href="../Lists/#plfa_plfa-part1-Lists-24985" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25002" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-25006" href="../Lists/#plfa_plfa-part1-Lists-24879" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25009" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25010" href="../Lists/#plfa_plfa-part1-Lists-25010" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25012" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25014" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25016" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25018" href="../Lists/#plfa_plfa-part1-Lists-25018" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25021" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25022" href="../Lists/#plfa_plfa-part1-Lists-25022" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25025" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25027" href="../Lists/#plfa_plfa-part1-Lists-25027" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-25034" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25036" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-25041" href="../Lists/#plfa_plfa-part1-Lists-24879" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25044" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25047" href="../Lists/#plfa_plfa-part1-Lists-25018" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25050" href="../Lists/#plfa_plfa-part1-Lists-25027" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-25060" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-25064" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-25066" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25068" href="../Lists/#plfa_plfa-part1-Lists-25068" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25072" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25074" href="../Lists/#plfa_plfa-part1-Lists-25074" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25078" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25080" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25082" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25084" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25087" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25089" href="../Lists/#plfa_plfa-part1-Lists-25068" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25093" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25095" href="../Lists/#plfa_plfa-part1-Lists-25074" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25099" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-25104" href="../Lists/#plfa_plfa-part1-Lists-25104" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25109" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25111" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25113" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25115" href="../Lists/#plfa_plfa-part1-Lists-25115" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25117" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25119" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25122" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25124" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25125" href="../Lists/#plfa_plfa-part1-Lists-25125" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25127" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25129" href="../Lists/#plfa_plfa-part1-Lists-25115" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25131" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25133" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25136" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25138" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25139" href="../Lists/#plfa_plfa-part1-Lists-25139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25142" href="../Lists/#plfa_plfa-part1-Lists-25142" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25145" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25147" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25152" href="../Lists/#plfa_plfa-part1-Lists-25115" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25153" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25155" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25161" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25165" href="../Lists/#plfa_plfa-part1-Lists-25125" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25167" href="../Lists/#plfa_plfa-part1-Lists-25139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25170" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25172" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25176" href="../Lists/#plfa_plfa-part1-Lists-25125" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25178" href="../Lists/#plfa_plfa-part1-Lists-25142" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25181" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25183" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25187" href="../Lists/#plfa_plfa-part1-Lists-25125" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25189" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25190" href="../Lists/#plfa_plfa-part1-Lists-25139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25193" href="../Lists/#plfa_plfa-part1-Lists-3437" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25196" href="../Lists/#plfa_plfa-part1-Lists-25142" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25198" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25202" href="../Lists/#plfa_plfa-part1-Lists-25104" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25207" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25210" href="../Lists/#plfa_plfa-part1-Lists-25210" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25213" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25215" href="../Lists/#plfa_plfa-part1-Lists-21717" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25218" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25220" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25224" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25226" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25228" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-25234" href="../Lists/#plfa_plfa-part1-Lists-25104" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25240" href="../Lists/#plfa_plfa-part1-Lists-25240" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25242" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25244" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25246" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25248" href="../Lists/#plfa_plfa-part1-Lists-25248" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25251" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25253" href="../Lists/#plfa_plfa-part1-Lists-25253" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25256" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25258" href="../Lists/#plfa_plfa-part1-Lists-25258" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25262" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25264" href="../Lists/#plfa_plfa-part1-Lists-25264" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25268" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25270" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25273" href="../Lists/#plfa_plfa-part1-Lists-25253" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25276" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25278" href="../Lists/#plfa_plfa-part1-Lists-25104" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25283" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25286" href="../Lists/#plfa_plfa-part1-Lists-25248" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25289" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25291" href="../Lists/#plfa_plfa-part1-Lists-25258" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25295" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25297" href="../Lists/#plfa_plfa-part1-Lists-25264" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25301" href="../Lists/#plfa_plfa-part1-Lists-826" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="exercise-any---recommended">Exercise <code>Any-++-⇔</code> (recommended)</h4><p>Prove a result similar to <code>All-++-⇔</code>, but with <code>Any</code> in place of <code>All</code>, and a suitable replacement for <code>_×_</code>. As a consequence, demonstrate an equivalence relating <code>_∈_</code> and <code>_++_</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25540" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all---stretch">Exercise <code>All-++-≃</code> (stretch)</h4><p>Show that the equivalence <code>All-++-⇔</code> can be extended to an isomorphism.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25685" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-recommended">Exercise <code>¬Any⇔All¬</code> (recommended)</h4><p>Show that <code>Any</code> and <code>All</code> satisfy a version of De Morgan’s Law:</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>(Can you see why it is important that here <code>_∘_</code> is generalised to arbitrary levels, as described in the section on <a href="../Equality/#unipoly">universe polymorphism</a>?)</p><p>Do we also have the following?</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>If so, prove; if not, explain why.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26137" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-stretch">Exercise <code>¬Any≃All¬</code> (stretch)</h4><p>Show that the equivalence <code>¬Any⇔All¬</code> can be extended to an isomorphism. You will need to use extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26321" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all--practice">Exercise <code>All-∀</code> (practice)</h4><p>Show that <code>All P xs</code> is isomorphic to <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26452" class="Comment">-- You code goes here</a>
</pre><h4 id="exercise-any--practice">Exercise <code>Any-∃</code> (practice)</h4><p>Show that <code>Any P xs</code> is isomorphic to <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26586" class="Comment">-- You code goes here</a>
</pre><h2 id="decidability-of-all">Decidability of All</h2>If we consider a predicate as a function that yields a boolean, it is easy to define an analogue of <code>All</code>, which returns true if a given predicate returns true for every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-26835" href="../Lists/#plfa_plfa-part1-Lists-26835" class="Function">all</a> <a id="plfa_plfa-part1-Lists-26839" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26841" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26843" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26844" href="../Lists/#plfa_plfa-part1-Lists-26844" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26846" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26848" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26851" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26853" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26855" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26856" href="../Lists/#plfa_plfa-part1-Lists-26844" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26858" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26860" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-26864" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26866" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26868" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-26873" href="../Lists/#plfa_plfa-part1-Lists-26844" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26875" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26877" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-26882" href="../Lists/#plfa_plfa-part1-Lists-26835" class="Function">all</a> <a id="plfa_plfa-part1-Lists-26886" href="../Lists/#plfa_plfa-part1-Lists-26886" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-26889" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-26892" href="../Lists/#plfa_plfa-part1-Lists-15334" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-26898" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-26902" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-26907" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-26909" href="../Lists/#plfa_plfa-part1-Lists-12877" class="Function">map</a> <a id="plfa_plfa-part1-Lists-26913" href="../Lists/#plfa_plfa-part1-Lists-26886" class="Bound">p</a>
</pre><p>The function can be written in a particularly compact style by using the higher-order functions <code>map</code> and <code>foldr</code>.</p>As one would hope, if we replace booleans by decidables there is again an analogue of <code>All</code>. First, return to the notion of a predicate <code>P</code> as a function of type <code>A → Set</code>, taking a value <code>x</code> of type <code>A</code> into evidence <code>P x</code> that a property holds for <code>x</code>. Say that a predicate <code>P</code> is <em>decidable</em> if we have a function that for a given <code>x</code> can decide <code>P x</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-27401" href="../Lists/#plfa_plfa-part1-Lists-27401" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27411" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27413" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27415" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27416" href="../Lists/#plfa_plfa-part1-Lists-27416" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27418" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27420" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27423" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27425" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27427" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27428" href="../Lists/#plfa_plfa-part1-Lists-27416" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27430" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27432" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27435" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27437" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27439" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-27443" href="../Lists/#plfa_plfa-part1-Lists-27401" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27453" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27454" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27455" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27457" href="../Lists/#plfa_plfa-part1-Lists-27457" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-27460" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27463" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27465" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27466" href="../Lists/#plfa_plfa-part1-Lists-27466" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27468" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27470" href="../Lists/#plfa_plfa-part1-Lists-27454" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27471" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27473" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1511" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-27479" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27480" href="../Lists/#plfa_plfa-part1-Lists-27457" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27482" href="../Lists/#plfa_plfa-part1-Lists-27466" class="Bound">x</a><a id="plfa_plfa-part1-Lists-27483" class="Symbol">)</a>
</pre>Then if predicate <code>P</code> is decidable, it is also decidable whether every element of a list satisfies the predicate:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-27611" href="../Lists/#plfa_plfa-part1-Lists-27611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27616" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27618" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27620" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27621" href="../Lists/#plfa_plfa-part1-Lists-27621" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27623" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27625" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27628" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27630" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27631" href="../Lists/#plfa_plfa-part1-Lists-27631" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27633" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27635" href="../Lists/#plfa_plfa-part1-Lists-27621" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27637" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27639" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27642" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27644" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27646" href="../Lists/#plfa_plfa-part1-Lists-27401" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27656" href="../Lists/#plfa_plfa-part1-Lists-27631" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27658" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27660" href="../Lists/#plfa_plfa-part1-Lists-27401" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27670" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27671" href="../Lists/#plfa_plfa-part1-Lists-21666" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27675" href="../Lists/#plfa_plfa-part1-Lists-27631" class="Bound">P</a><a id="plfa_plfa-part1-Lists-27676" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-27678" href="../Lists/#plfa_plfa-part1-Lists-27611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27683" href="../Lists/#plfa_plfa-part1-Lists-27683" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27686" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-27721" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27724" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27728" href="../Lists/#plfa_plfa-part1-Lists-21717" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-27731" href="../Lists/#plfa_plfa-part1-Lists-27611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27736" href="../Lists/#plfa_plfa-part1-Lists-27736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27739" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27740" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27742" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27744" href="../Lists/#plfa_plfa-part1-Lists-27744" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27746" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27748" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-27753" href="../Lists/#plfa_plfa-part1-Lists-27736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27756" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-27760" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27762" href="../Lists/#plfa_plfa-part1-Lists-27611" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27767" href="../Lists/#plfa_plfa-part1-Lists-27736" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27770" href="../Lists/#plfa_plfa-part1-Lists-27744" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-27773" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-27793" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27795" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27799" href="../Lists/#plfa_plfa-part1-Lists-27799" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27802" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27804" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27808" href="../Lists/#plfa_plfa-part1-Lists-27808" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-27816" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27819" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27823" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27824" href="../Lists/#plfa_plfa-part1-Lists-27799" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27827" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27829" href="../Lists/#plfa_plfa-part1-Lists-27808" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-27832" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-27834" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-27854" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27856" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-27859" href="../Lists/#plfa_plfa-part1-Lists-27859" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-27863" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27865" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-27877" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27880" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-27883" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-27886" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27887" href="../Lists/#plfa_plfa-part1-Lists-27887" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27890" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27892" href="../Lists/#plfa_plfa-part1-Lists-27892" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-27895" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27897" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27899" href="../Lists/#plfa_plfa-part1-Lists-27859" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-27903" href="../Lists/#plfa_plfa-part1-Lists-27887" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-27908" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-27910" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-27913" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-27930" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-27931" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-27932" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-27933" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-27939" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-27940" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-27941" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-27943" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-27944" href="../Lists/#plfa_plfa-part1-Lists-27944" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-27953" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27956" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-27959" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-27962" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27963" href="../Lists/#plfa_plfa-part1-Lists-27963" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27966" href="../Lists/#plfa_plfa-part1-Lists-21734" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27968" href="../Lists/#plfa_plfa-part1-Lists-27968" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-27971" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27973" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27975" href="../Lists/#plfa_plfa-part1-Lists-27944" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-27980" href="../Lists/#plfa_plfa-part1-Lists-27968" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-27984" class="Symbol">}</a>
</pre><p>If the list is empty, then trivially <code>P</code> holds for every element of the list. Otherwise, the structure of the proof is similar to that showing that the conjunction of two decidable propositions is itself decidable, using <code>_∷_</code> rather than <code>⟨_,_⟩</code> to combine the evidence for the head and tail of the list.</p><h4 id="exercise-any-stretch">Exercise <code>Any?</code> (stretch)</h4><p>Just as <code>All</code> has analogues <code>all</code> and <code>All?</code> which determine whether a predicate holds for every element of a list, so does <code>Any</code> have analogues <code>any</code> and <code>Any?</code> which determine whether a predicate holds for some element of a list. Give their definitions.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28597" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-split-stretch">Exercise <code>split</code> (stretch)</h4>The relation <code>merge</code> holds when two lists merge to give a third list.<pre class="Agda"><a id="plfa_plfa-part1-Lists-28737" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-28742" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28748" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28749" href="../Lists/#plfa_plfa-part1-Lists-28749" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-28751" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28753" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-28756" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-28758" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28760" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28761" href="../Lists/#plfa_plfa-part1-Lists-28761" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28764" href="../Lists/#plfa_plfa-part1-Lists-28764" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28767" href="../Lists/#plfa_plfa-part1-Lists-28767" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-28770" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28772" href="../Lists/#plfa_plfa-part1-Lists-1017" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-28777" href="../Lists/#plfa_plfa-part1-Lists-28749" class="Bound">A</a><a id="plfa_plfa-part1-Lists-28778" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28780" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28782" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-28786" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-28795" href="../Lists/#plfa_plfa-part1-Lists-28795" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28798" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-28806" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-28827" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28833" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28836" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28839" href="../Lists/#plfa_plfa-part1-Lists-1046" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-28845" href="../Lists/#plfa_plfa-part1-Lists-28845" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-28852" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28854" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-28856" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28857" href="../Lists/#plfa_plfa-part1-Lists-28857" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28859" href="../Lists/#plfa_plfa-part1-Lists-28859" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28862" href="../Lists/#plfa_plfa-part1-Lists-28862" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28865" href="../Lists/#plfa_plfa-part1-Lists-28865" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-28867" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-28873" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28875" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28881" href="../Lists/#plfa_plfa-part1-Lists-28859" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28884" href="../Lists/#plfa_plfa-part1-Lists-28862" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28887" href="../Lists/#plfa_plfa-part1-Lists-28865" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-28896" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-28927" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28929" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28935" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28936" href="../Lists/#plfa_plfa-part1-Lists-28857" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28938" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28940" href="../Lists/#plfa_plfa-part1-Lists-28859" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-28942" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28944" href="../Lists/#plfa_plfa-part1-Lists-28862" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28947" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28948" href="../Lists/#plfa_plfa-part1-Lists-28857" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28950" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28952" href="../Lists/#plfa_plfa-part1-Lists-28865" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-28954" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-28959" href="../Lists/#plfa_plfa-part1-Lists-28959" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-28967" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28969" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-28971" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28972" href="../Lists/#plfa_plfa-part1-Lists-28972" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-28974" href="../Lists/#plfa_plfa-part1-Lists-28974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28977" href="../Lists/#plfa_plfa-part1-Lists-28977" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28980" href="../Lists/#plfa_plfa-part1-Lists-28980" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-28982" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-28988" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28990" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28996" href="../Lists/#plfa_plfa-part1-Lists-28974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28999" href="../Lists/#plfa_plfa-part1-Lists-28977" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29002" href="../Lists/#plfa_plfa-part1-Lists-28980" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29011" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29042" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29044" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29050" href="../Lists/#plfa_plfa-part1-Lists-28974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29053" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29054" href="../Lists/#plfa_plfa-part1-Lists-28972" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29056" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29058" href="../Lists/#plfa_plfa-part1-Lists-28977" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-29060" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29062" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29063" href="../Lists/#plfa_plfa-part1-Lists-28972" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29065" href="../Lists/#plfa_plfa-part1-Lists-1061" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29067" href="../Lists/#plfa_plfa-part1-Lists-28980" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29069" class="Symbol">)</a>
</pre>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-29097" href="../Lists/#plfa_plfa-part1-Lists-29097" class="Function">_</a> <a id="plfa_plfa-part1-Lists-29099" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29101" href="../Lists/#plfa_plfa-part1-Lists-28742" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29107" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29109" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29111" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29113" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29115" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29117" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29119" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29121" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29123" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29125" href="../Lists/#plfa_plfa-part1-Lists-2816" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29127" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29129" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29131" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29133" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29135" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29137" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29139" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29141" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29143" href="../Lists/#plfa_plfa-part1-Lists-2886" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-29145" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-29147" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-29149" href="../Lists/#plfa_plfa-part1-Lists-28845" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29156" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29157" href="../Lists/#plfa_plfa-part1-Lists-28959" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29166" href="../Lists/#plfa_plfa-part1-Lists-28959" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29174" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29175" href="../Lists/#plfa_plfa-part1-Lists-28845" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29182" href="../Lists/#plfa_plfa-part1-Lists-28795" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-29184" class="Symbol">)))</a>

</pre><p>Given a decidable predicate and a list, we can split the list into two lists that merge to give the original list, where all elements of one list satisfy the predicate, and all elements of the other do not satisfy the predicate.</p><p>Define the following variant of the traditional <code>filter</code> function on lists, which given a decidable predicate and a list returns a list of elements that satisfy the predicate and a list of elements that don’t, with their corresponding proofs.</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-29820" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard Library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Lists-29960" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-29967" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-29977" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-29983" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29984" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-29988" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-29990" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-29994" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-29996" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4864" class="Function">length</a><a id="plfa_plfa-part1-Lists-30002" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30004" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#9817" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-30011" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30013" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#1544" class="Function">map</a><a id="plfa_plfa-part1-Lists-30016" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30018" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#4192" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-30023" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30025" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Base.html#6273" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-30033" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30035" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30042" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-30071" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30077" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30078" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-30081" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30083" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-30085" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30087" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-30090" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30092" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30099" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-30128" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30134" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30135" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-30138" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30140" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-30144" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30146" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-30151" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30153" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30160" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-30195" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30201" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30202" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-30205" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30207" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30214" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-30237" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30243" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30244" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#34556" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-30262" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30264" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3768" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-30275" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30277" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#3085" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-30291" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30293" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#16280" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-30301" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-30305" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-30314" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30315" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Properties.html#40456" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-30325" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-30328" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-30340" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30342" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30349" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-30368" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30374" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30375" href="https://agda.github.io/agda-stdlib/v1.7.1/Algebra.Structures.html#2801" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-30383" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30385" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30392" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-30407" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30413" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30414" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Unary.html#3536" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30423" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30425" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30432" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-30448" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30454" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30455" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30464" class="Symbol">)</a>
</pre><p>The standard library version of <code>IsMonoid</code> differs from the one given here, in that it is also parameterised on an equivalence relation.</p><p>Both <code>Relation.Unary</code> and <code>Relation.Binary</code> define a version of <code>Decidable</code>, one for unary relations (as used in this chapter where <code>P</code> ranges over unary predicates) and one for binary relations (as used earlier, where <code>_≤_</code> ranges over a binary relation).</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>