<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-MkpYfmkWIfATGEd6NpDhZJQB2nIkJDL4/+fTWrR8KGUYK4WpHdNkNtsOewHrkVqI4K1SrtjK7aC/fwQljbifBA==" title="Light" id="stylesheet-light"><link rel="alternate stylesheet" href="../assets/css/dark.css" integrity="sha512-T2Tad3PSo5pIHyLVaV57XanuJRwSgTPT+WVb96FUf6y0ZJIXP4d/lNPJUqbUZ3j0Nq/gej2yteryEz/Hkr2Cdg==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Negation</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Negation.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Negation: Negation, with intuitionistic and classical logic</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Negation-115" class="Keyword">module</a> <a id="plfa_plfa-part1-Negation-122" href="../Negation/#" class="Module">plfa.part1.Negation</a> <a id="plfa_plfa-part1-Negation-142" class="Keyword">where</a>
</pre><p>This chapter introduces negation, and discusses intuitionistic and classical logic.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Negation-258" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-263" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-270" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Negation-308" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-314" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-315" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Negation-318" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-320" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Negation-324" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-326" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-331" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-338" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Negation-347" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-353" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-354" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-355" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-357" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Negation-361" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-363" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Negation-366" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-368" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-373" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-380" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="plfa_plfa-part1-Negation-391" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-397" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-398" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a><a id="plfa_plfa-part1-Negation-399" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-401" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a><a id="plfa_plfa-part1-Negation-407" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-409" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-414" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-421" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Negation-430" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-436" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-437" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Negation-440" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-442" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Negation-446" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-448" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Negation-452" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-454" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-459" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-466" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Negation-479" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-485" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-486" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Product.html#1167" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Negation-489" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-491" class="Keyword">open</a> <a id="plfa_plfa-part1-Negation-496" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-503" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Negation-526" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-532" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-533" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Negation-536" class="Symbol">;</a> <a id="plfa_plfa-part1-Negation-538" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Negation-552" class="Symbol">)</a>
</pre><h2 id="negation">Negation</h2>Given a proposition <code>A</code>, the negation <code>¬ A</code> holds if <code>A</code> cannot hold. We formalise this idea by declaring negation to be the same as implication of false:<pre class="Agda"><a id="plfa_plfa-part1-Negation-¬_"></a><a id="plfa_plfa-part1-Negation-736" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬_</a> <a id="plfa_plfa-part1-Negation-739" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-741" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-745" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-747" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-751" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-753" href="../Negation/#plfa_plfa-part1-Negation-753" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-755" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-757" href="../Negation/#plfa_plfa-part1-Negation-753" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-759" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-761" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
</pre><p>This is a form of <em>reductio ad absurdum</em>: if assuming <code>A</code> leads to the conclusion <code>⊥</code> (an absurdity), then we must have <code>¬ A</code>.</p><p>Evidence that <code>¬ A</code> holds is of the form</p><pre><code>λ{ x → N }</code></pre><p>where <code>N</code> is a term of type <code>⊥</code> containing as a free variable <code>x</code> of type <code>A</code>. In other words, evidence that <code>¬ A</code> holds is a function that converts evidence that <code>A</code> holds into evidence that <code>⊥</code> holds.</p>Given evidence that both <code>¬ A</code> and <code>A</code> hold, we can conclude that <code>⊥</code> holds. In other words, if both <code>¬ A</code> and <code>A</code> hold, then we have a contradiction:<pre class="Agda"><a id="plfa_plfa-part1-Negation-¬-elim"></a><a id="plfa_plfa-part1-Negation-1316" href="../Negation/#plfa_plfa-part1-Negation-1316" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1323" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1325" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-1327" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-1328" href="../Negation/#plfa_plfa-part1-Negation-1328" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-1330" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-1332" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-1335" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-1339" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1341" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-1343" href="../Negation/#plfa_plfa-part1-Negation-1328" class="Bound">A</a>
  <a id="plfa_plfa-part1-Negation-1347" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1349" href="../Negation/#plfa_plfa-part1-Negation-1328" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-1355" class="Comment">---</a>
  <a id="plfa_plfa-part1-Negation-1361" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-1363" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-1365" href="../Negation/#plfa_plfa-part1-Negation-1316" class="Function">¬-elim</a> <a id="plfa_plfa-part1-Negation-1372" href="../Negation/#plfa_plfa-part1-Negation-1372" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1375" href="../Negation/#plfa_plfa-part1-Negation-1375" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-1377" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-1379" href="../Negation/#plfa_plfa-part1-Negation-1372" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-1382" href="../Negation/#plfa_plfa-part1-Negation-1375" class="Bound">x</a>
</pre><p>Here we write <code>¬x</code> for evidence of <code>¬ A</code> and <code>x</code> for evidence of <code>A</code>. This means that <code>¬x</code> must be a function of type <code>A → ⊥</code>, and hence the application <code>¬x x</code> must be of type <code>⊥</code>. Note that this rule is just a special case of <code>→-elim</code>.</p>We set the precedence of negation so that it binds more tightly than disjunction and conjunction, but less tightly than anything else:<pre class="Agda"><a id="plfa_plfa-part1-Negation-1771" class="Keyword">infix</a> <a id="plfa_plfa-part1-Negation-1777" class="Number">3</a> <a id="plfa_plfa-part1-Negation-1779" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬_</a>
</pre><p>Thus, <code>¬ A × ¬ B</code> parses as <code>(¬ A) × (¬ B)</code> and <code>¬ m ≡ n</code> as <code>¬ (m ≡ n)</code>.</p>In <em>classical</em> logic, we have that <code>A</code> is equivalent to <code>¬ ¬ A</code>. As we discuss below, in Agda we use <em>intuitionistic</em> logic, where we have only half of this equivalence, namely that <code>A</code> implies <code>¬ ¬ A</code>:<pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro"></a><a id="plfa_plfa-part1-Negation-2072" href="../Negation/#plfa_plfa-part1-Negation-2072" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2081" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2083" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2085" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2086" href="../Negation/#plfa_plfa-part1-Negation-2086" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2088" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2090" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2093" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2097" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2099" href="../Negation/#plfa_plfa-part1-Negation-2086" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2105" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-2113" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2115" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2117" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2119" href="../Negation/#plfa_plfa-part1-Negation-2086" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2121" href="../Negation/#plfa_plfa-part1-Negation-2072" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2130" href="../Negation/#plfa_plfa-part1-Negation-2130" class="Bound">x</a>  <a id="plfa_plfa-part1-Negation-2133" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-2136" class="Symbol">λ{</a><a id="plfa_plfa-part1-Negation-2138" href="../Negation/#plfa_plfa-part1-Negation-2138" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2141" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2143" href="../Negation/#plfa_plfa-part1-Negation-2138" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2146" href="../Negation/#plfa_plfa-part1-Negation-2130" class="Bound">x</a><a id="plfa_plfa-part1-Negation-2147" class="Symbol">}</a>
</pre><p>Let <code>x</code> be evidence of <code>A</code>. We show that assuming <code>¬ A</code> leads to a contradiction, and hence <code>¬ ¬ A</code> must hold. Let <code>¬x</code> be evidence of <code>¬ A</code>. Then from <code>A</code> and <code>¬ A</code> we have a contradiction, evidenced by <code>¬x x</code>. Hence, we have shown <code>¬ ¬ A</code>.</p>An equivalent way to write the above is as follows:<pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬-intro′"></a><a id="plfa_plfa-part1-Negation-2458" href="../Negation/#plfa_plfa-part1-Negation-2458" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-2468" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2470" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2472" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2473" href="../Negation/#plfa_plfa-part1-Negation-2473" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2475" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2477" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2480" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2484" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2486" href="../Negation/#plfa_plfa-part1-Negation-2473" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2492" class="Comment">-----</a>
  <a id="plfa_plfa-part1-Negation-2500" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2502" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2504" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2506" href="../Negation/#plfa_plfa-part1-Negation-2473" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2508" href="../Negation/#plfa_plfa-part1-Negation-2458" class="Function">¬¬-intro′</a> <a id="plfa_plfa-part1-Negation-2518" href="../Negation/#plfa_plfa-part1-Negation-2518" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-2520" href="../Negation/#plfa_plfa-part1-Negation-2520" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2523" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-2525" href="../Negation/#plfa_plfa-part1-Negation-2520" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-2528" href="../Negation/#plfa_plfa-part1-Negation-2518" class="Bound">x</a>
</pre><p>Here we have simply converted the argument of the lambda term to an additional argument of the function. We will usually use this latter style, as it is more compact.</p>We cannot show that <code>¬ ¬ A</code> implies <code>A</code>, but we can show that <code>¬ ¬ ¬ A</code> implies <code>¬ A</code>:<pre class="Agda"><a id="plfa_plfa-part1-Negation-¬¬¬-elim"></a><a id="plfa_plfa-part1-Negation-2798" href="../Negation/#plfa_plfa-part1-Negation-2798" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-2807" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2809" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-2811" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-2812" href="../Negation/#plfa_plfa-part1-Negation-2812" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-2814" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-2816" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-2819" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-2823" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2825" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2827" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2829" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2831" href="../Negation/#plfa_plfa-part1-Negation-2812" class="Bound">A</a>
    <a id="plfa_plfa-part1-Negation-2837" class="Comment">-------</a>
  <a id="plfa_plfa-part1-Negation-2847" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2849" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-2851" href="../Negation/#plfa_plfa-part1-Negation-2812" class="Bound">A</a>
<a id="plfa_plfa-part1-Negation-2853" href="../Negation/#plfa_plfa-part1-Negation-2798" class="Function">¬¬¬-elim</a> <a id="plfa_plfa-part1-Negation-2862" href="../Negation/#plfa_plfa-part1-Negation-2862" class="Bound">¬¬¬x</a>  <a id="plfa_plfa-part1-Negation-2868" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-2871" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-2873" href="../Negation/#plfa_plfa-part1-Negation-2873" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-2875" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-2877" href="../Negation/#plfa_plfa-part1-Negation-2862" class="Bound">¬¬¬x</a> <a id="plfa_plfa-part1-Negation-2882" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-2883" href="../Negation/#plfa_plfa-part1-Negation-2072" class="Function">¬¬-intro</a> <a id="plfa_plfa-part1-Negation-2892" href="../Negation/#plfa_plfa-part1-Negation-2873" class="Bound">x</a><a id="plfa_plfa-part1-Negation-2893" class="Symbol">)</a>
</pre><p>Let <code>¬¬¬x</code> be evidence of <code>¬ ¬ ¬ A</code>. We will show that assuming <code>A</code> leads to a contradiction, and hence <code>¬ A</code> must hold. Let <code>x</code> be evidence of <code>A</code>. Then by the previous result, we can conclude <code>¬ ¬ A</code>, evidenced by <code>¬¬-intro x</code>. Then from <code>¬ ¬ ¬ A</code> and <code>¬ ¬ A</code> we have a contradiction, evidenced by <code>¬¬¬x (¬¬-intro x)</code>. Hence we have shown <code>¬ A</code>.</p>Another law of logic is <em>contraposition</em>, stating that if <code>A</code> implies <code>B</code>, then <code>¬ B</code> implies <code>¬ A</code>:<pre class="Agda"><a id="plfa_plfa-part1-Negation-contraposition"></a><a id="plfa_plfa-part1-Negation-3359" href="../Negation/#plfa_plfa-part1-Negation-3359" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-3374" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3376" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3378" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3379" href="../Negation/#plfa_plfa-part1-Negation-3379" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3381" href="../Negation/#plfa_plfa-part1-Negation-3381" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-3383" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3385" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3388" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Negation-3392" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3394" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3395" href="../Negation/#plfa_plfa-part1-Negation-3379" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3397" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3399" href="../Negation/#plfa_plfa-part1-Negation-3381" class="Bound">B</a><a id="plfa_plfa-part1-Negation-3400" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Negation-3406" class="Comment">-----------</a>
  <a id="plfa_plfa-part1-Negation-3420" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3422" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3423" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3425" href="../Negation/#plfa_plfa-part1-Negation-3381" class="Bound">B</a> <a id="plfa_plfa-part1-Negation-3427" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3429" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3431" href="../Negation/#plfa_plfa-part1-Negation-3379" class="Bound">A</a><a id="plfa_plfa-part1-Negation-3432" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-3434" href="../Negation/#plfa_plfa-part1-Negation-3359" class="Function">contraposition</a> <a id="plfa_plfa-part1-Negation-3449" href="../Negation/#plfa_plfa-part1-Negation-3449" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-3451" href="../Negation/#plfa_plfa-part1-Negation-3451" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-3454" href="../Negation/#plfa_plfa-part1-Negation-3454" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3456" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-3458" href="../Negation/#plfa_plfa-part1-Negation-3451" class="Bound">¬y</a> <a id="plfa_plfa-part1-Negation-3461" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3462" href="../Negation/#plfa_plfa-part1-Negation-3449" class="Bound">f</a> <a id="plfa_plfa-part1-Negation-3464" href="../Negation/#plfa_plfa-part1-Negation-3454" class="Bound">x</a><a id="plfa_plfa-part1-Negation-3465" class="Symbol">)</a>
</pre><p>Let <code>f</code> be evidence of <code>A → B</code> and let <code>¬y</code> be evidence of <code>¬ B</code>. We will show that assuming <code>A</code> leads to a contradiction, and hence <code>¬ A</code> must hold. Let <code>x</code> be evidence of <code>A</code>. Then from <code>A → B</code> and <code>A</code> we may conclude <code>B</code>, evidenced by <code>f x</code>, and from <code>B</code> and <code>¬ B</code> we may conclude <code>⊥</code>, evidenced by <code>¬y (f x)</code>. Hence, we have shown <code>¬ A</code>.</p>Using negation, it is straightforward to define inequality:<pre class="Agda"><a id="plfa_plfa-part1-Negation-_≢_"></a><a id="plfa_plfa-part1-Negation-3885" href="../Negation/#plfa_plfa-part1-Negation-3885" class="Function Operator">_≢_</a> <a id="plfa_plfa-part1-Negation-3889" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3891" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-3893" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-3894" href="../Negation/#plfa_plfa-part1-Negation-3894" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3896" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-3898" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-3901" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-3903" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3905" href="../Negation/#plfa_plfa-part1-Negation-3894" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3907" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3909" href="../Negation/#plfa_plfa-part1-Negation-3894" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-3911" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-3913" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-3917" href="../Negation/#plfa_plfa-part1-Negation-3917" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3919" href="../Negation/#plfa_plfa-part1-Negation-3885" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-3921" href="../Negation/#plfa_plfa-part1-Negation-3921" class="Bound">y</a>  <a id="plfa_plfa-part1-Negation-3924" class="Symbol">=</a>  <a id="plfa_plfa-part1-Negation-3927" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-3929" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-3930" href="../Negation/#plfa_plfa-part1-Negation-3917" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-3932" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-3934" href="../Negation/#plfa_plfa-part1-Negation-3921" class="Bound">y</a><a id="plfa_plfa-part1-Negation-3935" class="Symbol">)</a>
</pre>It is trivial to show distinct numbers are not equal:<pre class="Agda"><a id="plfa_plfa-part1-Negation-4003" href="../Negation/#plfa_plfa-part1-Negation-4003" class="Function">_</a> <a id="plfa_plfa-part1-Negation-4005" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4007" class="Number">1</a> <a id="plfa_plfa-part1-Negation-4009" href="../Negation/#plfa_plfa-part1-Negation-3885" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-4011" class="Number">2</a>
<a id="plfa_plfa-part1-Negation-4013" class="Symbol">_</a> <a id="plfa_plfa-part1-Negation-4015" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4017" class="Symbol">λ()</a>
</pre>This is our first use of an absurd pattern in a lambda expression. The type <code>M ≡ N</code> is occupied exactly when <code>M</code> and <code>N</code> simplify to identical terms. Since <code>1</code> and <code>2</code> simplify to distinct normal forms, Agda determines that there is no possible evidence that <code>1 ≡ 2</code>. As a second example, it is also easy to validate Peano’s postulate that zero is not the successor of any number:<pre class="Agda"><a id="plfa_plfa-part1-Negation-peano"></a><a id="plfa_plfa-part1-Negation-4414" href="../Negation/#plfa_plfa-part1-Negation-4414" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-4420" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4422" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-4424" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-4425" href="../Negation/#plfa_plfa-part1-Negation-4425" class="Bound">m</a> <a id="plfa_plfa-part1-Negation-4427" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4429" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Negation-4430" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-4432" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4434" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Negation-4439" href="../Negation/#plfa_plfa-part1-Negation-3885" class="Function Operator">≢</a> <a id="plfa_plfa-part1-Negation-4441" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Negation-4445" href="../Negation/#plfa_plfa-part1-Negation-4425" class="Bound">m</a>
<a id="plfa_plfa-part1-Negation-4447" href="../Negation/#plfa_plfa-part1-Negation-4414" class="Function">peano</a> <a id="plfa_plfa-part1-Negation-4453" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4455" class="Symbol">λ()</a>
</pre><p>The evidence is essentially the same, as the absurd pattern matches all possible evidence of type <code>zero ≡ suc m</code>.</p><p>Given the correspondence of implication to exponentiation and false to the type with no members, we can view negation as raising to the zero power. This indeed corresponds to what we know for arithmetic, where</p><pre><code>0 ^ n  ≡  1,  if n ≡ 0
       ≡  0,  if n ≢ 0</code></pre>Indeed, there is exactly one proof of <code>⊥ → ⊥</code>. We can write this proof two different ways:<pre class="Agda"><a id="plfa_plfa-part1-Negation-id"></a><a id="plfa_plfa-part1-Negation-4945" href="../Negation/#plfa_plfa-part1-Negation-4945" class="Function">id</a> <a id="plfa_plfa-part1-Negation-4948" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4950" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-4952" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4954" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-4956" href="../Negation/#plfa_plfa-part1-Negation-4945" class="Function">id</a> <a id="plfa_plfa-part1-Negation-4959" href="../Negation/#plfa_plfa-part1-Negation-4959" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-4961" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-4963" href="../Negation/#plfa_plfa-part1-Negation-4959" class="Bound">x</a>

<a id="plfa_plfa-part1-Negation-id′"></a><a id="plfa_plfa-part1-Negation-4966" href="../Negation/#plfa_plfa-part1-Negation-4966" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-4970" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-4972" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a> <a id="plfa_plfa-part1-Negation-4974" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-4976" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#526" class="Datatype">⊥</a>
<a id="plfa_plfa-part1-Negation-4978" href="../Negation/#plfa_plfa-part1-Negation-4966" class="Function">id′</a> <a id="plfa_plfa-part1-Negation-4982" class="Symbol">()</a>
</pre>But, using extensionality, we can prove these equal:<pre class="Agda"><a id="plfa_plfa-part1-Negation-id≡id′"></a><a id="plfa_plfa-part1-Negation-5050" href="../Negation/#plfa_plfa-part1-Negation-5050" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-5057" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5059" href="../Negation/#plfa_plfa-part1-Negation-4945" class="Function">id</a> <a id="plfa_plfa-part1-Negation-5062" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-5064" href="../Negation/#plfa_plfa-part1-Negation-4966" class="Function">id′</a>
<a id="plfa_plfa-part1-Negation-5068" href="../Negation/#plfa_plfa-part1-Negation-5050" class="Function">id≡id′</a> <a id="plfa_plfa-part1-Negation-5075" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-5077" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-5092" class="Symbol">(λ())</a>
</pre><p>By extensionality, <code>id ≡ id′</code> holds if for every <code>x</code> in their domain we have <code>id x ≡ id′ x</code>. But there is no <code>x</code> in their domain, so the equality holds trivially.</p>Indeed, we can show any two proofs of a negation are equal:<pre class="Agda"><a id="plfa_plfa-part1-Negation-assimilation"></a><a id="plfa_plfa-part1-Negation-5334" href="../Negation/#plfa_plfa-part1-Negation-5334" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-5347" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5349" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-5351" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-5352" href="../Negation/#plfa_plfa-part1-Negation-5352" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-5354" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5356" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-5359" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-5361" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-5362" href="../Negation/#plfa_plfa-part1-Negation-5362" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-5365" href="../Negation/#plfa_plfa-part1-Negation-5365" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-5369" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-5371" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-5373" href="../Negation/#plfa_plfa-part1-Negation-5352" class="Bound">A</a><a id="plfa_plfa-part1-Negation-5374" class="Symbol">)</a> <a id="plfa_plfa-part1-Negation-5376" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5378" href="../Negation/#plfa_plfa-part1-Negation-5362" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-5381" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Negation-5383" href="../Negation/#plfa_plfa-part1-Negation-5365" class="Bound">¬x′</a>
<a id="plfa_plfa-part1-Negation-5387" href="../Negation/#plfa_plfa-part1-Negation-5334" class="Function">assimilation</a> <a id="plfa_plfa-part1-Negation-5400" href="../Negation/#plfa_plfa-part1-Negation-5400" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-5403" href="../Negation/#plfa_plfa-part1-Negation-5403" class="Bound">¬x′</a> <a id="plfa_plfa-part1-Negation-5407" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-5409" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Negation-5424" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-5427" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-5429" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-5431" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="plfa_plfa-part1-Negation-5438" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-5439" href="../Negation/#plfa_plfa-part1-Negation-5400" class="Bound">¬x</a> <a id="plfa_plfa-part1-Negation-5442" href="../Negation/#plfa_plfa-part1-Negation-5427" class="Bound">x</a><a id="plfa_plfa-part1-Negation-5443" class="Symbol">))</a>
</pre><p>Evidence for <code>¬ A</code> implies that any evidence of <code>A</code> immediately leads to a contradiction. But extensionality quantifies over all <code>x</code> such that <code>A</code> holds, hence any such <code>x</code> immediately leads to a contradiction, again causing the equality to hold trivially.</p><h4 id="exercise--irreflexive-recommended">Exercise <code>&lt;-irreflexive</code> (recommended)</h4><p>Using negation, show that <a href="../Relations/#strict-inequality">strict inequality</a> is irreflexive, that is, <code>n &lt; n</code> holds for no <code>n</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-5892" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-trichotomy-practice">Exercise <code>trichotomy</code> (practice)</h4><p>Show that strict inequality satisfies <a href="../Relations/#trichotomy">trichotomy</a>, that is, for any naturals <code>m</code> and <code>n</code> exactly one of the following holds:</p><ul><li><code>m &lt; n</code></li><li><code>m ≡ n</code></li><li><code>m &gt; n</code></li></ul><p>Here “exactly one” means that not only one of the three must hold, but that when one holds the negation of the other two must also hold.</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-6288" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise--dual--recommended">Exercise <code>⊎-dual-×</code> (recommended)</h4><p>Show that conjunction, disjunction, and negation are related by a version of De Morgan’s Law.</p><pre><code>¬ (A ⊎ B) ≃ (¬ A) × (¬ B)</code></pre><p>This result is an easy consequence of something we’ve proved previously.</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-6564" class="Comment">-- Your code goes here</a>
</pre><p>Do we also have the following?</p><pre><code>¬ (A × B) ≃ (¬ A) ⊎ (¬ B)</code></pre><p>If so, prove; if not, can you give a relation weaker than isomorphism that relates the two sides?</p><h2 id="intuitive-and-classical-logic">Intuitive and Classical logic</h2><p>In Gilbert and Sullivan’s <em>The Gondoliers</em>, Casilda is told that as an infant she was married to the heir of the King of Batavia, but that due to a mix-up no one knows which of two individuals, Marco or Giuseppe, is the heir. Alarmed, she wails “Then do you mean to say that I am married to one of two gondoliers, but it is impossible to say which?” To which the response is “Without any doubt of any kind whatever.”</p><p>Logic comes in many varieties, and one distinction is between <em>classical</em> and <em>intuitionistic</em>. Intuitionists, concerned by assumptions made by some logicians about the nature of infinity, insist upon a constructionist notion of truth. In particular, they insist that a proof of <code>A ⊎ B</code> must show <em>which</em> of <code>A</code> or <code>B</code> holds, and hence they would reject the claim that Casilda is married to Marco or Giuseppe until one of the two was identified as her husband. Perhaps Gilbert and Sullivan anticipated intuitionism, for their story’s outcome is that the heir turns out to be a third individual, Luiz, with whom Casilda is, conveniently, already in love.</p><p>Intuitionists also reject the law of the excluded middle, which asserts <code>A ⊎ ¬ A</code> for every <code>A</code>, since the law gives no clue as to <em>which</em> of <code>A</code> or <code>¬ A</code> holds. Heyting formalised a variant of Hilbert’s classical logic that captures the intuitionistic notion of provability. In particular, the law of the excluded middle is provable in Hilbert’s logic, but not in Heyting’s. Further, if the law of the excluded middle is added as an axiom to Heyting’s logic, then it becomes equivalent to Hilbert’s. Kolmogorov showed the two logics were closely related: he gave a double-negation translation, such that a formula is provable in classical logic if and only if its translation is provable in intuitionistic logic.</p><p>Propositions as Types was first formulated for intuitionistic logic. It is a perfect fit, because in the intuitionist interpretation the formula <code>A ⊎ B</code> is provable exactly when one exhibits either a proof of <code>A</code> or a proof of <code>B</code>, so the type corresponding to disjunction is a disjoint sum.</p><p>(Parts of the above are adopted from “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>, December 2015.)</p><h2 id="excluded-middle-is-irrefutable">Excluded middle is irrefutable</h2>The law of the excluded middle can be formulated as follows:<pre class="Agda"><a id="plfa_plfa-part1-Negation-9104" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Negation-em"></a><a id="plfa_plfa-part1-Negation-9116" href="../Negation/#plfa_plfa-part1-Negation-9116" class="Postulate">em</a> <a id="plfa_plfa-part1-Negation-9119" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-9121" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-9123" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-9124" href="../Negation/#plfa_plfa-part1-Negation-9124" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-9126" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-9128" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-9131" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-9133" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-9135" href="../Negation/#plfa_plfa-part1-Negation-9124" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-9137" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-9139" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-9141" href="../Negation/#plfa_plfa-part1-Negation-9124" class="Bound">A</a>
</pre>As we noted, the law of the excluded middle does not hold in intuitionistic logic. However, we can show that it is <em>irrefutable</em>, meaning that the negation of its negation is provable (and hence that its negation is never provable):<pre class="Agda"><a id="plfa_plfa-part1-Negation-em-irrefutable"></a><a id="plfa_plfa-part1-Negation-9389" href="../Negation/#plfa_plfa-part1-Negation-9389" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-9404" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-9406" class="Symbol">∀</a> <a id="plfa_plfa-part1-Negation-9408" class="Symbol">{</a><a id="plfa_plfa-part1-Negation-9409" href="../Negation/#plfa_plfa-part1-Negation-9409" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-9411" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-9413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="plfa_plfa-part1-Negation-9416" class="Symbol">}</a> <a id="plfa_plfa-part1-Negation-9418" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-9420" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-9422" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-9424" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-9425" href="../Negation/#plfa_plfa-part1-Negation-9409" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-9427" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Negation-9429" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-9431" href="../Negation/#plfa_plfa-part1-Negation-9409" class="Bound">A</a><a id="plfa_plfa-part1-Negation-9432" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-9434" href="../Negation/#plfa_plfa-part1-Negation-9389" class="Function">em-irrefutable</a> <a id="plfa_plfa-part1-Negation-9449" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-9451" class="Symbol">λ</a> <a id="plfa_plfa-part1-Negation-9453" href="../Negation/#plfa_plfa-part1-Negation-9453" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-9455" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-9457" href="../Negation/#plfa_plfa-part1-Negation-9453" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-9459" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-9460" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="plfa_plfa-part1-Negation-9465" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Negation-9468" href="../Negation/#plfa_plfa-part1-Negation-9468" class="Bound">x</a> <a id="plfa_plfa-part1-Negation-9470" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-9472" href="../Negation/#plfa_plfa-part1-Negation-9453" class="Bound">k</a> <a id="plfa_plfa-part1-Negation-9474" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-9475" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="plfa_plfa-part1-Negation-9480" href="../Negation/#plfa_plfa-part1-Negation-9468" class="Bound">x</a><a id="plfa_plfa-part1-Negation-9481" class="Symbol">)))</a>
</pre><p>The best way to explain this code is to develop it interactively:</p><pre><code>em-irrefutable k = ?</code></pre><p>Given evidence <code>k</code> that <code>¬ (A ⊎ ¬ A)</code>, that is, a function that given a value of type <code>A ⊎ ¬ A</code> returns a value of the empty type, we must fill in <code>?</code> with a term that returns a value of the empty type. The only way we can get a value of the empty type is by applying <code>k</code> itself, so let’s expand the hole accordingly:</p><pre><code>em-irrefutable k = k ?</code></pre><p>We need to fill the new hole with a value of type <code>A ⊎ ¬ A</code>. We don’t have a value of type <code>A</code> to hand, so let’s pick the second disjunct:</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → ? })</code></pre><p>The second disjunct accepts evidence of <code>¬ A</code>, that is, a function that given a value of type <code>A</code> returns a value of the empty type. We bind <code>x</code> to the value of type <code>A</code>, and now we need to fill in the hole with a value of the empty type. Once again, the only way we can get a value of the empty type is by applying <code>k</code> itself, so let’s expand the hole accordingly:</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k ? })</code></pre><p>This time we do have a value of type <code>A</code> to hand, namely <code>x</code>, so we can pick the first disjunct:</p><pre><code>em-irrefutable k = k (inj₂ λ{ x → k (inj₁ x) })</code></pre><p>There are no holes left! This completes the proof.</p><p>The following story illustrates the behaviour of the term we have created. (With apologies to Peter Selinger, who tells a similar story about a king, a wizard, and the Philosopher’s stone.)</p><p>Once upon a time, the devil approached a man and made an offer: “Either (a) I will give you one billion dollars, or (b) I will grant you any wish if you pay me one billion dollars. Of course, I get to choose whether I offer (a) or (b).”</p><p>The man was wary. Did he need to sign over his soul? No, said the devil, all the man need do is accept the offer.</p><p>The man pondered. If he was offered (b) it was unlikely that he would ever be able to buy the wish, but what was the harm in having the opportunity available?</p><p>“I accept,” said the man at last. “Do I get (a) or (b)?”</p><p>The devil paused. “I choose (b).”</p><p>The man was disappointed but not surprised. That was that, he thought. But the offer gnawed at him. Imagine what he could do with his wish! Many years passed, and the man began to accumulate money. To get the money he sometimes did bad things, and dimly he realised that this must be what the devil had in mind. Eventually he had his billion dollars, and the devil appeared again.</p><p>“Here is a billion dollars,” said the man, handing over a valise containing the money. “Grant me my wish!”</p><p>The devil took possession of the valise. Then he said, “Oh, did I say (b) before? I’m so sorry. I meant (a). It is my great pleasure to give you one billion dollars.”</p><p>And the devil handed back to the man the same valise that the man had just handed to him.</p><p>(Parts of the above are adopted from “Call-by-Value is Dual to Call-by-Name”, Philip Wadler, <em>International Conference on Functional Programming</em>, 2003.)</p><h4 id="exercise-classical-stretch">Exercise <code>Classical</code> (stretch)</h4><p>Consider the following principles:</p><ul><li>Excluded Middle: <code>A ⊎ ¬ A</code>, for all <code>A</code></li><li>Double Negation Elimination: <code>¬ ¬ A → A</code>, for all <code>A</code></li><li>Peirce’s Law: <code>((A → B) → A) → A</code>, for all <code>A</code> and <code>B</code>.</li><li>Implication as disjunction: <code>(A → B) → ¬ A ⊎ B</code>, for all <code>A</code> and <code>B</code>.</li><li>De Morgan: <code>¬ (¬ A × ¬ B) → A ⊎ B</code>, for all <code>A</code> and <code>B</code>.</li></ul><p>Show that each of these implies all the others.</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-12874" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-stable-stretch">Exercise <code>Stable</code> (stretch)</h4>Say that a formula is <em>stable</em> if double negation elimination holds for it:<pre class="Agda"><a id="plfa_plfa-part1-Negation-Stable"></a><a id="plfa_plfa-part1-Negation-13021" href="../Negation/#plfa_plfa-part1-Negation-13021" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-13028" class="Symbol">:</a> <a id="plfa_plfa-part1-Negation-13030" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="plfa_plfa-part1-Negation-13034" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13036" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Negation-13040" href="../Negation/#plfa_plfa-part1-Negation-13021" class="Function">Stable</a> <a id="plfa_plfa-part1-Negation-13047" href="../Negation/#plfa_plfa-part1-Negation-13047" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13049" class="Symbol">=</a> <a id="plfa_plfa-part1-Negation-13051" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13053" href="../Negation/#plfa_plfa-part1-Negation-736" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Negation-13055" href="../Negation/#plfa_plfa-part1-Negation-13047" class="Bound">A</a> <a id="plfa_plfa-part1-Negation-13057" class="Symbol">→</a> <a id="plfa_plfa-part1-Negation-13059" href="../Negation/#plfa_plfa-part1-Negation-13047" class="Bound">A</a>
</pre><p>Show that any negated formula is stable, and that the conjunction of two stable formulas is stable.</p><pre class="Agda"><a id="plfa_plfa-part1-Negation-13174" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-prelude">Standard Prelude</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Negation-13314" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-13321" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Negation-13338" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-13344" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13345" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Negation-13347" class="Symbol">)</a>
<a id="plfa_plfa-part1-Negation-13349" class="Keyword">import</a> <a id="plfa_plfa-part1-Negation-13356" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Negation-13382" class="Keyword">using</a> <a id="plfa_plfa-part1-Negation-13388" class="Symbol">(</a><a id="plfa_plfa-part1-Negation-13389" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Nullary.Negation.Core.html#998" class="Function">contraposition</a><a id="plfa_plfa-part1-Negation-13403" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>¬  U+00AC  NOT SIGN (\neg)
≢  U+2262  NOT IDENTICAL TO (\==n)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Connectives/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Negation.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Quantifiers/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>