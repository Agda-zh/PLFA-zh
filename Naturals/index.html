<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>编程语言基础：Agda 描述 – Naturals</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">编程语言基础：Agda 描述</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">主页</a> <a class="page-link" href="../Announcements/">公告</a> <a class="page-link" href="../GettingStarted/">使用说明</a> <a class="page-link" href="../Citing/">引用</a> <a class="page-link" href="https://plfa.github.io/">English</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../GettingStarted/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Naturals.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Induction/">下一章</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Naturals: 自然数</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Naturals-99" class="Keyword">module</a> <a id="plfa_plfa-part1-Naturals-106" href="../Naturals/#" class="Module">plfa.part1.Naturals</a> <a id="plfa_plfa-part1-Naturals-126" class="Keyword">where</a>
</pre><p>夜空中的星星不计其数，但只有不到五千颗是肉眼可见的。 可观测宇宙中则包含大约 7*10^22 颗恒星。</p><p>星星虽多，但却是有限的，而自然数是无限的。就算用自然数把所有的星星都数尽了， 剩下的自然数也和开始的一样多。</p><h2 id="自然数是一种归纳数据类型inductive-datatype">自然数是一种归纳数据类型（Inductive Datatype）</h2><p>大家都熟悉自然数，例如：</p><pre><code>0
1
2
3
...</code></pre><p>等等。我们将自然数的<strong>类型（Type）</strong>记作 <code>ℕ</code> ，并称 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 等数 是类型 <code>ℕ</code> 的<strong>值（Value）</strong>，表示为 <code>0 : ℕ</code>，<code>1 : ℕ</code>，<code>2 : ℕ</code>，<code>3 : ℕ</code> 等等。</p><p>自然数集是无限的，然而其定义只需寥寥几行即可写出。下面是用两条<strong>推导规则（Inference Rules）</strong>定义的自然数：</p><pre><code>--------
zero : ℕ

m : ℕ
---------
suc m : ℕ</code></pre><p>以及用 Agda 定义的自然数：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-1489" class="Keyword">data</a> <a id="plfa_plfa-part1-Naturals-ℕ"></a><a id="plfa_plfa-part1-Naturals-1494" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-1496" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-1498" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Naturals-1502" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Naturals-ℕ.zero"></a><a id="plfa_plfa-part1-Naturals-1510" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Naturals-1515" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-1517" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a>
  <a id="plfa_plfa-part1-Naturals-ℕ.suc"></a><a id="plfa_plfa-part1-Naturals-1521" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a>  <a id="plfa_plfa-part1-Naturals-1526" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-1528" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-1530" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-1532" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a>
</pre><p>其中 <code>ℕ</code> 是我们定义的<strong>数据类型（Datatype）</strong>的名字，而 <code>zero</code>（零）和 <code>suc</code> （<strong>后继</strong>，即 <strong>Successor</strong> 的简写）是该数据类型的<strong>构造子（Constructor）</strong>。</p><p>这两种定义说的是同一件事：</p><ul><li><strong>起始步骤（Base Case）</strong>：<code>zero</code> 是一个自然数。</li><li><strong>归纳步骤（Inductive Case）</strong>：如果 <code>m</code> 是一个自然数，那么 <code>suc m</code> 也是。</li></ul><p>此外，这两条规则给出了产生自然数<strong>唯一</strong>的方法。因此，可能的自然数包括：</p><pre><code>zero
suc zero
suc (suc zero)
suc (suc (suc zero))
...</code></pre><p>我们将 <code>zero</code> 简写为 <code>0</code>；将 <code>suc zero</code>，零的后继数， 也就是排在零之后的自然数，简写为 <code>1</code>；将 <code>suc (suc zero)</code>，也就是 <code>suc 1</code>， 即一的后继数，简写为 <code>2</code>；将二的后继数简写为 <code>3</code>；以此类推。</p><h4 id="seven">练习 <code>seven</code>（实践）</h4><p>请写出 <code>7</code> 的完整定义。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-2930" class="Comment">-- 请将代码写在此处</a>
</pre><p>你需要为 <code>seven</code> 给出类型签名以及定义。在 Emacs 中使用 <code>C-c C-l</code> 来让 Agda 重新加载。</p><h2 id="推导规则分析">推导规则分析</h2><p>我们来分析一下刚才的两条推导规则。每条推导规则包含写在一条水平直线上的 零条或多条<strong>判断（Judgment）</strong>，称之为<strong>假设（Hypothesis）</strong>；以及写在 直线下的一条判断，称之为<strong>结论（Conclusion）</strong>。第一条规则是起始步骤：它没 有任何假设，其结论断言 <code>zero</code> 是一个自然数。第二条规则是归纳步骤：它有 一条假设，即 <code>m</code> 是自然数，而结论断言 <code>suc m</code> 也是一个自然数。</p><h2 id="agda-定义分析">Agda 定义分析</h2><p>现在分析一下 Agda 的定义。关键字 <code>data</code> 表示这是一个归纳定义， 也就是用构造子定义一个新的数据类型。</p><pre><code>ℕ : Set</code></pre><p>表示 <code>ℕ</code> 是新的数据类型的名字，它是一个 <code>Set</code>，也就是在 Agda 中对类型的称呼。 关键字 <code>where</code> 用于分隔数据类型的声明和构造子的声明。 每个构造子的声明独占一行，用缩进来指明它所属的 <code>data</code> 声明。</p><pre><code>zero : ℕ
suc  : ℕ → ℕ</code></pre><p>这两行给出了构造子 <code>zero</code> 和 <code>suc</code> 的类型<strong>签名（Signature）</strong>。 它们表示 <code>zero</code> 是一个自然数，<code>suc</code> 则取一个自然数作为参数，返回另一个自然数。</p><p>读者可能注意到 <code>ℕ</code> 和 <code>→</code> 在键盘上没有对应的按键。它们是 <strong>Unicode（统一码）</strong>中的符号。每一章的结尾都会有本章节引入的 Unicode 符号列表，以及在 Emacs 编辑器中输入它们的方法。</p><h2 id="创世故事">创世故事</h2><p>我们再看一下自然数的定义规则：</p><ul><li><strong>起始步骤（Base Case）</strong>：<code>zero</code> 是一个自然数。</li><li><strong>归纳步骤（Inductive Case）</strong>：如果 <code>m</code> 是一个自然数，那么 <code>suc m</code> 也是。</li></ul><p>等等！第二行用自然数定义了自然数，这怎么能行？这个定义难道 不会像「脱欧即是脱欧」一样无用吗？</p><p>【译注：「脱欧即是脱欧」是英国首相特蕾莎·梅提出的一句口号。】</p><p>实际上，不必通过自我指涉，我们的自然数定义也是可以被赋予意义的。 我们甚至只需要处理<strong>有限</strong>的集合，而不必涉及<strong>无限</strong>的自然数集。</p><p>我们可以将这个过程比作一个创世故事。起初，我们对自然数一无所知：</p><pre><code>-- 起初，世上没有自然数。</code></pre><p>现在，我们对所有已知的自然数应用之前的规则。起始步骤告诉我们 <code>zero</code> 是 一个自然数，所以我们将它加入已知自然数的集合中。归纳步骤告诉我们如果 「昨天的」<code>m</code> 是一个自然数，那么「今天的」<code>suc m</code> 也是一个自然数。我们在 今天之前并不知道任何自然数，所以归纳步骤在此处不适用。</p><pre><code>-- 第一天，世上有了一个自然数。
zero : ℕ</code></pre><p>然后我们重复此过程。今天我们知道昨天的所有自然数，以及任何 通过规则添加的数。起始步骤依然告诉我们 <code>zero</code> 是一个自然数，我们 已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>zero</code> 在昨天是自然数， 那么 <code>suc zero</code> 在今天也是自然数：</p><pre><code>-- 第二天，世上有了两个自然数。
zero : ℕ
suc zero : ℕ</code></pre><p>我们再次重复此过程。现在归纳步骤告诉我们，由于 <code>zero</code> 和 <code>suc zero</code> 都是自然 数，因此 <code>suc zero</code> 和 <code>suc (suc zero)</code> 也是自然数。我们已经知道 <code>suc zero</code> 是自然数了，而后者 <code>suc (suc zero)</code> 是新加入的。</p><pre><code>-- 第三天，世上有了三个自然数。
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ</code></pre><p>此时规律已经很明显了。</p><pre><code>-- 第四天，世上有了四个自然数。
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
suc (suc (suc zero)) : ℕ</code></pre><p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的自然数。每个自然数都会在 某一天出现。具体来说，自然数 <em>n</em> 在第 <em>n+1</em> 天首次出现。至此，我们并没有使 用自然数集来定义其自身，而是根据第 <em>n</em> 天的数集定义了第 <em>n+1</em> 天的数集。</p><p>像这样的过程被称作是<strong>归纳的（Inductive）</strong>。我们从一无所有开始，通过应用将 一个有限集合转换到另一个有限集合的规则，逐步生成潜在无限的集合。</p><p>定义了零的规则之所以被称作<strong>起始步骤</strong>，是因为它在我们还不知道其它自然数时 就引入了一个自然数。定义了后继数的规则之所以被称作<strong>归纳步骤</strong>，则是因为它在 已知自然数的基础上引入了更多自然数。其中，起始步骤的重要性不可小觑。如果 只有归纳步骤，那么第一天就没有任何自然数。第二天，第三天，无论多久也依旧没有。 一个没有起始步骤的归纳定义是无用的，就像「脱欧即是脱欧」一样。</p><h2 id="哲学和历史">哲学和历史</h2><p>哲学家发现，我们对「第一天」「第二天」等说法的使用暗含了对自然数的理解。 在这个层面上，我们对自然数的定义也许某种程度上可以说是循环的，但我们不必为此烦恼。 每个人对自然数都有良好的非形式化的理解，而我们可以将它作为形式化描述自然数的基础。</p><p>尽管从人类开始计数起，自然数就被人所认知，然而其归纳定义却是近代的事情。 这可以追溯到理查德·戴德金（Richard Dedekind）于 1888 年发表的论文 <em>Was sind und was sollen die Zahlen?</em>”（《数是什么，应该是什么？》）， 以及朱塞佩·皮亚诺（Giuseppe Peano）于次年发表的著作 “<em>Arithmetices principia, nova methodo exposita</em>”（《算术原理：用一种新方法呈现》）。</p><h2 id="编译指令">编译指令</h2><p>在 Agda 中，任何跟在 <code>--</code> 之后或者由 <code>{-</code> 和 <code>-}</code> 包裹的文字都会被视为 <strong>注释（Comment）</strong>。一般的注释对代码没有任何作用，但有一种例外， 这种注释被称作<strong>编译指令（Pragma）</strong>，由 <code>{-#</code> 和 <code>#-}</code> 包裹。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-12141" class="Symbol">{-#</a> <a id="plfa_plfa-part1-Naturals-12145" class="Keyword">BUILTIN</a> <a id="plfa_plfa-part1-Naturals-12153" class="Keyword">NATURAL</a> <a id="plfa_plfa-part1-Naturals-12161" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-12163" class="Symbol">#-}</a>
</pre><p>这一行告诉 Agda 数据类型 <code>ℕ</code> 对应了自然数，然后编写者就可以将 <code>zero</code> 简写 为 <code>0</code>，将 <code>suc zero</code> 简写为 <code>1</code>，将 <code>suc (suc zero)</code> 简写为 <code>2</code> 了，以此类推。 必须要向编译指令给出之前声明的类型（本例中为 <code>ℕ</code>），该类型有且只有两个构造子， 其中一个没有参数（本例中为 <code>zero</code>），另一个只接受一个所给定类型的参数（本例中为 <code>suc</code>）。</p><p>在启用上述简写的同时，这条编译指令也会用 Haskell 的任意精度整数类型 来提供更高效的自然数内部表示。用 <code>zero</code> 和 <code>suc</code> 表示自然数 <em>n</em> 要占用正比 于 <em>n</em> 的空间，而将其表示为 Haskell 中的任意精度整数只会占用正比于 <em>n</em> 的对数的空间。</p><h2 id="导入模块">导入模块</h2><p>我们很快就能写一些包含自然数的等式了。在此之前，我们需要从 Agda 标准库 中导入<strong>相等性（Equality）</strong>的定义和用于等式推理的记法：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-13694" class="Keyword">import</a> <a id="plfa_plfa-part1-Naturals-13701" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Naturals-13739" class="Symbol">as</a> <a id="plfa_plfa-part1-Naturals-13742" class="Module">Eq</a>
<a id="plfa_plfa-part1-Naturals-13745" class="Keyword">open</a> <a id="plfa_plfa-part1-Naturals-13750" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Naturals-13753" class="Keyword">using</a> <a id="plfa_plfa-part1-Naturals-13759" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-13760" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Naturals-13763" class="Symbol">;</a> <a id="plfa_plfa-part1-Naturals-13765" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Naturals-13769" class="Symbol">)</a>
<a id="plfa_plfa-part1-Naturals-13771" class="Keyword">open</a> <a id="plfa_plfa-part1-Naturals-13776" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Naturals-13791" class="Keyword">using</a> <a id="plfa_plfa-part1-Naturals-13797" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-13798" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Naturals-13804" class="Symbol">;</a> <a id="plfa_plfa-part1-Naturals-13806" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">_≡⟨⟩_</a><a id="plfa_plfa-part1-Naturals-13811" class="Symbol">;</a> <a id="plfa_plfa-part1-Naturals-13813" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Naturals-13815" class="Symbol">)</a>
</pre><p>第一行代码将标准库中定义了相等性的模块导入到当前<strong>作用域（Scope）</strong>中， 并将其命名为 <code>Eq</code>。第二行打开了这个模块，也就是将所有在 <code>using</code> 从句中指定的名称添加到当前作用域中。此处添加的名称有相等性运算符 <code>_≡_</code> 和两个项相等的证据 <code>refl</code>。第三行选取的模块提供了用于等价关系推理的运算符，并将 <code>using</code> 从句中指定的名称添加到当前作用域。此处添加的名称有 <code>begin_</code>、 <code>_≡⟨⟩_</code> 和 <code>_∎</code>。我们后面会看到这些运算符的使用方法。现在暂且把它们当作现成的 工具来使用，不深究其细节。但我们会在<a href="../Equality/">相等性</a>一章中 学习它们的具体定义。</p><p>Agda 用下划线来标注<strong>项（Term）</strong>在中缀（Infix）或混缀（Mixfix）运算符中项出现的位置。 因此，<code>_≡_</code> 和 <code>_≡⟨⟩_</code> 是中缀的（运算符写在两个项之间），而 <code>begin_</code> 是前缀的 （运算符写在项之前），<code>_∎</code> 则是后缀的（运算符写在项之后）。</p><p>括号和分号是少有的几个不能在名称中出现的的字符，于是我们在 <code>using</code> 列表中不需要额外的空格来消除歧义。</p><h2 id="plus">自然数的运算是递归函数</h2><p>既然我们有了自然数，那么可以用它们做什么呢？比如，我们能定义 加法和乘法之类的算术运算吗？</p><p>我儿时曾花费了大量的时间来记忆加法表和乘法表。最开始，运算规则看起来很 复杂，我也经常犯错。在发现<strong>递归（Recursion）</strong>时，我如同醍醐灌顶。 有了这种简单的技巧，无数的加法和乘法运算只用几行就能概括。</p><p>这是用 Agda 编写的加法定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-_+_"></a><a id="plfa_plfa-part1-Naturals-16336" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">_+_</a> <a id="plfa_plfa-part1-Naturals-16340" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-16342" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-16344" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-16346" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-16348" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-16350" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Naturals-16352" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Naturals-16357" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-16359" href="../Naturals/#plfa_plfa-part1-Naturals-16359" class="Bound">n</a> <a id="plfa_plfa-part1-Naturals-16361" class="Symbol">=</a> <a id="plfa_plfa-part1-Naturals-16363" href="../Naturals/#plfa_plfa-part1-Naturals-16359" class="Bound">n</a>
<a id="plfa_plfa-part1-Naturals-16365" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-16366" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-16370" href="../Naturals/#plfa_plfa-part1-Naturals-16370" class="Bound">m</a><a id="plfa_plfa-part1-Naturals-16371" class="Symbol">)</a> <a id="plfa_plfa-part1-Naturals-16373" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-16375" href="../Naturals/#plfa_plfa-part1-Naturals-16375" class="Bound">n</a> <a id="plfa_plfa-part1-Naturals-16377" class="Symbol">=</a> <a id="plfa_plfa-part1-Naturals-16379" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-16383" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-16384" href="../Naturals/#plfa_plfa-part1-Naturals-16370" class="Bound">m</a> <a id="plfa_plfa-part1-Naturals-16386" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-16388" href="../Naturals/#plfa_plfa-part1-Naturals-16375" class="Bound">n</a><a id="plfa_plfa-part1-Naturals-16389" class="Symbol">)</a>
</pre><p>我们来分析一下它的定义。加法是一种中缀运算符，其名为 <code>_+_</code>，其中参数的 位置用下划线表示。第一行指定了运算符的类型签名。类型 <code>ℕ → ℕ → ℕ</code> 表示 加法接受两个自然数作为参数，并返回一个自然数。中缀记法只是函数应用的简写， <code>m + n</code> 和 <code>_+_ m n</code> 这两个项是等价的。</p><p>它的定义包含一个起始步骤和一个归纳步骤，与自然数的定义对应。起始步骤说明 零加上一个数仍返回这个数，即 <code>zero + n</code> 等于 <code>n</code>。归纳步骤说明一个数的后继数 加上另一个数返回两数之和的后继数，即 <code>(suc m) + n</code> 等于 <code>suc (m + n)</code>。在加法的 定义中，构造子出现在了等式左边，我们称之为<strong>模式匹配（Pattern Matching）</strong>。</p><p>如果我们将 <code>zero</code> 写作 <code>0</code>，将 <code>suc m</code> 写作 <code>1 + m</code>，上面的定义就变成了 两个熟悉的等式。</p><pre><code> 0       + n  ≡  n
 (1 + m) + n  ≡  1 + (m + n)</code></pre><p>因为零是加法的幺元，所以第一个等式成立。又因为加法满足结合律，所以 第二个等式也成立。加法结合律的一般形式如下，说明运算结果与括号位置无关。</p><pre><code> (m + n) + p  ≡  m + (n + p)</code></pre><p>将上面第三个等式中的 <code>m</code> 换成 <code>1</code>，<code>n</code> 换成 <code>m</code>，<code>p</code> 换成 <code>n</code>，我们就 得到了第二个等式。我们用等号 <code>=</code> 表示定义，用 <code>≡</code> 断言两个已定义的事物相等。</p><p>加法的定义是<strong>递归（Recursive）</strong>的，因为在最后一行我们用加法定义了加法。 与自然数的归纳定义类似，这种表面上的循环性并不会造成问题，因为较大 的数相加是用较小的数相加定义的。这样的定义被称作是<strong>良基的（Well founded）</strong>。</p><p>例如，我们来计算二加三：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-19013" href="../Naturals/#plfa_plfa-part1-Naturals-19013" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-19015" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-19017" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-19019" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19021" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-19023" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Naturals-19025" class="Number">5</a>
<a id="plfa_plfa-part1-Naturals-19027" class="Symbol">_</a> <a id="plfa_plfa-part1-Naturals-19029" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Naturals-19033" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Naturals-19043" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-19045" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19047" class="Number">3</a>
  <a id="plfa_plfa-part1-Naturals-19051" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-19058" class="Comment">-- 展开为</a>
    <a id="plfa_plfa-part1-Naturals-19069" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19070" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19074" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19075" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19079" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19083" class="Symbol">))</a> <a id="plfa_plfa-part1-Naturals-19086" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19088" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19089" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19093" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19094" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19098" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19099" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19103" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19107" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Naturals-19113" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-19120" class="Comment">-- 归纳步骤</a>
    <a id="plfa_plfa-part1-Naturals-19132" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19136" class="Symbol">((</a><a id="plfa_plfa-part1-Naturals-19138" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19142" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19146" class="Symbol">)</a> <a id="plfa_plfa-part1-Naturals-19148" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19150" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19151" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19155" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19156" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19160" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19161" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19165" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19169" class="Symbol">))))</a>
  <a id="plfa_plfa-part1-Naturals-19176" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-19183" class="Comment">-- 归纳步骤</a>
    <a id="plfa_plfa-part1-Naturals-19195" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19199" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19200" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19204" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19205" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Naturals-19210" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19212" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19213" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19217" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19218" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19222" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19223" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19227" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19231" class="Symbol">)))))</a>
  <a id="plfa_plfa-part1-Naturals-19239" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-19246" class="Comment">-- 起始步骤</a>
    <a id="plfa_plfa-part1-Naturals-19258" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19262" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19263" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19267" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19268" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19272" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19273" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19277" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19278" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19282" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Naturals-19286" class="Symbol">))))</a>
  <a id="plfa_plfa-part1-Naturals-19293" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-19300" class="Comment">-- 简写为</a>
    <a id="plfa_plfa-part1-Naturals-19311" class="Number">5</a>
  <a id="plfa_plfa-part1-Naturals-19315" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们可以按需展开简写，把同样的推导过程写得更加紧凑。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-19455" href="../Naturals/#plfa_plfa-part1-Naturals-19455" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-19457" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-19459" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-19461" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19463" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-19465" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Naturals-19467" class="Number">5</a>
<a id="plfa_plfa-part1-Naturals-19469" class="Symbol">_</a> <a id="plfa_plfa-part1-Naturals-19471" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Naturals-19475" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Naturals-19485" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-19487" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19489" class="Number">3</a>
  <a id="plfa_plfa-part1-Naturals-19493" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-19501" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19505" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19506" class="Number">1</a> <a id="plfa_plfa-part1-Naturals-19508" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19510" class="Number">3</a><a id="plfa_plfa-part1-Naturals-19511" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Naturals-19515" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-19523" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19527" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19528" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19532" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19533" class="Number">0</a> <a id="plfa_plfa-part1-Naturals-19535" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-19537" class="Number">3</a><a id="plfa_plfa-part1-Naturals-19538" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Naturals-19543" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-19551" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19555" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-19556" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-19560" class="Number">3</a><a id="plfa_plfa-part1-Naturals-19561" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Naturals-19565" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-19573" class="Number">5</a>
  <a id="plfa_plfa-part1-Naturals-19577" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行取 <code>m = 1</code> 和 <code>n = 3</code> 匹配了归纳步骤，第二行取 <code>m = 0</code> 和 <code>n = 3</code> 匹配了归纳步骤，第三行取 <code>n = 3</code> 匹配了起始步骤。</p><p>以上两个推导过程都由一个类型签名（包含冒号 <code>:</code> 的一行）和一个提供对应类型 的项的绑定（Binding）（包含等号 <code>=</code> 的一行及之后的部分）组成。在编写代码时 我们用了虚设名称 <code>_</code>。虚设名称可以被重复使用，在举例时非常方便。除了 <code>_</code> 之外 的名称在一个模块里只能被定义一次。</p><p>这里的类型是 <code>2 + 3 ≡ 5</code>，而该等式写成列表形式的等式链的项，提供了类型中表示 等式成立的<strong>证据（Evidence）</strong>。该等式链由 <code>begin</code> 开始，以 <code>∎</code> 结束（<code>∎</code> 可读作「qed（证毕）」或「tombstone（墓碑符号）」，后者来自于其外观）， 并由一系列 <code>≡⟨⟩</code> 分隔的项组成。</p><p>注意，上面的证明以彩色显示，表示 Agda 已经处理并接受了这些代码， 因此可以保证它们没有类型错误。在 Agda 中处理后，Emacs 源文件中会以同样的颜色显示。 在 Emacs 中，右键单击任何彩色的符号，例如 <code>+</code>、<code>suc</code> 或 <code>≡</code>，就会跳转到该符号的定义。</p><p>其实，以上两种证明都比实际所需的要长，下面的证明就足以让 Agda 满意了。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-21526" href="../Naturals/#plfa_plfa-part1-Naturals-21526" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-21528" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-21530" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-21532" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-21534" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-21536" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Naturals-21538" class="Number">5</a>
<a id="plfa_plfa-part1-Naturals-21540" class="Symbol">_</a> <a id="plfa_plfa-part1-Naturals-21542" class="Symbol">=</a> <a id="plfa_plfa-part1-Naturals-21544" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>Agda 知道如何计算 <code>2 + 3</code> 的值，也可以立刻确定这个值和 <code>5</code> 是一样的。如果一个 二元关系（Binary Relation）中每个值都和自己相关，我们称这个二元关系满足 <strong>自反性（Reflexivity）</strong>。在 Agda 中，一个值等于其自身的证据写作 <code>refl</code>。</p><p>在等式链中，Agda 只检查每个项是否都能化简为相同的值。如果我们打乱等式顺序， 省略或者加入一些额外的步骤，证明仍然会被接受。我们需要自己来保证等式的顺序 便于理解。</p><p>在这里，<code>2 + 3 ≡ 5</code> 是一个类型，等式链（以及 <code>refl</code>）都是这个类型的项。 换言之，我们也可以把每个项都看作断言 <code>2 + 3 ≡ 5</code> 的<strong>证据</strong>。这种解释的 对偶性——类型即命题，项即证据——是我们在 Agda 中形式化各种概念的核心， 也是贯穿本书的主题。</p><p>注意，当我们使用<strong>证据</strong>这个词时不容一点含糊。这里的证据确凿不移， 不像法庭上的证词一样必须被反复权衡以决定证人是否可信。 我们也会使用<strong>证明</strong>一词表达相同的意思，在本书中这两个词可以互换使用。</p><h4 id="plus-example">练习 <code>+-example</code>（实践）</h4><p>计算 <code>3 + 4</code>，将你的推导过程写成等式链，为 <code>+</code> 使用等式。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-23488" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="乘法">乘法</h2><p>一旦我们定义了加法，我们就可以将乘法定义为重复的加法。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-_*_"></a><a id="plfa_plfa-part1-Naturals-23666" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">_*_</a> <a id="plfa_plfa-part1-Naturals-23670" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-23672" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-23674" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-23676" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-23678" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-23680" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Naturals-23682" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Naturals-23690" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-23692" href="../Naturals/#plfa_plfa-part1-Naturals-23692" class="Bound">n</a>  <a id="plfa_plfa-part1-Naturals-23695" class="Symbol">=</a>  <a id="plfa_plfa-part1-Naturals-23698" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Naturals-23703" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-23704" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-23708" href="../Naturals/#plfa_plfa-part1-Naturals-23708" class="Bound">m</a><a id="plfa_plfa-part1-Naturals-23709" class="Symbol">)</a> <a id="plfa_plfa-part1-Naturals-23711" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-23713" href="../Naturals/#plfa_plfa-part1-Naturals-23713" class="Bound">n</a>  <a id="plfa_plfa-part1-Naturals-23716" class="Symbol">=</a>  <a id="plfa_plfa-part1-Naturals-23719" href="../Naturals/#plfa_plfa-part1-Naturals-23713" class="Bound">n</a> <a id="plfa_plfa-part1-Naturals-23721" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-23723" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-23724" href="../Naturals/#plfa_plfa-part1-Naturals-23708" class="Bound">m</a> <a id="plfa_plfa-part1-Naturals-23726" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-23728" href="../Naturals/#plfa_plfa-part1-Naturals-23713" class="Bound">n</a><a id="plfa_plfa-part1-Naturals-23729" class="Symbol">)</a>
</pre><p>计算 <code>m * n</code> 返回的结果是 <code>m</code> 个 <code>n</code> 之和。</p><p>重写定义再一次给出了两个熟悉的等式：</p><pre><code>0       * n  ≡  0
(1 + m) * n  ≡  n + (m * n)</code></pre><p>因为零乘任何数都是零，所以第一个等式成立。因为乘法对加法有分配律，所以 第二个等式也成立。乘法对加法的分配律的一般形式如下：</p><pre><code>(m + n) * p  ≡  (m * p) + (n * p)</code></pre><p>将上面第三个等式中的 <code>m</code> 换成 <code>1</code>，<code>n</code> 换成 <code>m</code>，<code>p</code> 换成 <code>n</code>，再根据 一是乘法的幺元，也就是 <code>1 * n ≡ n</code>，我们就得到了第二个等式。</p><p>这个定义也是良基的，因为较大的数相乘是用较小的数相乘定义的。</p><p>例如，我们来计算二乘三：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-24845" href="../Naturals/#plfa_plfa-part1-Naturals-24845" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-24847" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Naturals-24851" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Naturals-24861" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-24863" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-24865" class="Number">3</a>
  <a id="plfa_plfa-part1-Naturals-24869" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-24876" class="Comment">-- 归纳步骤</a>
    <a id="plfa_plfa-part1-Naturals-24888" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-24890" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-24892" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-24893" class="Number">1</a> <a id="plfa_plfa-part1-Naturals-24895" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-24897" class="Number">3</a><a id="plfa_plfa-part1-Naturals-24898" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Naturals-24902" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-24909" class="Comment">-- 归纳步骤</a>
    <a id="plfa_plfa-part1-Naturals-24921" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-24923" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-24925" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-24926" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-24928" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-24930" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-24931" class="Number">0</a> <a id="plfa_plfa-part1-Naturals-24933" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Function Operator">*</a> <a id="plfa_plfa-part1-Naturals-24935" class="Number">3</a><a id="plfa_plfa-part1-Naturals-24936" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Naturals-24941" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-24948" class="Comment">-- 起始步骤</a>
    <a id="plfa_plfa-part1-Naturals-24960" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-24962" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-24964" class="Symbol">(</a><a id="plfa_plfa-part1-Naturals-24965" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-24967" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Function Operator">+</a> <a id="plfa_plfa-part1-Naturals-24969" class="Number">0</a><a id="plfa_plfa-part1-Naturals-24970" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Naturals-24974" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>    <a id="plfa_plfa-part1-Naturals-24981" class="Comment">-- 化简</a>
    <a id="plfa_plfa-part1-Naturals-24991" class="Number">6</a>
  <a id="plfa_plfa-part1-Naturals-24995" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>第一行取 <code>m = 1</code> 和 <code>n = 3</code> 匹配了归纳步骤，第二行取 <code>m = 0</code> 和 <code>n = 3</code> 匹配了归纳步骤，最后第三行取 <code>n = 3</code> 匹配了起始步骤。在这里我们省略了 <code>_ : 2 * 3 ≡ 6</code> 的签名，因为它很容易从对应的项推导出来。</p><h4 id="times-example">练习 <code>*-example</code>（实践）</h4><p>计算 <code>3 * 4</code>，将你的推导过程写成等式链，为 <code>*</code> 使用等式。 （不必写出 <code>+</code> 求值的每一步。）</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-25811" class="Comment">-- 请将代码写在此处</a>
</pre><h4 id="power">练习 <code>_^_</code>（推荐）</h4><p>根据以下等式写出乘方的定义。</p><pre><code>m ^ 0        =  1
m ^ (1 + n)  =  m * (m ^ n)</code></pre><p>检查 <code>3 ^ 4</code> 是否等于 <code>81</code>。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-26127" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="饱和减法">饱和减法</h2><p>我们也可以定义减法。由于没有负的自然数，如果被减数比减数小， 我们就将结果取零。这种针对自然数的减法变种称作<strong>饱和减法（Monus，由 minus 修改而来）</strong>。</p><p>饱和减法是我们首次在定义中对两个参数都使用模式匹配：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-_∸_"></a><a id="plfa_plfa-part1-Naturals-26649" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">_∸_</a> <a id="plfa_plfa-part1-Naturals-26653" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-26655" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-26657" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-26659" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Naturals-26661" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-26663" href="../Naturals/#plfa_plfa-part1-Naturals-1494" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Naturals-26665" href="../Naturals/#plfa_plfa-part1-Naturals-26665" class="Bound">m</a>     <a id="plfa_plfa-part1-Naturals-26671" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-26673" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a>   <a id="plfa_plfa-part1-Naturals-26680" class="Symbol">=</a>  <a id="plfa_plfa-part1-Naturals-26683" href="../Naturals/#plfa_plfa-part1-Naturals-26665" class="Bound">m</a>
<a id="plfa_plfa-part1-Naturals-26685" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a>  <a id="plfa_plfa-part1-Naturals-26691" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-26693" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-26697" href="../Naturals/#plfa_plfa-part1-Naturals-26697" class="Bound">n</a>  <a id="plfa_plfa-part1-Naturals-26700" class="Symbol">=</a>  <a id="plfa_plfa-part1-Naturals-26703" href="../Naturals/#plfa_plfa-part1-Naturals-1510" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Naturals-26708" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-26712" href="../Naturals/#plfa_plfa-part1-Naturals-26712" class="Bound">m</a> <a id="plfa_plfa-part1-Naturals-26714" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-26716" href="../Naturals/#plfa_plfa-part1-Naturals-1521" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Naturals-26720" href="../Naturals/#plfa_plfa-part1-Naturals-26720" class="Bound">n</a>  <a id="plfa_plfa-part1-Naturals-26723" class="Symbol">=</a>  <a id="plfa_plfa-part1-Naturals-26726" href="../Naturals/#plfa_plfa-part1-Naturals-26712" class="Bound">m</a> <a id="plfa_plfa-part1-Naturals-26728" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-26730" href="../Naturals/#plfa_plfa-part1-Naturals-26720" class="Bound">n</a>
</pre><p>我们可以通过简单的分析来说明所有的情况都被考虑了。</p><ul><li>考虑第二个参数。<ul><li>如果它是 <code>zero</code>，应用第一个等式。</li><li>如果它是 <code>suc n</code>，考虑第一个参数。<ul><li>如果它是 <code>zero</code>，应用第二个等式。</li><li>如果它是 <code>suc m</code>，应用第三个等式。</li></ul></li></ul></li></ul><p>Agda will raise an error if all the cases are not covered. As with addition and multiplication, the recursive definition is well founded because monus on bigger numbers is defined in terms of monus on smaller numbers.</p><p>例如，我们来计算三减二：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-27537" href="../Naturals/#plfa_plfa-part1-Naturals-27537" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-27539" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Naturals-27543" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Naturals-27553" class="Number">3</a> <a id="plfa_plfa-part1-Naturals-27555" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27557" class="Number">2</a>
  <a id="plfa_plfa-part1-Naturals-27561" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27569" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-27571" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27573" class="Number">1</a>
  <a id="plfa_plfa-part1-Naturals-27577" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27585" class="Number">1</a> <a id="plfa_plfa-part1-Naturals-27587" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27589" class="Number">0</a>
  <a id="plfa_plfa-part1-Naturals-27593" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27601" class="Number">1</a>
  <a id="plfa_plfa-part1-Naturals-27605" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们没有使用第二个等式，但是如果被减数比减数小，我们还是会用到它。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-27790" href="../Naturals/#plfa_plfa-part1-Naturals-27790" class="Function">_</a> <a id="plfa_plfa-part1-Naturals-27792" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Naturals-27796" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Naturals-27806" class="Number">2</a> <a id="plfa_plfa-part1-Naturals-27808" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27810" class="Number">3</a>
  <a id="plfa_plfa-part1-Naturals-27814" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27822" class="Number">1</a> <a id="plfa_plfa-part1-Naturals-27824" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27826" class="Number">2</a>
  <a id="plfa_plfa-part1-Naturals-27830" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27838" class="Number">0</a> <a id="plfa_plfa-part1-Naturals-27840" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Function Operator">∸</a> <a id="plfa_plfa-part1-Naturals-27842" class="Number">1</a>
  <a id="plfa_plfa-part1-Naturals-27846" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Naturals-27854" class="Number">0</a>
  <a id="plfa_plfa-part1-Naturals-27858" href="https://agda.github.io/agda-stdlib/v1.7.1/Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
</pre><p>我们对饱和减法的定义确保了只有一条等式可以应用。 假设我们将第二条以下文取而代之</p><pre><code>zero  ∸ n  =  zero</code></pre><p>那样就不清楚 Agda 应该使用第一条或者第二条来简化 <code>zero ∸ zero</code>。 在这样的情况下，两者都可以相同的答案 <code>zero</code>，但这不一定是普遍的情况。 将</p><pre><code>{-# OPTIONS --exact-split #-}</code></pre><p>写在文件的开始可以让 Agda 在不同情况相互重叠时产生一个错误， 有些时候这会有帮助。我们会在<a href="../Decidable/#logical-connectives">逻辑连接符</a>部分 展示一个这样的例子。</p><h4 id="monus-examples">练习 <code>∸-example₁</code> 和 <code>∸-example₂</code>（推荐）</h4><p>计算 <code>5 ∸ 3</code> 和 <code>3 ∸ 5</code>，将你的推导过程写成等式链。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-29018" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="优先级">优先级</h2><p>我们经常使用<strong>优先级（Precedence）</strong>来避免书写大量的括号。 函数应用比其它任何运算符都<strong>结合得更紧密</strong>（即<strong>有更高的优先级</strong>），所以我们 可以用 <code>suc m + n</code> 来表示 <code>(suc m) + n</code>。另一个例子是，我们说乘法比 加法结合得更紧密，所以可以用 <code>n + m * n</code> 来表示 <code>n + (m * n)</code>。我们有 时候也说加法是<strong>左结合的</strong>，所以可以用 <code>m + n + p</code> 来表示 <code>(m + n) + p</code>。</p><p>在 Agda 中，中缀运算符的优先级和结合性需要被声明：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-29873" class="Keyword">infixl</a> <a id="plfa_plfa-part1-Naturals-29880" class="Number">6</a>  <a id="plfa_plfa-part1-Naturals-29883" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Primitive Operator">_+_</a>  <a id="plfa_plfa-part1-Naturals-29888" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Primitive Operator">_∸_</a>
<a id="plfa_plfa-part1-Naturals-29892" class="Keyword">infixl</a> <a id="plfa_plfa-part1-Naturals-29899" class="Number">7</a>  <a id="plfa_plfa-part1-Naturals-29902" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Primitive Operator">_*_</a>
</pre><p>它声明了运算符 <code>_+_</code> 和 <code>_∸_</code> 的优先级为 6，运算符 <code>_*_</code> 的优先级 为 7。因为加法和饱和减法的优先级更低，所以它们结合得不如乘法紧密。 <code>infixl</code> 意味着三个运算符都是左结合的。编写者也可以用 <code>infixr</code> 来表示 某个运算符是右结合的，或者用 <code>infix</code> 来表示总是需要括号来消除歧义。</p><h2 id="柯里化">柯里化</h2><p>我们曾将接受两个参数的函数表示成「接受第一个参数，返回接受第二个 参数的函数」的函数。这种技巧叫做<strong>柯里化（Currying）</strong>。</p><p>与 Haskell 和 ML 等函数式语言类似，Agda 在设计时就考虑了让柯里化更加易用。 函数箭头是右结合的，而函数应用是左结合的。</p><p>比如</p><p><code>ℕ → ℕ → ℕ</code> 表示 <code>ℕ → (ℕ → ℕ)</code></p><p>而</p><p><code>_+_ 2 3</code> 表示 <code>(_+_ 2) 3</code>。</p><p><code>_+_ 2</code> 这个项表示一个「将参数加二」的函数，因此将它应用到三就得到了五。</p><p>柯里化是以哈斯凯尔·柯里（Haskell Curry）的名字命名的，编程语言 Haskell 也是。 柯里的工作可以追溯到 19 世纪 30 年代。当我第一次了解到柯里化时， 有人告诉我柯里化的命名是个归因错误，因为在 20 年代同样的想法就已经被 Moses Schönfinkel 提出了。我也听说过这样一个笑话：「（柯里化）本来该命名成 Schönfinkel 化的，但是咖喱（Curry）更好吃」。直到之后我才了解到， 这个归因错误的解释本身也是个归因错误。柯里化的概念早在戈特洛布·弗雷格 （Gottlob Frege）发表于 1879 年的 <strong>“Begriffsschrift”（《概念文字》）</strong>中就出现了。</p><h2 id="又一个创世故事">又一个创世故事</h2><p>和归纳定义中用自然数定义了自然数一样，递归定义也用加法定义了加法。</p><p>同理，无需利用循环性，我们的加法定义也是可以被赋予意义的。 为此，我们需要将加法的定义归约到用于判断相等性的等价的推导规则上来。</p><pre><code>n : ℕ
--------------
zero + n  =  n

m + n  =  p
---------------------
(suc m) + n  =  suc p</code></pre><p>假设我们已经定义了自然数的无限集合，指定了判断 <code>n : ℕ</code> 的意义。 第一条推导规则是起始步骤。它断言如果 <code>n</code> 是一个自然数，那么零加上它得 <code>n</code>。 第二条推导规则是归纳步骤。它断言如果 <code>m</code> 加上 <code>n</code> 得 <code>p</code>，那么 <code>suc m</code> 加 上 <code>n</code> 得 <code>suc p</code>。</p><p>我们同样借创世故事来帮助理解，不过这次关注的是关于加法的判断。</p><pre><code>-- 起初，我们对加法一无所知。</code></pre><p>现在对所有已知的判断应用之前的规则。起始步骤告诉我们，对于 每个自然数 <code>n</code> 都有 <code>zero + n = n</code>，因此我们添加所有的这类等式。 归纳步骤告诉我们，如果「昨天」有 <code>m + n = p</code>，那么「今天」 就有 <code>suc m + n = suc p</code>。在今天之前，我们不知道任何关于加法的等式， 因此这条规则不会给我们任何新的等式。</p><pre><code>-- 第一天，我们知道了 0 为被加数的加法。
0 + 0 = 0     0 + 1 = 1    0 + 2 = 2     ...</code></pre><p>然后我们重复这个过程。今天我们知道来自昨天的所有等式，以及任何通过 规则添加的等式。起始步骤没有告诉我们任何新东西，但是归纳步骤添加了更多的等式。</p><pre><code>-- 第二天，我们知道了 0，1 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...</code></pre><p>我们再次重复这个过程：</p><pre><code>-- 第三天，我们知道了 0，1，2 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了 0，1，2，3 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
3 + 0 = 3     3 + 1 = 4     3 + 2 = 5     3 + 3 = 6     ...</code></pre><p>此过程可以继续下去。在第 <em>m</em> 天我们将知道所有被加数小于 <em>m</em> 的等式。</p><p>如上所示，归纳定义和递归定义的的推导过程十分相似。它们就像一枚硬币的两面。</p><h2 id="finite-creation">有限的创世故事</h2><p>前面的创世故事是用分层的方式讲述的。首先，我们创造了自然数的无限集合。 然后，我们构造加法的实例时把自然数集视为现成的，所以即使在第一天我 们也有一个无限的实例集合。</p><p>然而，我们也可以选择同时构造自然数集和加法的实例。这样在任何一天都只会有 一个有限的实例集合。</p><pre><code>-- 起初，我们一无所知。</code></pre><p>现在，对我们已知的所有判断应用之前的规则。只有自然数的起始步骤适用：</p><pre><code>-- 第一天，我们知道了零。
0 : ℕ</code></pre><p>我们再次应用所有的规则。这次我们有了一个新自然数，和加法的第一个等式。</p><pre><code>-- 第二天，我们知道了一和所有和为零的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0</code></pre><p>然后我们重复这个过程。我们通过加法的起始步骤得到了一个等式，也通过在前一天 的等式上应用加法的归纳步骤得到了一个等式：</p><pre><code>-- 第三天，我们知道了二和所有和为一的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1</code></pre><p>此时规律已经很明显了：</p><pre><code>-- 第四天，我们知道了三和所有和为二的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
3 : ℕ    0 + 2 = 2   1 + 1 = 2    2 + 0 = 2</code></pre><p>在第 <em>n</em> 天会有 <em>n</em> 个不同的自然数和 <em>n × (n-1) / 2</em> 个加法等式。 数字 <em>n</em> 和所有和小于 <em>n</em> 的加法等式在第 <em>n+1</em> 天首次出现。这提供了 一种无限的数据集合及与之相关的等式的有限主义视角。</p><h2 id="交互式地编写定义">交互式地编写定义</h2><p>Agda 被设计为使用 Emacs 作为文本编辑器，二者一同提供了很多能帮助 用户交互式地创建定义和证明的功能。</p><p>我们从输入以下代码开始：</p><pre><code>_+_ : ℕ → ℕ → ℕ
m + n = ?</code></pre><p>问号表示你希望 Agda 帮助你填入这部分代码。如果按下组合键 <code>C-c C-l</code> （按住 Control 键的同时先按 <code>c</code> 键再按 <code>l</code> 键，<code>l</code> 键代表载入 <strong>l</strong>oad），这个问号会被替换：</p><pre><code>_+_ : ℕ → ℕ → ℕ
m + n = { }0</code></pre><p>这对花括号被称作一个<strong>洞（Hole）</strong>，0 是这个洞的编号。洞将会被高亮显示为 绿色（或蓝色）。同时，Emacs 会创建一个窗口显示如下文字：</p><pre><code>?0 : ℕ</code></pre><p>这表示 0 号洞需要填入一个类型为 <code>ℕ</code> 的项。按组合键 <code>C-c C-f</code> （<code>f</code> 键代表向前 <strong>f</strong>orward）会移动到下一个洞。</p><p>我们希望在第一个参数上递归来定义加法。 将光标移至 0 号洞并按 <code>C-c C-c</code>（<code>c</code> 键代表分情况讨论 <strong>c</strong>ase），你将看见如下提示：</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>即「用于分项的模式变量（留空以对结果分项）：」。</p><p>键入 <code>m</code> 会对名为 <code>m</code> 的变量分项（即自动模式匹配），并将代码更新为：</p><pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = { }0
suc m + n = { }1</code></pre><p>现在有两个洞了。底部的窗口会告诉你每个洞所需的类型：</p><pre><code>?0 : ℕ
?1 : ℕ</code></pre><p>移动至 0 号洞，按下 <code>C-c C-,</code> 会显示当前洞所需类型的具体信息，以及 可用的自由变量：</p><pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ</code></pre><p>这些信息强烈建议了用 <code>n</code> 填入该洞。填入内容后，你可以按下 <code>C-c C-空格</code> 来移除这个洞。</p><pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = { }1</code></pre><p>同理，移动到 1 号洞并按下 <code>C-c C-,</code> 会显示当前洞所需类型的具体信息， 以及可用的自由变量：</p><pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ</code></pre><p>移动到一个洞并按下 <code>C-c C-r</code> （<code>r</code> 键表示细分 <strong>r</strong>efine）会将一个构造子填入这个洞（如果有唯一的选择的话）， 或者告诉你有哪些可用的构造子以供选择。在当前情况下，编辑器会显示如下内容：</p><pre><code>Don&#39;t know which constructor to introduce of zero or suc</code></pre><p>即「不知道在 <code>zero</code> 和 <code>suc</code> 中该引入哪一个构造子」。</p><p>我们将 <code>suc ?</code> 填入并按下 <code>C-c C-空格</code>，它会将代码更新为：</p><pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc { }1</code></pre><p>移动到新的洞并按下 <code>C-c C-,</code> 给出了和之前类似的信息：</p><pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ</code></pre><p>我们可以用 <code>m + n</code> 填入该洞并按 <code>C-c C-空格</code> 来完成程序：</p><pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc (m + n)</code></pre><p>在如此简单的程序上频繁使用交互操作可能帮助不大， 但是同样的技巧能够帮助你构建更复杂的程序。甚至对于加法定义这么简单的程序，使用 <code>C-c C-c</code> 来分项仍然是有用的。</p><h2 id="更多编译指令">更多编译指令</h2><pre class="Agda"><a id="plfa_plfa-part1-Naturals-43536" class="Symbol">{-#</a> <a id="plfa_plfa-part1-Naturals-43540" class="Keyword">BUILTIN</a> <a id="plfa_plfa-part1-Naturals-43548" class="Keyword">NATPLUS</a> <a id="plfa_plfa-part1-Naturals-43556" href="../Naturals/#plfa_plfa-part1-Naturals-16336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Naturals-43560" class="Symbol">#-}</a>
<a id="plfa_plfa-part1-Naturals-43564" class="Symbol">{-#</a> <a id="plfa_plfa-part1-Naturals-43568" class="Keyword">BUILTIN</a> <a id="plfa_plfa-part1-Naturals-43576" class="Keyword">NATTIMES</a> <a id="plfa_plfa-part1-Naturals-43585" href="../Naturals/#plfa_plfa-part1-Naturals-23666" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Naturals-43589" class="Symbol">#-}</a>
<a id="plfa_plfa-part1-Naturals-43593" class="Symbol">{-#</a> <a id="plfa_plfa-part1-Naturals-43597" class="Keyword">BUILTIN</a> <a id="plfa_plfa-part1-Naturals-43605" class="Keyword">NATMINUS</a> <a id="plfa_plfa-part1-Naturals-43614" href="../Naturals/#plfa_plfa-part1-Naturals-26649" class="Primitive Operator">_∸_</a> <a id="plfa_plfa-part1-Naturals-43618" class="Symbol">#-}</a>
</pre><p>以上几行告诉 Agda 这几个运算符和数学中常用的运算符相对应， 以便让它在计算时使用相应的，可处理任意精度整数类型的 Haskell 运算符。 计算 <code>m</code> 加 <code>n</code> 时，用 <code>zero</code> 和 <code>suc</code> 表示的自然数需要正比于 <code>m</code> 的时间， 而用 Haskell 整数表示的情况下只需要正比于 <code>m</code> 和 <code>n</code> 中较大者的对数的时间。 类似地，计算 <code>m</code> 乘 <code>n</code> 时，用 <code>zero</code> 和 <code>suc</code> 表示的自然数需要正比于 <code>m</code> 乘 <code>n</code> 的 时间，而用 Haskell 整数表示的情况下只需要正比于 <code>m</code> 和 <code>n</code> 的对数之和的时间。</p><h4 id="Bin">练习 <code>Bin</code>（拓展）</h4><p>使用二进制系统能提供比一进制系统更高效的自然数表示。我们可以用一个比特串来表示一个数：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-44874" class="Keyword">data</a> <a id="plfa_plfa-part1-Naturals-Bin"></a><a id="plfa_plfa-part1-Naturals-44879" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a> <a id="plfa_plfa-part1-Naturals-44883" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-44885" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Naturals-44889" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Naturals-Bin.⟨⟩"></a><a id="plfa_plfa-part1-Naturals-44897" href="../Naturals/#plfa_plfa-part1-Naturals-44897" class="InductiveConstructor">⟨⟩</a> <a id="plfa_plfa-part1-Naturals-44900" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-44902" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a>
  <a id="plfa_plfa-part1-Naturals-Bin._O"></a><a id="plfa_plfa-part1-Naturals-44908" href="../Naturals/#plfa_plfa-part1-Naturals-44908" class="InductiveConstructor Operator">_O</a> <a id="plfa_plfa-part1-Naturals-44911" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-44913" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a> <a id="plfa_plfa-part1-Naturals-44917" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-44919" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a>
  <a id="plfa_plfa-part1-Naturals-Bin._I"></a><a id="plfa_plfa-part1-Naturals-44925" href="../Naturals/#plfa_plfa-part1-Naturals-44925" class="InductiveConstructor Operator">_I</a> <a id="plfa_plfa-part1-Naturals-44928" class="Symbol">:</a> <a id="plfa_plfa-part1-Naturals-44930" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a> <a id="plfa_plfa-part1-Naturals-44934" class="Symbol">→</a> <a id="plfa_plfa-part1-Naturals-44936" href="../Naturals/#plfa_plfa-part1-Naturals-44879" class="Datatype">Bin</a>
</pre><p>例如，以下比特串</p><pre><code>1011</code></pre><p>代表数字十一被编码为了</p><pre><code>⟨⟩ I O I I</code></pre><p>由于前导零的存在，表示并不是唯一的。因此，十一同样可以 表示成 <code>001011</code>，编码为：</p><pre><code>⟨⟩ O O I O I I</code></pre><p>定义这样一个函数</p><pre><code>inc : Bin → Bin</code></pre><p>将一个比特串转换成下一个数的比特串。比如，<code>1100</code> 编码了十二，我们就应该有：</p><pre><code>inc (⟨⟩ I O I I) ≡ ⟨⟩ I I O O</code></pre><p>实现这个函数，并验证它对于表示零到四的比特串都能给出正确结果。</p><p>使用以上的定义，再定义一对函数用于在两种表示间转换。</p><pre><code>to   : ℕ → Bin
from : Bin → ℕ</code></pre><p>对于前者，用没有前导零的比特串来表示正数，并用 <code>⟨⟩ O</code> 表示零。 验证这两个函数都能对零到四给出正确结果。</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-46129" class="Comment">-- 请将代码写在此处</a>
</pre><h2 id="标准库">标准库</h2><p>在每一章的结尾，我们将展示如何在标准库中找到相关的定义。 自然数，它们的构造子，以及用于自然数的基本运算符，都在标准库模块 <code>Data.Nat</code> 中定义：</p><pre class="Agda"><a id="plfa_plfa-part1-Naturals-46503" class="Comment">-- import Data.Nat using (ℕ; zero; suc; _+_; _*_; _^_; _∸_)</a>
</pre><p>正常情况下，我们会以运行代码的形式展示一个导入语句， 这样如果我们尝试导入一个不可用的定义，Agda 就会报错。 不过现在，我们只在注释里展示了这个导入语句。这一章和标准库 都调用了 <code>NATURAL</code> 编译指令。我们是在 <code>ℕ</code> 上使用，而标准库是在 等价的类型 <code>Data.Nat.ℕ</code> 上使用。这样的编译指令只能被调用一次，因为 重复调用会导致 <code>2</code> 到底是类型 <code>ℕ</code> 的值还是类型 <code>Data.Nat.ℕ</code> 的 值这样的困惑。重复调用其它的编译指令也会导致同样的问题。基于这个原因， 我们在后续章节中通常会避免使用编译指令。更多关于编译指令的信息可在 <a href="https://agda-zh.readthedocs.io/zh_CN/latest/language/pragmas.html">Agda 文档</a>中找到。</p><h2 id="unicode">Unicode</h2><p>这一章使用了如下的 Unicode 符号：</p><pre><code>ℕ  U+2115  双线体大写 N (\bN)
→  U+2192  右箭头 (\to, \r, \-&gt;)
∸  U+2238  点减 (\.-)
≡  U+2261  等价于 (\==)
⟨  U+27E8  数学左尖括号 (\&lt;)
⟩  U+27E9  数学右尖括号 (\&gt;)
∎  U+220E  证毕 (\qed)</code></pre><p>以上的每一行均包含 Unicode 符号（如 <code>ℕ</code>），对应的 Unicode 码点（如 <code>U+2115</code>）， 符号的名称（如 <code>双线体大写 N</code>），以及用于在 Emacs 中键入该符号的按键序列（如 <code>\bN</code>）。</p><p>通过 <code>\r</code> 命令可以查看多种右箭头符号。在输入 <code>\r</code> 后，你可以 按左、右、上、下键来查看或选择可用的箭头符号。这个命令会记住你上一次选择的位置， 并在下一次使用时从该字符开始。用于输入左箭头的 <code>\l</code> 命令的用法与此类似。</p><p>除了在输入箭头的命令中使用左、右、上、下键以外，以下按键也可以起到相同的作用：</p><pre><code>C-b  左（后退一个字符）
C-f  右（前进一个字符）
C-p  上（到上一行）
C-n  下（到下一行）</code></pre><p><code>C-b</code> 表示按 Control + b，其余同理。你也可以直接输入显示的列表中的数字编号来选择。</p><p>要查看所支持字符的完整列表，请执行 <code>agda-input-show-translations</code> 命令：</p><pre><code>M-x agda-input-show-translations</code></pre><p>这样会显示出 <code>agda-mode</code> 中所有支持的字符。我们用 M-x 表示按下 <code>ESC</code> 后再按下 <code>x</code>。</p><p>如果你想知道如何在 agda 文件中输入一个特定的 Unicode 字符，请将光标移至该字符上， 然后执行 <code>quail-show-key</code> 命令：</p><pre><code>M-x quail-show-key</code></pre><p>你会在迷你缓冲区中看到输入该字符所需的按键序列。 例如，如果你在 <code>∸</code> 上执行 <code>M-x quail-show-key</code>，就会看到该字符的按键序列为 <code>\.-</code>。</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../GettingStarted/">上一章</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Naturals.lagda.md">源文件</a></li><li class="separator">•</li><li><a class="pagelink" href="../Induction/">下一章</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">编程语言基础：Agda 描述</h2>本章译者：Rongxiao Fu<div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>本书按照<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">创作公用 署名 4.0 国际</a>许可协议授权</div></footer></body></html>